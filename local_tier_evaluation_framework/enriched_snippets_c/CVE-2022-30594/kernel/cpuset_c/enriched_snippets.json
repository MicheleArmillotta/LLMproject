[
  {
    "function_name": "cpuset_task_status_allowed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3726-3732",
    "snippet": "void cpuset_task_status_allowed(struct seq_file *m, struct task_struct *task)\n{\n\tseq_printf(m, \"Mems_allowed:\\t%*pb\\n\",\n\t\t   nodemask_pr_args(&task->mems_allowed));\n\tseq_printf(m, \"Mems_allowed_list:\\t%*pbl\\n\",\n\t\t   nodemask_pr_args(&task->mems_allowed));\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"Mems_allowed_list:\\t%*pbl\\n\"",
            "nodemask_pr_args(&task->mems_allowed)"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodemask_pr_args",
          "args": [
            "&task->mems_allowed"
          ],
          "line": 3731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodemask_pr_args",
          "args": [
            "&task->mems_allowed"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid cpuset_task_status_allowed(struct seq_file *m, struct task_struct *task)\n{\n\tseq_printf(m, \"Mems_allowed:\\t%*pb\\n\",\n\t\t   nodemask_pr_args(&task->mems_allowed));\n\tseq_printf(m, \"Mems_allowed_list:\\t%*pbl\\n\",\n\t\t   nodemask_pr_args(&task->mems_allowed));\n}"
  },
  {
    "function_name": "proc_cpuset_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3695-3722",
    "snippet": "int proc_cpuset_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk)\n{\n\tchar *buf;\n\tstruct cgroup_subsys_state *css;\n\tint retval;\n\n\tretval = -ENOMEM;\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tcss = task_get_css(tsk, cpuset_cgrp_id);\n\tretval = cgroup_path_ns(css->cgroup, buf, PATH_MAX,\n\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\tcss_put(css);\n\tif (retval >= PATH_MAX)\n\t\tretval = -ENAMETOOLONG;\n\tif (retval < 0)\n\t\tgoto out_free;\n\tseq_puts(m, buf);\n\tseq_putc(m, '\\n');\n\tretval = 0;\nout_free:\n\tkfree(buf);\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 3716
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "buf"
          ],
          "line": 3715
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "css"
          ],
          "line": 3710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_path_ns",
          "args": [
            "css->cgroup",
            "buf",
            "PATH_MAX",
            "current->nsproxy->cgroup_ns"
          ],
          "line": 3708
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_path_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "2290-2304",
          "snippet": "int cgroup_path_ns(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t   struct cgroup_namespace *ns)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tret = cgroup_path_ns_locked(cgrp, buf, buflen, ns);\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static void cgroup_finalize_control(struct cgroup *cgrp, int ret);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic void cgroup_finalize_control(struct cgroup *cgrp, int ret);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\n\nint cgroup_path_ns(struct cgroup *cgrp, char *buf, size_t buflen,\n\t\t   struct cgroup_namespace *ns)\n{\n\tint ret;\n\n\tmutex_lock(&cgroup_mutex);\n\tspin_lock_irq(&css_set_lock);\n\n\tret = cgroup_path_ns_locked(cgrp, buf, buflen, ns);\n\n\tspin_unlock_irq(&css_set_lock);\n\tmutex_unlock(&cgroup_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_get_css",
          "args": [
            "tsk",
            "cpuset_cgrp_id"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PATH_MAX",
            "GFP_KERNEL"
          ],
          "line": 3703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nint proc_cpuset_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk)\n{\n\tchar *buf;\n\tstruct cgroup_subsys_state *css;\n\tint retval;\n\n\tretval = -ENOMEM;\n\tbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto out;\n\n\tcss = task_get_css(tsk, cpuset_cgrp_id);\n\tretval = cgroup_path_ns(css->cgroup, buf, PATH_MAX,\n\t\t\t\tcurrent->nsproxy->cgroup_ns);\n\tcss_put(css);\n\tif (retval >= PATH_MAX)\n\t\tretval = -ENAMETOOLONG;\n\tif (retval < 0)\n\t\tgoto out_free;\n\tseq_puts(m, buf);\n\tseq_putc(m, '\\n');\n\tretval = 0;\nout_free:\n\tkfree(buf);\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "__cpuset_memory_pressure_bump",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3678-3683",
    "snippet": "void __cpuset_memory_pressure_bump(void)\n{\n\trcu_read_lock();\n\tfmeter_markevent(&task_cs(current)->fmeter);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3682
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmeter_markevent",
          "args": [
            "&task_cs(current)->fmeter"
          ],
          "line": 3681
        },
        "resolved": true,
        "details": {
          "function_name": "fmeter_markevent",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "2162-2168",
          "snippet": "static void fmeter_markevent(struct fmeter *fmp)\n{\n\tspin_lock(&fmp->lock);\n\tfmeter_update(fmp);\n\tfmp->cnt = min(FM_MAXCNT, fmp->cnt + FM_SCALE);\n\tspin_unlock(&fmp->lock);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define FM_SCALE 1000\t\t/* faux fixed point scale */",
            "#define FM_MAXCNT 1000000\t/* limit cnt to avoid overflow */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define FM_SCALE 1000\t\t/* faux fixed point scale */\n#define FM_MAXCNT 1000000\t/* limit cnt to avoid overflow */\n\nstatic void fmeter_markevent(struct fmeter *fmp)\n{\n\tspin_lock(&fmp->lock);\n\tfmeter_update(fmp);\n\tfmp->cnt = min(FM_MAXCNT, fmp->cnt + FM_SCALE);\n\tspin_unlock(&fmp->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cs",
          "args": [
            "current"
          ],
          "line": 3681
        },
        "resolved": true,
        "details": {
          "function_name": "task_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "208-211",
          "snippet": "static inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3680
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid __cpuset_memory_pressure_bump(void)\n{\n\trcu_read_lock();\n\tfmeter_markevent(&task_cs(current)->fmeter);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "cpuset_print_current_mems_allowed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3637-3650",
    "snippet": "void cpuset_print_current_mems_allowed(void)\n{\n\tstruct cgroup *cgrp;\n\n\trcu_read_lock();\n\n\tcgrp = task_cs(current)->css.cgroup;\n\tpr_cont(\",cpuset=\");\n\tpr_cont_cgroup_name(cgrp);\n\tpr_cont(\",mems_allowed=%*pbl\",\n\t\tnodemask_pr_args(&current->mems_allowed));\n\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3649
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\",mems_allowed=%*pbl\"",
            "nodemask_pr_args(&current->mems_allowed)"
          ],
          "line": 3646
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4723-4735",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %ps\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodemask_pr_args",
          "args": [
            "&current->mems_allowed"
          ],
          "line": 3647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont_cgroup_name",
          "args": [
            "cgrp"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\",cpuset=\""
          ],
          "line": 3644
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cs",
          "args": [
            "current"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "task_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "208-211",
          "snippet": "static inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid cpuset_print_current_mems_allowed(void)\n{\n\tstruct cgroup *cgrp;\n\n\trcu_read_lock();\n\n\tcgrp = task_cs(current)->css.cgroup;\n\tpr_cont(\",cpuset=\");\n\tpr_cont_cgroup_name(cgrp);\n\tpr_cont(\",mems_allowed=%*pbl\",\n\t\tnodemask_pr_args(&current->mems_allowed));\n\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "cpuset_mems_allowed_intersects",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3625-3629",
    "snippet": "int cpuset_mems_allowed_intersects(const struct task_struct *tsk1,\n\t\t\t\t   const struct task_struct *tsk2)\n{\n\treturn nodes_intersects(tsk1->mems_allowed, tsk2->mems_allowed);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodes_intersects",
          "args": [
            "tsk1->mems_allowed",
            "tsk2->mems_allowed"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nint cpuset_mems_allowed_intersects(const struct task_struct *tsk1,\n\t\t\t\t   const struct task_struct *tsk2)\n{\n\treturn nodes_intersects(tsk1->mems_allowed, tsk2->mems_allowed);\n}"
  },
  {
    "function_name": "cpuset_slab_spread_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3603-3610",
    "snippet": "int cpuset_slab_spread_node(void)\n{\n\tif (current->cpuset_slab_spread_rotor == NUMA_NO_NODE)\n\t\tcurrent->cpuset_slab_spread_rotor =\n\t\t\tnode_random(&current->mems_allowed);\n\n\treturn cpuset_spread_node(&current->cpuset_slab_spread_rotor);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuset_spread_node",
          "args": [
            "&current->cpuset_slab_spread_rotor"
          ],
          "line": 3609
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_spread_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "3589-3592",
          "snippet": "static int cpuset_spread_node(int *rotor)\n{\n\treturn *rotor = next_node_in(*rotor, current->mems_allowed);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int cpuset_spread_node(int *rotor)\n{\n\treturn *rotor = next_node_in(*rotor, current->mems_allowed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_random",
          "args": [
            "&current->mems_allowed"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nint cpuset_slab_spread_node(void)\n{\n\tif (current->cpuset_slab_spread_rotor == NUMA_NO_NODE)\n\t\tcurrent->cpuset_slab_spread_rotor =\n\t\t\tnode_random(&current->mems_allowed);\n\n\treturn cpuset_spread_node(&current->cpuset_slab_spread_rotor);\n}"
  },
  {
    "function_name": "cpuset_mem_spread_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3594-3601",
    "snippet": "int cpuset_mem_spread_node(void)\n{\n\tif (current->cpuset_mem_spread_rotor == NUMA_NO_NODE)\n\t\tcurrent->cpuset_mem_spread_rotor =\n\t\t\tnode_random(&current->mems_allowed);\n\n\treturn cpuset_spread_node(&current->cpuset_mem_spread_rotor);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuset_spread_node",
          "args": [
            "&current->cpuset_mem_spread_rotor"
          ],
          "line": 3600
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_spread_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "3589-3592",
          "snippet": "static int cpuset_spread_node(int *rotor)\n{\n\treturn *rotor = next_node_in(*rotor, current->mems_allowed);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int cpuset_spread_node(int *rotor)\n{\n\treturn *rotor = next_node_in(*rotor, current->mems_allowed);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_random",
          "args": [
            "&current->mems_allowed"
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nint cpuset_mem_spread_node(void)\n{\n\tif (current->cpuset_mem_spread_rotor == NUMA_NO_NODE)\n\t\tcurrent->cpuset_mem_spread_rotor =\n\t\t\tnode_random(&current->mems_allowed);\n\n\treturn cpuset_spread_node(&current->cpuset_mem_spread_rotor);\n}"
  },
  {
    "function_name": "cpuset_spread_node",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3589-3592",
    "snippet": "static int cpuset_spread_node(int *rotor)\n{\n\treturn *rotor = next_node_in(*rotor, current->mems_allowed);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_node_in",
          "args": [
            "*rotor",
            "current->mems_allowed"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int cpuset_spread_node(int *rotor)\n{\n\treturn *rotor = next_node_in(*rotor, current->mems_allowed);\n}"
  },
  {
    "function_name": "__cpuset_node_allowed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3528-3560",
    "snippet": "bool __cpuset_node_allowed(int node, gfp_t gfp_mask)\n{\n\tstruct cpuset *cs;\t\t/* current cpuset ancestors */\n\tbool allowed;\t\t\t/* is allocation in zone z allowed? */\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn true;\n\tif (node_isset(node, current->mems_allowed))\n\t\treturn true;\n\t/*\n\t * Allow tasks that have access to memory reserves because they have\n\t * been OOM killed to get memory anywhere.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current)))\n\t\treturn true;\n\tif (gfp_mask & __GFP_HARDWALL)\t/* If hardwall request, stop here */\n\t\treturn false;\n\n\tif (current->flags & PF_EXITING) /* Let dying task have memory */\n\t\treturn true;\n\n\t/* Not hardwall and node outside mems_allowed: scan up cpusets */\n\tspin_lock_irqsave(&callback_lock, flags);\n\n\trcu_read_lock();\n\tcs = nearest_hardwall_ancestor(task_cs(current));\n\tallowed = node_isset(node, cs->mems_allowed);\n\trcu_read_unlock();\n\n\tspin_unlock_irqrestore(&callback_lock, flags);\n\treturn allowed;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&callback_lock",
            "flags"
          ],
          "line": 3558
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3556
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "node",
            "cs->mems_allowed"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nearest_hardwall_ancestor",
          "args": [
            "task_cs(current)"
          ],
          "line": 3554
        },
        "resolved": true,
        "details": {
          "function_name": "nearest_hardwall_ancestor",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "3481-3486",
          "snippet": "static struct cpuset *nearest_hardwall_ancestor(struct cpuset *cs)\n{\n\twhile (!(is_mem_exclusive(cs) || is_mem_hardwall(cs)) && parent_cs(cs))\n\t\tcs = parent_cs(cs);\n\treturn cs;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset *nearest_hardwall_ancestor(struct cpuset *cs)\n{\n\twhile (!(is_mem_exclusive(cs) || is_mem_hardwall(cs)) && parent_cs(cs))\n\t\tcs = parent_cs(cs);\n\treturn cs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cs",
          "args": [
            "current"
          ],
          "line": 3554
        },
        "resolved": true,
        "details": {
          "function_name": "task_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "208-211",
          "snippet": "static inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3553
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&callback_lock",
            "flags"
          ],
          "line": 3551
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk_is_oom_victim(current)"
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tsk_is_oom_victim",
          "args": [
            "current"
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node_isset",
          "args": [
            "node",
            "current->mems_allowed"
          ],
          "line": 3536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 3534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nbool __cpuset_node_allowed(int node, gfp_t gfp_mask)\n{\n\tstruct cpuset *cs;\t\t/* current cpuset ancestors */\n\tbool allowed;\t\t\t/* is allocation in zone z allowed? */\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn true;\n\tif (node_isset(node, current->mems_allowed))\n\t\treturn true;\n\t/*\n\t * Allow tasks that have access to memory reserves because they have\n\t * been OOM killed to get memory anywhere.\n\t */\n\tif (unlikely(tsk_is_oom_victim(current)))\n\t\treturn true;\n\tif (gfp_mask & __GFP_HARDWALL)\t/* If hardwall request, stop here */\n\t\treturn false;\n\n\tif (current->flags & PF_EXITING) /* Let dying task have memory */\n\t\treturn true;\n\n\t/* Not hardwall and node outside mems_allowed: scan up cpusets */\n\tspin_lock_irqsave(&callback_lock, flags);\n\n\trcu_read_lock();\n\tcs = nearest_hardwall_ancestor(task_cs(current));\n\tallowed = node_isset(node, cs->mems_allowed);\n\trcu_read_unlock();\n\n\tspin_unlock_irqrestore(&callback_lock, flags);\n\treturn allowed;\n}"
  },
  {
    "function_name": "nearest_hardwall_ancestor",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3481-3486",
    "snippet": "static struct cpuset *nearest_hardwall_ancestor(struct cpuset *cs)\n{\n\twhile (!(is_mem_exclusive(cs) || is_mem_hardwall(cs)) && parent_cs(cs))\n\t\tcs = parent_cs(cs);\n\treturn cs;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cs"
          ],
          "line": 3484
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mem_hardwall",
          "args": [
            "cs"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "is_mem_hardwall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "246-249",
          "snippet": "static inline int is_mem_hardwall(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_HARDWALL, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_mem_hardwall(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_HARDWALL, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mem_exclusive",
          "args": [
            "cs"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "is_mem_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "241-244",
          "snippet": "static inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset *nearest_hardwall_ancestor(struct cpuset *cs)\n{\n\twhile (!(is_mem_exclusive(cs) || is_mem_hardwall(cs)) && parent_cs(cs))\n\t\tcs = parent_cs(cs);\n\treturn cs;\n}"
  },
  {
    "function_name": "cpuset_nodemask_valid_mems_allowed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3470-3473",
    "snippet": "int cpuset_nodemask_valid_mems_allowed(nodemask_t *nodemask)\n{\n\treturn nodes_intersects(*nodemask, current->mems_allowed);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodes_intersects",
          "args": [
            "*nodemask",
            "current->mems_allowed"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nint cpuset_nodemask_valid_mems_allowed(nodemask_t *nodemask)\n{\n\treturn nodes_intersects(*nodemask, current->mems_allowed);\n}"
  },
  {
    "function_name": "cpuset_mems_allowed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3450-3462",
    "snippet": "nodemask_t cpuset_mems_allowed(struct task_struct *tsk)\n{\n\tnodemask_t mask;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&callback_lock, flags);\n\trcu_read_lock();\n\tguarantee_online_mems(task_cs(tsk), &mask);\n\trcu_read_unlock();\n\tspin_unlock_irqrestore(&callback_lock, flags);\n\n\treturn mask;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&callback_lock",
            "flags"
          ],
          "line": 3459
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3458
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guarantee_online_mems",
          "args": [
            "task_cs(tsk)",
            "&mask"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "guarantee_online_mems",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "460-465",
          "snippet": "static void guarantee_online_mems(struct cpuset *cs, nodemask_t *pmask)\n{\n\twhile (!nodes_intersects(cs->effective_mems, node_states[N_MEMORY]))\n\t\tcs = parent_cs(cs);\n\tnodes_and(*pmask, cs->effective_mems, node_states[N_MEMORY]);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void guarantee_online_mems(struct cpuset *cs, nodemask_t *pmask)\n{\n\twhile (!nodes_intersects(cs->effective_mems, node_states[N_MEMORY]))\n\t\tcs = parent_cs(cs);\n\tnodes_and(*pmask, cs->effective_mems, node_states[N_MEMORY]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cs",
          "args": [
            "tsk"
          ],
          "line": 3457
        },
        "resolved": true,
        "details": {
          "function_name": "task_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "208-211",
          "snippet": "static inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3456
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&callback_lock",
            "flags"
          ],
          "line": 3455
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nnodemask_t cpuset_mems_allowed(struct task_struct *tsk)\n{\n\tnodemask_t mask;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&callback_lock, flags);\n\trcu_read_lock();\n\tguarantee_online_mems(task_cs(tsk), &mask);\n\trcu_read_unlock();\n\tspin_unlock_irqrestore(&callback_lock, flags);\n\n\treturn mask;\n}"
  },
  {
    "function_name": "cpuset_init_current_mems_allowed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3435-3438",
    "snippet": "void __init cpuset_init_current_mems_allowed(void)\n{\n\tnodes_setall(current->mems_allowed);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodes_setall",
          "args": [
            "current->mems_allowed"
          ],
          "line": 3437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid __init cpuset_init_current_mems_allowed(void)\n{\n\tnodes_setall(current->mems_allowed);\n}"
  },
  {
    "function_name": "cpuset_cpus_allowed_fallback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3401-3433",
    "snippet": "bool cpuset_cpus_allowed_fallback(struct task_struct *tsk)\n{\n\tconst struct cpumask *possible_mask = task_cpu_possible_mask(tsk);\n\tconst struct cpumask *cs_mask;\n\tbool changed = false;\n\n\trcu_read_lock();\n\tcs_mask = task_cs(tsk)->cpus_allowed;\n\tif (is_in_v2_mode() && cpumask_subset(cs_mask, possible_mask)) {\n\t\tdo_set_cpus_allowed(tsk, cs_mask);\n\t\tchanged = true;\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * We own tsk->cpus_allowed, nobody can change it under us.\n\t *\n\t * But we used cs && cs->cpus_allowed lockless and thus can\n\t * race with cgroup_attach_task() or update_cpumask() and get\n\t * the wrong tsk->cpus_allowed. However, both cases imply the\n\t * subsequent cpuset_change_cpumask()->set_cpus_allowed_ptr()\n\t * which takes task_rq_lock().\n\t *\n\t * If we are called after it dropped the lock we must see all\n\t * changes in tsk_cs()->cpus_allowed. Otherwise we can temporary\n\t * set any mask even if it is not right from task_cs() pov,\n\t * the pending set_cpus_allowed_ptr() will fix things.\n\t *\n\t * select_fallback_rq() will fix things ups and set cpu_possible_mask\n\t * if required.\n\t */\n\treturn changed;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3413
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_set_cpus_allowed",
          "args": [
            "tsk",
            "cs_mask"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "do_set_cpus_allowed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2532-2535",
          "snippet": "void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\t__do_set_cpus_allowed(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n\t__do_set_cpus_allowed(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "cs_mask",
            "possible_mask"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_in_v2_mode",
          "args": [],
          "line": 3409
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_v2_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "401-405",
          "snippet": "static inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cs",
          "args": [
            "tsk"
          ],
          "line": 3408
        },
        "resolved": true,
        "details": {
          "function_name": "task_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "208-211",
          "snippet": "static inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3407
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu_possible_mask",
          "args": [
            "tsk"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nbool cpuset_cpus_allowed_fallback(struct task_struct *tsk)\n{\n\tconst struct cpumask *possible_mask = task_cpu_possible_mask(tsk);\n\tconst struct cpumask *cs_mask;\n\tbool changed = false;\n\n\trcu_read_lock();\n\tcs_mask = task_cs(tsk)->cpus_allowed;\n\tif (is_in_v2_mode() && cpumask_subset(cs_mask, possible_mask)) {\n\t\tdo_set_cpus_allowed(tsk, cs_mask);\n\t\tchanged = true;\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * We own tsk->cpus_allowed, nobody can change it under us.\n\t *\n\t * But we used cs && cs->cpus_allowed lockless and thus can\n\t * race with cgroup_attach_task() or update_cpumask() and get\n\t * the wrong tsk->cpus_allowed. However, both cases imply the\n\t * subsequent cpuset_change_cpumask()->set_cpus_allowed_ptr()\n\t * which takes task_rq_lock().\n\t *\n\t * If we are called after it dropped the lock we must see all\n\t * changes in tsk_cs()->cpus_allowed. Otherwise we can temporary\n\t * set any mask even if it is not right from task_cs() pov,\n\t * the pending set_cpus_allowed_ptr() will fix things.\n\t *\n\t * select_fallback_rq() will fix things ups and set cpu_possible_mask\n\t * if required.\n\t */\n\treturn changed;\n}"
  },
  {
    "function_name": "cpuset_cpus_allowed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3378-3385",
    "snippet": "void cpuset_cpus_allowed(struct task_struct *tsk, struct cpumask *pmask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&callback_lock, flags);\n\tguarantee_online_cpus(tsk, pmask);\n\tspin_unlock_irqrestore(&callback_lock, flags);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&callback_lock",
            "flags"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guarantee_online_cpus",
          "args": [
            "tsk",
            "pmask"
          ],
          "line": 3383
        },
        "resolved": true,
        "details": {
          "function_name": "guarantee_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "418-447",
          "snippet": "static void guarantee_online_cpus(struct task_struct *tsk,\n\t\t\t\t  struct cpumask *pmask)\n{\n\tconst struct cpumask *possible_mask = task_cpu_possible_mask(tsk);\n\tstruct cpuset *cs;\n\n\tif (WARN_ON(!cpumask_and(pmask, possible_mask, cpu_online_mask)))\n\t\tcpumask_copy(pmask, cpu_online_mask);\n\n\trcu_read_lock();\n\tcs = task_cs(tsk);\n\n\twhile (!cpumask_intersects(cs->effective_cpus, pmask)) {\n\t\tcs = parent_cs(cs);\n\t\tif (unlikely(!cs)) {\n\t\t\t/*\n\t\t\t * The top cpuset doesn't have any online cpu as a\n\t\t\t * consequence of a race between cpuset_hotplug_work\n\t\t\t * and cpu hotplug notifier.  But we know the top\n\t\t\t * cpuset's effective_cpus is on its way to be\n\t\t\t * identical to cpu_online_mask.\n\t\t\t */\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tcpumask_and(pmask, pmask, cs->effective_cpus);\n\nout_unlock:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void guarantee_online_cpus(struct task_struct *tsk,\n\t\t\t\t  struct cpumask *pmask)\n{\n\tconst struct cpumask *possible_mask = task_cpu_possible_mask(tsk);\n\tstruct cpuset *cs;\n\n\tif (WARN_ON(!cpumask_and(pmask, possible_mask, cpu_online_mask)))\n\t\tcpumask_copy(pmask, cpu_online_mask);\n\n\trcu_read_lock();\n\tcs = task_cs(tsk);\n\n\twhile (!cpumask_intersects(cs->effective_cpus, pmask)) {\n\t\tcs = parent_cs(cs);\n\t\tif (unlikely(!cs)) {\n\t\t\t/*\n\t\t\t * The top cpuset doesn't have any online cpu as a\n\t\t\t * consequence of a race between cpuset_hotplug_work\n\t\t\t * and cpu hotplug notifier.  But we know the top\n\t\t\t * cpuset's effective_cpus is on its way to be\n\t\t\t * identical to cpu_online_mask.\n\t\t\t */\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tcpumask_and(pmask, pmask, cs->effective_cpus);\n\nout_unlock:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&callback_lock",
            "flags"
          ],
          "line": 3382
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nvoid cpuset_cpus_allowed(struct task_struct *tsk, struct cpumask *pmask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&callback_lock, flags);\n\tguarantee_online_cpus(tsk, pmask);\n\tspin_unlock_irqrestore(&callback_lock, flags);\n}"
  },
  {
    "function_name": "cpuset_init_smp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3352-3365",
    "snippet": "void __init cpuset_init_smp(void)\n{\n\tcpumask_copy(top_cpuset.cpus_allowed, cpu_active_mask);\n\ttop_cpuset.mems_allowed = node_states[N_MEMORY];\n\ttop_cpuset.old_mems_allowed = top_cpuset.mems_allowed;\n\n\tcpumask_copy(top_cpuset.effective_cpus, cpu_active_mask);\n\ttop_cpuset.effective_mems = node_states[N_MEMORY];\n\n\tregister_hotmemory_notifier(&cpuset_track_online_nodes_nb);\n\n\tcpuset_migrate_mm_wq = alloc_ordered_workqueue(\"cpuset_migrate_mm\", 0);\n\tBUG_ON(!cpuset_migrate_mm_wq);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
      "static struct workqueue_struct *cpuset_migrate_mm_wq;",
      "static struct notifier_block cpuset_track_online_nodes_nb = {\n\t.notifier_call = cpuset_track_online_nodes,\n\t.priority = 10,\t\t/* ??! */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cpuset_migrate_mm_wq"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_ordered_workqueue",
          "args": [
            "\"cpuset_migrate_mm\"",
            "0"
          ],
          "line": 3363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_hotmemory_notifier",
          "args": [
            "&cpuset_track_online_nodes_nb"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "top_cpuset.effective_cpus",
            "cpu_active_mask"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "top_cpuset.cpus_allowed",
            "cpu_active_mask"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic struct workqueue_struct *cpuset_migrate_mm_wq;\nstatic struct notifier_block cpuset_track_online_nodes_nb = {\n\t.notifier_call = cpuset_track_online_nodes,\n\t.priority = 10,\t\t/* ??! */\n};\n\nvoid __init cpuset_init_smp(void)\n{\n\tcpumask_copy(top_cpuset.cpus_allowed, cpu_active_mask);\n\ttop_cpuset.mems_allowed = node_states[N_MEMORY];\n\ttop_cpuset.old_mems_allowed = top_cpuset.mems_allowed;\n\n\tcpumask_copy(top_cpuset.effective_cpus, cpu_active_mask);\n\ttop_cpuset.effective_mems = node_states[N_MEMORY];\n\n\tregister_hotmemory_notifier(&cpuset_track_online_nodes_nb);\n\n\tcpuset_migrate_mm_wq = alloc_ordered_workqueue(\"cpuset_migrate_mm\", 0);\n\tBUG_ON(!cpuset_migrate_mm_wq);\n}"
  },
  {
    "function_name": "cpuset_track_online_nodes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3335-3340",
    "snippet": "static int cpuset_track_online_nodes(struct notifier_block *self,\n\t\t\t\tunsigned long action, void *arg)\n{\n\tschedule_work(&cpuset_hotplug_work);\n\treturn NOTIFY_OK;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&cpuset_hotplug_work"
          ],
          "line": 3338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int cpuset_track_online_nodes(struct notifier_block *self,\n\t\t\t\tunsigned long action, void *arg)\n{\n\tschedule_work(&cpuset_hotplug_work);\n\treturn NOTIFY_OK;\n}"
  },
  {
    "function_name": "cpuset_wait_for_hotplug",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3325-3328",
    "snippet": "void cpuset_wait_for_hotplug(void)\n{\n\tflush_work(&cpuset_hotplug_work);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&cpuset_hotplug_work"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3112-3115",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid cpuset_wait_for_hotplug(void)\n{\n\tflush_work(&cpuset_hotplug_work);\n}"
  },
  {
    "function_name": "cpuset_update_active_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3315-3323",
    "snippet": "void cpuset_update_active_cpus(void)\n{\n\t/*\n\t * We're inside cpu hotplug critical region which usually nests\n\t * inside cgroup synchronization.  Bounce actual hotplug processing\n\t * to a work item to avoid reverse locking order.\n\t */\n\tschedule_work(&cpuset_hotplug_work);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cpuset_hotplug_workfn(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&cpuset_hotplug_work"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_hotplug_workfn(struct work_struct *work);\n\nvoid cpuset_update_active_cpus(void)\n{\n\t/*\n\t * We're inside cpu hotplug critical region which usually nests\n\t * inside cgroup synchronization.  Bounce actual hotplug processing\n\t * to a work item to avoid reverse locking order.\n\t */\n\tschedule_work(&cpuset_hotplug_work);\n}"
  },
  {
    "function_name": "cpuset_hotplug_workfn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3217-3313",
    "snippet": "static void cpuset_hotplug_workfn(struct work_struct *work)\n{\n\tstatic cpumask_t new_cpus;\n\tstatic nodemask_t new_mems;\n\tbool cpus_updated, mems_updated;\n\tbool on_dfl = is_in_v2_mode();\n\tstruct tmpmasks tmp, *ptmp = NULL;\n\n\tif (on_dfl && !alloc_cpumasks(NULL, &tmp))\n\t\tptmp = &tmp;\n\n\tpercpu_down_write(&cpuset_rwsem);\n\n\t/* fetch the available cpus/mems and find out which changed how */\n\tcpumask_copy(&new_cpus, cpu_active_mask);\n\tnew_mems = node_states[N_MEMORY];\n\n\t/*\n\t * If subparts_cpus is populated, it is likely that the check below\n\t * will produce a false positive on cpus_updated when the cpu list\n\t * isn't changed. It is extra work, but it is better to be safe.\n\t */\n\tcpus_updated = !cpumask_equal(top_cpuset.effective_cpus, &new_cpus);\n\tmems_updated = !nodes_equal(top_cpuset.effective_mems, new_mems);\n\n\t/*\n\t * In the rare case that hotplug removes all the cpus in subparts_cpus,\n\t * we assumed that cpus are updated.\n\t */\n\tif (!cpus_updated && top_cpuset.nr_subparts_cpus)\n\t\tcpus_updated = true;\n\n\t/* synchronize cpus_allowed to cpu_active_mask */\n\tif (cpus_updated) {\n\t\tspin_lock_irq(&callback_lock);\n\t\tif (!on_dfl)\n\t\t\tcpumask_copy(top_cpuset.cpus_allowed, &new_cpus);\n\t\t/*\n\t\t * Make sure that CPUs allocated to child partitions\n\t\t * do not show up in effective_cpus. If no CPU is left,\n\t\t * we clear the subparts_cpus & let the child partitions\n\t\t * fight for the CPUs again.\n\t\t */\n\t\tif (top_cpuset.nr_subparts_cpus) {\n\t\t\tif (cpumask_subset(&new_cpus,\n\t\t\t\t\t   top_cpuset.subparts_cpus)) {\n\t\t\t\ttop_cpuset.nr_subparts_cpus = 0;\n\t\t\t\tcpumask_clear(top_cpuset.subparts_cpus);\n\t\t\t} else {\n\t\t\t\tcpumask_andnot(&new_cpus, &new_cpus,\n\t\t\t\t\t       top_cpuset.subparts_cpus);\n\t\t\t}\n\t\t}\n\t\tcpumask_copy(top_cpuset.effective_cpus, &new_cpus);\n\t\tspin_unlock_irq(&callback_lock);\n\t\t/* we don't mess with cpumasks of tasks in top_cpuset */\n\t}\n\n\t/* synchronize mems_allowed to N_MEMORY */\n\tif (mems_updated) {\n\t\tspin_lock_irq(&callback_lock);\n\t\tif (!on_dfl)\n\t\t\ttop_cpuset.mems_allowed = new_mems;\n\t\ttop_cpuset.effective_mems = new_mems;\n\t\tspin_unlock_irq(&callback_lock);\n\t\tupdate_tasks_nodemask(&top_cpuset);\n\t}\n\n\tpercpu_up_write(&cpuset_rwsem);\n\n\t/* if cpus or mems changed, we need to propagate to descendants */\n\tif (cpus_updated || mems_updated) {\n\t\tstruct cpuset *cs;\n\t\tstruct cgroup_subsys_state *pos_css;\n\n\t\trcu_read_lock();\n\t\tcpuset_for_each_descendant_pre(cs, pos_css, &top_cpuset) {\n\t\t\tif (cs == &top_cpuset || !css_tryget_online(&cs->css))\n\t\t\t\tcontinue;\n\t\t\trcu_read_unlock();\n\n\t\t\tcpuset_hotplug_update_tasks(cs, ptmp);\n\n\t\t\trcu_read_lock();\n\t\t\tcss_put(&cs->css);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\t/* rebuild sched domains if cpus_allowed has changed */\n\tif (cpus_updated || force_rebuild) {\n\t\tforce_rebuild = false;\n\t\trebuild_sched_domains();\n\t}\n\n\tfree_cpumasks(NULL, ptmp);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
      "static DEFINE_SPINLOCK(callback_lock);",
      "static void cpuset_hotplug_workfn(struct work_struct *work);",
      "static DECLARE_WORK(cpuset_hotplug_work, cpuset_hotplug_workfn);",
      "static bool force_rebuild;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumasks",
          "args": [
            "NULL",
            "ptmp"
          ],
          "line": 3312
        },
        "resolved": true,
        "details": {
          "function_name": "free_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "547-559",
          "snippet": "static inline void free_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tif (cs) {\n\t\tfree_cpumask_var(cs->cpus_allowed);\n\t\tfree_cpumask_var(cs->effective_cpus);\n\t\tfree_cpumask_var(cs->subparts_cpus);\n\t}\n\tif (tmp) {\n\t\tfree_cpumask_var(tmp->new_cpus);\n\t\tfree_cpumask_var(tmp->addmask);\n\t\tfree_cpumask_var(tmp->delmask);\n\t}\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void free_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tif (cs) {\n\t\tfree_cpumask_var(cs->cpus_allowed);\n\t\tfree_cpumask_var(cs->effective_cpus);\n\t\tfree_cpumask_var(cs->subparts_cpus);\n\t}\n\tif (tmp) {\n\t\tfree_cpumask_var(tmp->new_cpus);\n\t\tfree_cpumask_var(tmp->addmask);\n\t\tfree_cpumask_var(tmp->delmask);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuild_sched_domains",
          "args": [],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1079-1086",
          "snippet": "void rebuild_sched_domains(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\trebuild_sched_domains_locked();\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid rebuild_sched_domains(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\trebuild_sched_domains_locked();\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3303
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&cs->css"
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3300
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_hotplug_update_tasks",
          "args": [
            "cs",
            "ptmp"
          ],
          "line": 3298
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_hotplug_update_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "3100-3199",
          "snippet": "static void cpuset_hotplug_update_tasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tstatic cpumask_t new_cpus;\n\tstatic nodemask_t new_mems;\n\tbool cpus_updated;\n\tbool mems_updated;\n\tstruct cpuset *parent;\nretry:\n\twait_event(cpuset_attach_wq, cs->attach_in_progress == 0);\n\n\tpercpu_down_write(&cpuset_rwsem);\n\n\t/*\n\t * We have raced with task attaching. We wait until attaching\n\t * is finished, so we won't attach a task to an empty cpuset.\n\t */\n\tif (cs->attach_in_progress) {\n\t\tpercpu_up_write(&cpuset_rwsem);\n\t\tgoto retry;\n\t}\n\n\tparent = parent_cs(cs);\n\tcompute_effective_cpumask(&new_cpus, cs, parent);\n\tnodes_and(new_mems, cs->mems_allowed, parent->effective_mems);\n\n\tif (cs->nr_subparts_cpus)\n\t\t/*\n\t\t * Make sure that CPUs allocated to child partitions\n\t\t * do not show up in effective_cpus.\n\t\t */\n\t\tcpumask_andnot(&new_cpus, &new_cpus, cs->subparts_cpus);\n\n\tif (!tmp || !cs->partition_root_state)\n\t\tgoto update_tasks;\n\n\t/*\n\t * In the unlikely event that a partition root has empty\n\t * effective_cpus or its parent becomes erroneous, we have to\n\t * transition it to the erroneous state.\n\t */\n\tif (is_partition_root(cs) && (cpumask_empty(&new_cpus) ||\n\t   (parent->partition_root_state == PRS_ERROR))) {\n\t\tif (cs->nr_subparts_cpus) {\n\t\t\tspin_lock_irq(&callback_lock);\n\t\t\tcs->nr_subparts_cpus = 0;\n\t\t\tcpumask_clear(cs->subparts_cpus);\n\t\t\tspin_unlock_irq(&callback_lock);\n\t\t\tcompute_effective_cpumask(&new_cpus, cs, parent);\n\t\t}\n\n\t\t/*\n\t\t * If the effective_cpus is empty because the child\n\t\t * partitions take away all the CPUs, we can keep\n\t\t * the current partition and let the child partitions\n\t\t * fight for available CPUs.\n\t\t */\n\t\tif ((parent->partition_root_state == PRS_ERROR) ||\n\t\t     cpumask_empty(&new_cpus)) {\n\t\t\tint old_prs;\n\n\t\t\tupdate_parent_subparts_cpumask(cs, partcmd_disable,\n\t\t\t\t\t\t       NULL, tmp);\n\t\t\told_prs = cs->partition_root_state;\n\t\t\tif (old_prs != PRS_ERROR) {\n\t\t\t\tspin_lock_irq(&callback_lock);\n\t\t\t\tcs->partition_root_state = PRS_ERROR;\n\t\t\t\tspin_unlock_irq(&callback_lock);\n\t\t\t\tnotify_partition_change(cs, old_prs, PRS_ERROR);\n\t\t\t}\n\t\t}\n\t\tcpuset_force_rebuild();\n\t}\n\n\t/*\n\t * On the other hand, an erroneous partition root may be transitioned\n\t * back to a regular one or a partition root with no CPU allocated\n\t * from the parent may change to erroneous.\n\t */\n\tif (is_partition_root(parent) &&\n\t   ((cs->partition_root_state == PRS_ERROR) ||\n\t    !cpumask_intersects(&new_cpus, parent->subparts_cpus)) &&\n\t     update_parent_subparts_cpumask(cs, partcmd_update, NULL, tmp))\n\t\tcpuset_force_rebuild();\n\nupdate_tasks:\n\tcpus_updated = !cpumask_equal(&new_cpus, cs->effective_cpus);\n\tmems_updated = !nodes_equal(new_mems, cs->effective_mems);\n\n\tif (mems_updated)\n\t\tcheck_insane_mems_config(&new_mems);\n\n\tif (is_in_v2_mode())\n\t\thotplug_update_tasks(cs, &new_cpus, &new_mems,\n\t\t\t\t     cpus_updated, mems_updated);\n\telse\n\t\thotplug_update_tasks_legacy(cs, &new_cpus, &new_mems,\n\t\t\t\t\t    cpus_updated, mems_updated);\n\n\tpercpu_up_write(&cpuset_rwsem);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define PRS_ERROR\t\t-1"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(cpuset_attach_wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n\nstatic DEFINE_SPINLOCK(callback_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(cpuset_attach_wq);\n\nstatic void cpuset_hotplug_update_tasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tstatic cpumask_t new_cpus;\n\tstatic nodemask_t new_mems;\n\tbool cpus_updated;\n\tbool mems_updated;\n\tstruct cpuset *parent;\nretry:\n\twait_event(cpuset_attach_wq, cs->attach_in_progress == 0);\n\n\tpercpu_down_write(&cpuset_rwsem);\n\n\t/*\n\t * We have raced with task attaching. We wait until attaching\n\t * is finished, so we won't attach a task to an empty cpuset.\n\t */\n\tif (cs->attach_in_progress) {\n\t\tpercpu_up_write(&cpuset_rwsem);\n\t\tgoto retry;\n\t}\n\n\tparent = parent_cs(cs);\n\tcompute_effective_cpumask(&new_cpus, cs, parent);\n\tnodes_and(new_mems, cs->mems_allowed, parent->effective_mems);\n\n\tif (cs->nr_subparts_cpus)\n\t\t/*\n\t\t * Make sure that CPUs allocated to child partitions\n\t\t * do not show up in effective_cpus.\n\t\t */\n\t\tcpumask_andnot(&new_cpus, &new_cpus, cs->subparts_cpus);\n\n\tif (!tmp || !cs->partition_root_state)\n\t\tgoto update_tasks;\n\n\t/*\n\t * In the unlikely event that a partition root has empty\n\t * effective_cpus or its parent becomes erroneous, we have to\n\t * transition it to the erroneous state.\n\t */\n\tif (is_partition_root(cs) && (cpumask_empty(&new_cpus) ||\n\t   (parent->partition_root_state == PRS_ERROR))) {\n\t\tif (cs->nr_subparts_cpus) {\n\t\t\tspin_lock_irq(&callback_lock);\n\t\t\tcs->nr_subparts_cpus = 0;\n\t\t\tcpumask_clear(cs->subparts_cpus);\n\t\t\tspin_unlock_irq(&callback_lock);\n\t\t\tcompute_effective_cpumask(&new_cpus, cs, parent);\n\t\t}\n\n\t\t/*\n\t\t * If the effective_cpus is empty because the child\n\t\t * partitions take away all the CPUs, we can keep\n\t\t * the current partition and let the child partitions\n\t\t * fight for available CPUs.\n\t\t */\n\t\tif ((parent->partition_root_state == PRS_ERROR) ||\n\t\t     cpumask_empty(&new_cpus)) {\n\t\t\tint old_prs;\n\n\t\t\tupdate_parent_subparts_cpumask(cs, partcmd_disable,\n\t\t\t\t\t\t       NULL, tmp);\n\t\t\told_prs = cs->partition_root_state;\n\t\t\tif (old_prs != PRS_ERROR) {\n\t\t\t\tspin_lock_irq(&callback_lock);\n\t\t\t\tcs->partition_root_state = PRS_ERROR;\n\t\t\t\tspin_unlock_irq(&callback_lock);\n\t\t\t\tnotify_partition_change(cs, old_prs, PRS_ERROR);\n\t\t\t}\n\t\t}\n\t\tcpuset_force_rebuild();\n\t}\n\n\t/*\n\t * On the other hand, an erroneous partition root may be transitioned\n\t * back to a regular one or a partition root with no CPU allocated\n\t * from the parent may change to erroneous.\n\t */\n\tif (is_partition_root(parent) &&\n\t   ((cs->partition_root_state == PRS_ERROR) ||\n\t    !cpumask_intersects(&new_cpus, parent->subparts_cpus)) &&\n\t     update_parent_subparts_cpumask(cs, partcmd_update, NULL, tmp))\n\t\tcpuset_force_rebuild();\n\nupdate_tasks:\n\tcpus_updated = !cpumask_equal(&new_cpus, cs->effective_cpus);\n\tmems_updated = !nodes_equal(new_mems, cs->effective_mems);\n\n\tif (mems_updated)\n\t\tcheck_insane_mems_config(&new_mems);\n\n\tif (is_in_v2_mode())\n\t\thotplug_update_tasks(cs, &new_cpus, &new_mems,\n\t\t\t\t     cpus_updated, mems_updated);\n\telse\n\t\thotplug_update_tasks_legacy(cs, &new_cpus, &new_mems,\n\t\t\t\t\t    cpus_updated, mems_updated);\n\n\tpercpu_up_write(&cpuset_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "&cs->css"
          ],
          "line": 3294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_for_each_descendant_pre",
          "args": [
            "cs",
            "pos_css",
            "&top_cpuset"
          ],
          "line": 3293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 3285
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_tasks_nodemask",
          "args": [
            "&top_cpuset"
          ],
          "line": 3282
        },
        "resolved": true,
        "details": {
          "function_name": "update_tasks_nodemask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1722-1771",
          "snippet": "static void update_tasks_nodemask(struct cpuset *cs)\n{\n\tstatic nodemask_t newmems;\t/* protected by cpuset_rwsem */\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcpuset_being_rebound = cs;\t\t/* causes mpol_dup() rebind */\n\n\tguarantee_online_mems(cs, &newmems);\n\n\t/*\n\t * The mpol_rebind_mm() call takes mmap_lock, which we couldn't\n\t * take while holding tasklist_lock.  Forks can happen - the\n\t * mpol_dup() cpuset_being_rebound check will catch such forks,\n\t * and rebind their vma mempolicies too.  Because we still hold\n\t * the global cpuset_rwsem, we know that no other rebind effort\n\t * will be contending for the global variable cpuset_being_rebound.\n\t * It's ok if we rebind the same mm twice; mpol_rebind_mm()\n\t * is idempotent.  Also migrate pages in each mm to new nodes.\n\t */\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tstruct mm_struct *mm;\n\t\tbool migrate;\n\n\t\tcpuset_change_task_nodemask(task, &newmems);\n\n\t\tmm = get_task_mm(task);\n\t\tif (!mm)\n\t\t\tcontinue;\n\n\t\tmigrate = is_memory_migrate(cs);\n\n\t\tmpol_rebind_mm(mm, &cs->mems_allowed);\n\t\tif (migrate)\n\t\t\tcpuset_migrate_mm(mm, &cs->old_mems_allowed, &newmems);\n\t\telse\n\t\t\tmmput(mm);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * All the tasks' nodemasks have been updated, update\n\t * cs->old_mems_allowed.\n\t */\n\tcs->old_mems_allowed = newmems;\n\n\t/* We're done rebinding vmas to this cpuset's new mems_allowed. */\n\tcpuset_being_rebound = NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *cpuset_being_rebound;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void *cpuset_being_rebound;\n\nstatic void update_tasks_nodemask(struct cpuset *cs)\n{\n\tstatic nodemask_t newmems;\t/* protected by cpuset_rwsem */\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcpuset_being_rebound = cs;\t\t/* causes mpol_dup() rebind */\n\n\tguarantee_online_mems(cs, &newmems);\n\n\t/*\n\t * The mpol_rebind_mm() call takes mmap_lock, which we couldn't\n\t * take while holding tasklist_lock.  Forks can happen - the\n\t * mpol_dup() cpuset_being_rebound check will catch such forks,\n\t * and rebind their vma mempolicies too.  Because we still hold\n\t * the global cpuset_rwsem, we know that no other rebind effort\n\t * will be contending for the global variable cpuset_being_rebound.\n\t * It's ok if we rebind the same mm twice; mpol_rebind_mm()\n\t * is idempotent.  Also migrate pages in each mm to new nodes.\n\t */\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tstruct mm_struct *mm;\n\t\tbool migrate;\n\n\t\tcpuset_change_task_nodemask(task, &newmems);\n\n\t\tmm = get_task_mm(task);\n\t\tif (!mm)\n\t\t\tcontinue;\n\n\t\tmigrate = is_memory_migrate(cs);\n\n\t\tmpol_rebind_mm(mm, &cs->mems_allowed);\n\t\tif (migrate)\n\t\t\tcpuset_migrate_mm(mm, &cs->old_mems_allowed, &newmems);\n\t\telse\n\t\t\tmmput(mm);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * All the tasks' nodemasks have been updated, update\n\t * cs->old_mems_allowed.\n\t */\n\tcs->old_mems_allowed = newmems;\n\n\t/* We're done rebinding vmas to this cpuset's new mems_allowed. */\n\tcpuset_being_rebound = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 3277
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "top_cpuset.effective_cpus",
            "&new_cpus"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "&new_cpus",
            "&new_cpus",
            "top_cpuset.subparts_cpus"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "top_cpuset.subparts_cpus"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "&new_cpus",
            "top_cpuset.subparts_cpus"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "top_cpuset.cpus_allowed",
            "&new_cpus"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_equal",
          "args": [
            "top_cpuset.effective_mems",
            "new_mems"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "top_cpuset.effective_cpus",
            "&new_cpus"
          ],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "&new_cpus",
            "cpu_active_mask"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cpumasks",
          "args": [
            "NULL",
            "&tmp"
          ],
          "line": 3225
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "510-540",
          "snippet": "static inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tcpumask_var_t *pmask1, *pmask2, *pmask3;\n\n\tif (cs) {\n\t\tpmask1 = &cs->cpus_allowed;\n\t\tpmask2 = &cs->effective_cpus;\n\t\tpmask3 = &cs->subparts_cpus;\n\t} else {\n\t\tpmask1 = &tmp->new_cpus;\n\t\tpmask2 = &tmp->addmask;\n\t\tpmask3 = &tmp->delmask;\n\t}\n\n\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))\n\t\tgoto free_one;\n\n\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))\n\t\tgoto free_two;\n\n\treturn 0;\n\nfree_two:\n\tfree_cpumask_var(*pmask2);\nfree_one:\n\tfree_cpumask_var(*pmask1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tcpumask_var_t *pmask1, *pmask2, *pmask3;\n\n\tif (cs) {\n\t\tpmask1 = &cs->cpus_allowed;\n\t\tpmask2 = &cs->effective_cpus;\n\t\tpmask3 = &cs->subparts_cpus;\n\t} else {\n\t\tpmask1 = &tmp->new_cpus;\n\t\tpmask2 = &tmp->addmask;\n\t\tpmask3 = &tmp->delmask;\n\t}\n\n\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))\n\t\tgoto free_one;\n\n\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))\n\t\tgoto free_two;\n\n\treturn 0;\n\nfree_two:\n\tfree_cpumask_var(*pmask2);\nfree_one:\n\tfree_cpumask_var(*pmask1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_in_v2_mode",
          "args": [],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_v2_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "401-405",
          "snippet": "static inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DEFINE_SPINLOCK(callback_lock);\nstatic void cpuset_hotplug_workfn(struct work_struct *work);\nstatic DECLARE_WORK(cpuset_hotplug_work, cpuset_hotplug_workfn);\nstatic bool force_rebuild;\n\nstatic void cpuset_hotplug_workfn(struct work_struct *work)\n{\n\tstatic cpumask_t new_cpus;\n\tstatic nodemask_t new_mems;\n\tbool cpus_updated, mems_updated;\n\tbool on_dfl = is_in_v2_mode();\n\tstruct tmpmasks tmp, *ptmp = NULL;\n\n\tif (on_dfl && !alloc_cpumasks(NULL, &tmp))\n\t\tptmp = &tmp;\n\n\tpercpu_down_write(&cpuset_rwsem);\n\n\t/* fetch the available cpus/mems and find out which changed how */\n\tcpumask_copy(&new_cpus, cpu_active_mask);\n\tnew_mems = node_states[N_MEMORY];\n\n\t/*\n\t * If subparts_cpus is populated, it is likely that the check below\n\t * will produce a false positive on cpus_updated when the cpu list\n\t * isn't changed. It is extra work, but it is better to be safe.\n\t */\n\tcpus_updated = !cpumask_equal(top_cpuset.effective_cpus, &new_cpus);\n\tmems_updated = !nodes_equal(top_cpuset.effective_mems, new_mems);\n\n\t/*\n\t * In the rare case that hotplug removes all the cpus in subparts_cpus,\n\t * we assumed that cpus are updated.\n\t */\n\tif (!cpus_updated && top_cpuset.nr_subparts_cpus)\n\t\tcpus_updated = true;\n\n\t/* synchronize cpus_allowed to cpu_active_mask */\n\tif (cpus_updated) {\n\t\tspin_lock_irq(&callback_lock);\n\t\tif (!on_dfl)\n\t\t\tcpumask_copy(top_cpuset.cpus_allowed, &new_cpus);\n\t\t/*\n\t\t * Make sure that CPUs allocated to child partitions\n\t\t * do not show up in effective_cpus. If no CPU is left,\n\t\t * we clear the subparts_cpus & let the child partitions\n\t\t * fight for the CPUs again.\n\t\t */\n\t\tif (top_cpuset.nr_subparts_cpus) {\n\t\t\tif (cpumask_subset(&new_cpus,\n\t\t\t\t\t   top_cpuset.subparts_cpus)) {\n\t\t\t\ttop_cpuset.nr_subparts_cpus = 0;\n\t\t\t\tcpumask_clear(top_cpuset.subparts_cpus);\n\t\t\t} else {\n\t\t\t\tcpumask_andnot(&new_cpus, &new_cpus,\n\t\t\t\t\t       top_cpuset.subparts_cpus);\n\t\t\t}\n\t\t}\n\t\tcpumask_copy(top_cpuset.effective_cpus, &new_cpus);\n\t\tspin_unlock_irq(&callback_lock);\n\t\t/* we don't mess with cpumasks of tasks in top_cpuset */\n\t}\n\n\t/* synchronize mems_allowed to N_MEMORY */\n\tif (mems_updated) {\n\t\tspin_lock_irq(&callback_lock);\n\t\tif (!on_dfl)\n\t\t\ttop_cpuset.mems_allowed = new_mems;\n\t\ttop_cpuset.effective_mems = new_mems;\n\t\tspin_unlock_irq(&callback_lock);\n\t\tupdate_tasks_nodemask(&top_cpuset);\n\t}\n\n\tpercpu_up_write(&cpuset_rwsem);\n\n\t/* if cpus or mems changed, we need to propagate to descendants */\n\tif (cpus_updated || mems_updated) {\n\t\tstruct cpuset *cs;\n\t\tstruct cgroup_subsys_state *pos_css;\n\n\t\trcu_read_lock();\n\t\tcpuset_for_each_descendant_pre(cs, pos_css, &top_cpuset) {\n\t\t\tif (cs == &top_cpuset || !css_tryget_online(&cs->css))\n\t\t\t\tcontinue;\n\t\t\trcu_read_unlock();\n\n\t\t\tcpuset_hotplug_update_tasks(cs, ptmp);\n\n\t\t\trcu_read_lock();\n\t\t\tcss_put(&cs->css);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\t/* rebuild sched domains if cpus_allowed has changed */\n\tif (cpus_updated || force_rebuild) {\n\t\tforce_rebuild = false;\n\t\trebuild_sched_domains();\n\t}\n\n\tfree_cpumasks(NULL, ptmp);\n}"
  },
  {
    "function_name": "cpuset_hotplug_update_tasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3100-3199",
    "snippet": "static void cpuset_hotplug_update_tasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tstatic cpumask_t new_cpus;\n\tstatic nodemask_t new_mems;\n\tbool cpus_updated;\n\tbool mems_updated;\n\tstruct cpuset *parent;\nretry:\n\twait_event(cpuset_attach_wq, cs->attach_in_progress == 0);\n\n\tpercpu_down_write(&cpuset_rwsem);\n\n\t/*\n\t * We have raced with task attaching. We wait until attaching\n\t * is finished, so we won't attach a task to an empty cpuset.\n\t */\n\tif (cs->attach_in_progress) {\n\t\tpercpu_up_write(&cpuset_rwsem);\n\t\tgoto retry;\n\t}\n\n\tparent = parent_cs(cs);\n\tcompute_effective_cpumask(&new_cpus, cs, parent);\n\tnodes_and(new_mems, cs->mems_allowed, parent->effective_mems);\n\n\tif (cs->nr_subparts_cpus)\n\t\t/*\n\t\t * Make sure that CPUs allocated to child partitions\n\t\t * do not show up in effective_cpus.\n\t\t */\n\t\tcpumask_andnot(&new_cpus, &new_cpus, cs->subparts_cpus);\n\n\tif (!tmp || !cs->partition_root_state)\n\t\tgoto update_tasks;\n\n\t/*\n\t * In the unlikely event that a partition root has empty\n\t * effective_cpus or its parent becomes erroneous, we have to\n\t * transition it to the erroneous state.\n\t */\n\tif (is_partition_root(cs) && (cpumask_empty(&new_cpus) ||\n\t   (parent->partition_root_state == PRS_ERROR))) {\n\t\tif (cs->nr_subparts_cpus) {\n\t\t\tspin_lock_irq(&callback_lock);\n\t\t\tcs->nr_subparts_cpus = 0;\n\t\t\tcpumask_clear(cs->subparts_cpus);\n\t\t\tspin_unlock_irq(&callback_lock);\n\t\t\tcompute_effective_cpumask(&new_cpus, cs, parent);\n\t\t}\n\n\t\t/*\n\t\t * If the effective_cpus is empty because the child\n\t\t * partitions take away all the CPUs, we can keep\n\t\t * the current partition and let the child partitions\n\t\t * fight for available CPUs.\n\t\t */\n\t\tif ((parent->partition_root_state == PRS_ERROR) ||\n\t\t     cpumask_empty(&new_cpus)) {\n\t\t\tint old_prs;\n\n\t\t\tupdate_parent_subparts_cpumask(cs, partcmd_disable,\n\t\t\t\t\t\t       NULL, tmp);\n\t\t\told_prs = cs->partition_root_state;\n\t\t\tif (old_prs != PRS_ERROR) {\n\t\t\t\tspin_lock_irq(&callback_lock);\n\t\t\t\tcs->partition_root_state = PRS_ERROR;\n\t\t\t\tspin_unlock_irq(&callback_lock);\n\t\t\t\tnotify_partition_change(cs, old_prs, PRS_ERROR);\n\t\t\t}\n\t\t}\n\t\tcpuset_force_rebuild();\n\t}\n\n\t/*\n\t * On the other hand, an erroneous partition root may be transitioned\n\t * back to a regular one or a partition root with no CPU allocated\n\t * from the parent may change to erroneous.\n\t */\n\tif (is_partition_root(parent) &&\n\t   ((cs->partition_root_state == PRS_ERROR) ||\n\t    !cpumask_intersects(&new_cpus, parent->subparts_cpus)) &&\n\t     update_parent_subparts_cpumask(cs, partcmd_update, NULL, tmp))\n\t\tcpuset_force_rebuild();\n\nupdate_tasks:\n\tcpus_updated = !cpumask_equal(&new_cpus, cs->effective_cpus);\n\tmems_updated = !nodes_equal(new_mems, cs->effective_mems);\n\n\tif (mems_updated)\n\t\tcheck_insane_mems_config(&new_mems);\n\n\tif (is_in_v2_mode())\n\t\thotplug_update_tasks(cs, &new_cpus, &new_mems,\n\t\t\t\t     cpus_updated, mems_updated);\n\telse\n\t\thotplug_update_tasks_legacy(cs, &new_cpus, &new_mems,\n\t\t\t\t\t    cpus_updated, mems_updated);\n\n\tpercpu_up_write(&cpuset_rwsem);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define PRS_ERROR\t\t-1"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);",
      "static DECLARE_WAIT_QUEUE_HEAD(cpuset_attach_wq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hotplug_update_tasks_legacy",
          "args": [
            "cs",
            "&new_cpus",
            "&new_mems",
            "cpus_updated",
            "mems_updated"
          ],
          "line": 3195
        },
        "resolved": true,
        "details": {
          "function_name": "hotplug_update_tasks_legacy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "3024-3061",
          "snippet": "static void\nhotplug_update_tasks_legacy(struct cpuset *cs,\n\t\t\t    struct cpumask *new_cpus, nodemask_t *new_mems,\n\t\t\t    bool cpus_updated, bool mems_updated)\n{\n\tbool is_empty;\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->cpus_allowed, new_cpus);\n\tcpumask_copy(cs->effective_cpus, new_cpus);\n\tcs->mems_allowed = *new_mems;\n\tcs->effective_mems = *new_mems;\n\tspin_unlock_irq(&callback_lock);\n\n\t/*\n\t * Don't call update_tasks_cpumask() if the cpuset becomes empty,\n\t * as the tasks will be migratecd to an ancestor.\n\t */\n\tif (cpus_updated && !cpumask_empty(cs->cpus_allowed))\n\t\tupdate_tasks_cpumask(cs);\n\tif (mems_updated && !nodes_empty(cs->mems_allowed))\n\t\tupdate_tasks_nodemask(cs);\n\n\tis_empty = cpumask_empty(cs->cpus_allowed) ||\n\t\t   nodes_empty(cs->mems_allowed);\n\n\tpercpu_up_write(&cpuset_rwsem);\n\n\t/*\n\t * Move tasks to the nearest ancestor with execution resources,\n\t * This is full cgroup operation which will also call back into\n\t * cpuset. Should be done outside any lock.\n\t */\n\tif (is_empty)\n\t\tremove_tasks_in_empty_cpuset(cs);\n\n\tpercpu_down_write(&cpuset_rwsem);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic void\nhotplug_update_tasks_legacy(struct cpuset *cs,\n\t\t\t    struct cpumask *new_cpus, nodemask_t *new_mems,\n\t\t\t    bool cpus_updated, bool mems_updated)\n{\n\tbool is_empty;\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->cpus_allowed, new_cpus);\n\tcpumask_copy(cs->effective_cpus, new_cpus);\n\tcs->mems_allowed = *new_mems;\n\tcs->effective_mems = *new_mems;\n\tspin_unlock_irq(&callback_lock);\n\n\t/*\n\t * Don't call update_tasks_cpumask() if the cpuset becomes empty,\n\t * as the tasks will be migratecd to an ancestor.\n\t */\n\tif (cpus_updated && !cpumask_empty(cs->cpus_allowed))\n\t\tupdate_tasks_cpumask(cs);\n\tif (mems_updated && !nodes_empty(cs->mems_allowed))\n\t\tupdate_tasks_nodemask(cs);\n\n\tis_empty = cpumask_empty(cs->cpus_allowed) ||\n\t\t   nodes_empty(cs->mems_allowed);\n\n\tpercpu_up_write(&cpuset_rwsem);\n\n\t/*\n\t * Move tasks to the nearest ancestor with execution resources,\n\t * This is full cgroup operation which will also call back into\n\t * cpuset. Should be done outside any lock.\n\t */\n\tif (is_empty)\n\t\tremove_tasks_in_empty_cpuset(cs);\n\n\tpercpu_down_write(&cpuset_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hotplug_update_tasks",
          "args": [
            "cs",
            "&new_cpus",
            "&new_mems",
            "cpus_updated",
            "mems_updated"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "hotplug_update_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "3063-3082",
          "snippet": "static void\nhotplug_update_tasks(struct cpuset *cs,\n\t\t     struct cpumask *new_cpus, nodemask_t *new_mems,\n\t\t     bool cpus_updated, bool mems_updated)\n{\n\tif (cpumask_empty(new_cpus))\n\t\tcpumask_copy(new_cpus, parent_cs(cs)->effective_cpus);\n\tif (nodes_empty(*new_mems))\n\t\t*new_mems = parent_cs(cs)->effective_mems;\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->effective_cpus, new_cpus);\n\tcs->effective_mems = *new_mems;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (cpus_updated)\n\t\tupdate_tasks_cpumask(cs);\n\tif (mems_updated)\n\t\tupdate_tasks_nodemask(cs);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic void\nhotplug_update_tasks(struct cpuset *cs,\n\t\t     struct cpumask *new_cpus, nodemask_t *new_mems,\n\t\t     bool cpus_updated, bool mems_updated)\n{\n\tif (cpumask_empty(new_cpus))\n\t\tcpumask_copy(new_cpus, parent_cs(cs)->effective_cpus);\n\tif (nodes_empty(*new_mems))\n\t\t*new_mems = parent_cs(cs)->effective_mems;\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->effective_cpus, new_cpus);\n\tcs->effective_mems = *new_mems;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (cpus_updated)\n\t\tupdate_tasks_cpumask(cs);\n\tif (mems_updated)\n\t\tupdate_tasks_nodemask(cs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_in_v2_mode",
          "args": [],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_v2_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "401-405",
          "snippet": "static inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_insane_mems_config",
          "args": [
            "&new_mems"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "check_insane_mems_config",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "382-391",
          "snippet": "static inline void check_insane_mems_config(nodemask_t *nodes)\n{\n\tif (!cpusets_insane_config() &&\n\t\tmovable_only_nodes(nodes)) {\n\t\tstatic_branch_enable(&cpusets_insane_config_key);\n\t\tpr_info(\"Unsupported (movable nodes only) cpuset configuration detected (nmask=%*pbl)!\\n\"\n\t\t\t\"Cpuset allocations might fail even with a lot of memory available.\\n\",\n\t\t\tnodemask_pr_args(nodes));\n\t}\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void check_insane_mems_config(nodemask_t *nodes)\n{\n\tif (!cpusets_insane_config() &&\n\t\tmovable_only_nodes(nodes)) {\n\t\tstatic_branch_enable(&cpusets_insane_config_key);\n\t\tpr_info(\"Unsupported (movable nodes only) cpuset configuration detected (nmask=%*pbl)!\\n\"\n\t\t\t\"Cpuset allocations might fail even with a lot of memory available.\\n\",\n\t\t\tnodemask_pr_args(nodes));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_equal",
          "args": [
            "new_mems",
            "cs->effective_mems"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "&new_cpus",
            "cs->effective_cpus"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_force_rebuild",
          "args": [],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_force_rebuild",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "3086-3089",
          "snippet": "void cpuset_force_rebuild(void)\n{\n\tforce_rebuild = true;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool force_rebuild;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic bool force_rebuild;\n\nvoid cpuset_force_rebuild(void)\n{\n\tforce_rebuild = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_parent_subparts_cpumask",
          "args": [
            "cs",
            "partcmd_update",
            "NULL",
            "tmp"
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "update_parent_subparts_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1182-1350",
          "snippet": "static int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,\n\t\t\t\t\t  struct cpumask *newmask,\n\t\t\t\t\t  struct tmpmasks *tmp)\n{\n\tstruct cpuset *parent = parent_cs(cpuset);\n\tint adding;\t/* Moving cpus from effective_cpus to subparts_cpus */\n\tint deleting;\t/* Moving cpus from subparts_cpus to effective_cpus */\n\tint old_prs, new_prs;\n\tbool part_error = false;\t/* Partition error? */\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * The parent must be a partition root.\n\t * The new cpumask, if present, or the current cpus_allowed must\n\t * not be empty.\n\t */\n\tif (!is_partition_root(parent) ||\n\t   (newmask && cpumask_empty(newmask)) ||\n\t   (!newmask && cpumask_empty(cpuset->cpus_allowed)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Enabling/disabling partition root is not allowed if there are\n\t * online children.\n\t */\n\tif ((cmd != partcmd_update) && css_has_online_children(&cpuset->css))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Enabling partition root is not allowed if not all the CPUs\n\t * can be granted from parent's effective_cpus or at least one\n\t * CPU will be left after that.\n\t */\n\tif ((cmd == partcmd_enable) &&\n\t   (!cpumask_subset(cpuset->cpus_allowed, parent->effective_cpus) ||\n\t     cpumask_equal(cpuset->cpus_allowed, parent->effective_cpus)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * A cpumask update cannot make parent's effective_cpus become empty.\n\t */\n\tadding = deleting = false;\n\told_prs = new_prs = cpuset->partition_root_state;\n\tif (cmd == partcmd_enable) {\n\t\tcpumask_copy(tmp->addmask, cpuset->cpus_allowed);\n\t\tadding = true;\n\t} else if (cmd == partcmd_disable) {\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t} else if (newmask) {\n\t\t/*\n\t\t * partcmd_update with newmask:\n\t\t *\n\t\t * delmask = cpus_allowed & ~newmask & parent->subparts_cpus\n\t\t * addmask = newmask & parent->effective_cpus\n\t\t *\t\t     & ~parent->subparts_cpus\n\t\t */\n\t\tcpumask_andnot(tmp->delmask, cpuset->cpus_allowed, newmask);\n\t\tdeleting = cpumask_and(tmp->delmask, tmp->delmask,\n\t\t\t\t       parent->subparts_cpus);\n\n\t\tcpumask_and(tmp->addmask, newmask, parent->effective_cpus);\n\t\tadding = cpumask_andnot(tmp->addmask, tmp->addmask,\n\t\t\t\t\tparent->subparts_cpus);\n\t\t/*\n\t\t * Return error if the new effective_cpus could become empty.\n\t\t */\n\t\tif (adding &&\n\t\t    cpumask_equal(parent->effective_cpus, tmp->addmask)) {\n\t\t\tif (!deleting)\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * As some of the CPUs in subparts_cpus might have\n\t\t\t * been offlined, we need to compute the real delmask\n\t\t\t * to confirm that.\n\t\t\t */\n\t\t\tif (!cpumask_and(tmp->addmask, tmp->delmask,\n\t\t\t\t\t cpu_active_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tcpumask_copy(tmp->addmask, parent->effective_cpus);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * partcmd_update w/o newmask:\n\t\t *\n\t\t * addmask = cpus_allowed & parent->effective_cpus\n\t\t *\n\t\t * Note that parent's subparts_cpus may have been\n\t\t * pre-shrunk in case there is a change in the cpu list.\n\t\t * So no deletion is needed.\n\t\t */\n\t\tadding = cpumask_and(tmp->addmask, cpuset->cpus_allowed,\n\t\t\t\t     parent->effective_cpus);\n\t\tpart_error = cpumask_equal(tmp->addmask,\n\t\t\t\t\t   parent->effective_cpus);\n\t}\n\n\tif (cmd == partcmd_update) {\n\t\tint prev_prs = cpuset->partition_root_state;\n\n\t\t/*\n\t\t * Check for possible transition between PRS_ENABLED\n\t\t * and PRS_ERROR.\n\t\t */\n\t\tswitch (cpuset->partition_root_state) {\n\t\tcase PRS_ENABLED:\n\t\t\tif (part_error)\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\tbreak;\n\t\tcase PRS_ERROR:\n\t\t\tif (!part_error)\n\t\t\t\tnew_prs = PRS_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Set part_error if previously in invalid state.\n\t\t */\n\t\tpart_error = (prev_prs == PRS_ERROR);\n\t}\n\n\tif (!part_error && (new_prs == PRS_ERROR))\n\t\treturn 0;\t/* Nothing need to be done */\n\n\tif (new_prs == PRS_ERROR) {\n\t\t/*\n\t\t * Remove all its cpus from parent's subparts_cpus.\n\t\t */\n\t\tadding = false;\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t}\n\n\tif (!adding && !deleting && (new_prs == old_prs))\n\t\treturn 0;\n\n\t/*\n\t * Change the parent's subparts_cpus.\n\t * Newly added CPUs will be removed from effective_cpus and\n\t * newly deleted ones will be added back to effective_cpus.\n\t */\n\tspin_lock_irq(&callback_lock);\n\tif (adding) {\n\t\tcpumask_or(parent->subparts_cpus,\n\t\t\t   parent->subparts_cpus, tmp->addmask);\n\t\tcpumask_andnot(parent->effective_cpus,\n\t\t\t       parent->effective_cpus, tmp->addmask);\n\t}\n\tif (deleting) {\n\t\tcpumask_andnot(parent->subparts_cpus,\n\t\t\t       parent->subparts_cpus, tmp->delmask);\n\t\t/*\n\t\t * Some of the CPUs in subparts_cpus might have been offlined.\n\t\t */\n\t\tcpumask_and(tmp->delmask, tmp->delmask, cpu_active_mask);\n\t\tcpumask_or(parent->effective_cpus,\n\t\t\t   parent->effective_cpus, tmp->delmask);\n\t}\n\n\tparent->nr_subparts_cpus = cpumask_weight(parent->subparts_cpus);\n\n\tif (old_prs != new_prs)\n\t\tcpuset->partition_root_state = new_prs;\n\n\tspin_unlock_irq(&callback_lock);\n\tnotify_partition_change(cpuset, old_prs, new_prs);\n\n\treturn cmd == partcmd_update;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define PRS_ERROR\t\t-1",
            "#define PRS_ENABLED\t\t1"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n#define PRS_ENABLED\t\t1\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,\n\t\t\t\t\t  struct cpumask *newmask,\n\t\t\t\t\t  struct tmpmasks *tmp)\n{\n\tstruct cpuset *parent = parent_cs(cpuset);\n\tint adding;\t/* Moving cpus from effective_cpus to subparts_cpus */\n\tint deleting;\t/* Moving cpus from subparts_cpus to effective_cpus */\n\tint old_prs, new_prs;\n\tbool part_error = false;\t/* Partition error? */\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * The parent must be a partition root.\n\t * The new cpumask, if present, or the current cpus_allowed must\n\t * not be empty.\n\t */\n\tif (!is_partition_root(parent) ||\n\t   (newmask && cpumask_empty(newmask)) ||\n\t   (!newmask && cpumask_empty(cpuset->cpus_allowed)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Enabling/disabling partition root is not allowed if there are\n\t * online children.\n\t */\n\tif ((cmd != partcmd_update) && css_has_online_children(&cpuset->css))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Enabling partition root is not allowed if not all the CPUs\n\t * can be granted from parent's effective_cpus or at least one\n\t * CPU will be left after that.\n\t */\n\tif ((cmd == partcmd_enable) &&\n\t   (!cpumask_subset(cpuset->cpus_allowed, parent->effective_cpus) ||\n\t     cpumask_equal(cpuset->cpus_allowed, parent->effective_cpus)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * A cpumask update cannot make parent's effective_cpus become empty.\n\t */\n\tadding = deleting = false;\n\told_prs = new_prs = cpuset->partition_root_state;\n\tif (cmd == partcmd_enable) {\n\t\tcpumask_copy(tmp->addmask, cpuset->cpus_allowed);\n\t\tadding = true;\n\t} else if (cmd == partcmd_disable) {\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t} else if (newmask) {\n\t\t/*\n\t\t * partcmd_update with newmask:\n\t\t *\n\t\t * delmask = cpus_allowed & ~newmask & parent->subparts_cpus\n\t\t * addmask = newmask & parent->effective_cpus\n\t\t *\t\t     & ~parent->subparts_cpus\n\t\t */\n\t\tcpumask_andnot(tmp->delmask, cpuset->cpus_allowed, newmask);\n\t\tdeleting = cpumask_and(tmp->delmask, tmp->delmask,\n\t\t\t\t       parent->subparts_cpus);\n\n\t\tcpumask_and(tmp->addmask, newmask, parent->effective_cpus);\n\t\tadding = cpumask_andnot(tmp->addmask, tmp->addmask,\n\t\t\t\t\tparent->subparts_cpus);\n\t\t/*\n\t\t * Return error if the new effective_cpus could become empty.\n\t\t */\n\t\tif (adding &&\n\t\t    cpumask_equal(parent->effective_cpus, tmp->addmask)) {\n\t\t\tif (!deleting)\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * As some of the CPUs in subparts_cpus might have\n\t\t\t * been offlined, we need to compute the real delmask\n\t\t\t * to confirm that.\n\t\t\t */\n\t\t\tif (!cpumask_and(tmp->addmask, tmp->delmask,\n\t\t\t\t\t cpu_active_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tcpumask_copy(tmp->addmask, parent->effective_cpus);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * partcmd_update w/o newmask:\n\t\t *\n\t\t * addmask = cpus_allowed & parent->effective_cpus\n\t\t *\n\t\t * Note that parent's subparts_cpus may have been\n\t\t * pre-shrunk in case there is a change in the cpu list.\n\t\t * So no deletion is needed.\n\t\t */\n\t\tadding = cpumask_and(tmp->addmask, cpuset->cpus_allowed,\n\t\t\t\t     parent->effective_cpus);\n\t\tpart_error = cpumask_equal(tmp->addmask,\n\t\t\t\t\t   parent->effective_cpus);\n\t}\n\n\tif (cmd == partcmd_update) {\n\t\tint prev_prs = cpuset->partition_root_state;\n\n\t\t/*\n\t\t * Check for possible transition between PRS_ENABLED\n\t\t * and PRS_ERROR.\n\t\t */\n\t\tswitch (cpuset->partition_root_state) {\n\t\tcase PRS_ENABLED:\n\t\t\tif (part_error)\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\tbreak;\n\t\tcase PRS_ERROR:\n\t\t\tif (!part_error)\n\t\t\t\tnew_prs = PRS_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Set part_error if previously in invalid state.\n\t\t */\n\t\tpart_error = (prev_prs == PRS_ERROR);\n\t}\n\n\tif (!part_error && (new_prs == PRS_ERROR))\n\t\treturn 0;\t/* Nothing need to be done */\n\n\tif (new_prs == PRS_ERROR) {\n\t\t/*\n\t\t * Remove all its cpus from parent's subparts_cpus.\n\t\t */\n\t\tadding = false;\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t}\n\n\tif (!adding && !deleting && (new_prs == old_prs))\n\t\treturn 0;\n\n\t/*\n\t * Change the parent's subparts_cpus.\n\t * Newly added CPUs will be removed from effective_cpus and\n\t * newly deleted ones will be added back to effective_cpus.\n\t */\n\tspin_lock_irq(&callback_lock);\n\tif (adding) {\n\t\tcpumask_or(parent->subparts_cpus,\n\t\t\t   parent->subparts_cpus, tmp->addmask);\n\t\tcpumask_andnot(parent->effective_cpus,\n\t\t\t       parent->effective_cpus, tmp->addmask);\n\t}\n\tif (deleting) {\n\t\tcpumask_andnot(parent->subparts_cpus,\n\t\t\t       parent->subparts_cpus, tmp->delmask);\n\t\t/*\n\t\t * Some of the CPUs in subparts_cpus might have been offlined.\n\t\t */\n\t\tcpumask_and(tmp->delmask, tmp->delmask, cpu_active_mask);\n\t\tcpumask_or(parent->effective_cpus,\n\t\t\t   parent->effective_cpus, tmp->delmask);\n\t}\n\n\tparent->nr_subparts_cpus = cpumask_weight(parent->subparts_cpus);\n\n\tif (old_prs != new_prs)\n\t\tcpuset->partition_root_state = new_prs;\n\n\tspin_unlock_irq(&callback_lock);\n\tnotify_partition_change(cpuset, old_prs, new_prs);\n\n\treturn cmd == partcmd_update;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "&new_cpus",
            "parent->subparts_cpus"
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_partition_root",
          "args": [
            "parent"
          ],
          "line": 3178
        },
        "resolved": true,
        "details": {
          "function_name": "is_partition_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "271-274",
          "snippet": "static inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_partition_change",
          "args": [
            "cs",
            "old_prs",
            "PRS_ERROR"
          ],
          "line": 3167
        },
        "resolved": true,
        "details": {
          "function_name": "notify_partition_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "279-284",
          "snippet": "static inline void notify_partition_change(struct cpuset *cs,\n\t\t\t\t\t   int old_prs, int new_prs)\n{\n\tif (old_prs != new_prs)\n\t\tcgroup_file_notify(&cs->partition_file);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void notify_partition_change(struct cpuset *cs,\n\t\t\t\t\t   int old_prs, int new_prs)\n{\n\tif (old_prs != new_prs)\n\t\tcgroup_file_notify(&cs->partition_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 3166
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 3164
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "&new_cpus"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compute_effective_cpumask",
          "args": [
            "&new_cpus",
            "cs",
            "parent"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "compute_effective_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1118-1129",
          "snippet": "static void compute_effective_cpumask(struct cpumask *new_cpus,\n\t\t\t\t      struct cpuset *cs, struct cpuset *parent)\n{\n\tif (parent->nr_subparts_cpus) {\n\t\tcpumask_or(new_cpus, parent->effective_cpus,\n\t\t\t   parent->subparts_cpus);\n\t\tcpumask_and(new_cpus, new_cpus, cs->cpus_allowed);\n\t\tcpumask_and(new_cpus, new_cpus, cpu_active_mask);\n\t} else {\n\t\tcpumask_and(new_cpus, cs->cpus_allowed, parent->effective_cpus);\n\t}\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void compute_effective_cpumask(struct cpumask *new_cpus,\n\t\t\t\t      struct cpuset *cs, struct cpuset *parent)\n{\n\tif (parent->nr_subparts_cpus) {\n\t\tcpumask_or(new_cpus, parent->effective_cpus,\n\t\t\t   parent->subparts_cpus);\n\t\tcpumask_and(new_cpus, new_cpus, cs->cpus_allowed);\n\t\tcpumask_and(new_cpus, new_cpus, cpu_active_mask);\n\t} else {\n\t\tcpumask_and(new_cpus, cs->cpus_allowed, parent->effective_cpus);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "cs->subparts_cpus"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "&new_cpus"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "&new_cpus",
            "&new_cpus",
            "cs->subparts_cpus"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_and",
          "args": [
            "new_mems",
            "cs->mems_allowed",
            "parent->effective_mems"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cs"
          ],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "cpuset_attach_wq",
            "cs->attach_in_progress == 0"
          ],
          "line": 3108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n\nstatic DEFINE_SPINLOCK(callback_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(cpuset_attach_wq);\n\nstatic void cpuset_hotplug_update_tasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tstatic cpumask_t new_cpus;\n\tstatic nodemask_t new_mems;\n\tbool cpus_updated;\n\tbool mems_updated;\n\tstruct cpuset *parent;\nretry:\n\twait_event(cpuset_attach_wq, cs->attach_in_progress == 0);\n\n\tpercpu_down_write(&cpuset_rwsem);\n\n\t/*\n\t * We have raced with task attaching. We wait until attaching\n\t * is finished, so we won't attach a task to an empty cpuset.\n\t */\n\tif (cs->attach_in_progress) {\n\t\tpercpu_up_write(&cpuset_rwsem);\n\t\tgoto retry;\n\t}\n\n\tparent = parent_cs(cs);\n\tcompute_effective_cpumask(&new_cpus, cs, parent);\n\tnodes_and(new_mems, cs->mems_allowed, parent->effective_mems);\n\n\tif (cs->nr_subparts_cpus)\n\t\t/*\n\t\t * Make sure that CPUs allocated to child partitions\n\t\t * do not show up in effective_cpus.\n\t\t */\n\t\tcpumask_andnot(&new_cpus, &new_cpus, cs->subparts_cpus);\n\n\tif (!tmp || !cs->partition_root_state)\n\t\tgoto update_tasks;\n\n\t/*\n\t * In the unlikely event that a partition root has empty\n\t * effective_cpus or its parent becomes erroneous, we have to\n\t * transition it to the erroneous state.\n\t */\n\tif (is_partition_root(cs) && (cpumask_empty(&new_cpus) ||\n\t   (parent->partition_root_state == PRS_ERROR))) {\n\t\tif (cs->nr_subparts_cpus) {\n\t\t\tspin_lock_irq(&callback_lock);\n\t\t\tcs->nr_subparts_cpus = 0;\n\t\t\tcpumask_clear(cs->subparts_cpus);\n\t\t\tspin_unlock_irq(&callback_lock);\n\t\t\tcompute_effective_cpumask(&new_cpus, cs, parent);\n\t\t}\n\n\t\t/*\n\t\t * If the effective_cpus is empty because the child\n\t\t * partitions take away all the CPUs, we can keep\n\t\t * the current partition and let the child partitions\n\t\t * fight for available CPUs.\n\t\t */\n\t\tif ((parent->partition_root_state == PRS_ERROR) ||\n\t\t     cpumask_empty(&new_cpus)) {\n\t\t\tint old_prs;\n\n\t\t\tupdate_parent_subparts_cpumask(cs, partcmd_disable,\n\t\t\t\t\t\t       NULL, tmp);\n\t\t\told_prs = cs->partition_root_state;\n\t\t\tif (old_prs != PRS_ERROR) {\n\t\t\t\tspin_lock_irq(&callback_lock);\n\t\t\t\tcs->partition_root_state = PRS_ERROR;\n\t\t\t\tspin_unlock_irq(&callback_lock);\n\t\t\t\tnotify_partition_change(cs, old_prs, PRS_ERROR);\n\t\t\t}\n\t\t}\n\t\tcpuset_force_rebuild();\n\t}\n\n\t/*\n\t * On the other hand, an erroneous partition root may be transitioned\n\t * back to a regular one or a partition root with no CPU allocated\n\t * from the parent may change to erroneous.\n\t */\n\tif (is_partition_root(parent) &&\n\t   ((cs->partition_root_state == PRS_ERROR) ||\n\t    !cpumask_intersects(&new_cpus, parent->subparts_cpus)) &&\n\t     update_parent_subparts_cpumask(cs, partcmd_update, NULL, tmp))\n\t\tcpuset_force_rebuild();\n\nupdate_tasks:\n\tcpus_updated = !cpumask_equal(&new_cpus, cs->effective_cpus);\n\tmems_updated = !nodes_equal(new_mems, cs->effective_mems);\n\n\tif (mems_updated)\n\t\tcheck_insane_mems_config(&new_mems);\n\n\tif (is_in_v2_mode())\n\t\thotplug_update_tasks(cs, &new_cpus, &new_mems,\n\t\t\t\t     cpus_updated, mems_updated);\n\telse\n\t\thotplug_update_tasks_legacy(cs, &new_cpus, &new_mems,\n\t\t\t\t\t    cpus_updated, mems_updated);\n\n\tpercpu_up_write(&cpuset_rwsem);\n}"
  },
  {
    "function_name": "cpuset_force_rebuild",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3086-3089",
    "snippet": "void cpuset_force_rebuild(void)\n{\n\tforce_rebuild = true;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool force_rebuild;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic bool force_rebuild;\n\nvoid cpuset_force_rebuild(void)\n{\n\tforce_rebuild = true;\n}"
  },
  {
    "function_name": "hotplug_update_tasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3063-3082",
    "snippet": "static void\nhotplug_update_tasks(struct cpuset *cs,\n\t\t     struct cpumask *new_cpus, nodemask_t *new_mems,\n\t\t     bool cpus_updated, bool mems_updated)\n{\n\tif (cpumask_empty(new_cpus))\n\t\tcpumask_copy(new_cpus, parent_cs(cs)->effective_cpus);\n\tif (nodes_empty(*new_mems))\n\t\t*new_mems = parent_cs(cs)->effective_mems;\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->effective_cpus, new_cpus);\n\tcs->effective_mems = *new_mems;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (cpus_updated)\n\t\tupdate_tasks_cpumask(cs);\n\tif (mems_updated)\n\t\tupdate_tasks_nodemask(cs);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_tasks_nodemask",
          "args": [
            "cs"
          ],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "update_tasks_nodemask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1722-1771",
          "snippet": "static void update_tasks_nodemask(struct cpuset *cs)\n{\n\tstatic nodemask_t newmems;\t/* protected by cpuset_rwsem */\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcpuset_being_rebound = cs;\t\t/* causes mpol_dup() rebind */\n\n\tguarantee_online_mems(cs, &newmems);\n\n\t/*\n\t * The mpol_rebind_mm() call takes mmap_lock, which we couldn't\n\t * take while holding tasklist_lock.  Forks can happen - the\n\t * mpol_dup() cpuset_being_rebound check will catch such forks,\n\t * and rebind their vma mempolicies too.  Because we still hold\n\t * the global cpuset_rwsem, we know that no other rebind effort\n\t * will be contending for the global variable cpuset_being_rebound.\n\t * It's ok if we rebind the same mm twice; mpol_rebind_mm()\n\t * is idempotent.  Also migrate pages in each mm to new nodes.\n\t */\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tstruct mm_struct *mm;\n\t\tbool migrate;\n\n\t\tcpuset_change_task_nodemask(task, &newmems);\n\n\t\tmm = get_task_mm(task);\n\t\tif (!mm)\n\t\t\tcontinue;\n\n\t\tmigrate = is_memory_migrate(cs);\n\n\t\tmpol_rebind_mm(mm, &cs->mems_allowed);\n\t\tif (migrate)\n\t\t\tcpuset_migrate_mm(mm, &cs->old_mems_allowed, &newmems);\n\t\telse\n\t\t\tmmput(mm);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * All the tasks' nodemasks have been updated, update\n\t * cs->old_mems_allowed.\n\t */\n\tcs->old_mems_allowed = newmems;\n\n\t/* We're done rebinding vmas to this cpuset's new mems_allowed. */\n\tcpuset_being_rebound = NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *cpuset_being_rebound;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void *cpuset_being_rebound;\n\nstatic void update_tasks_nodemask(struct cpuset *cs)\n{\n\tstatic nodemask_t newmems;\t/* protected by cpuset_rwsem */\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcpuset_being_rebound = cs;\t\t/* causes mpol_dup() rebind */\n\n\tguarantee_online_mems(cs, &newmems);\n\n\t/*\n\t * The mpol_rebind_mm() call takes mmap_lock, which we couldn't\n\t * take while holding tasklist_lock.  Forks can happen - the\n\t * mpol_dup() cpuset_being_rebound check will catch such forks,\n\t * and rebind their vma mempolicies too.  Because we still hold\n\t * the global cpuset_rwsem, we know that no other rebind effort\n\t * will be contending for the global variable cpuset_being_rebound.\n\t * It's ok if we rebind the same mm twice; mpol_rebind_mm()\n\t * is idempotent.  Also migrate pages in each mm to new nodes.\n\t */\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tstruct mm_struct *mm;\n\t\tbool migrate;\n\n\t\tcpuset_change_task_nodemask(task, &newmems);\n\n\t\tmm = get_task_mm(task);\n\t\tif (!mm)\n\t\t\tcontinue;\n\n\t\tmigrate = is_memory_migrate(cs);\n\n\t\tmpol_rebind_mm(mm, &cs->mems_allowed);\n\t\tif (migrate)\n\t\t\tcpuset_migrate_mm(mm, &cs->old_mems_allowed, &newmems);\n\t\telse\n\t\t\tmmput(mm);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * All the tasks' nodemasks have been updated, update\n\t * cs->old_mems_allowed.\n\t */\n\tcs->old_mems_allowed = newmems;\n\n\t/* We're done rebinding vmas to this cpuset's new mems_allowed. */\n\tcpuset_being_rebound = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_tasks_cpumask",
          "args": [
            "cs"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "update_tasks_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1096-1105",
          "snippet": "static void update_tasks_cpumask(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tset_cpus_allowed_ptr(task, cs->effective_cpus);\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_tasks_cpumask(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tset_cpus_allowed_ptr(task, cs->effective_cpus);\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 3076
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cs->effective_cpus",
            "new_cpus"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 3073
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cs"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*new_mems"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "new_cpus",
            "parent_cs(cs)->effective_cpus"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "new_cpus"
          ],
          "line": 3068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic void\nhotplug_update_tasks(struct cpuset *cs,\n\t\t     struct cpumask *new_cpus, nodemask_t *new_mems,\n\t\t     bool cpus_updated, bool mems_updated)\n{\n\tif (cpumask_empty(new_cpus))\n\t\tcpumask_copy(new_cpus, parent_cs(cs)->effective_cpus);\n\tif (nodes_empty(*new_mems))\n\t\t*new_mems = parent_cs(cs)->effective_mems;\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->effective_cpus, new_cpus);\n\tcs->effective_mems = *new_mems;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (cpus_updated)\n\t\tupdate_tasks_cpumask(cs);\n\tif (mems_updated)\n\t\tupdate_tasks_nodemask(cs);\n}"
  },
  {
    "function_name": "hotplug_update_tasks_legacy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3024-3061",
    "snippet": "static void\nhotplug_update_tasks_legacy(struct cpuset *cs,\n\t\t\t    struct cpumask *new_cpus, nodemask_t *new_mems,\n\t\t\t    bool cpus_updated, bool mems_updated)\n{\n\tbool is_empty;\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->cpus_allowed, new_cpus);\n\tcpumask_copy(cs->effective_cpus, new_cpus);\n\tcs->mems_allowed = *new_mems;\n\tcs->effective_mems = *new_mems;\n\tspin_unlock_irq(&callback_lock);\n\n\t/*\n\t * Don't call update_tasks_cpumask() if the cpuset becomes empty,\n\t * as the tasks will be migratecd to an ancestor.\n\t */\n\tif (cpus_updated && !cpumask_empty(cs->cpus_allowed))\n\t\tupdate_tasks_cpumask(cs);\n\tif (mems_updated && !nodes_empty(cs->mems_allowed))\n\t\tupdate_tasks_nodemask(cs);\n\n\tis_empty = cpumask_empty(cs->cpus_allowed) ||\n\t\t   nodes_empty(cs->mems_allowed);\n\n\tpercpu_up_write(&cpuset_rwsem);\n\n\t/*\n\t * Move tasks to the nearest ancestor with execution resources,\n\t * This is full cgroup operation which will also call back into\n\t * cpuset. Should be done outside any lock.\n\t */\n\tif (is_empty)\n\t\tremove_tasks_in_empty_cpuset(cs);\n\n\tpercpu_down_write(&cpuset_rwsem);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_tasks_in_empty_cpuset",
          "args": [
            "cs"
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "remove_tasks_in_empty_cpuset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "3004-3022",
          "snippet": "static void remove_tasks_in_empty_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *parent;\n\n\t/*\n\t * Find its next-highest non-empty parent, (top cpuset\n\t * has online cpus, so can't be empty).\n\t */\n\tparent = parent_cs(cs);\n\twhile (cpumask_empty(parent->cpus_allowed) ||\n\t\t\tnodes_empty(parent->mems_allowed))\n\t\tparent = parent_cs(parent);\n\n\tif (cgroup_transfer_tasks(parent->css.cgroup, cs->css.cgroup)) {\n\t\tpr_err(\"cpuset: failed to transfer tasks out of empty cpuset \");\n\t\tpr_cont_cgroup_name(cs->css.cgroup);\n\t\tpr_cont(\"\\n\");\n\t}\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void remove_tasks_in_empty_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *parent;\n\n\t/*\n\t * Find its next-highest non-empty parent, (top cpuset\n\t * has online cpus, so can't be empty).\n\t */\n\tparent = parent_cs(cs);\n\twhile (cpumask_empty(parent->cpus_allowed) ||\n\t\t\tnodes_empty(parent->mems_allowed))\n\t\tparent = parent_cs(parent);\n\n\tif (cgroup_transfer_tasks(parent->css.cgroup, cs->css.cgroup)) {\n\t\tpr_err(\"cpuset: failed to transfer tasks out of empty cpuset \");\n\t\tpr_cont_cgroup_name(cs->css.cgroup);\n\t\tpr_cont(\"\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "cs->mems_allowed"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cs->cpus_allowed"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_tasks_nodemask",
          "args": [
            "cs"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "update_tasks_nodemask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1722-1771",
          "snippet": "static void update_tasks_nodemask(struct cpuset *cs)\n{\n\tstatic nodemask_t newmems;\t/* protected by cpuset_rwsem */\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcpuset_being_rebound = cs;\t\t/* causes mpol_dup() rebind */\n\n\tguarantee_online_mems(cs, &newmems);\n\n\t/*\n\t * The mpol_rebind_mm() call takes mmap_lock, which we couldn't\n\t * take while holding tasklist_lock.  Forks can happen - the\n\t * mpol_dup() cpuset_being_rebound check will catch such forks,\n\t * and rebind their vma mempolicies too.  Because we still hold\n\t * the global cpuset_rwsem, we know that no other rebind effort\n\t * will be contending for the global variable cpuset_being_rebound.\n\t * It's ok if we rebind the same mm twice; mpol_rebind_mm()\n\t * is idempotent.  Also migrate pages in each mm to new nodes.\n\t */\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tstruct mm_struct *mm;\n\t\tbool migrate;\n\n\t\tcpuset_change_task_nodemask(task, &newmems);\n\n\t\tmm = get_task_mm(task);\n\t\tif (!mm)\n\t\t\tcontinue;\n\n\t\tmigrate = is_memory_migrate(cs);\n\n\t\tmpol_rebind_mm(mm, &cs->mems_allowed);\n\t\tif (migrate)\n\t\t\tcpuset_migrate_mm(mm, &cs->old_mems_allowed, &newmems);\n\t\telse\n\t\t\tmmput(mm);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * All the tasks' nodemasks have been updated, update\n\t * cs->old_mems_allowed.\n\t */\n\tcs->old_mems_allowed = newmems;\n\n\t/* We're done rebinding vmas to this cpuset's new mems_allowed. */\n\tcpuset_being_rebound = NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *cpuset_being_rebound;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void *cpuset_being_rebound;\n\nstatic void update_tasks_nodemask(struct cpuset *cs)\n{\n\tstatic nodemask_t newmems;\t/* protected by cpuset_rwsem */\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcpuset_being_rebound = cs;\t\t/* causes mpol_dup() rebind */\n\n\tguarantee_online_mems(cs, &newmems);\n\n\t/*\n\t * The mpol_rebind_mm() call takes mmap_lock, which we couldn't\n\t * take while holding tasklist_lock.  Forks can happen - the\n\t * mpol_dup() cpuset_being_rebound check will catch such forks,\n\t * and rebind their vma mempolicies too.  Because we still hold\n\t * the global cpuset_rwsem, we know that no other rebind effort\n\t * will be contending for the global variable cpuset_being_rebound.\n\t * It's ok if we rebind the same mm twice; mpol_rebind_mm()\n\t * is idempotent.  Also migrate pages in each mm to new nodes.\n\t */\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tstruct mm_struct *mm;\n\t\tbool migrate;\n\n\t\tcpuset_change_task_nodemask(task, &newmems);\n\n\t\tmm = get_task_mm(task);\n\t\tif (!mm)\n\t\t\tcontinue;\n\n\t\tmigrate = is_memory_migrate(cs);\n\n\t\tmpol_rebind_mm(mm, &cs->mems_allowed);\n\t\tif (migrate)\n\t\t\tcpuset_migrate_mm(mm, &cs->old_mems_allowed, &newmems);\n\t\telse\n\t\t\tmmput(mm);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * All the tasks' nodemasks have been updated, update\n\t * cs->old_mems_allowed.\n\t */\n\tcs->old_mems_allowed = newmems;\n\n\t/* We're done rebinding vmas to this cpuset's new mems_allowed. */\n\tcpuset_being_rebound = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "cs->mems_allowed"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_tasks_cpumask",
          "args": [
            "cs"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "update_tasks_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1096-1105",
          "snippet": "static void update_tasks_cpumask(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tset_cpus_allowed_ptr(task, cs->effective_cpus);\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_tasks_cpumask(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tset_cpus_allowed_ptr(task, cs->effective_cpus);\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cs->cpus_allowed"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cs->effective_cpus",
            "new_cpus"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cs->cpus_allowed",
            "new_cpus"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic void\nhotplug_update_tasks_legacy(struct cpuset *cs,\n\t\t\t    struct cpumask *new_cpus, nodemask_t *new_mems,\n\t\t\t    bool cpus_updated, bool mems_updated)\n{\n\tbool is_empty;\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->cpus_allowed, new_cpus);\n\tcpumask_copy(cs->effective_cpus, new_cpus);\n\tcs->mems_allowed = *new_mems;\n\tcs->effective_mems = *new_mems;\n\tspin_unlock_irq(&callback_lock);\n\n\t/*\n\t * Don't call update_tasks_cpumask() if the cpuset becomes empty,\n\t * as the tasks will be migratecd to an ancestor.\n\t */\n\tif (cpus_updated && !cpumask_empty(cs->cpus_allowed))\n\t\tupdate_tasks_cpumask(cs);\n\tif (mems_updated && !nodes_empty(cs->mems_allowed))\n\t\tupdate_tasks_nodemask(cs);\n\n\tis_empty = cpumask_empty(cs->cpus_allowed) ||\n\t\t   nodes_empty(cs->mems_allowed);\n\n\tpercpu_up_write(&cpuset_rwsem);\n\n\t/*\n\t * Move tasks to the nearest ancestor with execution resources,\n\t * This is full cgroup operation which will also call back into\n\t * cpuset. Should be done outside any lock.\n\t */\n\tif (is_empty)\n\t\tremove_tasks_in_empty_cpuset(cs);\n\n\tpercpu_down_write(&cpuset_rwsem);\n}"
  },
  {
    "function_name": "remove_tasks_in_empty_cpuset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "3004-3022",
    "snippet": "static void remove_tasks_in_empty_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *parent;\n\n\t/*\n\t * Find its next-highest non-empty parent, (top cpuset\n\t * has online cpus, so can't be empty).\n\t */\n\tparent = parent_cs(cs);\n\twhile (cpumask_empty(parent->cpus_allowed) ||\n\t\t\tnodes_empty(parent->mems_allowed))\n\t\tparent = parent_cs(parent);\n\n\tif (cgroup_transfer_tasks(parent->css.cgroup, cs->css.cgroup)) {\n\t\tpr_err(\"cpuset: failed to transfer tasks out of empty cpuset \");\n\t\tpr_cont_cgroup_name(cs->css.cgroup);\n\t\tpr_cont(\"\\n\");\n\t}\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4715-4721",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont_cgroup_name",
          "args": [
            "cs->css.cgroup"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cpuset: failed to transfer tasks out of empty cpuset \""
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_transfer_tasks",
          "args": [
            "parent->css.cgroup",
            "cs->css.cgroup"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_transfer_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "94-150",
          "snippet": "int cgroup_transfer_tasks(struct cgroup *to, struct cgroup *from)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgrp_cset_link *link;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\tint ret;\n\n\tif (cgroup_on_dfl(to))\n\t\treturn -EINVAL;\n\n\tret = cgroup_migrate_vet_dst(to);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\t/* all tasks in @from are being moved, all csets are source */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &from->cset_links, cset_link)\n\t\tcgroup_migrate_add_src(link->cset, to, &mgctx);\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_err;\n\n\t/*\n\t * Migrate tasks one-by-one until @from is empty.  This fails iff\n\t * ->can_attach() fails.\n\t */\n\tdo {\n\t\tcss_task_iter_start(&from->self, 0, &it);\n\n\t\tdo {\n\t\t\ttask = css_task_iter_next(&it);\n\t\t} while (task && (task->flags & PF_EXITING));\n\n\t\tif (task)\n\t\t\tget_task_struct(task);\n\t\tcss_task_iter_end(&it);\n\n\t\tif (task) {\n\t\t\tret = cgroup_migrate(task, false, &mgctx);\n\t\t\tif (!ret)\n\t\t\t\tTRACE_CGROUP_PATH(transfer_tasks, to, task, false);\n\t\t\tput_task_struct(task);\n\t\t}\n\t} while (task && !ret);\nout_err:\n\tcgroup_migrate_finish(&mgctx);\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/fs_parser.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nint cgroup_transfer_tasks(struct cgroup *to, struct cgroup *from)\n{\n\tDEFINE_CGROUP_MGCTX(mgctx);\n\tstruct cgrp_cset_link *link;\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\tint ret;\n\n\tif (cgroup_on_dfl(to))\n\t\treturn -EINVAL;\n\n\tret = cgroup_migrate_vet_dst(to);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&cgroup_mutex);\n\n\tpercpu_down_write(&cgroup_threadgroup_rwsem);\n\n\t/* all tasks in @from are being moved, all csets are source */\n\tspin_lock_irq(&css_set_lock);\n\tlist_for_each_entry(link, &from->cset_links, cset_link)\n\t\tcgroup_migrate_add_src(link->cset, to, &mgctx);\n\tspin_unlock_irq(&css_set_lock);\n\n\tret = cgroup_migrate_prepare_dst(&mgctx);\n\tif (ret)\n\t\tgoto out_err;\n\n\t/*\n\t * Migrate tasks one-by-one until @from is empty.  This fails iff\n\t * ->can_attach() fails.\n\t */\n\tdo {\n\t\tcss_task_iter_start(&from->self, 0, &it);\n\n\t\tdo {\n\t\t\ttask = css_task_iter_next(&it);\n\t\t} while (task && (task->flags & PF_EXITING));\n\n\t\tif (task)\n\t\t\tget_task_struct(task);\n\t\tcss_task_iter_end(&it);\n\n\t\tif (task) {\n\t\t\tret = cgroup_migrate(task, false, &mgctx);\n\t\t\tif (!ret)\n\t\t\t\tTRACE_CGROUP_PATH(transfer_tasks, to, task, false);\n\t\t\tput_task_struct(task);\n\t\t}\n\t} while (task && !ret);\nout_err:\n\tcgroup_migrate_finish(&mgctx);\n\tpercpu_up_write(&cgroup_threadgroup_rwsem);\n\tmutex_unlock(&cgroup_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "parent"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "parent->mems_allowed"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "parent->cpus_allowed"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void remove_tasks_in_empty_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *parent;\n\n\t/*\n\t * Find its next-highest non-empty parent, (top cpuset\n\t * has online cpus, so can't be empty).\n\t */\n\tparent = parent_cs(cs);\n\twhile (cpumask_empty(parent->cpus_allowed) ||\n\t\t\tnodes_empty(parent->mems_allowed))\n\t\tparent = parent_cs(parent);\n\n\tif (cgroup_transfer_tasks(parent->css.cgroup, cs->css.cgroup)) {\n\t\tpr_err(\"cpuset: failed to transfer tasks out of empty cpuset \");\n\t\tpr_cont_cgroup_name(cs->css.cgroup);\n\t\tpr_cont(\"\\n\");\n\t}\n}"
  },
  {
    "function_name": "cpuset_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2975-2995",
    "snippet": "int __init cpuset_init(void)\n{\n\tBUG_ON(percpu_init_rwsem(&cpuset_rwsem));\n\n\tBUG_ON(!alloc_cpumask_var(&top_cpuset.cpus_allowed, GFP_KERNEL));\n\tBUG_ON(!alloc_cpumask_var(&top_cpuset.effective_cpus, GFP_KERNEL));\n\tBUG_ON(!zalloc_cpumask_var(&top_cpuset.subparts_cpus, GFP_KERNEL));\n\n\tcpumask_setall(top_cpuset.cpus_allowed);\n\tnodes_setall(top_cpuset.mems_allowed);\n\tcpumask_setall(top_cpuset.effective_cpus);\n\tnodes_setall(top_cpuset.effective_mems);\n\n\tfmeter_init(&top_cpuset.fmeter);\n\tset_bit(CS_SCHED_LOAD_BALANCE, &top_cpuset.flags);\n\ttop_cpuset.relax_domain_level = -1;\n\n\tBUG_ON(!alloc_cpumask_var(&cpus_attach, GFP_KERNEL));\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
      "static cpumask_var_t cpus_attach;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!alloc_cpumask_var(&cpus_attach, GFP_KERNEL)"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&cpus_attach",
            "GFP_KERNEL"
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CS_SCHED_LOAD_BALANCE",
            "&top_cpuset.flags"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmeter_init",
          "args": [
            "&top_cpuset.fmeter"
          ],
          "line": 2988
        },
        "resolved": true,
        "details": {
          "function_name": "fmeter_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "2132-2138",
          "snippet": "static void fmeter_init(struct fmeter *fmp)\n{\n\tfmp->cnt = 0;\n\tfmp->val = 0;\n\tfmp->time = 0;\n\tspin_lock_init(&fmp->lock);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void fmeter_init(struct fmeter *fmp)\n{\n\tfmp->cnt = 0;\n\tfmp->val = 0;\n\tfmp->time = 0;\n\tspin_lock_init(&fmp->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_setall",
          "args": [
            "top_cpuset.effective_mems"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_setall",
          "args": [
            "top_cpuset.effective_cpus"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_setall",
          "args": [
            "top_cpuset.mems_allowed"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_setall",
          "args": [
            "top_cpuset.cpus_allowed"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!zalloc_cpumask_var(&top_cpuset.subparts_cpus, GFP_KERNEL)"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&top_cpuset.subparts_cpus",
            "GFP_KERNEL"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!alloc_cpumask_var(&top_cpuset.effective_cpus, GFP_KERNEL)"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&top_cpuset.effective_cpus",
            "GFP_KERNEL"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!alloc_cpumask_var(&top_cpuset.cpus_allowed, GFP_KERNEL)"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&top_cpuset.cpus_allowed",
            "GFP_KERNEL"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "percpu_init_rwsem(&cpuset_rwsem)"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_init_rwsem",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic cpumask_var_t cpus_attach;\n\nint __init cpuset_init(void)\n{\n\tBUG_ON(percpu_init_rwsem(&cpuset_rwsem));\n\n\tBUG_ON(!alloc_cpumask_var(&top_cpuset.cpus_allowed, GFP_KERNEL));\n\tBUG_ON(!alloc_cpumask_var(&top_cpuset.effective_cpus, GFP_KERNEL));\n\tBUG_ON(!zalloc_cpumask_var(&top_cpuset.subparts_cpus, GFP_KERNEL));\n\n\tcpumask_setall(top_cpuset.cpus_allowed);\n\tnodes_setall(top_cpuset.mems_allowed);\n\tcpumask_setall(top_cpuset.effective_cpus);\n\tnodes_setall(top_cpuset.effective_mems);\n\n\tfmeter_init(&top_cpuset.fmeter);\n\tset_bit(CS_SCHED_LOAD_BALANCE, &top_cpuset.flags);\n\ttop_cpuset.relax_domain_level = -1;\n\n\tBUG_ON(!alloc_cpumask_var(&cpus_attach, GFP_KERNEL));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuset_fork",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2943-2950",
    "snippet": "static void cpuset_fork(struct task_struct *task)\n{\n\tif (task_css_is_root(task, cpuset_cgrp_id))\n\t\treturn;\n\n\tset_cpus_allowed_ptr(task, current->cpus_ptr);\n\ttask->mems_allowed = current->mems_allowed;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "task",
            "current->cpus_ptr"
          ],
          "line": 2948
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css_is_root",
          "args": [
            "task",
            "cpuset_cgrp_id"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_fork(struct task_struct *task)\n{\n\tif (task_css_is_root(task, cpuset_cgrp_id))\n\t\treturn;\n\n\tset_cpus_allowed_ptr(task, current->cpus_ptr);\n\ttask->mems_allowed = current->mems_allowed;\n}"
  },
  {
    "function_name": "cpuset_bind",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2920-2936",
    "snippet": "static void cpuset_bind(struct cgroup_subsys_state *root_css)\n{\n\tpercpu_down_write(&cpuset_rwsem);\n\tspin_lock_irq(&callback_lock);\n\n\tif (is_in_v2_mode()) {\n\t\tcpumask_copy(top_cpuset.cpus_allowed, cpu_possible_mask);\n\t\ttop_cpuset.mems_allowed = node_possible_map;\n\t} else {\n\t\tcpumask_copy(top_cpuset.cpus_allowed,\n\t\t\t     top_cpuset.effective_cpus);\n\t\ttop_cpuset.mems_allowed = top_cpuset.effective_mems;\n\t}\n\n\tspin_unlock_irq(&callback_lock);\n\tpercpu_up_write(&cpuset_rwsem);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "top_cpuset.cpus_allowed",
            "top_cpuset.effective_cpus"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "top_cpuset.cpus_allowed",
            "cpu_possible_mask"
          ],
          "line": 2926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_in_v2_mode",
          "args": [],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_v2_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "401-405",
          "snippet": "static inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2922
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic void cpuset_bind(struct cgroup_subsys_state *root_css)\n{\n\tpercpu_down_write(&cpuset_rwsem);\n\tspin_lock_irq(&callback_lock);\n\n\tif (is_in_v2_mode()) {\n\t\tcpumask_copy(top_cpuset.cpus_allowed, cpu_possible_mask);\n\t\ttop_cpuset.mems_allowed = node_possible_map;\n\t} else {\n\t\tcpumask_copy(top_cpuset.cpus_allowed,\n\t\t\t     top_cpuset.effective_cpus);\n\t\ttop_cpuset.mems_allowed = top_cpuset.effective_mems;\n\t}\n\n\tspin_unlock_irq(&callback_lock);\n\tpercpu_up_write(&cpuset_rwsem);\n}"
  },
  {
    "function_name": "cpuset_css_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2913-2918",
    "snippet": "static void cpuset_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct cpuset *cs = css_cs(css);\n\n\tfree_cpuset(cs);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpuset",
          "args": [
            "cs"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "free_cpuset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "587-591",
          "snippet": "static inline void free_cpuset(struct cpuset *cs)\n{\n\tfree_cpumasks(cs, NULL);\n\tkfree(cs);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void free_cpuset(struct cpuset *cs)\n{\n\tfree_cpumasks(cs, NULL);\n\tkfree(cs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "css"
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct cpuset *cs = css_cs(css);\n\n\tfree_cpuset(cs);\n}"
  },
  {
    "function_name": "cpuset_css_offline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2885-2911",
    "snippet": "static void cpuset_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct cpuset *cs = css_cs(css);\n\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\n\tif (is_partition_root(cs))\n\t\tupdate_prstate(cs, 0);\n\n\tif (!cgroup_subsys_on_dfl(cpuset_cgrp_subsys) &&\n\t    is_sched_load_balance(cs))\n\t\tupdate_flag(CS_SCHED_LOAD_BALANCE, cs, 0);\n\n\tif (cs->use_parent_ecpus) {\n\t\tstruct cpuset *parent = parent_cs(cs);\n\n\t\tcs->use_parent_ecpus = false;\n\t\tparent->child_ecpus_count--;\n\t}\n\n\tcpuset_dec();\n\tclear_bit(CS_ONLINE, &cs->flags);\n\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CS_ONLINE",
            "&cs->flags"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_dec",
          "args": [],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cs"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_flag",
          "args": [
            "CS_SCHED_LOAD_BALANCE",
            "cs",
            "0"
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "update_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1951-1990",
          "snippet": "static int update_flag(cpuset_flagbits_t bit, struct cpuset *cs,\n\t\t       int turning_on)\n{\n\tstruct cpuset *trialcs;\n\tint balance_flag_changed;\n\tint spread_flag_changed;\n\tint err;\n\n\ttrialcs = alloc_trial_cpuset(cs);\n\tif (!trialcs)\n\t\treturn -ENOMEM;\n\n\tif (turning_on)\n\t\tset_bit(bit, &trialcs->flags);\n\telse\n\t\tclear_bit(bit, &trialcs->flags);\n\n\terr = validate_change(cs, trialcs);\n\tif (err < 0)\n\t\tgoto out;\n\n\tbalance_flag_changed = (is_sched_load_balance(cs) !=\n\t\t\t\tis_sched_load_balance(trialcs));\n\n\tspread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))\n\t\t\t|| (is_spread_page(cs) != is_spread_page(trialcs)));\n\n\tspin_lock_irq(&callback_lock);\n\tcs->flags = trialcs->flags;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (!cpumask_empty(trialcs->cpus_allowed) && balance_flag_changed)\n\t\trebuild_sched_domains_locked();\n\n\tif (spread_flag_changed)\n\t\tupdate_tasks_flags(cs);\nout:\n\tfree_cpuset(trialcs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_flag(cpuset_flagbits_t bit, struct cpuset *cs,\n\t\t       int turning_on)\n{\n\tstruct cpuset *trialcs;\n\tint balance_flag_changed;\n\tint spread_flag_changed;\n\tint err;\n\n\ttrialcs = alloc_trial_cpuset(cs);\n\tif (!trialcs)\n\t\treturn -ENOMEM;\n\n\tif (turning_on)\n\t\tset_bit(bit, &trialcs->flags);\n\telse\n\t\tclear_bit(bit, &trialcs->flags);\n\n\terr = validate_change(cs, trialcs);\n\tif (err < 0)\n\t\tgoto out;\n\n\tbalance_flag_changed = (is_sched_load_balance(cs) !=\n\t\t\t\tis_sched_load_balance(trialcs));\n\n\tspread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))\n\t\t\t|| (is_spread_page(cs) != is_spread_page(trialcs)));\n\n\tspin_lock_irq(&callback_lock);\n\tcs->flags = trialcs->flags;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (!cpumask_empty(trialcs->cpus_allowed) && balance_flag_changed)\n\t\trebuild_sched_domains_locked();\n\n\tif (spread_flag_changed)\n\t\tupdate_tasks_flags(cs);\nout:\n\tfree_cpuset(trialcs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sched_load_balance",
          "args": [
            "cs"
          ],
          "line": 2896
        },
        "resolved": true,
        "details": {
          "function_name": "is_sched_load_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "251-254",
          "snippet": "static inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "cpuset_cgrp_subsys"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_prstate",
          "args": [
            "cs",
            "0"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "update_prstate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1999-2079",
          "snippet": "static int update_prstate(struct cpuset *cs, int new_prs)\n{\n\tint err, old_prs = cs->partition_root_state;\n\tstruct cpuset *parent = parent_cs(cs);\n\tstruct tmpmasks tmpmask;\n\n\tif (old_prs == new_prs)\n\t\treturn 0;\n\n\t/*\n\t * Cannot force a partial or invalid partition root to a full\n\t * partition root.\n\t */\n\tif (new_prs && (old_prs == PRS_ERROR))\n\t\treturn -EINVAL;\n\n\tif (alloc_cpumasks(NULL, &tmpmask))\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tif (!old_prs) {\n\t\t/*\n\t\t * Turning on partition root requires setting the\n\t\t * CS_CPU_EXCLUSIVE bit implicitly as well and cpus_allowed\n\t\t * cannot be NULL.\n\t\t */\n\t\tif (cpumask_empty(cs->cpus_allowed))\n\t\t\tgoto out;\n\n\t\terr = update_flag(CS_CPU_EXCLUSIVE, cs, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_enable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Turning off partition root will clear the\n\t\t * CS_CPU_EXCLUSIVE bit.\n\t\t */\n\t\tif (old_prs == PRS_ERROR) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_disable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Turning off CS_CPU_EXCLUSIVE will not return error */\n\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t}\n\n\t/*\n\t * Update cpumask of parent's tasks except when it is the top\n\t * cpuset as some system daemons cannot be mapped to other CPUs.\n\t */\n\tif (parent != &top_cpuset)\n\t\tupdate_tasks_cpumask(parent);\n\n\tif (parent->child_ecpus_count)\n\t\tupdate_sibling_cpumasks(parent, cs, &tmpmask);\n\n\trebuild_sched_domains_locked();\nout:\n\tif (!err) {\n\t\tspin_lock_irq(&callback_lock);\n\t\tcs->partition_root_state = new_prs;\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cs, old_prs, new_prs);\n\t}\n\n\tfree_cpumasks(NULL, &tmpmask);\n\treturn err;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define PRS_ERROR\t\t-1"
          ],
          "globals_used": [
            "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_prstate(struct cpuset *cs, int new_prs)\n{\n\tint err, old_prs = cs->partition_root_state;\n\tstruct cpuset *parent = parent_cs(cs);\n\tstruct tmpmasks tmpmask;\n\n\tif (old_prs == new_prs)\n\t\treturn 0;\n\n\t/*\n\t * Cannot force a partial or invalid partition root to a full\n\t * partition root.\n\t */\n\tif (new_prs && (old_prs == PRS_ERROR))\n\t\treturn -EINVAL;\n\n\tif (alloc_cpumasks(NULL, &tmpmask))\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tif (!old_prs) {\n\t\t/*\n\t\t * Turning on partition root requires setting the\n\t\t * CS_CPU_EXCLUSIVE bit implicitly as well and cpus_allowed\n\t\t * cannot be NULL.\n\t\t */\n\t\tif (cpumask_empty(cs->cpus_allowed))\n\t\t\tgoto out;\n\n\t\terr = update_flag(CS_CPU_EXCLUSIVE, cs, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_enable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Turning off partition root will clear the\n\t\t * CS_CPU_EXCLUSIVE bit.\n\t\t */\n\t\tif (old_prs == PRS_ERROR) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_disable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Turning off CS_CPU_EXCLUSIVE will not return error */\n\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t}\n\n\t/*\n\t * Update cpumask of parent's tasks except when it is the top\n\t * cpuset as some system daemons cannot be mapped to other CPUs.\n\t */\n\tif (parent != &top_cpuset)\n\t\tupdate_tasks_cpumask(parent);\n\n\tif (parent->child_ecpus_count)\n\t\tupdate_sibling_cpumasks(parent, cs, &tmpmask);\n\n\trebuild_sched_domains_locked();\nout:\n\tif (!err) {\n\t\tspin_lock_irq(&callback_lock);\n\t\tcs->partition_root_state = new_prs;\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cs, old_prs, new_prs);\n\t}\n\n\tfree_cpumasks(NULL, &tmpmask);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_partition_root",
          "args": [
            "cs"
          ],
          "line": 2892
        },
        "resolved": true,
        "details": {
          "function_name": "is_partition_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "271-274",
          "snippet": "static inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "css"
          ],
          "line": 2887
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic void cpuset_css_offline(struct cgroup_subsys_state *css)\n{\n\tstruct cpuset *cs = css_cs(css);\n\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\n\tif (is_partition_root(cs))\n\t\tupdate_prstate(cs, 0);\n\n\tif (!cgroup_subsys_on_dfl(cpuset_cgrp_subsys) &&\n\t    is_sched_load_balance(cs))\n\t\tupdate_flag(CS_SCHED_LOAD_BALANCE, cs, 0);\n\n\tif (cs->use_parent_ecpus) {\n\t\tstruct cpuset *parent = parent_cs(cs);\n\n\t\tcs->use_parent_ecpus = false;\n\t\tparent->child_ecpus_count--;\n\t}\n\n\tcpuset_dec();\n\tclear_bit(CS_ONLINE, &cs->flags);\n\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "cpuset_css_online",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2807-2872",
    "snippet": "static int cpuset_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct cpuset *cs = css_cs(css);\n\tstruct cpuset *parent = parent_cs(cs);\n\tstruct cpuset *tmp_cs;\n\tstruct cgroup_subsys_state *pos_css;\n\n\tif (!parent)\n\t\treturn 0;\n\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\n\tset_bit(CS_ONLINE, &cs->flags);\n\tif (is_spread_page(parent))\n\t\tset_bit(CS_SPREAD_PAGE, &cs->flags);\n\tif (is_spread_slab(parent))\n\t\tset_bit(CS_SPREAD_SLAB, &cs->flags);\n\n\tcpuset_inc();\n\n\tspin_lock_irq(&callback_lock);\n\tif (is_in_v2_mode()) {\n\t\tcpumask_copy(cs->effective_cpus, parent->effective_cpus);\n\t\tcs->effective_mems = parent->effective_mems;\n\t\tcs->use_parent_ecpus = true;\n\t\tparent->child_ecpus_count++;\n\t}\n\tspin_unlock_irq(&callback_lock);\n\n\tif (!test_bit(CGRP_CPUSET_CLONE_CHILDREN, &css->cgroup->flags))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Clone @parent's configuration if CGRP_CPUSET_CLONE_CHILDREN is\n\t * set.  This flag handling is implemented in cgroup core for\n\t * histrical reasons - the flag may be specified during mount.\n\t *\n\t * Currently, if any sibling cpusets have exclusive cpus or mem, we\n\t * refuse to clone the configuration - thereby refusing the task to\n\t * be entered, and as a result refusing the sys_unshare() or\n\t * clone() which initiated it.  If this becomes a problem for some\n\t * users who wish to allow that scenario, then this could be\n\t * changed to grant parent->cpus_allowed-sibling_cpus_exclusive\n\t * (and likewise for mems) to the new cgroup.\n\t */\n\trcu_read_lock();\n\tcpuset_for_each_child(tmp_cs, pos_css, parent) {\n\t\tif (is_mem_exclusive(tmp_cs) || is_cpu_exclusive(tmp_cs)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tspin_lock_irq(&callback_lock);\n\tcs->mems_allowed = parent->mems_allowed;\n\tcs->effective_mems = parent->mems_allowed;\n\tcpumask_copy(cs->cpus_allowed, parent->cpus_allowed);\n\tcpumask_copy(cs->effective_cpus, parent->cpus_allowed);\n\tspin_unlock_irq(&callback_lock);\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 2870
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2869
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cs->effective_cpus",
            "parent->cpus_allowed"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cs->cpus_allowed",
            "parent->cpus_allowed"
          ],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2860
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpu_exclusive",
          "args": [
            "tmp_cs"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpu_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "236-239",
          "snippet": "static inline int is_cpu_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_cpu_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mem_exclusive",
          "args": [
            "tmp_cs"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "is_mem_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "241-244",
          "snippet": "static inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_for_each_child",
          "args": [
            "tmp_cs",
            "pos_css",
            "parent"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CGRP_CPUSET_CLONE_CHILDREN",
            "&css->cgroup->flags"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cs->effective_cpus",
            "parent->effective_cpus"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_in_v2_mode",
          "args": [],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_v2_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "401-405",
          "snippet": "static inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_inc",
          "args": [],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "CS_SPREAD_SLAB",
            "&cs->flags"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_spread_slab",
          "args": [
            "parent"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "is_spread_slab",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "266-269",
          "snippet": "static inline int is_spread_slab(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_spread_slab(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_spread_page",
          "args": [
            "parent"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "is_spread_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "261-264",
          "snippet": "static inline int is_spread_page(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_spread_page(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cs"
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "css"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int cpuset_css_online(struct cgroup_subsys_state *css)\n{\n\tstruct cpuset *cs = css_cs(css);\n\tstruct cpuset *parent = parent_cs(cs);\n\tstruct cpuset *tmp_cs;\n\tstruct cgroup_subsys_state *pos_css;\n\n\tif (!parent)\n\t\treturn 0;\n\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\n\tset_bit(CS_ONLINE, &cs->flags);\n\tif (is_spread_page(parent))\n\t\tset_bit(CS_SPREAD_PAGE, &cs->flags);\n\tif (is_spread_slab(parent))\n\t\tset_bit(CS_SPREAD_SLAB, &cs->flags);\n\n\tcpuset_inc();\n\n\tspin_lock_irq(&callback_lock);\n\tif (is_in_v2_mode()) {\n\t\tcpumask_copy(cs->effective_cpus, parent->effective_cpus);\n\t\tcs->effective_mems = parent->effective_mems;\n\t\tcs->use_parent_ecpus = true;\n\t\tparent->child_ecpus_count++;\n\t}\n\tspin_unlock_irq(&callback_lock);\n\n\tif (!test_bit(CGRP_CPUSET_CLONE_CHILDREN, &css->cgroup->flags))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Clone @parent's configuration if CGRP_CPUSET_CLONE_CHILDREN is\n\t * set.  This flag handling is implemented in cgroup core for\n\t * histrical reasons - the flag may be specified during mount.\n\t *\n\t * Currently, if any sibling cpusets have exclusive cpus or mem, we\n\t * refuse to clone the configuration - thereby refusing the task to\n\t * be entered, and as a result refusing the sys_unshare() or\n\t * clone() which initiated it.  If this becomes a problem for some\n\t * users who wish to allow that scenario, then this could be\n\t * changed to grant parent->cpus_allowed-sibling_cpus_exclusive\n\t * (and likewise for mems) to the new cgroup.\n\t */\n\trcu_read_lock();\n\tcpuset_for_each_child(tmp_cs, pos_css, parent) {\n\t\tif (is_mem_exclusive(tmp_cs) || is_cpu_exclusive(tmp_cs)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tspin_lock_irq(&callback_lock);\n\tcs->mems_allowed = parent->mems_allowed;\n\tcs->effective_mems = parent->mems_allowed;\n\tcpumask_copy(cs->cpus_allowed, parent->cpus_allowed);\n\tcpumask_copy(cs->effective_cpus, parent->cpus_allowed);\n\tspin_unlock_irq(&callback_lock);\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuset_css_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2777-2805",
    "snippet": "static struct cgroup_subsys_state *\ncpuset_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct cpuset *cs;\n\n\tif (!parent_css)\n\t\treturn &top_cpuset.css;\n\n\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\tif (!cs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (alloc_cpumasks(cs, NULL)) {\n\t\tkfree(cs);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t__set_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n\tnodes_clear(cs->mems_allowed);\n\tnodes_clear(cs->effective_mems);\n\tfmeter_init(&cs->fmeter);\n\tcs->relax_domain_level = -1;\n\n\t/* Set CS_MEMORY_MIGRATE for default hierarchy */\n\tif (cgroup_subsys_on_dfl(cpuset_cgrp_subsys))\n\t\t__set_bit(CS_MEMORY_MIGRATE, &cs->flags);\n\n\treturn &cs->css;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
      "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "CS_MEMORY_MIGRATE",
            "&cs->flags"
          ],
          "line": 2802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "cpuset_cgrp_subsys"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fmeter_init",
          "args": [
            "&cs->fmeter"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "fmeter_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "2132-2138",
          "snippet": "static void fmeter_init(struct fmeter *fmp)\n{\n\tfmp->cnt = 0;\n\tfmp->val = 0;\n\tfmp->time = 0;\n\tspin_lock_init(&fmp->lock);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void fmeter_init(struct fmeter *fmp)\n{\n\tfmp->cnt = 0;\n\tfmp->val = 0;\n\tfmp->time = 0;\n\tspin_lock_init(&fmp->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_clear",
          "args": [
            "cs->effective_mems"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_clear",
          "args": [
            "cs->mems_allowed"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "CS_SCHED_LOAD_BALANCE",
            "&cs->flags"
          ],
          "line": 2794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cs"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cpumasks",
          "args": [
            "cs",
            "NULL"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "510-540",
          "snippet": "static inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tcpumask_var_t *pmask1, *pmask2, *pmask3;\n\n\tif (cs) {\n\t\tpmask1 = &cs->cpus_allowed;\n\t\tpmask2 = &cs->effective_cpus;\n\t\tpmask3 = &cs->subparts_cpus;\n\t} else {\n\t\tpmask1 = &tmp->new_cpus;\n\t\tpmask2 = &tmp->addmask;\n\t\tpmask3 = &tmp->delmask;\n\t}\n\n\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))\n\t\tgoto free_one;\n\n\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))\n\t\tgoto free_two;\n\n\treturn 0;\n\nfree_two:\n\tfree_cpumask_var(*pmask2);\nfree_one:\n\tfree_cpumask_var(*pmask1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tcpumask_var_t *pmask1, *pmask2, *pmask3;\n\n\tif (cs) {\n\t\tpmask1 = &cs->cpus_allowed;\n\t\tpmask2 = &cs->effective_cpus;\n\t\tpmask3 = &cs->subparts_cpus;\n\t} else {\n\t\tpmask1 = &tmp->new_cpus;\n\t\tpmask2 = &tmp->addmask;\n\t\tpmask3 = &tmp->delmask;\n\t}\n\n\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))\n\t\tgoto free_one;\n\n\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))\n\t\tgoto free_two;\n\n\treturn 0;\n\nfree_two:\n\tfree_cpumask_var(*pmask2);\nfree_one:\n\tfree_cpumask_var(*pmask1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cs)",
            "GFP_KERNEL"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic struct cgroup_subsys_state *\ncpuset_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct cpuset *cs;\n\n\tif (!parent_css)\n\t\treturn &top_cpuset.css;\n\n\tcs = kzalloc(sizeof(*cs), GFP_KERNEL);\n\tif (!cs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (alloc_cpumasks(cs, NULL)) {\n\t\tkfree(cs);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t__set_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n\tnodes_clear(cs->mems_allowed);\n\tnodes_clear(cs->effective_mems);\n\tfmeter_init(&cs->fmeter);\n\tcs->relax_domain_level = -1;\n\n\t/* Set CS_MEMORY_MIGRATE for default hierarchy */\n\tif (cgroup_subsys_on_dfl(cpuset_cgrp_subsys))\n\t\t__set_bit(CS_MEMORY_MIGRATE, &cs->flags);\n\n\treturn &cs->css;\n}"
  },
  {
    "function_name": "sched_partition_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2578-2609",
    "snippet": "static ssize_t sched_partition_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t     size_t nbytes, loff_t off)\n{\n\tstruct cpuset *cs = css_cs(of_css(of));\n\tint val;\n\tint retval = -ENODEV;\n\n\tbuf = strstrip(buf);\n\n\t/*\n\t * Convert \"root\" to ENABLED, and convert \"member\" to DISABLED.\n\t */\n\tif (!strcmp(buf, \"root\"))\n\t\tval = PRS_ENABLED;\n\telse if (!strcmp(buf, \"member\"))\n\t\tval = PRS_DISABLED;\n\telse\n\t\treturn -EINVAL;\n\n\tcss_get(&cs->css);\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\tif (!is_cpuset_online(cs))\n\t\tgoto out_unlock;\n\n\tretval = update_prstate(cs, val);\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n\tcss_put(&cs->css);\n\treturn retval ?: nbytes;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define PRS_ENABLED\t\t1",
      "#define PRS_DISABLED\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&cs->css"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_prstate",
          "args": [
            "cs",
            "val"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "update_prstate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1999-2079",
          "snippet": "static int update_prstate(struct cpuset *cs, int new_prs)\n{\n\tint err, old_prs = cs->partition_root_state;\n\tstruct cpuset *parent = parent_cs(cs);\n\tstruct tmpmasks tmpmask;\n\n\tif (old_prs == new_prs)\n\t\treturn 0;\n\n\t/*\n\t * Cannot force a partial or invalid partition root to a full\n\t * partition root.\n\t */\n\tif (new_prs && (old_prs == PRS_ERROR))\n\t\treturn -EINVAL;\n\n\tif (alloc_cpumasks(NULL, &tmpmask))\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tif (!old_prs) {\n\t\t/*\n\t\t * Turning on partition root requires setting the\n\t\t * CS_CPU_EXCLUSIVE bit implicitly as well and cpus_allowed\n\t\t * cannot be NULL.\n\t\t */\n\t\tif (cpumask_empty(cs->cpus_allowed))\n\t\t\tgoto out;\n\n\t\terr = update_flag(CS_CPU_EXCLUSIVE, cs, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_enable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Turning off partition root will clear the\n\t\t * CS_CPU_EXCLUSIVE bit.\n\t\t */\n\t\tif (old_prs == PRS_ERROR) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_disable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Turning off CS_CPU_EXCLUSIVE will not return error */\n\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t}\n\n\t/*\n\t * Update cpumask of parent's tasks except when it is the top\n\t * cpuset as some system daemons cannot be mapped to other CPUs.\n\t */\n\tif (parent != &top_cpuset)\n\t\tupdate_tasks_cpumask(parent);\n\n\tif (parent->child_ecpus_count)\n\t\tupdate_sibling_cpumasks(parent, cs, &tmpmask);\n\n\trebuild_sched_domains_locked();\nout:\n\tif (!err) {\n\t\tspin_lock_irq(&callback_lock);\n\t\tcs->partition_root_state = new_prs;\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cs, old_prs, new_prs);\n\t}\n\n\tfree_cpumasks(NULL, &tmpmask);\n\treturn err;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define PRS_ERROR\t\t-1"
          ],
          "globals_used": [
            "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_prstate(struct cpuset *cs, int new_prs)\n{\n\tint err, old_prs = cs->partition_root_state;\n\tstruct cpuset *parent = parent_cs(cs);\n\tstruct tmpmasks tmpmask;\n\n\tif (old_prs == new_prs)\n\t\treturn 0;\n\n\t/*\n\t * Cannot force a partial or invalid partition root to a full\n\t * partition root.\n\t */\n\tif (new_prs && (old_prs == PRS_ERROR))\n\t\treturn -EINVAL;\n\n\tif (alloc_cpumasks(NULL, &tmpmask))\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tif (!old_prs) {\n\t\t/*\n\t\t * Turning on partition root requires setting the\n\t\t * CS_CPU_EXCLUSIVE bit implicitly as well and cpus_allowed\n\t\t * cannot be NULL.\n\t\t */\n\t\tif (cpumask_empty(cs->cpus_allowed))\n\t\t\tgoto out;\n\n\t\terr = update_flag(CS_CPU_EXCLUSIVE, cs, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_enable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Turning off partition root will clear the\n\t\t * CS_CPU_EXCLUSIVE bit.\n\t\t */\n\t\tif (old_prs == PRS_ERROR) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_disable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Turning off CS_CPU_EXCLUSIVE will not return error */\n\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t}\n\n\t/*\n\t * Update cpumask of parent's tasks except when it is the top\n\t * cpuset as some system daemons cannot be mapped to other CPUs.\n\t */\n\tif (parent != &top_cpuset)\n\t\tupdate_tasks_cpumask(parent);\n\n\tif (parent->child_ecpus_count)\n\t\tupdate_sibling_cpumasks(parent, cs, &tmpmask);\n\n\trebuild_sched_domains_locked();\nout:\n\tif (!err) {\n\t\tspin_lock_irq(&callback_lock);\n\t\tcs->partition_root_state = new_prs;\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cs, old_prs, new_prs);\n\t}\n\n\tfree_cpumasks(NULL, &tmpmask);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpuset_online",
          "args": [
            "cs"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpuset_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "231-234",
          "snippet": "static inline bool is_cpuset_online(struct cpuset *cs)\n{\n\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline bool is_cpuset_online(struct cpuset *cs)\n{\n\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&cs->css"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"member\""
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "of_css(of)"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "of_css",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "652-669",
          "snippet": "struct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ENABLED\t\t1\n#define PRS_DISABLED\t\t0\n\nstatic ssize_t sched_partition_write(struct kernfs_open_file *of, char *buf,\n\t\t\t\t     size_t nbytes, loff_t off)\n{\n\tstruct cpuset *cs = css_cs(of_css(of));\n\tint val;\n\tint retval = -ENODEV;\n\n\tbuf = strstrip(buf);\n\n\t/*\n\t * Convert \"root\" to ENABLED, and convert \"member\" to DISABLED.\n\t */\n\tif (!strcmp(buf, \"root\"))\n\t\tval = PRS_ENABLED;\n\telse if (!strcmp(buf, \"member\"))\n\t\tval = PRS_DISABLED;\n\telse\n\t\treturn -EINVAL;\n\n\tcss_get(&cs->css);\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\tif (!is_cpuset_online(cs))\n\t\tgoto out_unlock;\n\n\tretval = update_prstate(cs, val);\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n\tcss_put(&cs->css);\n\treturn retval ?: nbytes;\n}"
  },
  {
    "function_name": "sched_partition_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2560-2576",
    "snippet": "static int sched_partition_show(struct seq_file *seq, void *v)\n{\n\tstruct cpuset *cs = css_cs(seq_css(seq));\n\n\tswitch (cs->partition_root_state) {\n\tcase PRS_ENABLED:\n\t\tseq_puts(seq, \"root\\n\");\n\t\tbreak;\n\tcase PRS_DISABLED:\n\t\tseq_puts(seq, \"member\\n\");\n\t\tbreak;\n\tcase PRS_ERROR:\n\t\tseq_puts(seq, \"root invalid\\n\");\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define PRS_ERROR\t\t-1",
      "#define PRS_ENABLED\t\t1",
      "#define PRS_DISABLED\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\"root invalid\\n\""
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "seq_css(seq)"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "seq"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n#define PRS_ENABLED\t\t1\n#define PRS_DISABLED\t\t0\n\nstatic int sched_partition_show(struct seq_file *seq, void *v)\n{\n\tstruct cpuset *cs = css_cs(seq_css(seq));\n\n\tswitch (cs->partition_root_state) {\n\tcase PRS_ENABLED:\n\t\tseq_puts(seq, \"root\\n\");\n\t\tbreak;\n\tcase PRS_DISABLED:\n\t\tseq_puts(seq, \"member\\n\");\n\t\tbreak;\n\tcase PRS_ERROR:\n\t\tseq_puts(seq, \"root invalid\\n\");\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuset_read_s64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2545-2558",
    "snippet": "static s64 cpuset_read_s64(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\tstruct cpuset *cs = css_cs(css);\n\tcpuset_filetype_t type = cft->private;\n\tswitch (type) {\n\tcase FILE_SCHED_RELAX_DOMAIN_LEVEL:\n\t\treturn cs->relax_domain_level;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Unreachable but makes gcc happy */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "css"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic s64 cpuset_read_s64(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\tstruct cpuset *cs = css_cs(css);\n\tcpuset_filetype_t type = cft->private;\n\tswitch (type) {\n\tcase FILE_SCHED_RELAX_DOMAIN_LEVEL:\n\t\treturn cs->relax_domain_level;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Unreachable but makes gcc happy */\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuset_read_u64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2514-2543",
    "snippet": "static u64 cpuset_read_u64(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\tstruct cpuset *cs = css_cs(css);\n\tcpuset_filetype_t type = cft->private;\n\tswitch (type) {\n\tcase FILE_CPU_EXCLUSIVE:\n\t\treturn is_cpu_exclusive(cs);\n\tcase FILE_MEM_EXCLUSIVE:\n\t\treturn is_mem_exclusive(cs);\n\tcase FILE_MEM_HARDWALL:\n\t\treturn is_mem_hardwall(cs);\n\tcase FILE_SCHED_LOAD_BALANCE:\n\t\treturn is_sched_load_balance(cs);\n\tcase FILE_MEMORY_MIGRATE:\n\t\treturn is_memory_migrate(cs);\n\tcase FILE_MEMORY_PRESSURE_ENABLED:\n\t\treturn cpuset_memory_pressure_enabled;\n\tcase FILE_MEMORY_PRESSURE:\n\t\treturn fmeter_getrate(&cs->fmeter);\n\tcase FILE_SPREAD_PAGE:\n\t\treturn is_spread_page(cs);\n\tcase FILE_SPREAD_SLAB:\n\t\treturn is_spread_slab(cs);\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Unreachable but makes gcc happy */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int cpuset_memory_pressure_enabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_spread_slab",
          "args": [
            "cs"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "is_spread_slab",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "266-269",
          "snippet": "static inline int is_spread_slab(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_spread_slab(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_spread_page",
          "args": [
            "cs"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "is_spread_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "261-264",
          "snippet": "static inline int is_spread_page(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_spread_page(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmeter_getrate",
          "args": [
            "&cs->fmeter"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "fmeter_getrate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "2171-2180",
          "snippet": "static int fmeter_getrate(struct fmeter *fmp)\n{\n\tint val;\n\n\tspin_lock(&fmp->lock);\n\tfmeter_update(fmp);\n\tval = fmp->val;\n\tspin_unlock(&fmp->lock);\n\treturn val;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int fmeter_getrate(struct fmeter *fmp)\n{\n\tint val;\n\n\tspin_lock(&fmp->lock);\n\tfmeter_update(fmp);\n\tval = fmp->val;\n\tspin_unlock(&fmp->lock);\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_memory_migrate",
          "args": [
            "cs"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "is_memory_migrate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "256-259",
          "snippet": "static inline int is_memory_migrate(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEMORY_MIGRATE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_memory_migrate(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEMORY_MIGRATE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sched_load_balance",
          "args": [
            "cs"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "is_sched_load_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "251-254",
          "snippet": "static inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mem_hardwall",
          "args": [
            "cs"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "is_mem_hardwall",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "246-249",
          "snippet": "static inline int is_mem_hardwall(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_HARDWALL, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_mem_hardwall(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_HARDWALL, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mem_exclusive",
          "args": [
            "cs"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "is_mem_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "241-244",
          "snippet": "static inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpu_exclusive",
          "args": [
            "cs"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpu_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "236-239",
          "snippet": "static inline int is_cpu_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_cpu_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "css"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nint cpuset_memory_pressure_enabled;\n\nstatic u64 cpuset_read_u64(struct cgroup_subsys_state *css, struct cftype *cft)\n{\n\tstruct cpuset *cs = css_cs(css);\n\tcpuset_filetype_t type = cft->private;\n\tswitch (type) {\n\tcase FILE_CPU_EXCLUSIVE:\n\t\treturn is_cpu_exclusive(cs);\n\tcase FILE_MEM_EXCLUSIVE:\n\t\treturn is_mem_exclusive(cs);\n\tcase FILE_MEM_HARDWALL:\n\t\treturn is_mem_hardwall(cs);\n\tcase FILE_SCHED_LOAD_BALANCE:\n\t\treturn is_sched_load_balance(cs);\n\tcase FILE_MEMORY_MIGRATE:\n\t\treturn is_memory_migrate(cs);\n\tcase FILE_MEMORY_PRESSURE_ENABLED:\n\t\treturn cpuset_memory_pressure_enabled;\n\tcase FILE_MEMORY_PRESSURE:\n\t\treturn fmeter_getrate(&cs->fmeter);\n\tcase FILE_SPREAD_PAGE:\n\t\treturn is_spread_page(cs);\n\tcase FILE_SPREAD_SLAB:\n\t\treturn is_spread_slab(cs);\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/* Unreachable but makes gcc happy */\n\treturn 0;\n}"
  },
  {
    "function_name": "cpuset_common_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2482-2512",
    "snippet": "static int cpuset_common_seq_show(struct seq_file *sf, void *v)\n{\n\tstruct cpuset *cs = css_cs(seq_css(sf));\n\tcpuset_filetype_t type = seq_cft(sf)->private;\n\tint ret = 0;\n\n\tspin_lock_irq(&callback_lock);\n\n\tswitch (type) {\n\tcase FILE_CPULIST:\n\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(cs->cpus_allowed));\n\t\tbreak;\n\tcase FILE_MEMLIST:\n\t\tseq_printf(sf, \"%*pbl\\n\", nodemask_pr_args(&cs->mems_allowed));\n\t\tbreak;\n\tcase FILE_EFFECTIVE_CPULIST:\n\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(cs->effective_cpus));\n\t\tbreak;\n\tcase FILE_EFFECTIVE_MEMLIST:\n\t\tseq_printf(sf, \"%*pbl\\n\", nodemask_pr_args(&cs->effective_mems));\n\t\tbreak;\n\tcase FILE_SUBPARTS_CPULIST:\n\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(cs->subparts_cpus));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tspin_unlock_irq(&callback_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%*pbl\\n\"",
            "cpumask_pr_args(cs->subparts_cpus)"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cs->subparts_cpus"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodemask_pr_args",
          "args": [
            "&cs->effective_mems"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cs->effective_cpus"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodemask_pr_args",
          "args": [
            "&cs->mems_allowed"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "cs->cpus_allowed"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_cft",
          "args": [
            "sf"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "seq_css(sf)"
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_css",
          "args": [
            "sf"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int cpuset_common_seq_show(struct seq_file *sf, void *v)\n{\n\tstruct cpuset *cs = css_cs(seq_css(sf));\n\tcpuset_filetype_t type = seq_cft(sf)->private;\n\tint ret = 0;\n\n\tspin_lock_irq(&callback_lock);\n\n\tswitch (type) {\n\tcase FILE_CPULIST:\n\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(cs->cpus_allowed));\n\t\tbreak;\n\tcase FILE_MEMLIST:\n\t\tseq_printf(sf, \"%*pbl\\n\", nodemask_pr_args(&cs->mems_allowed));\n\t\tbreak;\n\tcase FILE_EFFECTIVE_CPULIST:\n\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(cs->effective_cpus));\n\t\tbreak;\n\tcase FILE_EFFECTIVE_MEMLIST:\n\t\tseq_printf(sf, \"%*pbl\\n\", nodemask_pr_args(&cs->effective_mems));\n\t\tbreak;\n\tcase FILE_SUBPARTS_CPULIST:\n\t\tseq_printf(sf, \"%*pbl\\n\", cpumask_pr_args(cs->subparts_cpus));\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tspin_unlock_irq(&callback_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "cpuset_write_resmask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2409-2472",
    "snippet": "static ssize_t cpuset_write_resmask(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cpuset *cs = css_cs(of_css(of));\n\tstruct cpuset *trialcs;\n\tint retval = -ENODEV;\n\n\tbuf = strstrip(buf);\n\n\t/*\n\t * CPU or memory hotunplug may leave @cs w/o any execution\n\t * resources, in which case the hotplug code asynchronously updates\n\t * configuration and transfers all tasks to the nearest ancestor\n\t * which can execute.\n\t *\n\t * As writes to \"cpus\" or \"mems\" may restore @cs's execution\n\t * resources, wait for the previously scheduled operations before\n\t * proceeding, so that we don't end up keep removing tasks added\n\t * after execution capability is restored.\n\t *\n\t * cpuset_hotplug_work calls back into cgroup core via\n\t * cgroup_transfer_tasks() and waiting for it from a cgroupfs\n\t * operation like this one can lead to a deadlock through kernfs\n\t * active_ref protection.  Let's break the protection.  Losing the\n\t * protection is okay as we check whether @cs is online after\n\t * grabbing cpuset_rwsem anyway.  This only happens on the legacy\n\t * hierarchies.\n\t */\n\tcss_get(&cs->css);\n\tkernfs_break_active_protection(of->kn);\n\tflush_work(&cpuset_hotplug_work);\n\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\tif (!is_cpuset_online(cs))\n\t\tgoto out_unlock;\n\n\ttrialcs = alloc_trial_cpuset(cs);\n\tif (!trialcs) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (of_cft(of)->private) {\n\tcase FILE_CPULIST:\n\t\tretval = update_cpumask(cs, trialcs, buf);\n\t\tbreak;\n\tcase FILE_MEMLIST:\n\t\tretval = update_nodemask(cs, trialcs, buf);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfree_cpuset(trialcs);\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n\tkernfs_unbreak_active_protection(of->kn);\n\tcss_put(&cs->css);\n\tflush_workqueue(cpuset_migrate_mm_wq);\n\treturn retval ?: nbytes;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *cpuset_migrate_mm_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "cpuset_migrate_mm_wq"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "flush_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2815-2963",
          "snippet": "void flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&cs->css"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernfs_unbreak_active_protection",
          "args": [
            "of->kn"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpuset",
          "args": [
            "trialcs"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "free_cpuset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "587-591",
          "snippet": "static inline void free_cpuset(struct cpuset *cs)\n{\n\tfree_cpumasks(cs, NULL);\n\tkfree(cs);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void free_cpuset(struct cpuset *cs)\n{\n\tfree_cpumasks(cs, NULL);\n\tkfree(cs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_nodemask",
          "args": [
            "cs",
            "trialcs",
            "buf"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "update_nodemask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1841-1893",
          "snippet": "static int update_nodemask(struct cpuset *cs, struct cpuset *trialcs,\n\t\t\t   const char *buf)\n{\n\tint retval;\n\n\t/*\n\t * top_cpuset.mems_allowed tracks node_stats[N_MEMORY];\n\t * it's read-only\n\t */\n\tif (cs == &top_cpuset) {\n\t\tretval = -EACCES;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * An empty mems_allowed is ok iff there are no tasks in the cpuset.\n\t * Since nodelist_parse() fails on an empty mask, we special case\n\t * that parsing.  The validate_change() call ensures that cpusets\n\t * with tasks have memory.\n\t */\n\tif (!*buf) {\n\t\tnodes_clear(trialcs->mems_allowed);\n\t} else {\n\t\tretval = nodelist_parse(buf, trialcs->mems_allowed);\n\t\tif (retval < 0)\n\t\t\tgoto done;\n\n\t\tif (!nodes_subset(trialcs->mems_allowed,\n\t\t\t\t  top_cpuset.mems_allowed)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (nodes_equal(cs->mems_allowed, trialcs->mems_allowed)) {\n\t\tretval = 0;\t\t/* Too easy - nothing to do */\n\t\tgoto done;\n\t}\n\tretval = validate_change(cs, trialcs);\n\tif (retval < 0)\n\t\tgoto done;\n\n\tcheck_insane_mems_config(&trialcs->mems_allowed);\n\n\tspin_lock_irq(&callback_lock);\n\tcs->mems_allowed = trialcs->mems_allowed;\n\tspin_unlock_irq(&callback_lock);\n\n\t/* use trialcs->mems_allowed as a temp variable */\n\tupdate_nodemasks_hier(cs, &trialcs->mems_allowed);\ndone:\n\treturn retval;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_nodemask(struct cpuset *cs, struct cpuset *trialcs,\n\t\t\t   const char *buf)\n{\n\tint retval;\n\n\t/*\n\t * top_cpuset.mems_allowed tracks node_stats[N_MEMORY];\n\t * it's read-only\n\t */\n\tif (cs == &top_cpuset) {\n\t\tretval = -EACCES;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * An empty mems_allowed is ok iff there are no tasks in the cpuset.\n\t * Since nodelist_parse() fails on an empty mask, we special case\n\t * that parsing.  The validate_change() call ensures that cpusets\n\t * with tasks have memory.\n\t */\n\tif (!*buf) {\n\t\tnodes_clear(trialcs->mems_allowed);\n\t} else {\n\t\tretval = nodelist_parse(buf, trialcs->mems_allowed);\n\t\tif (retval < 0)\n\t\t\tgoto done;\n\n\t\tif (!nodes_subset(trialcs->mems_allowed,\n\t\t\t\t  top_cpuset.mems_allowed)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (nodes_equal(cs->mems_allowed, trialcs->mems_allowed)) {\n\t\tretval = 0;\t\t/* Too easy - nothing to do */\n\t\tgoto done;\n\t}\n\tretval = validate_change(cs, trialcs);\n\tif (retval < 0)\n\t\tgoto done;\n\n\tcheck_insane_mems_config(&trialcs->mems_allowed);\n\n\tspin_lock_irq(&callback_lock);\n\tcs->mems_allowed = trialcs->mems_allowed;\n\tspin_unlock_irq(&callback_lock);\n\n\t/* use trialcs->mems_allowed as a temp variable */\n\tupdate_nodemasks_hier(cs, &trialcs->mems_allowed);\ndone:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cpumask",
          "args": [
            "cs",
            "trialcs",
            "buf"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "update_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1548-1629",
          "snippet": "static int update_cpumask(struct cpuset *cs, struct cpuset *trialcs,\n\t\t\t  const char *buf)\n{\n\tint retval;\n\tstruct tmpmasks tmp;\n\n\t/* top_cpuset.cpus_allowed tracks cpu_online_mask; it's read-only */\n\tif (cs == &top_cpuset)\n\t\treturn -EACCES;\n\n\t/*\n\t * An empty cpus_allowed is ok only if the cpuset has no tasks.\n\t * Since cpulist_parse() fails on an empty mask, we special case\n\t * that parsing.  The validate_change() call ensures that cpusets\n\t * with tasks have cpus.\n\t */\n\tif (!*buf) {\n\t\tcpumask_clear(trialcs->cpus_allowed);\n\t} else {\n\t\tretval = cpulist_parse(buf, trialcs->cpus_allowed);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tif (!cpumask_subset(trialcs->cpus_allowed,\n\t\t\t\t    top_cpuset.cpus_allowed))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Nothing to do if the cpus didn't change */\n\tif (cpumask_equal(cs->cpus_allowed, trialcs->cpus_allowed))\n\t\treturn 0;\n\n\tretval = validate_change(cs, trialcs);\n\tif (retval < 0)\n\t\treturn retval;\n\n#ifdef CONFIG_CPUMASK_OFFSTACK\n\t/*\n\t * Use the cpumasks in trialcs for tmpmasks when they are pointers\n\t * to allocated cpumasks.\n\t */\n\ttmp.addmask  = trialcs->subparts_cpus;\n\ttmp.delmask  = trialcs->effective_cpus;\n\ttmp.new_cpus = trialcs->cpus_allowed;\n#endif\n\n\tif (cs->partition_root_state) {\n\t\t/* Cpumask of a partition root cannot be empty */\n\t\tif (cpumask_empty(trialcs->cpus_allowed))\n\t\t\treturn -EINVAL;\n\t\tif (update_parent_subparts_cpumask(cs, partcmd_update,\n\t\t\t\t\ttrialcs->cpus_allowed, &tmp) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->cpus_allowed, trialcs->cpus_allowed);\n\n\t/*\n\t * Make sure that subparts_cpus is a subset of cpus_allowed.\n\t */\n\tif (cs->nr_subparts_cpus) {\n\t\tcpumask_andnot(cs->subparts_cpus, cs->subparts_cpus,\n\t\t\t       cs->cpus_allowed);\n\t\tcs->nr_subparts_cpus = cpumask_weight(cs->subparts_cpus);\n\t}\n\tspin_unlock_irq(&callback_lock);\n\n\tupdate_cpumasks_hier(cs, &tmp);\n\n\tif (cs->partition_root_state) {\n\t\tstruct cpuset *parent = parent_cs(cs);\n\n\t\t/*\n\t\t * For partition root, update the cpumasks of sibling\n\t\t * cpusets if they use parent's effective_cpus.\n\t\t */\n\t\tif (parent->child_ecpus_count)\n\t\t\tupdate_sibling_cpumasks(parent, cs, &tmp);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_cpumask(struct cpuset *cs, struct cpuset *trialcs,\n\t\t\t  const char *buf)\n{\n\tint retval;\n\tstruct tmpmasks tmp;\n\n\t/* top_cpuset.cpus_allowed tracks cpu_online_mask; it's read-only */\n\tif (cs == &top_cpuset)\n\t\treturn -EACCES;\n\n\t/*\n\t * An empty cpus_allowed is ok only if the cpuset has no tasks.\n\t * Since cpulist_parse() fails on an empty mask, we special case\n\t * that parsing.  The validate_change() call ensures that cpusets\n\t * with tasks have cpus.\n\t */\n\tif (!*buf) {\n\t\tcpumask_clear(trialcs->cpus_allowed);\n\t} else {\n\t\tretval = cpulist_parse(buf, trialcs->cpus_allowed);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tif (!cpumask_subset(trialcs->cpus_allowed,\n\t\t\t\t    top_cpuset.cpus_allowed))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Nothing to do if the cpus didn't change */\n\tif (cpumask_equal(cs->cpus_allowed, trialcs->cpus_allowed))\n\t\treturn 0;\n\n\tretval = validate_change(cs, trialcs);\n\tif (retval < 0)\n\t\treturn retval;\n\n#ifdef CONFIG_CPUMASK_OFFSTACK\n\t/*\n\t * Use the cpumasks in trialcs for tmpmasks when they are pointers\n\t * to allocated cpumasks.\n\t */\n\ttmp.addmask  = trialcs->subparts_cpus;\n\ttmp.delmask  = trialcs->effective_cpus;\n\ttmp.new_cpus = trialcs->cpus_allowed;\n#endif\n\n\tif (cs->partition_root_state) {\n\t\t/* Cpumask of a partition root cannot be empty */\n\t\tif (cpumask_empty(trialcs->cpus_allowed))\n\t\t\treturn -EINVAL;\n\t\tif (update_parent_subparts_cpumask(cs, partcmd_update,\n\t\t\t\t\ttrialcs->cpus_allowed, &tmp) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->cpus_allowed, trialcs->cpus_allowed);\n\n\t/*\n\t * Make sure that subparts_cpus is a subset of cpus_allowed.\n\t */\n\tif (cs->nr_subparts_cpus) {\n\t\tcpumask_andnot(cs->subparts_cpus, cs->subparts_cpus,\n\t\t\t       cs->cpus_allowed);\n\t\tcs->nr_subparts_cpus = cpumask_weight(cs->subparts_cpus);\n\t}\n\tspin_unlock_irq(&callback_lock);\n\n\tupdate_cpumasks_hier(cs, &tmp);\n\n\tif (cs->partition_root_state) {\n\t\tstruct cpuset *parent = parent_cs(cs);\n\n\t\t/*\n\t\t * For partition root, update the cpumasks of sibling\n\t\t * cpusets if they use parent's effective_cpus.\n\t\t */\n\t\tif (parent->child_ecpus_count)\n\t\t\tupdate_sibling_cpumasks(parent, cs, &tmp);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_cft",
          "args": [
            "of"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_trial_cpuset",
          "args": [
            "cs"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_trial_cpuset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "565-581",
          "snippet": "static struct cpuset *alloc_trial_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *trial;\n\n\ttrial = kmemdup(cs, sizeof(*cs), GFP_KERNEL);\n\tif (!trial)\n\t\treturn NULL;\n\n\tif (alloc_cpumasks(trial, NULL)) {\n\t\tkfree(trial);\n\t\treturn NULL;\n\t}\n\n\tcpumask_copy(trial->cpus_allowed, cs->cpus_allowed);\n\tcpumask_copy(trial->effective_cpus, cs->effective_cpus);\n\treturn trial;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset *alloc_trial_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *trial;\n\n\ttrial = kmemdup(cs, sizeof(*cs), GFP_KERNEL);\n\tif (!trial)\n\t\treturn NULL;\n\n\tif (alloc_cpumasks(trial, NULL)) {\n\t\tkfree(trial);\n\t\treturn NULL;\n\t}\n\n\tcpumask_copy(trial->cpus_allowed, cs->cpus_allowed);\n\tcpumask_copy(trial->effective_cpus, cs->effective_cpus);\n\treturn trial;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpuset_online",
          "args": [
            "cs"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpuset_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "231-234",
          "snippet": "static inline bool is_cpuset_online(struct cpuset *cs)\n{\n\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline bool is_cpuset_online(struct cpuset *cs)\n{\n\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&cpuset_hotplug_work"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3112-3115",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernfs_break_active_protection",
          "args": [
            "of->kn"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&cs->css"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buf"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "of_css(of)"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_css",
          "args": [
            "of"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "of_css",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "652-669",
          "snippet": "struct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static int cgroup_apply_control(struct cgroup *cgrp);",
            "static int cgroup_destroy_locked(struct cgroup *cgrp);",
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic int cgroup_apply_control(struct cgroup *cgrp);\nstatic int cgroup_destroy_locked(struct cgroup *cgrp);\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nstruct cgroup_subsys_state *of_css(struct kernfs_open_file *of)\n{\n\tstruct cgroup *cgrp = of->kn->parent->priv;\n\tstruct cftype *cft = of_cft(of);\n\n\t/*\n\t * This is open and unprotected implementation of cgroup_css().\n\t * seq_css() is only called from a kernfs file operation which has\n\t * an active reference on the file.  Because all the subsystem\n\t * files are drained before a css is disassociated with a cgroup,\n\t * the matching css from the cgroup's subsys table is guaranteed to\n\t * be and stay valid until the enclosing operation is complete.\n\t */\n\tif (CGROUP_HAS_SUBSYS_CONFIG && cft->ss)\n\t\treturn rcu_dereference_raw(cgrp->subsys[cft->ss->id]);\n\telse\n\t\treturn &cgrp->self;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct workqueue_struct *cpuset_migrate_mm_wq;\n\nstatic ssize_t cpuset_write_resmask(struct kernfs_open_file *of,\n\t\t\t\t    char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cpuset *cs = css_cs(of_css(of));\n\tstruct cpuset *trialcs;\n\tint retval = -ENODEV;\n\n\tbuf = strstrip(buf);\n\n\t/*\n\t * CPU or memory hotunplug may leave @cs w/o any execution\n\t * resources, in which case the hotplug code asynchronously updates\n\t * configuration and transfers all tasks to the nearest ancestor\n\t * which can execute.\n\t *\n\t * As writes to \"cpus\" or \"mems\" may restore @cs's execution\n\t * resources, wait for the previously scheduled operations before\n\t * proceeding, so that we don't end up keep removing tasks added\n\t * after execution capability is restored.\n\t *\n\t * cpuset_hotplug_work calls back into cgroup core via\n\t * cgroup_transfer_tasks() and waiting for it from a cgroupfs\n\t * operation like this one can lead to a deadlock through kernfs\n\t * active_ref protection.  Let's break the protection.  Losing the\n\t * protection is okay as we check whether @cs is online after\n\t * grabbing cpuset_rwsem anyway.  This only happens on the legacy\n\t * hierarchies.\n\t */\n\tcss_get(&cs->css);\n\tkernfs_break_active_protection(of->kn);\n\tflush_work(&cpuset_hotplug_work);\n\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\tif (!is_cpuset_online(cs))\n\t\tgoto out_unlock;\n\n\ttrialcs = alloc_trial_cpuset(cs);\n\tif (!trialcs) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (of_cft(of)->private) {\n\tcase FILE_CPULIST:\n\t\tretval = update_cpumask(cs, trialcs, buf);\n\t\tbreak;\n\tcase FILE_MEMLIST:\n\t\tretval = update_nodemask(cs, trialcs, buf);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfree_cpuset(trialcs);\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n\tkernfs_unbreak_active_protection(of->kn);\n\tcss_put(&cs->css);\n\tflush_workqueue(cpuset_migrate_mm_wq);\n\treturn retval ?: nbytes;\n}"
  },
  {
    "function_name": "cpuset_write_s64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2380-2404",
    "snippet": "static int cpuset_write_s64(struct cgroup_subsys_state *css, struct cftype *cft,\n\t\t\t    s64 val)\n{\n\tstruct cpuset *cs = css_cs(css);\n\tcpuset_filetype_t type = cft->private;\n\tint retval = -ENODEV;\n\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\tif (!is_cpuset_online(cs))\n\t\tgoto out_unlock;\n\n\tswitch (type) {\n\tcase FILE_SCHED_RELAX_DOMAIN_LEVEL:\n\t\tretval = update_relax_domain_level(cs, val);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n\treturn retval;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_relax_domain_level",
          "args": [
            "cs",
            "val"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "update_relax_domain_level",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1906-1921",
          "snippet": "static int update_relax_domain_level(struct cpuset *cs, s64 val)\n{\n#ifdef CONFIG_SMP\n\tif (val < -1 || val >= sched_domain_level_max)\n\t\treturn -EINVAL;\n#endif\n\n\tif (val != cs->relax_domain_level) {\n\t\tcs->relax_domain_level = val;\n\t\tif (!cpumask_empty(cs->cpus_allowed) &&\n\t\t    is_sched_load_balance(cs))\n\t\t\trebuild_sched_domains_locked();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int update_relax_domain_level(struct cpuset *cs, s64 val)\n{\n#ifdef CONFIG_SMP\n\tif (val < -1 || val >= sched_domain_level_max)\n\t\treturn -EINVAL;\n#endif\n\n\tif (val != cs->relax_domain_level) {\n\t\tcs->relax_domain_level = val;\n\t\tif (!cpumask_empty(cs->cpus_allowed) &&\n\t\t    is_sched_load_balance(cs))\n\t\t\trebuild_sched_domains_locked();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpuset_online",
          "args": [
            "cs"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpuset_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "231-234",
          "snippet": "static inline bool is_cpuset_online(struct cpuset *cs)\n{\n\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline bool is_cpuset_online(struct cpuset *cs)\n{\n\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "css"
          ],
          "line": 2383
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int cpuset_write_s64(struct cgroup_subsys_state *css, struct cftype *cft,\n\t\t\t    s64 val)\n{\n\tstruct cpuset *cs = css_cs(css);\n\tcpuset_filetype_t type = cft->private;\n\tint retval = -ENODEV;\n\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\tif (!is_cpuset_online(cs))\n\t\tgoto out_unlock;\n\n\tswitch (type) {\n\tcase FILE_SCHED_RELAX_DOMAIN_LEVEL:\n\t\tretval = update_relax_domain_level(cs, val);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n\treturn retval;\n}"
  },
  {
    "function_name": "cpuset_write_u64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2331-2378",
    "snippet": "static int cpuset_write_u64(struct cgroup_subsys_state *css, struct cftype *cft,\n\t\t\t    u64 val)\n{\n\tstruct cpuset *cs = css_cs(css);\n\tcpuset_filetype_t type = cft->private;\n\tint retval = 0;\n\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\tif (!is_cpuset_online(cs)) {\n\t\tretval = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase FILE_CPU_EXCLUSIVE:\n\t\tretval = update_flag(CS_CPU_EXCLUSIVE, cs, val);\n\t\tbreak;\n\tcase FILE_MEM_EXCLUSIVE:\n\t\tretval = update_flag(CS_MEM_EXCLUSIVE, cs, val);\n\t\tbreak;\n\tcase FILE_MEM_HARDWALL:\n\t\tretval = update_flag(CS_MEM_HARDWALL, cs, val);\n\t\tbreak;\n\tcase FILE_SCHED_LOAD_BALANCE:\n\t\tretval = update_flag(CS_SCHED_LOAD_BALANCE, cs, val);\n\t\tbreak;\n\tcase FILE_MEMORY_MIGRATE:\n\t\tretval = update_flag(CS_MEMORY_MIGRATE, cs, val);\n\t\tbreak;\n\tcase FILE_MEMORY_PRESSURE_ENABLED:\n\t\tcpuset_memory_pressure_enabled = !!val;\n\t\tbreak;\n\tcase FILE_SPREAD_PAGE:\n\t\tretval = update_flag(CS_SPREAD_PAGE, cs, val);\n\t\tbreak;\n\tcase FILE_SPREAD_SLAB:\n\t\tretval = update_flag(CS_SPREAD_SLAB, cs, val);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n\treturn retval;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int cpuset_memory_pressure_enabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_flag",
          "args": [
            "CS_SPREAD_SLAB",
            "cs",
            "val"
          ],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "update_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1951-1990",
          "snippet": "static int update_flag(cpuset_flagbits_t bit, struct cpuset *cs,\n\t\t       int turning_on)\n{\n\tstruct cpuset *trialcs;\n\tint balance_flag_changed;\n\tint spread_flag_changed;\n\tint err;\n\n\ttrialcs = alloc_trial_cpuset(cs);\n\tif (!trialcs)\n\t\treturn -ENOMEM;\n\n\tif (turning_on)\n\t\tset_bit(bit, &trialcs->flags);\n\telse\n\t\tclear_bit(bit, &trialcs->flags);\n\n\terr = validate_change(cs, trialcs);\n\tif (err < 0)\n\t\tgoto out;\n\n\tbalance_flag_changed = (is_sched_load_balance(cs) !=\n\t\t\t\tis_sched_load_balance(trialcs));\n\n\tspread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))\n\t\t\t|| (is_spread_page(cs) != is_spread_page(trialcs)));\n\n\tspin_lock_irq(&callback_lock);\n\tcs->flags = trialcs->flags;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (!cpumask_empty(trialcs->cpus_allowed) && balance_flag_changed)\n\t\trebuild_sched_domains_locked();\n\n\tif (spread_flag_changed)\n\t\tupdate_tasks_flags(cs);\nout:\n\tfree_cpuset(trialcs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_flag(cpuset_flagbits_t bit, struct cpuset *cs,\n\t\t       int turning_on)\n{\n\tstruct cpuset *trialcs;\n\tint balance_flag_changed;\n\tint spread_flag_changed;\n\tint err;\n\n\ttrialcs = alloc_trial_cpuset(cs);\n\tif (!trialcs)\n\t\treturn -ENOMEM;\n\n\tif (turning_on)\n\t\tset_bit(bit, &trialcs->flags);\n\telse\n\t\tclear_bit(bit, &trialcs->flags);\n\n\terr = validate_change(cs, trialcs);\n\tif (err < 0)\n\t\tgoto out;\n\n\tbalance_flag_changed = (is_sched_load_balance(cs) !=\n\t\t\t\tis_sched_load_balance(trialcs));\n\n\tspread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))\n\t\t\t|| (is_spread_page(cs) != is_spread_page(trialcs)));\n\n\tspin_lock_irq(&callback_lock);\n\tcs->flags = trialcs->flags;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (!cpumask_empty(trialcs->cpus_allowed) && balance_flag_changed)\n\t\trebuild_sched_domains_locked();\n\n\tif (spread_flag_changed)\n\t\tupdate_tasks_flags(cs);\nout:\n\tfree_cpuset(trialcs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpuset_online",
          "args": [
            "cs"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpuset_online",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "231-234",
          "snippet": "static inline bool is_cpuset_online(struct cpuset *cs)\n{\n\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline bool is_cpuset_online(struct cpuset *cs)\n{\n\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2339
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "css"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nint cpuset_memory_pressure_enabled;\n\nstatic int cpuset_write_u64(struct cgroup_subsys_state *css, struct cftype *cft,\n\t\t\t    u64 val)\n{\n\tstruct cpuset *cs = css_cs(css);\n\tcpuset_filetype_t type = cft->private;\n\tint retval = 0;\n\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\tif (!is_cpuset_online(cs)) {\n\t\tretval = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tswitch (type) {\n\tcase FILE_CPU_EXCLUSIVE:\n\t\tretval = update_flag(CS_CPU_EXCLUSIVE, cs, val);\n\t\tbreak;\n\tcase FILE_MEM_EXCLUSIVE:\n\t\tretval = update_flag(CS_MEM_EXCLUSIVE, cs, val);\n\t\tbreak;\n\tcase FILE_MEM_HARDWALL:\n\t\tretval = update_flag(CS_MEM_HARDWALL, cs, val);\n\t\tbreak;\n\tcase FILE_SCHED_LOAD_BALANCE:\n\t\tretval = update_flag(CS_SCHED_LOAD_BALANCE, cs, val);\n\t\tbreak;\n\tcase FILE_MEMORY_MIGRATE:\n\t\tretval = update_flag(CS_MEMORY_MIGRATE, cs, val);\n\t\tbreak;\n\tcase FILE_MEMORY_PRESSURE_ENABLED:\n\t\tcpuset_memory_pressure_enabled = !!val;\n\t\tbreak;\n\tcase FILE_SPREAD_PAGE:\n\t\tretval = update_flag(CS_SPREAD_PAGE, cs, val);\n\t\tbreak;\n\tcase FILE_SPREAD_SLAB:\n\t\tretval = update_flag(CS_SPREAD_SLAB, cs, val);\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tbreak;\n\t}\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n\treturn retval;\n}"
  },
  {
    "function_name": "cpuset_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2242-2308",
    "snippet": "static void cpuset_attach(struct cgroup_taskset *tset)\n{\n\t/* static buf protected by cpuset_rwsem */\n\tstatic nodemask_t cpuset_attach_nodemask_to;\n\tstruct task_struct *task;\n\tstruct task_struct *leader;\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *cs;\n\tstruct cpuset *oldcs = cpuset_attach_old_cs;\n\n\tcgroup_taskset_first(tset, &css);\n\tcs = css_cs(css);\n\n\tpercpu_down_write(&cpuset_rwsem);\n\n\tguarantee_online_mems(cs, &cpuset_attach_nodemask_to);\n\n\tcgroup_taskset_for_each(task, css, tset) {\n\t\tif (cs != &top_cpuset)\n\t\t\tguarantee_online_cpus(task, cpus_attach);\n\t\telse\n\t\t\tcpumask_copy(cpus_attach, task_cpu_possible_mask(task));\n\t\t/*\n\t\t * can_attach beforehand should guarantee that this doesn't\n\t\t * fail.  TODO: have a better way to handle failure here\n\t\t */\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(task, cpus_attach));\n\n\t\tcpuset_change_task_nodemask(task, &cpuset_attach_nodemask_to);\n\t\tcpuset_update_task_spread_flag(cs, task);\n\t}\n\n\t/*\n\t * Change mm for all threadgroup leaders. This is expensive and may\n\t * sleep and should be moved outside migration path proper.\n\t */\n\tcpuset_attach_nodemask_to = cs->effective_mems;\n\tcgroup_taskset_for_each_leader(leader, css, tset) {\n\t\tstruct mm_struct *mm = get_task_mm(leader);\n\n\t\tif (mm) {\n\t\t\tmpol_rebind_mm(mm, &cpuset_attach_nodemask_to);\n\n\t\t\t/*\n\t\t\t * old_mems_allowed is the same with mems_allowed\n\t\t\t * here, except if this task is being moved\n\t\t\t * automatically due to hotplug.  In that case\n\t\t\t * @mems_allowed has been updated and is empty, so\n\t\t\t * @old_mems_allowed is the right nodesets that we\n\t\t\t * migrate mm from.\n\t\t\t */\n\t\t\tif (is_memory_migrate(cs))\n\t\t\t\tcpuset_migrate_mm(mm, &oldcs->old_mems_allowed,\n\t\t\t\t\t\t  &cpuset_attach_nodemask_to);\n\t\t\telse\n\t\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\tcs->old_mems_allowed = cpuset_attach_nodemask_to;\n\n\tcs->attach_in_progress--;\n\tif (!cs->attach_in_progress)\n\t\twake_up(&cpuset_attach_wq);\n\n\tpercpu_up_write(&cpuset_rwsem);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
      "static DECLARE_WAIT_QUEUE_HEAD(cpuset_attach_wq);",
      "static struct cpuset *cpuset_attach_old_cs;",
      "static cpumask_var_t cpus_attach;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&cpuset_attach_wq"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "847-853",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);",
            "static void show_one_worker_pool(struct worker_pool *pool);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\nstatic void show_one_worker_pool(struct worker_pool *pool);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1148-1154",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_migrate_mm",
          "args": [
            "mm",
            "&oldcs->old_mems_allowed",
            "&cpuset_attach_nodemask_to"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_migrate_mm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1657-1677",
          "snippet": "static void cpuset_migrate_mm(struct mm_struct *mm, const nodemask_t *from,\n\t\t\t\t\t\t\tconst nodemask_t *to)\n{\n\tstruct cpuset_migrate_mm_work *mwork;\n\n\tif (nodes_equal(*from, *to)) {\n\t\tmmput(mm);\n\t\treturn;\n\t}\n\n\tmwork = kzalloc(sizeof(*mwork), GFP_KERNEL);\n\tif (mwork) {\n\t\tmwork->mm = mm;\n\t\tmwork->from = *from;\n\t\tmwork->to = *to;\n\t\tINIT_WORK(&mwork->work, cpuset_migrate_mm_workfn);\n\t\tqueue_work(cpuset_migrate_mm_wq, &mwork->work);\n\t} else {\n\t\tmmput(mm);\n\t}\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *cpuset_migrate_mm_wq;",
            "static void cpuset_hotplug_workfn(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct workqueue_struct *cpuset_migrate_mm_wq;\nstatic void cpuset_hotplug_workfn(struct work_struct *work);\n\nstatic void cpuset_migrate_mm(struct mm_struct *mm, const nodemask_t *from,\n\t\t\t\t\t\t\tconst nodemask_t *to)\n{\n\tstruct cpuset_migrate_mm_work *mwork;\n\n\tif (nodes_equal(*from, *to)) {\n\t\tmmput(mm);\n\t\treturn;\n\t}\n\n\tmwork = kzalloc(sizeof(*mwork), GFP_KERNEL);\n\tif (mwork) {\n\t\tmwork->mm = mm;\n\t\tmwork->from = *from;\n\t\tmwork->to = *to;\n\t\tINIT_WORK(&mwork->work, cpuset_migrate_mm_workfn);\n\t\tqueue_work(cpuset_migrate_mm_wq, &mwork->work);\n\t} else {\n\t\tmmput(mm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_memory_migrate",
          "args": [
            "cs"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "is_memory_migrate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "256-259",
          "snippet": "static inline int is_memory_migrate(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEMORY_MIGRATE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_memory_migrate(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEMORY_MIGRATE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_rebind_mm",
          "args": [
            "mm",
            "&cpuset_attach_nodemask_to"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "leader"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_mm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1297-1311",
          "snippet": "struct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each_leader",
          "args": [
            "leader",
            "css",
            "tset"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_update_task_spread_flag",
          "args": [
            "cs",
            "task"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_update_task_spread_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "472-484",
          "snippet": "static void cpuset_update_task_spread_flag(struct cpuset *cs,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tif (is_spread_page(cs))\n\t\ttask_set_spread_page(tsk);\n\telse\n\t\ttask_clear_spread_page(tsk);\n\n\tif (is_spread_slab(cs))\n\t\ttask_set_spread_slab(tsk);\n\telse\n\t\ttask_clear_spread_slab(tsk);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_update_task_spread_flag(struct cpuset *cs,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tif (is_spread_page(cs))\n\t\ttask_set_spread_page(tsk);\n\telse\n\t\ttask_clear_spread_page(tsk);\n\n\tif (is_spread_slab(cs))\n\t\ttask_set_spread_slab(tsk);\n\telse\n\t\ttask_clear_spread_slab(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_change_task_nodemask",
          "args": [
            "task",
            "&cpuset_attach_nodemask_to"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_change_task_nodemask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1694-1710",
          "snippet": "static void cpuset_change_task_nodemask(struct task_struct *tsk,\n\t\t\t\t\tnodemask_t *newmems)\n{\n\ttask_lock(tsk);\n\n\tlocal_irq_disable();\n\twrite_seqcount_begin(&tsk->mems_allowed_seq);\n\n\tnodes_or(tsk->mems_allowed, tsk->mems_allowed, *newmems);\n\tmpol_rebind_task(tsk, newmems);\n\ttsk->mems_allowed = *newmems;\n\n\twrite_seqcount_end(&tsk->mems_allowed_seq);\n\tlocal_irq_enable();\n\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_change_task_nodemask(struct task_struct *tsk,\n\t\t\t\t\tnodemask_t *newmems)\n{\n\ttask_lock(tsk);\n\n\tlocal_irq_disable();\n\twrite_seqcount_begin(&tsk->mems_allowed_seq);\n\n\tnodes_or(tsk->mems_allowed, tsk->mems_allowed, *newmems);\n\tmpol_rebind_task(tsk, newmems);\n\ttsk->mems_allowed = *newmems;\n\n\twrite_seqcount_end(&tsk->mems_allowed_seq);\n\tlocal_irq_enable();\n\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "set_cpus_allowed_ptr(task, cpus_attach)"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "task",
            "cpus_attach"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cpus_attach",
            "task_cpu_possible_mask(task)"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu_possible_mask",
          "args": [
            "task"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guarantee_online_cpus",
          "args": [
            "task",
            "cpus_attach"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "guarantee_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "418-447",
          "snippet": "static void guarantee_online_cpus(struct task_struct *tsk,\n\t\t\t\t  struct cpumask *pmask)\n{\n\tconst struct cpumask *possible_mask = task_cpu_possible_mask(tsk);\n\tstruct cpuset *cs;\n\n\tif (WARN_ON(!cpumask_and(pmask, possible_mask, cpu_online_mask)))\n\t\tcpumask_copy(pmask, cpu_online_mask);\n\n\trcu_read_lock();\n\tcs = task_cs(tsk);\n\n\twhile (!cpumask_intersects(cs->effective_cpus, pmask)) {\n\t\tcs = parent_cs(cs);\n\t\tif (unlikely(!cs)) {\n\t\t\t/*\n\t\t\t * The top cpuset doesn't have any online cpu as a\n\t\t\t * consequence of a race between cpuset_hotplug_work\n\t\t\t * and cpu hotplug notifier.  But we know the top\n\t\t\t * cpuset's effective_cpus is on its way to be\n\t\t\t * identical to cpu_online_mask.\n\t\t\t */\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tcpumask_and(pmask, pmask, cs->effective_cpus);\n\nout_unlock:\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void guarantee_online_cpus(struct task_struct *tsk,\n\t\t\t\t  struct cpumask *pmask)\n{\n\tconst struct cpumask *possible_mask = task_cpu_possible_mask(tsk);\n\tstruct cpuset *cs;\n\n\tif (WARN_ON(!cpumask_and(pmask, possible_mask, cpu_online_mask)))\n\t\tcpumask_copy(pmask, cpu_online_mask);\n\n\trcu_read_lock();\n\tcs = task_cs(tsk);\n\n\twhile (!cpumask_intersects(cs->effective_cpus, pmask)) {\n\t\tcs = parent_cs(cs);\n\t\tif (unlikely(!cs)) {\n\t\t\t/*\n\t\t\t * The top cpuset doesn't have any online cpu as a\n\t\t\t * consequence of a race between cpuset_hotplug_work\n\t\t\t * and cpu hotplug notifier.  But we know the top\n\t\t\t * cpuset's effective_cpus is on its way to be\n\t\t\t * identical to cpu_online_mask.\n\t\t\t */\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tcpumask_and(pmask, pmask, cs->effective_cpus);\n\nout_unlock:\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each",
          "args": [
            "task",
            "css",
            "tset"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guarantee_online_mems",
          "args": [
            "cs",
            "&cpuset_attach_nodemask_to"
          ],
          "line": 2257
        },
        "resolved": true,
        "details": {
          "function_name": "guarantee_online_mems",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "460-465",
          "snippet": "static void guarantee_online_mems(struct cpuset *cs, nodemask_t *pmask)\n{\n\twhile (!nodes_intersects(cs->effective_mems, node_states[N_MEMORY]))\n\t\tcs = parent_cs(cs);\n\tnodes_and(*pmask, cs->effective_mems, node_states[N_MEMORY]);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void guarantee_online_mems(struct cpuset *cs, nodemask_t *pmask)\n{\n\twhile (!nodes_intersects(cs->effective_mems, node_states[N_MEMORY]))\n\t\tcs = parent_cs(cs);\n\tnodes_and(*pmask, cs->effective_mems, node_states[N_MEMORY]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "css"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_first",
          "args": [
            "tset",
            "&css"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_taskset_first",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "2392-2399",
          "snippet": "struct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DECLARE_WAIT_QUEUE_HEAD(cpuset_attach_wq);\nstatic struct cpuset *cpuset_attach_old_cs;\nstatic cpumask_var_t cpus_attach;\n\nstatic void cpuset_attach(struct cgroup_taskset *tset)\n{\n\t/* static buf protected by cpuset_rwsem */\n\tstatic nodemask_t cpuset_attach_nodemask_to;\n\tstruct task_struct *task;\n\tstruct task_struct *leader;\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *cs;\n\tstruct cpuset *oldcs = cpuset_attach_old_cs;\n\n\tcgroup_taskset_first(tset, &css);\n\tcs = css_cs(css);\n\n\tpercpu_down_write(&cpuset_rwsem);\n\n\tguarantee_online_mems(cs, &cpuset_attach_nodemask_to);\n\n\tcgroup_taskset_for_each(task, css, tset) {\n\t\tif (cs != &top_cpuset)\n\t\t\tguarantee_online_cpus(task, cpus_attach);\n\t\telse\n\t\t\tcpumask_copy(cpus_attach, task_cpu_possible_mask(task));\n\t\t/*\n\t\t * can_attach beforehand should guarantee that this doesn't\n\t\t * fail.  TODO: have a better way to handle failure here\n\t\t */\n\t\tWARN_ON_ONCE(set_cpus_allowed_ptr(task, cpus_attach));\n\n\t\tcpuset_change_task_nodemask(task, &cpuset_attach_nodemask_to);\n\t\tcpuset_update_task_spread_flag(cs, task);\n\t}\n\n\t/*\n\t * Change mm for all threadgroup leaders. This is expensive and may\n\t * sleep and should be moved outside migration path proper.\n\t */\n\tcpuset_attach_nodemask_to = cs->effective_mems;\n\tcgroup_taskset_for_each_leader(leader, css, tset) {\n\t\tstruct mm_struct *mm = get_task_mm(leader);\n\n\t\tif (mm) {\n\t\t\tmpol_rebind_mm(mm, &cpuset_attach_nodemask_to);\n\n\t\t\t/*\n\t\t\t * old_mems_allowed is the same with mems_allowed\n\t\t\t * here, except if this task is being moved\n\t\t\t * automatically due to hotplug.  In that case\n\t\t\t * @mems_allowed has been updated and is empty, so\n\t\t\t * @old_mems_allowed is the right nodesets that we\n\t\t\t * migrate mm from.\n\t\t\t */\n\t\t\tif (is_memory_migrate(cs))\n\t\t\t\tcpuset_migrate_mm(mm, &oldcs->old_mems_allowed,\n\t\t\t\t\t\t  &cpuset_attach_nodemask_to);\n\t\t\telse\n\t\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\tcs->old_mems_allowed = cpuset_attach_nodemask_to;\n\n\tcs->attach_in_progress--;\n\tif (!cs->attach_in_progress)\n\t\twake_up(&cpuset_attach_wq);\n\n\tpercpu_up_write(&cpuset_rwsem);\n}"
  },
  {
    "function_name": "cpuset_cancel_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2224-2233",
    "snippet": "static void cpuset_cancel_attach(struct cgroup_taskset *tset)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_first(tset, &css);\n\n\tpercpu_down_write(&cpuset_rwsem);\n\tcss_cs(css)->attach_in_progress--;\n\tpercpu_up_write(&cpuset_rwsem);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "css"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_first",
          "args": [
            "tset",
            "&css"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_taskset_first",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "2392-2399",
          "snippet": "struct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_cancel_attach(struct cgroup_taskset *tset)\n{\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_first(tset, &css);\n\n\tpercpu_down_write(&cpuset_rwsem);\n\tcss_cs(css)->attach_in_progress--;\n\tpercpu_up_write(&cpuset_rwsem);\n}"
  },
  {
    "function_name": "cpuset_can_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2185-2222",
    "snippet": "static int cpuset_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *cs;\n\tstruct task_struct *task;\n\tint ret;\n\n\t/* used later by cpuset_attach() */\n\tcpuset_attach_old_cs = task_cs(cgroup_taskset_first(tset, &css));\n\tcs = css_cs(css);\n\n\tpercpu_down_write(&cpuset_rwsem);\n\n\t/* allow moving tasks into an empty cpuset if on default hierarchy */\n\tret = -ENOSPC;\n\tif (!is_in_v2_mode() &&\n\t    (cpumask_empty(cs->cpus_allowed) || nodes_empty(cs->mems_allowed)))\n\t\tgoto out_unlock;\n\n\tcgroup_taskset_for_each(task, css, tset) {\n\t\tret = task_can_attach(task, cs->cpus_allowed);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tret = security_task_setscheduler(task);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Mark attach is in progress.  This makes validate_change() fail\n\t * changes which zero cpus/mems_allowed.\n\t */\n\tcs->attach_in_progress++;\n\tret = 0;\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset *cpuset_attach_old_cs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_setscheduler",
          "args": [
            "task"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_can_attach",
          "args": [
            "task",
            "cs->cpus_allowed"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "task_can_attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8718-8743",
          "snippet": "int task_can_attach(struct task_struct *p,\n\t\t    const struct cpumask *cs_cpus_allowed)\n{\n\tint ret = 0;\n\n\t/*\n\t * Kthreads which disallow setaffinity shouldn't be moved\n\t * to a new cpuset; we don't want to change their CPU\n\t * affinity and isolating such threads by their set of\n\t * allowed nodes is unnecessary.  Thus, cpusets are not\n\t * applicable for such threads.  This prevents checking for\n\t * success of set_cpus_allowed_ptr() on all attached tasks\n\t * before cpus_mask may be changed.\n\t */\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (dl_task(p) && !cpumask_intersects(task_rq(p)->rd->span,\n\t\t\t\t\t      cs_cpus_allowed))\n\t\tret = dl_task_can_attach(p, cs_cpus_allowed);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint task_can_attach(struct task_struct *p,\n\t\t    const struct cpumask *cs_cpus_allowed)\n{\n\tint ret = 0;\n\n\t/*\n\t * Kthreads which disallow setaffinity shouldn't be moved\n\t * to a new cpuset; we don't want to change their CPU\n\t * affinity and isolating such threads by their set of\n\t * allowed nodes is unnecessary.  Thus, cpusets are not\n\t * applicable for such threads.  This prevents checking for\n\t * success of set_cpus_allowed_ptr() on all attached tasks\n\t * before cpus_mask may be changed.\n\t */\n\tif (p->flags & PF_NO_SETAFFINITY) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (dl_task(p) && !cpumask_intersects(task_rq(p)->rd->span,\n\t\t\t\t\t      cs_cpus_allowed))\n\t\tret = dl_task_can_attach(p, cs_cpus_allowed);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_for_each",
          "args": [
            "task",
            "css",
            "tset"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "cs->mems_allowed"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cs->cpus_allowed"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_in_v2_mode",
          "args": [],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_v2_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "401-405",
          "snippet": "static inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "css"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cs",
          "args": [
            "cgroup_taskset_first(tset, &css)"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "task_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "208-211",
          "snippet": "static inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_taskset_first",
          "args": [
            "tset",
            "&css"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_taskset_first",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "2392-2399",
          "snippet": "struct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset,\n\t\t\t\t\t struct cgroup_subsys_state **dst_cssp)\n{\n\ttset->cur_cset = list_first_entry(tset->csets, struct css_set, mg_node);\n\ttset->cur_task = NULL;\n\n\treturn cgroup_taskset_next(tset, dst_cssp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset *cpuset_attach_old_cs;\n\nstatic int cpuset_can_attach(struct cgroup_taskset *tset)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *cs;\n\tstruct task_struct *task;\n\tint ret;\n\n\t/* used later by cpuset_attach() */\n\tcpuset_attach_old_cs = task_cs(cgroup_taskset_first(tset, &css));\n\tcs = css_cs(css);\n\n\tpercpu_down_write(&cpuset_rwsem);\n\n\t/* allow moving tasks into an empty cpuset if on default hierarchy */\n\tret = -ENOSPC;\n\tif (!is_in_v2_mode() &&\n\t    (cpumask_empty(cs->cpus_allowed) || nodes_empty(cs->mems_allowed)))\n\t\tgoto out_unlock;\n\n\tcgroup_taskset_for_each(task, css, tset) {\n\t\tret = task_can_attach(task, cs->cpus_allowed);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tret = security_task_setscheduler(task);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Mark attach is in progress.  This makes validate_change() fail\n\t * changes which zero cpus/mems_allowed.\n\t */\n\tcs->attach_in_progress++;\n\tret = 0;\nout_unlock:\n\tpercpu_up_write(&cpuset_rwsem);\n\treturn ret;\n}"
  },
  {
    "function_name": "fmeter_getrate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2171-2180",
    "snippet": "static int fmeter_getrate(struct fmeter *fmp)\n{\n\tint val;\n\n\tspin_lock(&fmp->lock);\n\tfmeter_update(fmp);\n\tval = fmp->val;\n\tspin_unlock(&fmp->lock);\n\treturn val;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fmp->lock"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmeter_update",
          "args": [
            "fmp"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "fmeter_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "2141-2159",
          "snippet": "static void fmeter_update(struct fmeter *fmp)\n{\n\ttime64_t now;\n\tu32 ticks;\n\n\tnow = ktime_get_seconds();\n\tticks = now - fmp->time;\n\n\tif (ticks == 0)\n\t\treturn;\n\n\tticks = min(FM_MAXTICKS, ticks);\n\twhile (ticks-- > 0)\n\t\tfmp->val = (FM_COEF * fmp->val) / FM_SCALE;\n\tfmp->time = now;\n\n\tfmp->val += ((FM_SCALE - FM_COEF) * fmp->cnt) / FM_SCALE;\n\tfmp->cnt = 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define FM_SCALE 1000\t\t/* faux fixed point scale */",
            "#define FM_MAXTICKS ((u32)99)   /* useless computing more ticks than this */",
            "#define FM_COEF 933\t\t/* coefficient for half-life of 10 secs */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define FM_SCALE 1000\t\t/* faux fixed point scale */\n#define FM_MAXTICKS ((u32)99)   /* useless computing more ticks than this */\n#define FM_COEF 933\t\t/* coefficient for half-life of 10 secs */\n\nstatic void fmeter_update(struct fmeter *fmp)\n{\n\ttime64_t now;\n\tu32 ticks;\n\n\tnow = ktime_get_seconds();\n\tticks = now - fmp->time;\n\n\tif (ticks == 0)\n\t\treturn;\n\n\tticks = min(FM_MAXTICKS, ticks);\n\twhile (ticks-- > 0)\n\t\tfmp->val = (FM_COEF * fmp->val) / FM_SCALE;\n\tfmp->time = now;\n\n\tfmp->val += ((FM_SCALE - FM_COEF) * fmp->cnt) / FM_SCALE;\n\tfmp->cnt = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fmp->lock"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int fmeter_getrate(struct fmeter *fmp)\n{\n\tint val;\n\n\tspin_lock(&fmp->lock);\n\tfmeter_update(fmp);\n\tval = fmp->val;\n\tspin_unlock(&fmp->lock);\n\treturn val;\n}"
  },
  {
    "function_name": "fmeter_markevent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2162-2168",
    "snippet": "static void fmeter_markevent(struct fmeter *fmp)\n{\n\tspin_lock(&fmp->lock);\n\tfmeter_update(fmp);\n\tfmp->cnt = min(FM_MAXCNT, fmp->cnt + FM_SCALE);\n\tspin_unlock(&fmp->lock);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define FM_SCALE 1000\t\t/* faux fixed point scale */",
      "#define FM_MAXCNT 1000000\t/* limit cnt to avoid overflow */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fmp->lock"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "FM_MAXCNT",
            "fmp->cnt + FM_SCALE"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "fmeter_update",
          "args": [
            "fmp"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "fmeter_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "2141-2159",
          "snippet": "static void fmeter_update(struct fmeter *fmp)\n{\n\ttime64_t now;\n\tu32 ticks;\n\n\tnow = ktime_get_seconds();\n\tticks = now - fmp->time;\n\n\tif (ticks == 0)\n\t\treturn;\n\n\tticks = min(FM_MAXTICKS, ticks);\n\twhile (ticks-- > 0)\n\t\tfmp->val = (FM_COEF * fmp->val) / FM_SCALE;\n\tfmp->time = now;\n\n\tfmp->val += ((FM_SCALE - FM_COEF) * fmp->cnt) / FM_SCALE;\n\tfmp->cnt = 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define FM_SCALE 1000\t\t/* faux fixed point scale */",
            "#define FM_MAXTICKS ((u32)99)   /* useless computing more ticks than this */",
            "#define FM_COEF 933\t\t/* coefficient for half-life of 10 secs */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define FM_SCALE 1000\t\t/* faux fixed point scale */\n#define FM_MAXTICKS ((u32)99)   /* useless computing more ticks than this */\n#define FM_COEF 933\t\t/* coefficient for half-life of 10 secs */\n\nstatic void fmeter_update(struct fmeter *fmp)\n{\n\ttime64_t now;\n\tu32 ticks;\n\n\tnow = ktime_get_seconds();\n\tticks = now - fmp->time;\n\n\tif (ticks == 0)\n\t\treturn;\n\n\tticks = min(FM_MAXTICKS, ticks);\n\twhile (ticks-- > 0)\n\t\tfmp->val = (FM_COEF * fmp->val) / FM_SCALE;\n\tfmp->time = now;\n\n\tfmp->val += ((FM_SCALE - FM_COEF) * fmp->cnt) / FM_SCALE;\n\tfmp->cnt = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fmp->lock"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define FM_SCALE 1000\t\t/* faux fixed point scale */\n#define FM_MAXCNT 1000000\t/* limit cnt to avoid overflow */\n\nstatic void fmeter_markevent(struct fmeter *fmp)\n{\n\tspin_lock(&fmp->lock);\n\tfmeter_update(fmp);\n\tfmp->cnt = min(FM_MAXCNT, fmp->cnt + FM_SCALE);\n\tspin_unlock(&fmp->lock);\n}"
  },
  {
    "function_name": "fmeter_update",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2141-2159",
    "snippet": "static void fmeter_update(struct fmeter *fmp)\n{\n\ttime64_t now;\n\tu32 ticks;\n\n\tnow = ktime_get_seconds();\n\tticks = now - fmp->time;\n\n\tif (ticks == 0)\n\t\treturn;\n\n\tticks = min(FM_MAXTICKS, ticks);\n\twhile (ticks-- > 0)\n\t\tfmp->val = (FM_COEF * fmp->val) / FM_SCALE;\n\tfmp->time = now;\n\n\tfmp->val += ((FM_SCALE - FM_COEF) * fmp->cnt) / FM_SCALE;\n\tfmp->cnt = 0;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define FM_SCALE 1000\t\t/* faux fixed point scale */",
      "#define FM_MAXTICKS ((u32)99)   /* useless computing more ticks than this */",
      "#define FM_COEF 933\t\t/* coefficient for half-life of 10 secs */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "FM_MAXTICKS",
            "ticks"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_seconds",
          "args": [],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "982-988",
          "snippet": "time64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t ktime_get_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\tWARN_ON(timekeeping_suspended);\n\treturn tk->ktime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define FM_SCALE 1000\t\t/* faux fixed point scale */\n#define FM_MAXTICKS ((u32)99)   /* useless computing more ticks than this */\n#define FM_COEF 933\t\t/* coefficient for half-life of 10 secs */\n\nstatic void fmeter_update(struct fmeter *fmp)\n{\n\ttime64_t now;\n\tu32 ticks;\n\n\tnow = ktime_get_seconds();\n\tticks = now - fmp->time;\n\n\tif (ticks == 0)\n\t\treturn;\n\n\tticks = min(FM_MAXTICKS, ticks);\n\twhile (ticks-- > 0)\n\t\tfmp->val = (FM_COEF * fmp->val) / FM_SCALE;\n\tfmp->time = now;\n\n\tfmp->val += ((FM_SCALE - FM_COEF) * fmp->cnt) / FM_SCALE;\n\tfmp->cnt = 0;\n}"
  },
  {
    "function_name": "fmeter_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "2132-2138",
    "snippet": "static void fmeter_init(struct fmeter *fmp)\n{\n\tfmp->cnt = 0;\n\tfmp->val = 0;\n\tfmp->time = 0;\n\tspin_lock_init(&fmp->lock);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&fmp->lock"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void fmeter_init(struct fmeter *fmp)\n{\n\tfmp->cnt = 0;\n\tfmp->val = 0;\n\tfmp->time = 0;\n\tspin_lock_init(&fmp->lock);\n}"
  },
  {
    "function_name": "update_prstate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1999-2079",
    "snippet": "static int update_prstate(struct cpuset *cs, int new_prs)\n{\n\tint err, old_prs = cs->partition_root_state;\n\tstruct cpuset *parent = parent_cs(cs);\n\tstruct tmpmasks tmpmask;\n\n\tif (old_prs == new_prs)\n\t\treturn 0;\n\n\t/*\n\t * Cannot force a partial or invalid partition root to a full\n\t * partition root.\n\t */\n\tif (new_prs && (old_prs == PRS_ERROR))\n\t\treturn -EINVAL;\n\n\tif (alloc_cpumasks(NULL, &tmpmask))\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tif (!old_prs) {\n\t\t/*\n\t\t * Turning on partition root requires setting the\n\t\t * CS_CPU_EXCLUSIVE bit implicitly as well and cpus_allowed\n\t\t * cannot be NULL.\n\t\t */\n\t\tif (cpumask_empty(cs->cpus_allowed))\n\t\t\tgoto out;\n\n\t\terr = update_flag(CS_CPU_EXCLUSIVE, cs, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_enable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Turning off partition root will clear the\n\t\t * CS_CPU_EXCLUSIVE bit.\n\t\t */\n\t\tif (old_prs == PRS_ERROR) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_disable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Turning off CS_CPU_EXCLUSIVE will not return error */\n\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t}\n\n\t/*\n\t * Update cpumask of parent's tasks except when it is the top\n\t * cpuset as some system daemons cannot be mapped to other CPUs.\n\t */\n\tif (parent != &top_cpuset)\n\t\tupdate_tasks_cpumask(parent);\n\n\tif (parent->child_ecpus_count)\n\t\tupdate_sibling_cpumasks(parent, cs, &tmpmask);\n\n\trebuild_sched_domains_locked();\nout:\n\tif (!err) {\n\t\tspin_lock_irq(&callback_lock);\n\t\tcs->partition_root_state = new_prs;\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cs, old_prs, new_prs);\n\t}\n\n\tfree_cpumasks(NULL, &tmpmask);\n\treturn err;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define PRS_ERROR\t\t-1"
    ],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumasks",
          "args": [
            "NULL",
            "&tmpmask"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "free_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "547-559",
          "snippet": "static inline void free_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tif (cs) {\n\t\tfree_cpumask_var(cs->cpus_allowed);\n\t\tfree_cpumask_var(cs->effective_cpus);\n\t\tfree_cpumask_var(cs->subparts_cpus);\n\t}\n\tif (tmp) {\n\t\tfree_cpumask_var(tmp->new_cpus);\n\t\tfree_cpumask_var(tmp->addmask);\n\t\tfree_cpumask_var(tmp->delmask);\n\t}\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void free_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tif (cs) {\n\t\tfree_cpumask_var(cs->cpus_allowed);\n\t\tfree_cpumask_var(cs->effective_cpus);\n\t\tfree_cpumask_var(cs->subparts_cpus);\n\t}\n\tif (tmp) {\n\t\tfree_cpumask_var(tmp->new_cpus);\n\t\tfree_cpumask_var(tmp->addmask);\n\t\tfree_cpumask_var(tmp->delmask);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_partition_change",
          "args": [
            "cs",
            "old_prs",
            "new_prs"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "notify_partition_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "279-284",
          "snippet": "static inline void notify_partition_change(struct cpuset *cs,\n\t\t\t\t\t   int old_prs, int new_prs)\n{\n\tif (old_prs != new_prs)\n\t\tcgroup_file_notify(&cs->partition_file);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void notify_partition_change(struct cpuset *cs,\n\t\t\t\t\t   int old_prs, int new_prs)\n{\n\tif (old_prs != new_prs)\n\t\tcgroup_file_notify(&cs->partition_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuild_sched_domains_locked",
          "args": [],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_sched_domains_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1074-1076",
          "snippet": "static void rebuild_sched_domains_locked(void)\n{\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void rebuild_sched_domains_locked(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_sibling_cpumasks",
          "args": [
            "parent",
            "cs",
            "&tmpmask"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "update_sibling_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1519-1540",
          "snippet": "static void update_sibling_cpumasks(struct cpuset *parent, struct cpuset *cs,\n\t\t\t\t    struct tmpmasks *tmp)\n{\n\tstruct cpuset *sibling;\n\tstruct cgroup_subsys_state *pos_css;\n\n\t/*\n\t * Check all its siblings and call update_cpumasks_hier()\n\t * if their use_parent_ecpus flag is set in order for them\n\t * to use the right effective_cpus value.\n\t */\n\trcu_read_lock();\n\tcpuset_for_each_child(sibling, pos_css, parent) {\n\t\tif (sibling == cs)\n\t\t\tcontinue;\n\t\tif (!sibling->use_parent_ecpus)\n\t\t\tcontinue;\n\n\t\tupdate_cpumasks_hier(sibling, tmp);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_sibling_cpumasks(struct cpuset *parent, struct cpuset *cs,\n\t\t\t\t    struct tmpmasks *tmp)\n{\n\tstruct cpuset *sibling;\n\tstruct cgroup_subsys_state *pos_css;\n\n\t/*\n\t * Check all its siblings and call update_cpumasks_hier()\n\t * if their use_parent_ecpus flag is set in order for them\n\t * to use the right effective_cpus value.\n\t */\n\trcu_read_lock();\n\tcpuset_for_each_child(sibling, pos_css, parent) {\n\t\tif (sibling == cs)\n\t\t\tcontinue;\n\t\tif (!sibling->use_parent_ecpus)\n\t\t\tcontinue;\n\n\t\tupdate_cpumasks_hier(sibling, tmp);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_tasks_cpumask",
          "args": [
            "parent"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "update_tasks_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1096-1105",
          "snippet": "static void update_tasks_cpumask(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tset_cpus_allowed_ptr(task, cs->effective_cpus);\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_tasks_cpumask(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tset_cpus_allowed_ptr(task, cs->effective_cpus);\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_flag",
          "args": [
            "CS_CPU_EXCLUSIVE",
            "cs",
            "0"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "update_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1951-1990",
          "snippet": "static int update_flag(cpuset_flagbits_t bit, struct cpuset *cs,\n\t\t       int turning_on)\n{\n\tstruct cpuset *trialcs;\n\tint balance_flag_changed;\n\tint spread_flag_changed;\n\tint err;\n\n\ttrialcs = alloc_trial_cpuset(cs);\n\tif (!trialcs)\n\t\treturn -ENOMEM;\n\n\tif (turning_on)\n\t\tset_bit(bit, &trialcs->flags);\n\telse\n\t\tclear_bit(bit, &trialcs->flags);\n\n\terr = validate_change(cs, trialcs);\n\tif (err < 0)\n\t\tgoto out;\n\n\tbalance_flag_changed = (is_sched_load_balance(cs) !=\n\t\t\t\tis_sched_load_balance(trialcs));\n\n\tspread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))\n\t\t\t|| (is_spread_page(cs) != is_spread_page(trialcs)));\n\n\tspin_lock_irq(&callback_lock);\n\tcs->flags = trialcs->flags;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (!cpumask_empty(trialcs->cpus_allowed) && balance_flag_changed)\n\t\trebuild_sched_domains_locked();\n\n\tif (spread_flag_changed)\n\t\tupdate_tasks_flags(cs);\nout:\n\tfree_cpuset(trialcs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_flag(cpuset_flagbits_t bit, struct cpuset *cs,\n\t\t       int turning_on)\n{\n\tstruct cpuset *trialcs;\n\tint balance_flag_changed;\n\tint spread_flag_changed;\n\tint err;\n\n\ttrialcs = alloc_trial_cpuset(cs);\n\tif (!trialcs)\n\t\treturn -ENOMEM;\n\n\tif (turning_on)\n\t\tset_bit(bit, &trialcs->flags);\n\telse\n\t\tclear_bit(bit, &trialcs->flags);\n\n\terr = validate_change(cs, trialcs);\n\tif (err < 0)\n\t\tgoto out;\n\n\tbalance_flag_changed = (is_sched_load_balance(cs) !=\n\t\t\t\tis_sched_load_balance(trialcs));\n\n\tspread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))\n\t\t\t|| (is_spread_page(cs) != is_spread_page(trialcs)));\n\n\tspin_lock_irq(&callback_lock);\n\tcs->flags = trialcs->flags;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (!cpumask_empty(trialcs->cpus_allowed) && balance_flag_changed)\n\t\trebuild_sched_domains_locked();\n\n\tif (spread_flag_changed)\n\t\tupdate_tasks_flags(cs);\nout:\n\tfree_cpuset(trialcs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_parent_subparts_cpumask",
          "args": [
            "cs",
            "partcmd_disable",
            "NULL",
            "&tmpmask"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "update_parent_subparts_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1182-1350",
          "snippet": "static int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,\n\t\t\t\t\t  struct cpumask *newmask,\n\t\t\t\t\t  struct tmpmasks *tmp)\n{\n\tstruct cpuset *parent = parent_cs(cpuset);\n\tint adding;\t/* Moving cpus from effective_cpus to subparts_cpus */\n\tint deleting;\t/* Moving cpus from subparts_cpus to effective_cpus */\n\tint old_prs, new_prs;\n\tbool part_error = false;\t/* Partition error? */\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * The parent must be a partition root.\n\t * The new cpumask, if present, or the current cpus_allowed must\n\t * not be empty.\n\t */\n\tif (!is_partition_root(parent) ||\n\t   (newmask && cpumask_empty(newmask)) ||\n\t   (!newmask && cpumask_empty(cpuset->cpus_allowed)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Enabling/disabling partition root is not allowed if there are\n\t * online children.\n\t */\n\tif ((cmd != partcmd_update) && css_has_online_children(&cpuset->css))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Enabling partition root is not allowed if not all the CPUs\n\t * can be granted from parent's effective_cpus or at least one\n\t * CPU will be left after that.\n\t */\n\tif ((cmd == partcmd_enable) &&\n\t   (!cpumask_subset(cpuset->cpus_allowed, parent->effective_cpus) ||\n\t     cpumask_equal(cpuset->cpus_allowed, parent->effective_cpus)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * A cpumask update cannot make parent's effective_cpus become empty.\n\t */\n\tadding = deleting = false;\n\told_prs = new_prs = cpuset->partition_root_state;\n\tif (cmd == partcmd_enable) {\n\t\tcpumask_copy(tmp->addmask, cpuset->cpus_allowed);\n\t\tadding = true;\n\t} else if (cmd == partcmd_disable) {\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t} else if (newmask) {\n\t\t/*\n\t\t * partcmd_update with newmask:\n\t\t *\n\t\t * delmask = cpus_allowed & ~newmask & parent->subparts_cpus\n\t\t * addmask = newmask & parent->effective_cpus\n\t\t *\t\t     & ~parent->subparts_cpus\n\t\t */\n\t\tcpumask_andnot(tmp->delmask, cpuset->cpus_allowed, newmask);\n\t\tdeleting = cpumask_and(tmp->delmask, tmp->delmask,\n\t\t\t\t       parent->subparts_cpus);\n\n\t\tcpumask_and(tmp->addmask, newmask, parent->effective_cpus);\n\t\tadding = cpumask_andnot(tmp->addmask, tmp->addmask,\n\t\t\t\t\tparent->subparts_cpus);\n\t\t/*\n\t\t * Return error if the new effective_cpus could become empty.\n\t\t */\n\t\tif (adding &&\n\t\t    cpumask_equal(parent->effective_cpus, tmp->addmask)) {\n\t\t\tif (!deleting)\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * As some of the CPUs in subparts_cpus might have\n\t\t\t * been offlined, we need to compute the real delmask\n\t\t\t * to confirm that.\n\t\t\t */\n\t\t\tif (!cpumask_and(tmp->addmask, tmp->delmask,\n\t\t\t\t\t cpu_active_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tcpumask_copy(tmp->addmask, parent->effective_cpus);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * partcmd_update w/o newmask:\n\t\t *\n\t\t * addmask = cpus_allowed & parent->effective_cpus\n\t\t *\n\t\t * Note that parent's subparts_cpus may have been\n\t\t * pre-shrunk in case there is a change in the cpu list.\n\t\t * So no deletion is needed.\n\t\t */\n\t\tadding = cpumask_and(tmp->addmask, cpuset->cpus_allowed,\n\t\t\t\t     parent->effective_cpus);\n\t\tpart_error = cpumask_equal(tmp->addmask,\n\t\t\t\t\t   parent->effective_cpus);\n\t}\n\n\tif (cmd == partcmd_update) {\n\t\tint prev_prs = cpuset->partition_root_state;\n\n\t\t/*\n\t\t * Check for possible transition between PRS_ENABLED\n\t\t * and PRS_ERROR.\n\t\t */\n\t\tswitch (cpuset->partition_root_state) {\n\t\tcase PRS_ENABLED:\n\t\t\tif (part_error)\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\tbreak;\n\t\tcase PRS_ERROR:\n\t\t\tif (!part_error)\n\t\t\t\tnew_prs = PRS_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Set part_error if previously in invalid state.\n\t\t */\n\t\tpart_error = (prev_prs == PRS_ERROR);\n\t}\n\n\tif (!part_error && (new_prs == PRS_ERROR))\n\t\treturn 0;\t/* Nothing need to be done */\n\n\tif (new_prs == PRS_ERROR) {\n\t\t/*\n\t\t * Remove all its cpus from parent's subparts_cpus.\n\t\t */\n\t\tadding = false;\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t}\n\n\tif (!adding && !deleting && (new_prs == old_prs))\n\t\treturn 0;\n\n\t/*\n\t * Change the parent's subparts_cpus.\n\t * Newly added CPUs will be removed from effective_cpus and\n\t * newly deleted ones will be added back to effective_cpus.\n\t */\n\tspin_lock_irq(&callback_lock);\n\tif (adding) {\n\t\tcpumask_or(parent->subparts_cpus,\n\t\t\t   parent->subparts_cpus, tmp->addmask);\n\t\tcpumask_andnot(parent->effective_cpus,\n\t\t\t       parent->effective_cpus, tmp->addmask);\n\t}\n\tif (deleting) {\n\t\tcpumask_andnot(parent->subparts_cpus,\n\t\t\t       parent->subparts_cpus, tmp->delmask);\n\t\t/*\n\t\t * Some of the CPUs in subparts_cpus might have been offlined.\n\t\t */\n\t\tcpumask_and(tmp->delmask, tmp->delmask, cpu_active_mask);\n\t\tcpumask_or(parent->effective_cpus,\n\t\t\t   parent->effective_cpus, tmp->delmask);\n\t}\n\n\tparent->nr_subparts_cpus = cpumask_weight(parent->subparts_cpus);\n\n\tif (old_prs != new_prs)\n\t\tcpuset->partition_root_state = new_prs;\n\n\tspin_unlock_irq(&callback_lock);\n\tnotify_partition_change(cpuset, old_prs, new_prs);\n\n\treturn cmd == partcmd_update;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define PRS_ERROR\t\t-1",
            "#define PRS_ENABLED\t\t1"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n#define PRS_ENABLED\t\t1\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,\n\t\t\t\t\t  struct cpumask *newmask,\n\t\t\t\t\t  struct tmpmasks *tmp)\n{\n\tstruct cpuset *parent = parent_cs(cpuset);\n\tint adding;\t/* Moving cpus from effective_cpus to subparts_cpus */\n\tint deleting;\t/* Moving cpus from subparts_cpus to effective_cpus */\n\tint old_prs, new_prs;\n\tbool part_error = false;\t/* Partition error? */\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * The parent must be a partition root.\n\t * The new cpumask, if present, or the current cpus_allowed must\n\t * not be empty.\n\t */\n\tif (!is_partition_root(parent) ||\n\t   (newmask && cpumask_empty(newmask)) ||\n\t   (!newmask && cpumask_empty(cpuset->cpus_allowed)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Enabling/disabling partition root is not allowed if there are\n\t * online children.\n\t */\n\tif ((cmd != partcmd_update) && css_has_online_children(&cpuset->css))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Enabling partition root is not allowed if not all the CPUs\n\t * can be granted from parent's effective_cpus or at least one\n\t * CPU will be left after that.\n\t */\n\tif ((cmd == partcmd_enable) &&\n\t   (!cpumask_subset(cpuset->cpus_allowed, parent->effective_cpus) ||\n\t     cpumask_equal(cpuset->cpus_allowed, parent->effective_cpus)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * A cpumask update cannot make parent's effective_cpus become empty.\n\t */\n\tadding = deleting = false;\n\told_prs = new_prs = cpuset->partition_root_state;\n\tif (cmd == partcmd_enable) {\n\t\tcpumask_copy(tmp->addmask, cpuset->cpus_allowed);\n\t\tadding = true;\n\t} else if (cmd == partcmd_disable) {\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t} else if (newmask) {\n\t\t/*\n\t\t * partcmd_update with newmask:\n\t\t *\n\t\t * delmask = cpus_allowed & ~newmask & parent->subparts_cpus\n\t\t * addmask = newmask & parent->effective_cpus\n\t\t *\t\t     & ~parent->subparts_cpus\n\t\t */\n\t\tcpumask_andnot(tmp->delmask, cpuset->cpus_allowed, newmask);\n\t\tdeleting = cpumask_and(tmp->delmask, tmp->delmask,\n\t\t\t\t       parent->subparts_cpus);\n\n\t\tcpumask_and(tmp->addmask, newmask, parent->effective_cpus);\n\t\tadding = cpumask_andnot(tmp->addmask, tmp->addmask,\n\t\t\t\t\tparent->subparts_cpus);\n\t\t/*\n\t\t * Return error if the new effective_cpus could become empty.\n\t\t */\n\t\tif (adding &&\n\t\t    cpumask_equal(parent->effective_cpus, tmp->addmask)) {\n\t\t\tif (!deleting)\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * As some of the CPUs in subparts_cpus might have\n\t\t\t * been offlined, we need to compute the real delmask\n\t\t\t * to confirm that.\n\t\t\t */\n\t\t\tif (!cpumask_and(tmp->addmask, tmp->delmask,\n\t\t\t\t\t cpu_active_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tcpumask_copy(tmp->addmask, parent->effective_cpus);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * partcmd_update w/o newmask:\n\t\t *\n\t\t * addmask = cpus_allowed & parent->effective_cpus\n\t\t *\n\t\t * Note that parent's subparts_cpus may have been\n\t\t * pre-shrunk in case there is a change in the cpu list.\n\t\t * So no deletion is needed.\n\t\t */\n\t\tadding = cpumask_and(tmp->addmask, cpuset->cpus_allowed,\n\t\t\t\t     parent->effective_cpus);\n\t\tpart_error = cpumask_equal(tmp->addmask,\n\t\t\t\t\t   parent->effective_cpus);\n\t}\n\n\tif (cmd == partcmd_update) {\n\t\tint prev_prs = cpuset->partition_root_state;\n\n\t\t/*\n\t\t * Check for possible transition between PRS_ENABLED\n\t\t * and PRS_ERROR.\n\t\t */\n\t\tswitch (cpuset->partition_root_state) {\n\t\tcase PRS_ENABLED:\n\t\t\tif (part_error)\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\tbreak;\n\t\tcase PRS_ERROR:\n\t\t\tif (!part_error)\n\t\t\t\tnew_prs = PRS_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Set part_error if previously in invalid state.\n\t\t */\n\t\tpart_error = (prev_prs == PRS_ERROR);\n\t}\n\n\tif (!part_error && (new_prs == PRS_ERROR))\n\t\treturn 0;\t/* Nothing need to be done */\n\n\tif (new_prs == PRS_ERROR) {\n\t\t/*\n\t\t * Remove all its cpus from parent's subparts_cpus.\n\t\t */\n\t\tadding = false;\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t}\n\n\tif (!adding && !deleting && (new_prs == old_prs))\n\t\treturn 0;\n\n\t/*\n\t * Change the parent's subparts_cpus.\n\t * Newly added CPUs will be removed from effective_cpus and\n\t * newly deleted ones will be added back to effective_cpus.\n\t */\n\tspin_lock_irq(&callback_lock);\n\tif (adding) {\n\t\tcpumask_or(parent->subparts_cpus,\n\t\t\t   parent->subparts_cpus, tmp->addmask);\n\t\tcpumask_andnot(parent->effective_cpus,\n\t\t\t       parent->effective_cpus, tmp->addmask);\n\t}\n\tif (deleting) {\n\t\tcpumask_andnot(parent->subparts_cpus,\n\t\t\t       parent->subparts_cpus, tmp->delmask);\n\t\t/*\n\t\t * Some of the CPUs in subparts_cpus might have been offlined.\n\t\t */\n\t\tcpumask_and(tmp->delmask, tmp->delmask, cpu_active_mask);\n\t\tcpumask_or(parent->effective_cpus,\n\t\t\t   parent->effective_cpus, tmp->delmask);\n\t}\n\n\tparent->nr_subparts_cpus = cpumask_weight(parent->subparts_cpus);\n\n\tif (old_prs != new_prs)\n\t\tcpuset->partition_root_state = new_prs;\n\n\tspin_unlock_irq(&callback_lock);\n\tnotify_partition_change(cpuset, old_prs, new_prs);\n\n\treturn cmd == partcmd_update;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cs->cpus_allowed"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumasks",
          "args": [
            "NULL",
            "&tmpmask"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "510-540",
          "snippet": "static inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tcpumask_var_t *pmask1, *pmask2, *pmask3;\n\n\tif (cs) {\n\t\tpmask1 = &cs->cpus_allowed;\n\t\tpmask2 = &cs->effective_cpus;\n\t\tpmask3 = &cs->subparts_cpus;\n\t} else {\n\t\tpmask1 = &tmp->new_cpus;\n\t\tpmask2 = &tmp->addmask;\n\t\tpmask3 = &tmp->delmask;\n\t}\n\n\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))\n\t\tgoto free_one;\n\n\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))\n\t\tgoto free_two;\n\n\treturn 0;\n\nfree_two:\n\tfree_cpumask_var(*pmask2);\nfree_one:\n\tfree_cpumask_var(*pmask1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tcpumask_var_t *pmask1, *pmask2, *pmask3;\n\n\tif (cs) {\n\t\tpmask1 = &cs->cpus_allowed;\n\t\tpmask2 = &cs->effective_cpus;\n\t\tpmask3 = &cs->subparts_cpus;\n\t} else {\n\t\tpmask1 = &tmp->new_cpus;\n\t\tpmask2 = &tmp->addmask;\n\t\tpmask3 = &tmp->delmask;\n\t}\n\n\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))\n\t\tgoto free_one;\n\n\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))\n\t\tgoto free_two;\n\n\treturn 0;\n\nfree_two:\n\tfree_cpumask_var(*pmask2);\nfree_one:\n\tfree_cpumask_var(*pmask1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cs"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_prstate(struct cpuset *cs, int new_prs)\n{\n\tint err, old_prs = cs->partition_root_state;\n\tstruct cpuset *parent = parent_cs(cs);\n\tstruct tmpmasks tmpmask;\n\n\tif (old_prs == new_prs)\n\t\treturn 0;\n\n\t/*\n\t * Cannot force a partial or invalid partition root to a full\n\t * partition root.\n\t */\n\tif (new_prs && (old_prs == PRS_ERROR))\n\t\treturn -EINVAL;\n\n\tif (alloc_cpumasks(NULL, &tmpmask))\n\t\treturn -ENOMEM;\n\n\terr = -EINVAL;\n\tif (!old_prs) {\n\t\t/*\n\t\t * Turning on partition root requires setting the\n\t\t * CS_CPU_EXCLUSIVE bit implicitly as well and cpus_allowed\n\t\t * cannot be NULL.\n\t\t */\n\t\tif (cpumask_empty(cs->cpus_allowed))\n\t\t\tgoto out;\n\n\t\terr = update_flag(CS_CPU_EXCLUSIVE, cs, 1);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_enable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Turning off partition root will clear the\n\t\t * CS_CPU_EXCLUSIVE bit.\n\t\t */\n\t\tif (old_prs == PRS_ERROR) {\n\t\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = update_parent_subparts_cpumask(cs, partcmd_disable,\n\t\t\t\t\t\t     NULL, &tmpmask);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t/* Turning off CS_CPU_EXCLUSIVE will not return error */\n\t\tupdate_flag(CS_CPU_EXCLUSIVE, cs, 0);\n\t}\n\n\t/*\n\t * Update cpumask of parent's tasks except when it is the top\n\t * cpuset as some system daemons cannot be mapped to other CPUs.\n\t */\n\tif (parent != &top_cpuset)\n\t\tupdate_tasks_cpumask(parent);\n\n\tif (parent->child_ecpus_count)\n\t\tupdate_sibling_cpumasks(parent, cs, &tmpmask);\n\n\trebuild_sched_domains_locked();\nout:\n\tif (!err) {\n\t\tspin_lock_irq(&callback_lock);\n\t\tcs->partition_root_state = new_prs;\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cs, old_prs, new_prs);\n\t}\n\n\tfree_cpumasks(NULL, &tmpmask);\n\treturn err;\n}"
  },
  {
    "function_name": "update_flag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1951-1990",
    "snippet": "static int update_flag(cpuset_flagbits_t bit, struct cpuset *cs,\n\t\t       int turning_on)\n{\n\tstruct cpuset *trialcs;\n\tint balance_flag_changed;\n\tint spread_flag_changed;\n\tint err;\n\n\ttrialcs = alloc_trial_cpuset(cs);\n\tif (!trialcs)\n\t\treturn -ENOMEM;\n\n\tif (turning_on)\n\t\tset_bit(bit, &trialcs->flags);\n\telse\n\t\tclear_bit(bit, &trialcs->flags);\n\n\terr = validate_change(cs, trialcs);\n\tif (err < 0)\n\t\tgoto out;\n\n\tbalance_flag_changed = (is_sched_load_balance(cs) !=\n\t\t\t\tis_sched_load_balance(trialcs));\n\n\tspread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))\n\t\t\t|| (is_spread_page(cs) != is_spread_page(trialcs)));\n\n\tspin_lock_irq(&callback_lock);\n\tcs->flags = trialcs->flags;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (!cpumask_empty(trialcs->cpus_allowed) && balance_flag_changed)\n\t\trebuild_sched_domains_locked();\n\n\tif (spread_flag_changed)\n\t\tupdate_tasks_flags(cs);\nout:\n\tfree_cpuset(trialcs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpuset",
          "args": [
            "trialcs"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "free_cpuset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "587-591",
          "snippet": "static inline void free_cpuset(struct cpuset *cs)\n{\n\tfree_cpumasks(cs, NULL);\n\tkfree(cs);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void free_cpuset(struct cpuset *cs)\n{\n\tfree_cpumasks(cs, NULL);\n\tkfree(cs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_tasks_flags",
          "args": [
            "cs"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "update_tasks_flags",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1931-1940",
          "snippet": "static void update_tasks_flags(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tcpuset_update_task_spread_flag(cs, task);\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_tasks_flags(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tcpuset_update_task_spread_flag(cs, task);\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuild_sched_domains_locked",
          "args": [],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_sched_domains_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1074-1076",
          "snippet": "static void rebuild_sched_domains_locked(void)\n{\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void rebuild_sched_domains_locked(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "trialcs->cpus_allowed"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_spread_page",
          "args": [
            "trialcs"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "is_spread_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "261-264",
          "snippet": "static inline int is_spread_page(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_spread_page(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_spread_slab",
          "args": [
            "trialcs"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "is_spread_slab",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "266-269",
          "snippet": "static inline int is_spread_slab(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_spread_slab(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sched_load_balance",
          "args": [
            "trialcs"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "is_sched_load_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "251-254",
          "snippet": "static inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_change",
          "args": [
            "cs",
            "trialcs"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "validate_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "613-675",
          "snippet": "static int validate_change(struct cpuset *cur, struct cpuset *trial)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *c, *par;\n\tint ret;\n\n\t/* The checks don't apply to root cpuset */\n\tif (cur == &top_cpuset)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpar = parent_cs(cur);\n\n\t/* On legacy hierarchy, we must be a subset of our parent cpuset. */\n\tret = -EACCES;\n\tif (!is_in_v2_mode() && !is_cpuset_subset(trial, par))\n\t\tgoto out;\n\n\t/*\n\t * If either I or some sibling (!= me) is exclusive, we can't\n\t * overlap\n\t */\n\tret = -EINVAL;\n\tcpuset_for_each_child(c, css, par) {\n\t\tif ((is_cpu_exclusive(trial) || is_cpu_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    cpumask_intersects(trial->cpus_allowed, c->cpus_allowed))\n\t\t\tgoto out;\n\t\tif ((is_mem_exclusive(trial) || is_mem_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    nodes_intersects(trial->mems_allowed, c->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Cpusets with tasks - existing or newly being attached - can't\n\t * be changed to have empty cpus_allowed or mems_allowed.\n\t */\n\tret = -ENOSPC;\n\tif ((cgroup_is_populated(cur->css.cgroup) || cur->attach_in_progress)) {\n\t\tif (!cpumask_empty(cur->cpus_allowed) &&\n\t\t    cpumask_empty(trial->cpus_allowed))\n\t\t\tgoto out;\n\t\tif (!nodes_empty(cur->mems_allowed) &&\n\t\t    nodes_empty(trial->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We can't shrink if we won't have enough room for SCHED_DEADLINE\n\t * tasks.\n\t */\n\tret = -EBUSY;\n\tif (is_cpu_exclusive(cur) &&\n\t    !cpuset_cpumask_can_shrink(cur->cpus_allowed,\n\t\t\t\t       trial->cpus_allowed))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\n\nstatic int validate_change(struct cpuset *cur, struct cpuset *trial)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *c, *par;\n\tint ret;\n\n\t/* The checks don't apply to root cpuset */\n\tif (cur == &top_cpuset)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpar = parent_cs(cur);\n\n\t/* On legacy hierarchy, we must be a subset of our parent cpuset. */\n\tret = -EACCES;\n\tif (!is_in_v2_mode() && !is_cpuset_subset(trial, par))\n\t\tgoto out;\n\n\t/*\n\t * If either I or some sibling (!= me) is exclusive, we can't\n\t * overlap\n\t */\n\tret = -EINVAL;\n\tcpuset_for_each_child(c, css, par) {\n\t\tif ((is_cpu_exclusive(trial) || is_cpu_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    cpumask_intersects(trial->cpus_allowed, c->cpus_allowed))\n\t\t\tgoto out;\n\t\tif ((is_mem_exclusive(trial) || is_mem_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    nodes_intersects(trial->mems_allowed, c->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Cpusets with tasks - existing or newly being attached - can't\n\t * be changed to have empty cpus_allowed or mems_allowed.\n\t */\n\tret = -ENOSPC;\n\tif ((cgroup_is_populated(cur->css.cgroup) || cur->attach_in_progress)) {\n\t\tif (!cpumask_empty(cur->cpus_allowed) &&\n\t\t    cpumask_empty(trial->cpus_allowed))\n\t\t\tgoto out;\n\t\tif (!nodes_empty(cur->mems_allowed) &&\n\t\t    nodes_empty(trial->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We can't shrink if we won't have enough room for SCHED_DEADLINE\n\t * tasks.\n\t */\n\tret = -EBUSY;\n\tif (is_cpu_exclusive(cur) &&\n\t    !cpuset_cpumask_can_shrink(cur->cpus_allowed,\n\t\t\t\t       trial->cpus_allowed))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "bit",
            "&trialcs->flags"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit",
            "&trialcs->flags"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_trial_cpuset",
          "args": [
            "cs"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_trial_cpuset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "565-581",
          "snippet": "static struct cpuset *alloc_trial_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *trial;\n\n\ttrial = kmemdup(cs, sizeof(*cs), GFP_KERNEL);\n\tif (!trial)\n\t\treturn NULL;\n\n\tif (alloc_cpumasks(trial, NULL)) {\n\t\tkfree(trial);\n\t\treturn NULL;\n\t}\n\n\tcpumask_copy(trial->cpus_allowed, cs->cpus_allowed);\n\tcpumask_copy(trial->effective_cpus, cs->effective_cpus);\n\treturn trial;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset *alloc_trial_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *trial;\n\n\ttrial = kmemdup(cs, sizeof(*cs), GFP_KERNEL);\n\tif (!trial)\n\t\treturn NULL;\n\n\tif (alloc_cpumasks(trial, NULL)) {\n\t\tkfree(trial);\n\t\treturn NULL;\n\t}\n\n\tcpumask_copy(trial->cpus_allowed, cs->cpus_allowed);\n\tcpumask_copy(trial->effective_cpus, cs->effective_cpus);\n\treturn trial;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_flag(cpuset_flagbits_t bit, struct cpuset *cs,\n\t\t       int turning_on)\n{\n\tstruct cpuset *trialcs;\n\tint balance_flag_changed;\n\tint spread_flag_changed;\n\tint err;\n\n\ttrialcs = alloc_trial_cpuset(cs);\n\tif (!trialcs)\n\t\treturn -ENOMEM;\n\n\tif (turning_on)\n\t\tset_bit(bit, &trialcs->flags);\n\telse\n\t\tclear_bit(bit, &trialcs->flags);\n\n\terr = validate_change(cs, trialcs);\n\tif (err < 0)\n\t\tgoto out;\n\n\tbalance_flag_changed = (is_sched_load_balance(cs) !=\n\t\t\t\tis_sched_load_balance(trialcs));\n\n\tspread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))\n\t\t\t|| (is_spread_page(cs) != is_spread_page(trialcs)));\n\n\tspin_lock_irq(&callback_lock);\n\tcs->flags = trialcs->flags;\n\tspin_unlock_irq(&callback_lock);\n\n\tif (!cpumask_empty(trialcs->cpus_allowed) && balance_flag_changed)\n\t\trebuild_sched_domains_locked();\n\n\tif (spread_flag_changed)\n\t\tupdate_tasks_flags(cs);\nout:\n\tfree_cpuset(trialcs);\n\treturn err;\n}"
  },
  {
    "function_name": "update_tasks_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1931-1940",
    "snippet": "static void update_tasks_flags(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tcpuset_update_task_spread_flag(cs, task);\n\tcss_task_iter_end(&it);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_update_task_spread_flag",
          "args": [
            "cs",
            "task"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_update_task_spread_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "472-484",
          "snippet": "static void cpuset_update_task_spread_flag(struct cpuset *cs,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tif (is_spread_page(cs))\n\t\ttask_set_spread_page(tsk);\n\telse\n\t\ttask_clear_spread_page(tsk);\n\n\tif (is_spread_slab(cs))\n\t\ttask_set_spread_slab(tsk);\n\telse\n\t\ttask_clear_spread_slab(tsk);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_update_task_spread_flag(struct cpuset *cs,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tif (is_spread_page(cs))\n\t\ttask_set_spread_page(tsk);\n\telse\n\t\ttask_clear_spread_page(tsk);\n\n\tif (is_spread_slab(cs))\n\t\ttask_set_spread_slab(tsk);\n\telse\n\t\ttask_clear_spread_slab(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&cs->css",
            "0",
            "&it"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_tasks_flags(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tcpuset_update_task_spread_flag(cs, task);\n\tcss_task_iter_end(&it);\n}"
  },
  {
    "function_name": "update_relax_domain_level",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1906-1921",
    "snippet": "static int update_relax_domain_level(struct cpuset *cs, s64 val)\n{\n#ifdef CONFIG_SMP\n\tif (val < -1 || val >= sched_domain_level_max)\n\t\treturn -EINVAL;\n#endif\n\n\tif (val != cs->relax_domain_level) {\n\t\tcs->relax_domain_level = val;\n\t\tif (!cpumask_empty(cs->cpus_allowed) &&\n\t\t    is_sched_load_balance(cs))\n\t\t\trebuild_sched_domains_locked();\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rebuild_sched_domains_locked",
          "args": [],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_sched_domains_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1074-1076",
          "snippet": "static void rebuild_sched_domains_locked(void)\n{\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void rebuild_sched_domains_locked(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sched_load_balance",
          "args": [
            "cs"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "is_sched_load_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "251-254",
          "snippet": "static inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cs->cpus_allowed"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int update_relax_domain_level(struct cpuset *cs, s64 val)\n{\n#ifdef CONFIG_SMP\n\tif (val < -1 || val >= sched_domain_level_max)\n\t\treturn -EINVAL;\n#endif\n\n\tif (val != cs->relax_domain_level) {\n\t\tcs->relax_domain_level = val;\n\t\tif (!cpumask_empty(cs->cpus_allowed) &&\n\t\t    is_sched_load_balance(cs))\n\t\t\trebuild_sched_domains_locked();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "current_cpuset_is_being_rebound",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1895-1904",
    "snippet": "bool current_cpuset_is_being_rebound(void)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = task_cs(current) == cpuset_being_rebound;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *cpuset_being_rebound;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cs",
          "args": [
            "current"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "task_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "208-211",
          "snippet": "static inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void *cpuset_being_rebound;\n\nbool current_cpuset_is_being_rebound(void)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = task_cs(current) == cpuset_being_rebound;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "update_nodemask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1841-1893",
    "snippet": "static int update_nodemask(struct cpuset *cs, struct cpuset *trialcs,\n\t\t\t   const char *buf)\n{\n\tint retval;\n\n\t/*\n\t * top_cpuset.mems_allowed tracks node_stats[N_MEMORY];\n\t * it's read-only\n\t */\n\tif (cs == &top_cpuset) {\n\t\tretval = -EACCES;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * An empty mems_allowed is ok iff there are no tasks in the cpuset.\n\t * Since nodelist_parse() fails on an empty mask, we special case\n\t * that parsing.  The validate_change() call ensures that cpusets\n\t * with tasks have memory.\n\t */\n\tif (!*buf) {\n\t\tnodes_clear(trialcs->mems_allowed);\n\t} else {\n\t\tretval = nodelist_parse(buf, trialcs->mems_allowed);\n\t\tif (retval < 0)\n\t\t\tgoto done;\n\n\t\tif (!nodes_subset(trialcs->mems_allowed,\n\t\t\t\t  top_cpuset.mems_allowed)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (nodes_equal(cs->mems_allowed, trialcs->mems_allowed)) {\n\t\tretval = 0;\t\t/* Too easy - nothing to do */\n\t\tgoto done;\n\t}\n\tretval = validate_change(cs, trialcs);\n\tif (retval < 0)\n\t\tgoto done;\n\n\tcheck_insane_mems_config(&trialcs->mems_allowed);\n\n\tspin_lock_irq(&callback_lock);\n\tcs->mems_allowed = trialcs->mems_allowed;\n\tspin_unlock_irq(&callback_lock);\n\n\t/* use trialcs->mems_allowed as a temp variable */\n\tupdate_nodemasks_hier(cs, &trialcs->mems_allowed);\ndone:\n\treturn retval;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_nodemasks_hier",
          "args": [
            "cs",
            "&trialcs->mems_allowed"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "update_nodemasks_hier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1785-1826",
          "snippet": "static void update_nodemasks_hier(struct cpuset *cs, nodemask_t *new_mems)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, cs) {\n\t\tstruct cpuset *parent = parent_cs(cp);\n\n\t\tnodes_and(*new_mems, cp->mems_allowed, parent->effective_mems);\n\n\t\t/*\n\t\t * If it becomes empty, inherit the effective mask of the\n\t\t * parent, which is guaranteed to have some MEMs.\n\t\t */\n\t\tif (is_in_v2_mode() && nodes_empty(*new_mems))\n\t\t\t*new_mems = parent->effective_mems;\n\n\t\t/* Skip the whole subtree if the nodemask remains the same. */\n\t\tif (nodes_equal(*new_mems, cp->effective_mems)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!css_tryget_online(&cp->css))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tspin_lock_irq(&callback_lock);\n\t\tcp->effective_mems = *new_mems;\n\t\tspin_unlock_irq(&callback_lock);\n\n\t\tWARN_ON(!is_in_v2_mode() &&\n\t\t\t!nodes_equal(cp->mems_allowed, cp->effective_mems));\n\n\t\tupdate_tasks_nodemask(cp);\n\n\t\trcu_read_lock();\n\t\tcss_put(&cp->css);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic void update_nodemasks_hier(struct cpuset *cs, nodemask_t *new_mems)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, cs) {\n\t\tstruct cpuset *parent = parent_cs(cp);\n\n\t\tnodes_and(*new_mems, cp->mems_allowed, parent->effective_mems);\n\n\t\t/*\n\t\t * If it becomes empty, inherit the effective mask of the\n\t\t * parent, which is guaranteed to have some MEMs.\n\t\t */\n\t\tif (is_in_v2_mode() && nodes_empty(*new_mems))\n\t\t\t*new_mems = parent->effective_mems;\n\n\t\t/* Skip the whole subtree if the nodemask remains the same. */\n\t\tif (nodes_equal(*new_mems, cp->effective_mems)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!css_tryget_online(&cp->css))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tspin_lock_irq(&callback_lock);\n\t\tcp->effective_mems = *new_mems;\n\t\tspin_unlock_irq(&callback_lock);\n\n\t\tWARN_ON(!is_in_v2_mode() &&\n\t\t\t!nodes_equal(cp->mems_allowed, cp->effective_mems));\n\n\t\tupdate_tasks_nodemask(cp);\n\n\t\trcu_read_lock();\n\t\tcss_put(&cp->css);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_insane_mems_config",
          "args": [
            "&trialcs->mems_allowed"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "check_insane_mems_config",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "382-391",
          "snippet": "static inline void check_insane_mems_config(nodemask_t *nodes)\n{\n\tif (!cpusets_insane_config() &&\n\t\tmovable_only_nodes(nodes)) {\n\t\tstatic_branch_enable(&cpusets_insane_config_key);\n\t\tpr_info(\"Unsupported (movable nodes only) cpuset configuration detected (nmask=%*pbl)!\\n\"\n\t\t\t\"Cpuset allocations might fail even with a lot of memory available.\\n\",\n\t\t\tnodemask_pr_args(nodes));\n\t}\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void check_insane_mems_config(nodemask_t *nodes)\n{\n\tif (!cpusets_insane_config() &&\n\t\tmovable_only_nodes(nodes)) {\n\t\tstatic_branch_enable(&cpusets_insane_config_key);\n\t\tpr_info(\"Unsupported (movable nodes only) cpuset configuration detected (nmask=%*pbl)!\\n\"\n\t\t\t\"Cpuset allocations might fail even with a lot of memory available.\\n\",\n\t\t\tnodemask_pr_args(nodes));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_change",
          "args": [
            "cs",
            "trialcs"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "validate_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "613-675",
          "snippet": "static int validate_change(struct cpuset *cur, struct cpuset *trial)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *c, *par;\n\tint ret;\n\n\t/* The checks don't apply to root cpuset */\n\tif (cur == &top_cpuset)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpar = parent_cs(cur);\n\n\t/* On legacy hierarchy, we must be a subset of our parent cpuset. */\n\tret = -EACCES;\n\tif (!is_in_v2_mode() && !is_cpuset_subset(trial, par))\n\t\tgoto out;\n\n\t/*\n\t * If either I or some sibling (!= me) is exclusive, we can't\n\t * overlap\n\t */\n\tret = -EINVAL;\n\tcpuset_for_each_child(c, css, par) {\n\t\tif ((is_cpu_exclusive(trial) || is_cpu_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    cpumask_intersects(trial->cpus_allowed, c->cpus_allowed))\n\t\t\tgoto out;\n\t\tif ((is_mem_exclusive(trial) || is_mem_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    nodes_intersects(trial->mems_allowed, c->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Cpusets with tasks - existing or newly being attached - can't\n\t * be changed to have empty cpus_allowed or mems_allowed.\n\t */\n\tret = -ENOSPC;\n\tif ((cgroup_is_populated(cur->css.cgroup) || cur->attach_in_progress)) {\n\t\tif (!cpumask_empty(cur->cpus_allowed) &&\n\t\t    cpumask_empty(trial->cpus_allowed))\n\t\t\tgoto out;\n\t\tif (!nodes_empty(cur->mems_allowed) &&\n\t\t    nodes_empty(trial->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We can't shrink if we won't have enough room for SCHED_DEADLINE\n\t * tasks.\n\t */\n\tret = -EBUSY;\n\tif (is_cpu_exclusive(cur) &&\n\t    !cpuset_cpumask_can_shrink(cur->cpus_allowed,\n\t\t\t\t       trial->cpus_allowed))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\n\nstatic int validate_change(struct cpuset *cur, struct cpuset *trial)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *c, *par;\n\tint ret;\n\n\t/* The checks don't apply to root cpuset */\n\tif (cur == &top_cpuset)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpar = parent_cs(cur);\n\n\t/* On legacy hierarchy, we must be a subset of our parent cpuset. */\n\tret = -EACCES;\n\tif (!is_in_v2_mode() && !is_cpuset_subset(trial, par))\n\t\tgoto out;\n\n\t/*\n\t * If either I or some sibling (!= me) is exclusive, we can't\n\t * overlap\n\t */\n\tret = -EINVAL;\n\tcpuset_for_each_child(c, css, par) {\n\t\tif ((is_cpu_exclusive(trial) || is_cpu_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    cpumask_intersects(trial->cpus_allowed, c->cpus_allowed))\n\t\t\tgoto out;\n\t\tif ((is_mem_exclusive(trial) || is_mem_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    nodes_intersects(trial->mems_allowed, c->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Cpusets with tasks - existing or newly being attached - can't\n\t * be changed to have empty cpus_allowed or mems_allowed.\n\t */\n\tret = -ENOSPC;\n\tif ((cgroup_is_populated(cur->css.cgroup) || cur->attach_in_progress)) {\n\t\tif (!cpumask_empty(cur->cpus_allowed) &&\n\t\t    cpumask_empty(trial->cpus_allowed))\n\t\t\tgoto out;\n\t\tif (!nodes_empty(cur->mems_allowed) &&\n\t\t    nodes_empty(trial->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We can't shrink if we won't have enough room for SCHED_DEADLINE\n\t * tasks.\n\t */\n\tret = -EBUSY;\n\tif (is_cpu_exclusive(cur) &&\n\t    !cpuset_cpumask_can_shrink(cur->cpus_allowed,\n\t\t\t\t       trial->cpus_allowed))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_equal",
          "args": [
            "cs->mems_allowed",
            "trialcs->mems_allowed"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_subset",
          "args": [
            "trialcs->mems_allowed",
            "top_cpuset.mems_allowed"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodelist_parse",
          "args": [
            "buf",
            "trialcs->mems_allowed"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_clear",
          "args": [
            "trialcs->mems_allowed"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_nodemask(struct cpuset *cs, struct cpuset *trialcs,\n\t\t\t   const char *buf)\n{\n\tint retval;\n\n\t/*\n\t * top_cpuset.mems_allowed tracks node_stats[N_MEMORY];\n\t * it's read-only\n\t */\n\tif (cs == &top_cpuset) {\n\t\tretval = -EACCES;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * An empty mems_allowed is ok iff there are no tasks in the cpuset.\n\t * Since nodelist_parse() fails on an empty mask, we special case\n\t * that parsing.  The validate_change() call ensures that cpusets\n\t * with tasks have memory.\n\t */\n\tif (!*buf) {\n\t\tnodes_clear(trialcs->mems_allowed);\n\t} else {\n\t\tretval = nodelist_parse(buf, trialcs->mems_allowed);\n\t\tif (retval < 0)\n\t\t\tgoto done;\n\n\t\tif (!nodes_subset(trialcs->mems_allowed,\n\t\t\t\t  top_cpuset.mems_allowed)) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (nodes_equal(cs->mems_allowed, trialcs->mems_allowed)) {\n\t\tretval = 0;\t\t/* Too easy - nothing to do */\n\t\tgoto done;\n\t}\n\tretval = validate_change(cs, trialcs);\n\tif (retval < 0)\n\t\tgoto done;\n\n\tcheck_insane_mems_config(&trialcs->mems_allowed);\n\n\tspin_lock_irq(&callback_lock);\n\tcs->mems_allowed = trialcs->mems_allowed;\n\tspin_unlock_irq(&callback_lock);\n\n\t/* use trialcs->mems_allowed as a temp variable */\n\tupdate_nodemasks_hier(cs, &trialcs->mems_allowed);\ndone:\n\treturn retval;\n}"
  },
  {
    "function_name": "update_nodemasks_hier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1785-1826",
    "snippet": "static void update_nodemasks_hier(struct cpuset *cs, nodemask_t *new_mems)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, cs) {\n\t\tstruct cpuset *parent = parent_cs(cp);\n\n\t\tnodes_and(*new_mems, cp->mems_allowed, parent->effective_mems);\n\n\t\t/*\n\t\t * If it becomes empty, inherit the effective mask of the\n\t\t * parent, which is guaranteed to have some MEMs.\n\t\t */\n\t\tif (is_in_v2_mode() && nodes_empty(*new_mems))\n\t\t\t*new_mems = parent->effective_mems;\n\n\t\t/* Skip the whole subtree if the nodemask remains the same. */\n\t\tif (nodes_equal(*new_mems, cp->effective_mems)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!css_tryget_online(&cp->css))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tspin_lock_irq(&callback_lock);\n\t\tcp->effective_mems = *new_mems;\n\t\tspin_unlock_irq(&callback_lock);\n\n\t\tWARN_ON(!is_in_v2_mode() &&\n\t\t\t!nodes_equal(cp->mems_allowed, cp->effective_mems));\n\n\t\tupdate_tasks_nodemask(cp);\n\n\t\trcu_read_lock();\n\t\tcss_put(&cp->css);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&cp->css"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_tasks_nodemask",
          "args": [
            "cp"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "update_tasks_nodemask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1722-1771",
          "snippet": "static void update_tasks_nodemask(struct cpuset *cs)\n{\n\tstatic nodemask_t newmems;\t/* protected by cpuset_rwsem */\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcpuset_being_rebound = cs;\t\t/* causes mpol_dup() rebind */\n\n\tguarantee_online_mems(cs, &newmems);\n\n\t/*\n\t * The mpol_rebind_mm() call takes mmap_lock, which we couldn't\n\t * take while holding tasklist_lock.  Forks can happen - the\n\t * mpol_dup() cpuset_being_rebound check will catch such forks,\n\t * and rebind their vma mempolicies too.  Because we still hold\n\t * the global cpuset_rwsem, we know that no other rebind effort\n\t * will be contending for the global variable cpuset_being_rebound.\n\t * It's ok if we rebind the same mm twice; mpol_rebind_mm()\n\t * is idempotent.  Also migrate pages in each mm to new nodes.\n\t */\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tstruct mm_struct *mm;\n\t\tbool migrate;\n\n\t\tcpuset_change_task_nodemask(task, &newmems);\n\n\t\tmm = get_task_mm(task);\n\t\tif (!mm)\n\t\t\tcontinue;\n\n\t\tmigrate = is_memory_migrate(cs);\n\n\t\tmpol_rebind_mm(mm, &cs->mems_allowed);\n\t\tif (migrate)\n\t\t\tcpuset_migrate_mm(mm, &cs->old_mems_allowed, &newmems);\n\t\telse\n\t\t\tmmput(mm);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * All the tasks' nodemasks have been updated, update\n\t * cs->old_mems_allowed.\n\t */\n\tcs->old_mems_allowed = newmems;\n\n\t/* We're done rebinding vmas to this cpuset's new mems_allowed. */\n\tcpuset_being_rebound = NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void *cpuset_being_rebound;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void *cpuset_being_rebound;\n\nstatic void update_tasks_nodemask(struct cpuset *cs)\n{\n\tstatic nodemask_t newmems;\t/* protected by cpuset_rwsem */\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcpuset_being_rebound = cs;\t\t/* causes mpol_dup() rebind */\n\n\tguarantee_online_mems(cs, &newmems);\n\n\t/*\n\t * The mpol_rebind_mm() call takes mmap_lock, which we couldn't\n\t * take while holding tasklist_lock.  Forks can happen - the\n\t * mpol_dup() cpuset_being_rebound check will catch such forks,\n\t * and rebind their vma mempolicies too.  Because we still hold\n\t * the global cpuset_rwsem, we know that no other rebind effort\n\t * will be contending for the global variable cpuset_being_rebound.\n\t * It's ok if we rebind the same mm twice; mpol_rebind_mm()\n\t * is idempotent.  Also migrate pages in each mm to new nodes.\n\t */\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tstruct mm_struct *mm;\n\t\tbool migrate;\n\n\t\tcpuset_change_task_nodemask(task, &newmems);\n\n\t\tmm = get_task_mm(task);\n\t\tif (!mm)\n\t\t\tcontinue;\n\n\t\tmigrate = is_memory_migrate(cs);\n\n\t\tmpol_rebind_mm(mm, &cs->mems_allowed);\n\t\tif (migrate)\n\t\t\tcpuset_migrate_mm(mm, &cs->old_mems_allowed, &newmems);\n\t\telse\n\t\t\tmmput(mm);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * All the tasks' nodemasks have been updated, update\n\t * cs->old_mems_allowed.\n\t */\n\tcs->old_mems_allowed = newmems;\n\n\t/* We're done rebinding vmas to this cpuset's new mems_allowed. */\n\tcpuset_being_rebound = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!is_in_v2_mode() &&\n\t\t\t!nodes_equal(cp->mems_allowed, cp->effective_mems)"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_equal",
          "args": [
            "cp->mems_allowed",
            "cp->effective_mems"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_in_v2_mode",
          "args": [],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_v2_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "401-405",
          "snippet": "static inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "&cp->css"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_rightmost_descendant",
          "args": [
            "pos_css"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_equal",
          "args": [
            "*new_mems",
            "cp->effective_mems"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "*new_mems"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_and",
          "args": [
            "*new_mems",
            "cp->mems_allowed",
            "parent->effective_mems"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cp"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_for_each_descendant_pre",
          "args": [
            "cp",
            "pos_css",
            "cs"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic void update_nodemasks_hier(struct cpuset *cs, nodemask_t *new_mems)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, cs) {\n\t\tstruct cpuset *parent = parent_cs(cp);\n\n\t\tnodes_and(*new_mems, cp->mems_allowed, parent->effective_mems);\n\n\t\t/*\n\t\t * If it becomes empty, inherit the effective mask of the\n\t\t * parent, which is guaranteed to have some MEMs.\n\t\t */\n\t\tif (is_in_v2_mode() && nodes_empty(*new_mems))\n\t\t\t*new_mems = parent->effective_mems;\n\n\t\t/* Skip the whole subtree if the nodemask remains the same. */\n\t\tif (nodes_equal(*new_mems, cp->effective_mems)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!css_tryget_online(&cp->css))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tspin_lock_irq(&callback_lock);\n\t\tcp->effective_mems = *new_mems;\n\t\tspin_unlock_irq(&callback_lock);\n\n\t\tWARN_ON(!is_in_v2_mode() &&\n\t\t\t!nodes_equal(cp->mems_allowed, cp->effective_mems));\n\n\t\tupdate_tasks_nodemask(cp);\n\n\t\trcu_read_lock();\n\t\tcss_put(&cp->css);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "update_tasks_nodemask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1722-1771",
    "snippet": "static void update_tasks_nodemask(struct cpuset *cs)\n{\n\tstatic nodemask_t newmems;\t/* protected by cpuset_rwsem */\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcpuset_being_rebound = cs;\t\t/* causes mpol_dup() rebind */\n\n\tguarantee_online_mems(cs, &newmems);\n\n\t/*\n\t * The mpol_rebind_mm() call takes mmap_lock, which we couldn't\n\t * take while holding tasklist_lock.  Forks can happen - the\n\t * mpol_dup() cpuset_being_rebound check will catch such forks,\n\t * and rebind their vma mempolicies too.  Because we still hold\n\t * the global cpuset_rwsem, we know that no other rebind effort\n\t * will be contending for the global variable cpuset_being_rebound.\n\t * It's ok if we rebind the same mm twice; mpol_rebind_mm()\n\t * is idempotent.  Also migrate pages in each mm to new nodes.\n\t */\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tstruct mm_struct *mm;\n\t\tbool migrate;\n\n\t\tcpuset_change_task_nodemask(task, &newmems);\n\n\t\tmm = get_task_mm(task);\n\t\tif (!mm)\n\t\t\tcontinue;\n\n\t\tmigrate = is_memory_migrate(cs);\n\n\t\tmpol_rebind_mm(mm, &cs->mems_allowed);\n\t\tif (migrate)\n\t\t\tcpuset_migrate_mm(mm, &cs->old_mems_allowed, &newmems);\n\t\telse\n\t\t\tmmput(mm);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * All the tasks' nodemasks have been updated, update\n\t * cs->old_mems_allowed.\n\t */\n\tcs->old_mems_allowed = newmems;\n\n\t/* We're done rebinding vmas to this cpuset's new mems_allowed. */\n\tcpuset_being_rebound = NULL;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *cpuset_being_rebound;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1148-1154",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_migrate_mm",
          "args": [
            "mm",
            "&cs->old_mems_allowed",
            "&newmems"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_migrate_mm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1657-1677",
          "snippet": "static void cpuset_migrate_mm(struct mm_struct *mm, const nodemask_t *from,\n\t\t\t\t\t\t\tconst nodemask_t *to)\n{\n\tstruct cpuset_migrate_mm_work *mwork;\n\n\tif (nodes_equal(*from, *to)) {\n\t\tmmput(mm);\n\t\treturn;\n\t}\n\n\tmwork = kzalloc(sizeof(*mwork), GFP_KERNEL);\n\tif (mwork) {\n\t\tmwork->mm = mm;\n\t\tmwork->from = *from;\n\t\tmwork->to = *to;\n\t\tINIT_WORK(&mwork->work, cpuset_migrate_mm_workfn);\n\t\tqueue_work(cpuset_migrate_mm_wq, &mwork->work);\n\t} else {\n\t\tmmput(mm);\n\t}\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *cpuset_migrate_mm_wq;",
            "static void cpuset_hotplug_workfn(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct workqueue_struct *cpuset_migrate_mm_wq;\nstatic void cpuset_hotplug_workfn(struct work_struct *work);\n\nstatic void cpuset_migrate_mm(struct mm_struct *mm, const nodemask_t *from,\n\t\t\t\t\t\t\tconst nodemask_t *to)\n{\n\tstruct cpuset_migrate_mm_work *mwork;\n\n\tif (nodes_equal(*from, *to)) {\n\t\tmmput(mm);\n\t\treturn;\n\t}\n\n\tmwork = kzalloc(sizeof(*mwork), GFP_KERNEL);\n\tif (mwork) {\n\t\tmwork->mm = mm;\n\t\tmwork->from = *from;\n\t\tmwork->to = *to;\n\t\tINIT_WORK(&mwork->work, cpuset_migrate_mm_workfn);\n\t\tqueue_work(cpuset_migrate_mm_wq, &mwork->work);\n\t} else {\n\t\tmmput(mm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpol_rebind_mm",
          "args": [
            "mm",
            "&cs->mems_allowed"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_memory_migrate",
          "args": [
            "cs"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "is_memory_migrate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "256-259",
          "snippet": "static inline int is_memory_migrate(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEMORY_MIGRATE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_memory_migrate(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEMORY_MIGRATE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_mm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1297-1311",
          "snippet": "struct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstruct mm_struct *get_task_mm(struct task_struct *task)\n{\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm) {\n\t\tif (task->flags & PF_KTHREAD)\n\t\t\tmm = NULL;\n\t\telse\n\t\t\tmmget(mm);\n\t}\n\ttask_unlock(task);\n\treturn mm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_change_task_nodemask",
          "args": [
            "task",
            "&newmems"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_change_task_nodemask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1694-1710",
          "snippet": "static void cpuset_change_task_nodemask(struct task_struct *tsk,\n\t\t\t\t\tnodemask_t *newmems)\n{\n\ttask_lock(tsk);\n\n\tlocal_irq_disable();\n\twrite_seqcount_begin(&tsk->mems_allowed_seq);\n\n\tnodes_or(tsk->mems_allowed, tsk->mems_allowed, *newmems);\n\tmpol_rebind_task(tsk, newmems);\n\ttsk->mems_allowed = *newmems;\n\n\twrite_seqcount_end(&tsk->mems_allowed_seq);\n\tlocal_irq_enable();\n\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_change_task_nodemask(struct task_struct *tsk,\n\t\t\t\t\tnodemask_t *newmems)\n{\n\ttask_lock(tsk);\n\n\tlocal_irq_disable();\n\twrite_seqcount_begin(&tsk->mems_allowed_seq);\n\n\tnodes_or(tsk->mems_allowed, tsk->mems_allowed, *newmems);\n\tmpol_rebind_task(tsk, newmems);\n\ttsk->mems_allowed = *newmems;\n\n\twrite_seqcount_end(&tsk->mems_allowed_seq);\n\tlocal_irq_enable();\n\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&cs->css",
            "0",
            "&it"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guarantee_online_mems",
          "args": [
            "cs",
            "&newmems"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "guarantee_online_mems",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "460-465",
          "snippet": "static void guarantee_online_mems(struct cpuset *cs, nodemask_t *pmask)\n{\n\twhile (!nodes_intersects(cs->effective_mems, node_states[N_MEMORY]))\n\t\tcs = parent_cs(cs);\n\tnodes_and(*pmask, cs->effective_mems, node_states[N_MEMORY]);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void guarantee_online_mems(struct cpuset *cs, nodemask_t *pmask)\n{\n\twhile (!nodes_intersects(cs->effective_mems, node_states[N_MEMORY]))\n\t\tcs = parent_cs(cs);\n\tnodes_and(*pmask, cs->effective_mems, node_states[N_MEMORY]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void *cpuset_being_rebound;\n\nstatic void update_tasks_nodemask(struct cpuset *cs)\n{\n\tstatic nodemask_t newmems;\t/* protected by cpuset_rwsem */\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcpuset_being_rebound = cs;\t\t/* causes mpol_dup() rebind */\n\n\tguarantee_online_mems(cs, &newmems);\n\n\t/*\n\t * The mpol_rebind_mm() call takes mmap_lock, which we couldn't\n\t * take while holding tasklist_lock.  Forks can happen - the\n\t * mpol_dup() cpuset_being_rebound check will catch such forks,\n\t * and rebind their vma mempolicies too.  Because we still hold\n\t * the global cpuset_rwsem, we know that no other rebind effort\n\t * will be contending for the global variable cpuset_being_rebound.\n\t * It's ok if we rebind the same mm twice; mpol_rebind_mm()\n\t * is idempotent.  Also migrate pages in each mm to new nodes.\n\t */\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it))) {\n\t\tstruct mm_struct *mm;\n\t\tbool migrate;\n\n\t\tcpuset_change_task_nodemask(task, &newmems);\n\n\t\tmm = get_task_mm(task);\n\t\tif (!mm)\n\t\t\tcontinue;\n\n\t\tmigrate = is_memory_migrate(cs);\n\n\t\tmpol_rebind_mm(mm, &cs->mems_allowed);\n\t\tif (migrate)\n\t\t\tcpuset_migrate_mm(mm, &cs->old_mems_allowed, &newmems);\n\t\telse\n\t\t\tmmput(mm);\n\t}\n\tcss_task_iter_end(&it);\n\n\t/*\n\t * All the tasks' nodemasks have been updated, update\n\t * cs->old_mems_allowed.\n\t */\n\tcs->old_mems_allowed = newmems;\n\n\t/* We're done rebinding vmas to this cpuset's new mems_allowed. */\n\tcpuset_being_rebound = NULL;\n}"
  },
  {
    "function_name": "cpuset_change_task_nodemask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1694-1710",
    "snippet": "static void cpuset_change_task_nodemask(struct task_struct *tsk,\n\t\t\t\t\tnodemask_t *newmems)\n{\n\ttask_lock(tsk);\n\n\tlocal_irq_disable();\n\twrite_seqcount_begin(&tsk->mems_allowed_seq);\n\n\tnodes_or(tsk->mems_allowed, tsk->mems_allowed, *newmems);\n\tmpol_rebind_task(tsk, newmems);\n\ttsk->mems_allowed = *newmems;\n\n\twrite_seqcount_end(&tsk->mems_allowed_seq);\n\tlocal_irq_enable();\n\n\ttask_unlock(tsk);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&tsk->mems_allowed_seq"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpol_rebind_task",
          "args": [
            "tsk",
            "newmems"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_or",
          "args": [
            "tsk->mems_allowed",
            "tsk->mems_allowed",
            "*newmems"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&tsk->mems_allowed_seq"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_change_task_nodemask(struct task_struct *tsk,\n\t\t\t\t\tnodemask_t *newmems)\n{\n\ttask_lock(tsk);\n\n\tlocal_irq_disable();\n\twrite_seqcount_begin(&tsk->mems_allowed_seq);\n\n\tnodes_or(tsk->mems_allowed, tsk->mems_allowed, *newmems);\n\tmpol_rebind_task(tsk, newmems);\n\ttsk->mems_allowed = *newmems;\n\n\twrite_seqcount_end(&tsk->mems_allowed_seq);\n\tlocal_irq_enable();\n\n\ttask_unlock(tsk);\n}"
  },
  {
    "function_name": "cpuset_post_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1679-1682",
    "snippet": "static void cpuset_post_attach(void)\n{\n\tflush_workqueue(cpuset_migrate_mm_wq);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *cpuset_migrate_mm_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "cpuset_migrate_mm_wq"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "flush_workqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "2815-2963",
          "snippet": "void flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (READ_ONCE(wq->first_flusher) != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\tWRITE_ONCE(wq->first_flusher, NULL);\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct workqueue_struct *cpuset_migrate_mm_wq;\n\nstatic void cpuset_post_attach(void)\n{\n\tflush_workqueue(cpuset_migrate_mm_wq);\n}"
  },
  {
    "function_name": "cpuset_migrate_mm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1657-1677",
    "snippet": "static void cpuset_migrate_mm(struct mm_struct *mm, const nodemask_t *from,\n\t\t\t\t\t\t\tconst nodemask_t *to)\n{\n\tstruct cpuset_migrate_mm_work *mwork;\n\n\tif (nodes_equal(*from, *to)) {\n\t\tmmput(mm);\n\t\treturn;\n\t}\n\n\tmwork = kzalloc(sizeof(*mwork), GFP_KERNEL);\n\tif (mwork) {\n\t\tmwork->mm = mm;\n\t\tmwork->from = *from;\n\t\tmwork->to = *to;\n\t\tINIT_WORK(&mwork->work, cpuset_migrate_mm_workfn);\n\t\tqueue_work(cpuset_migrate_mm_wq, &mwork->work);\n\t} else {\n\t\tmmput(mm);\n\t}\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct workqueue_struct *cpuset_migrate_mm_wq;",
      "static void cpuset_hotplug_workfn(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1148-1154",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "cpuset_migrate_mm_wq",
            "&mwork->work"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&mwork->work",
            "cpuset_migrate_mm_workfn"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*mwork)",
            "GFP_KERNEL"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_equal",
          "args": [
            "*from",
            "*to"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct workqueue_struct *cpuset_migrate_mm_wq;\nstatic void cpuset_hotplug_workfn(struct work_struct *work);\n\nstatic void cpuset_migrate_mm(struct mm_struct *mm, const nodemask_t *from,\n\t\t\t\t\t\t\tconst nodemask_t *to)\n{\n\tstruct cpuset_migrate_mm_work *mwork;\n\n\tif (nodes_equal(*from, *to)) {\n\t\tmmput(mm);\n\t\treturn;\n\t}\n\n\tmwork = kzalloc(sizeof(*mwork), GFP_KERNEL);\n\tif (mwork) {\n\t\tmwork->mm = mm;\n\t\tmwork->from = *from;\n\t\tmwork->to = *to;\n\t\tINIT_WORK(&mwork->work, cpuset_migrate_mm_workfn);\n\t\tqueue_work(cpuset_migrate_mm_wq, &mwork->work);\n\t} else {\n\t\tmmput(mm);\n\t}\n}"
  },
  {
    "function_name": "cpuset_migrate_mm_workfn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1646-1655",
    "snippet": "static void cpuset_migrate_mm_workfn(struct work_struct *work)\n{\n\tstruct cpuset_migrate_mm_work *mwork =\n\t\tcontainer_of(work, struct cpuset_migrate_mm_work, work);\n\n\t/* on a wq worker, no need to worry about %current's mems_allowed */\n\tdo_migrate_pages(mwork->mm, &mwork->from, &mwork->to, MPOL_MF_MOVE_ALL);\n\tmmput(mwork->mm);\n\tkfree(mwork);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cpuset_hotplug_workfn(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "mwork"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mwork->mm"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "mmput_async",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1148-1154",
          "snippet": "void mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid mmput_async(struct mm_struct *mm)\n{\n\tif (atomic_dec_and_test(&mm->mm_users)) {\n\t\tINIT_WORK(&mm->async_put_work, mmput_async_fn);\n\t\tschedule_work(&mm->async_put_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_migrate_pages",
          "args": [
            "mwork->mm",
            "&mwork->from",
            "&mwork->to",
            "MPOL_MF_MOVE_ALL"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structcpuset_migrate_mm_work",
            "work"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_hotplug_workfn(struct work_struct *work);\n\nstatic void cpuset_migrate_mm_workfn(struct work_struct *work)\n{\n\tstruct cpuset_migrate_mm_work *mwork =\n\t\tcontainer_of(work, struct cpuset_migrate_mm_work, work);\n\n\t/* on a wq worker, no need to worry about %current's mems_allowed */\n\tdo_migrate_pages(mwork->mm, &mwork->from, &mwork->to, MPOL_MF_MOVE_ALL);\n\tmmput(mwork->mm);\n\tkfree(mwork);\n}"
  },
  {
    "function_name": "update_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1548-1629",
    "snippet": "static int update_cpumask(struct cpuset *cs, struct cpuset *trialcs,\n\t\t\t  const char *buf)\n{\n\tint retval;\n\tstruct tmpmasks tmp;\n\n\t/* top_cpuset.cpus_allowed tracks cpu_online_mask; it's read-only */\n\tif (cs == &top_cpuset)\n\t\treturn -EACCES;\n\n\t/*\n\t * An empty cpus_allowed is ok only if the cpuset has no tasks.\n\t * Since cpulist_parse() fails on an empty mask, we special case\n\t * that parsing.  The validate_change() call ensures that cpusets\n\t * with tasks have cpus.\n\t */\n\tif (!*buf) {\n\t\tcpumask_clear(trialcs->cpus_allowed);\n\t} else {\n\t\tretval = cpulist_parse(buf, trialcs->cpus_allowed);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tif (!cpumask_subset(trialcs->cpus_allowed,\n\t\t\t\t    top_cpuset.cpus_allowed))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Nothing to do if the cpus didn't change */\n\tif (cpumask_equal(cs->cpus_allowed, trialcs->cpus_allowed))\n\t\treturn 0;\n\n\tretval = validate_change(cs, trialcs);\n\tif (retval < 0)\n\t\treturn retval;\n\n#ifdef CONFIG_CPUMASK_OFFSTACK\n\t/*\n\t * Use the cpumasks in trialcs for tmpmasks when they are pointers\n\t * to allocated cpumasks.\n\t */\n\ttmp.addmask  = trialcs->subparts_cpus;\n\ttmp.delmask  = trialcs->effective_cpus;\n\ttmp.new_cpus = trialcs->cpus_allowed;\n#endif\n\n\tif (cs->partition_root_state) {\n\t\t/* Cpumask of a partition root cannot be empty */\n\t\tif (cpumask_empty(trialcs->cpus_allowed))\n\t\t\treturn -EINVAL;\n\t\tif (update_parent_subparts_cpumask(cs, partcmd_update,\n\t\t\t\t\ttrialcs->cpus_allowed, &tmp) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->cpus_allowed, trialcs->cpus_allowed);\n\n\t/*\n\t * Make sure that subparts_cpus is a subset of cpus_allowed.\n\t */\n\tif (cs->nr_subparts_cpus) {\n\t\tcpumask_andnot(cs->subparts_cpus, cs->subparts_cpus,\n\t\t\t       cs->cpus_allowed);\n\t\tcs->nr_subparts_cpus = cpumask_weight(cs->subparts_cpus);\n\t}\n\tspin_unlock_irq(&callback_lock);\n\n\tupdate_cpumasks_hier(cs, &tmp);\n\n\tif (cs->partition_root_state) {\n\t\tstruct cpuset *parent = parent_cs(cs);\n\n\t\t/*\n\t\t * For partition root, update the cpumasks of sibling\n\t\t * cpusets if they use parent's effective_cpus.\n\t\t */\n\t\tif (parent->child_ecpus_count)\n\t\t\tupdate_sibling_cpumasks(parent, cs, &tmp);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_sibling_cpumasks",
          "args": [
            "parent",
            "cs",
            "&tmp"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "update_sibling_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1519-1540",
          "snippet": "static void update_sibling_cpumasks(struct cpuset *parent, struct cpuset *cs,\n\t\t\t\t    struct tmpmasks *tmp)\n{\n\tstruct cpuset *sibling;\n\tstruct cgroup_subsys_state *pos_css;\n\n\t/*\n\t * Check all its siblings and call update_cpumasks_hier()\n\t * if their use_parent_ecpus flag is set in order for them\n\t * to use the right effective_cpus value.\n\t */\n\trcu_read_lock();\n\tcpuset_for_each_child(sibling, pos_css, parent) {\n\t\tif (sibling == cs)\n\t\t\tcontinue;\n\t\tif (!sibling->use_parent_ecpus)\n\t\t\tcontinue;\n\n\t\tupdate_cpumasks_hier(sibling, tmp);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_sibling_cpumasks(struct cpuset *parent, struct cpuset *cs,\n\t\t\t\t    struct tmpmasks *tmp)\n{\n\tstruct cpuset *sibling;\n\tstruct cgroup_subsys_state *pos_css;\n\n\t/*\n\t * Check all its siblings and call update_cpumasks_hier()\n\t * if their use_parent_ecpus flag is set in order for them\n\t * to use the right effective_cpus value.\n\t */\n\trcu_read_lock();\n\tcpuset_for_each_child(sibling, pos_css, parent) {\n\t\tif (sibling == cs)\n\t\t\tcontinue;\n\t\tif (!sibling->use_parent_ecpus)\n\t\t\tcontinue;\n\n\t\tupdate_cpumasks_hier(sibling, tmp);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cs"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cpumasks_hier",
          "args": [
            "cs",
            "&tmp"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "update_cpumasks_hier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1364-1511",
          "snippet": "static void update_cpumasks_hier(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\tbool need_rebuild_sched_domains = false;\n\tint old_prs, new_prs;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, cs) {\n\t\tstruct cpuset *parent = parent_cs(cp);\n\n\t\tcompute_effective_cpumask(tmp->new_cpus, cp, parent);\n\n\t\t/*\n\t\t * If it becomes empty, inherit the effective mask of the\n\t\t * parent, which is guaranteed to have some CPUs.\n\t\t */\n\t\tif (is_in_v2_mode() && cpumask_empty(tmp->new_cpus)) {\n\t\t\tcpumask_copy(tmp->new_cpus, parent->effective_cpus);\n\t\t\tif (!cp->use_parent_ecpus) {\n\t\t\t\tcp->use_parent_ecpus = true;\n\t\t\t\tparent->child_ecpus_count++;\n\t\t\t}\n\t\t} else if (cp->use_parent_ecpus) {\n\t\t\tcp->use_parent_ecpus = false;\n\t\t\tWARN_ON_ONCE(!parent->child_ecpus_count);\n\t\t\tparent->child_ecpus_count--;\n\t\t}\n\n\t\t/*\n\t\t * Skip the whole subtree if the cpumask remains the same\n\t\t * and has no partition root state.\n\t\t */\n\t\tif (!cp->partition_root_state &&\n\t\t    cpumask_equal(tmp->new_cpus, cp->effective_cpus)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * update_parent_subparts_cpumask() should have been called\n\t\t * for cs already in update_cpumask(). We should also call\n\t\t * update_tasks_cpumask() again for tasks in the parent\n\t\t * cpuset if the parent's subparts_cpus changes.\n\t\t */\n\t\told_prs = new_prs = cp->partition_root_state;\n\t\tif ((cp != cs) && old_prs) {\n\t\t\tswitch (parent->partition_root_state) {\n\t\t\tcase PRS_DISABLED:\n\t\t\t\t/*\n\t\t\t\t * If parent is not a partition root or an\n\t\t\t\t * invalid partition root, clear its state\n\t\t\t\t * and its CS_CPU_EXCLUSIVE flag.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(cp->partition_root_state\n\t\t\t\t\t     != PRS_ERROR);\n\t\t\t\tnew_prs = PRS_DISABLED;\n\n\t\t\t\t/*\n\t\t\t\t * clear_bit() is an atomic operation and\n\t\t\t\t * readers aren't interested in the state\n\t\t\t\t * of CS_CPU_EXCLUSIVE anyway. So we can\n\t\t\t\t * just update the flag without holding\n\t\t\t\t * the callback_lock.\n\t\t\t\t */\n\t\t\t\tclear_bit(CS_CPU_EXCLUSIVE, &cp->flags);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ENABLED:\n\t\t\t\tif (update_parent_subparts_cpumask(cp, partcmd_update, NULL, tmp))\n\t\t\t\t\tupdate_tasks_cpumask(parent);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ERROR:\n\t\t\t\t/*\n\t\t\t\t * When parent is invalid, it has to be too.\n\t\t\t\t */\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!css_tryget_online(&cp->css))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tspin_lock_irq(&callback_lock);\n\n\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\tif (cp->nr_subparts_cpus && (new_prs != PRS_ENABLED)) {\n\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t} else if (cp->nr_subparts_cpus) {\n\t\t\t/*\n\t\t\t * Make sure that effective_cpus & subparts_cpus\n\t\t\t * are mutually exclusive.\n\t\t\t *\n\t\t\t * In the unlikely event that effective_cpus\n\t\t\t * becomes empty. we clear cp->nr_subparts_cpus and\n\t\t\t * let its child partition roots to compete for\n\t\t\t * CPUs again.\n\t\t\t */\n\t\t\tcpumask_andnot(cp->effective_cpus, cp->effective_cpus,\n\t\t\t\t       cp->subparts_cpus);\n\t\t\tif (cpumask_empty(cp->effective_cpus)) {\n\t\t\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\t} else if (!cpumask_subset(cp->subparts_cpus,\n\t\t\t\t\t\t   tmp->new_cpus)) {\n\t\t\t\tcpumask_andnot(cp->subparts_cpus,\n\t\t\t\t\tcp->subparts_cpus, tmp->new_cpus);\n\t\t\t\tcp->nr_subparts_cpus\n\t\t\t\t\t= cpumask_weight(cp->subparts_cpus);\n\t\t\t}\n\t\t}\n\n\t\tif (new_prs != old_prs)\n\t\t\tcp->partition_root_state = new_prs;\n\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cp, old_prs, new_prs);\n\n\t\tWARN_ON(!is_in_v2_mode() &&\n\t\t\t!cpumask_equal(cp->cpus_allowed, cp->effective_cpus));\n\n\t\tupdate_tasks_cpumask(cp);\n\n\t\t/*\n\t\t * On legacy hierarchy, if the effective cpumask of any non-\n\t\t * empty cpuset is changed, we need to rebuild sched domains.\n\t\t * On default hierarchy, the cpuset needs to be a partition\n\t\t * root as well.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    is_sched_load_balance(cp) &&\n\t\t   (!cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t\t    is_partition_root(cp)))\n\t\t\tneed_rebuild_sched_domains = true;\n\n\t\trcu_read_lock();\n\t\tcss_put(&cp->css);\n\t}\n\trcu_read_unlock();\n\n\tif (need_rebuild_sched_domains)\n\t\trebuild_sched_domains_locked();\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define PRS_ERROR\t\t-1",
            "#define PRS_ENABLED\t\t1",
            "#define PRS_DISABLED\t\t0"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);",
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n#define PRS_ENABLED\t\t1\n#define PRS_DISABLED\t\t0\n\nstatic DEFINE_SPINLOCK(callback_lock);\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic void update_cpumasks_hier(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\tbool need_rebuild_sched_domains = false;\n\tint old_prs, new_prs;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, cs) {\n\t\tstruct cpuset *parent = parent_cs(cp);\n\n\t\tcompute_effective_cpumask(tmp->new_cpus, cp, parent);\n\n\t\t/*\n\t\t * If it becomes empty, inherit the effective mask of the\n\t\t * parent, which is guaranteed to have some CPUs.\n\t\t */\n\t\tif (is_in_v2_mode() && cpumask_empty(tmp->new_cpus)) {\n\t\t\tcpumask_copy(tmp->new_cpus, parent->effective_cpus);\n\t\t\tif (!cp->use_parent_ecpus) {\n\t\t\t\tcp->use_parent_ecpus = true;\n\t\t\t\tparent->child_ecpus_count++;\n\t\t\t}\n\t\t} else if (cp->use_parent_ecpus) {\n\t\t\tcp->use_parent_ecpus = false;\n\t\t\tWARN_ON_ONCE(!parent->child_ecpus_count);\n\t\t\tparent->child_ecpus_count--;\n\t\t}\n\n\t\t/*\n\t\t * Skip the whole subtree if the cpumask remains the same\n\t\t * and has no partition root state.\n\t\t */\n\t\tif (!cp->partition_root_state &&\n\t\t    cpumask_equal(tmp->new_cpus, cp->effective_cpus)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * update_parent_subparts_cpumask() should have been called\n\t\t * for cs already in update_cpumask(). We should also call\n\t\t * update_tasks_cpumask() again for tasks in the parent\n\t\t * cpuset if the parent's subparts_cpus changes.\n\t\t */\n\t\told_prs = new_prs = cp->partition_root_state;\n\t\tif ((cp != cs) && old_prs) {\n\t\t\tswitch (parent->partition_root_state) {\n\t\t\tcase PRS_DISABLED:\n\t\t\t\t/*\n\t\t\t\t * If parent is not a partition root or an\n\t\t\t\t * invalid partition root, clear its state\n\t\t\t\t * and its CS_CPU_EXCLUSIVE flag.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(cp->partition_root_state\n\t\t\t\t\t     != PRS_ERROR);\n\t\t\t\tnew_prs = PRS_DISABLED;\n\n\t\t\t\t/*\n\t\t\t\t * clear_bit() is an atomic operation and\n\t\t\t\t * readers aren't interested in the state\n\t\t\t\t * of CS_CPU_EXCLUSIVE anyway. So we can\n\t\t\t\t * just update the flag without holding\n\t\t\t\t * the callback_lock.\n\t\t\t\t */\n\t\t\t\tclear_bit(CS_CPU_EXCLUSIVE, &cp->flags);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ENABLED:\n\t\t\t\tif (update_parent_subparts_cpumask(cp, partcmd_update, NULL, tmp))\n\t\t\t\t\tupdate_tasks_cpumask(parent);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ERROR:\n\t\t\t\t/*\n\t\t\t\t * When parent is invalid, it has to be too.\n\t\t\t\t */\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!css_tryget_online(&cp->css))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tspin_lock_irq(&callback_lock);\n\n\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\tif (cp->nr_subparts_cpus && (new_prs != PRS_ENABLED)) {\n\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t} else if (cp->nr_subparts_cpus) {\n\t\t\t/*\n\t\t\t * Make sure that effective_cpus & subparts_cpus\n\t\t\t * are mutually exclusive.\n\t\t\t *\n\t\t\t * In the unlikely event that effective_cpus\n\t\t\t * becomes empty. we clear cp->nr_subparts_cpus and\n\t\t\t * let its child partition roots to compete for\n\t\t\t * CPUs again.\n\t\t\t */\n\t\t\tcpumask_andnot(cp->effective_cpus, cp->effective_cpus,\n\t\t\t\t       cp->subparts_cpus);\n\t\t\tif (cpumask_empty(cp->effective_cpus)) {\n\t\t\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\t} else if (!cpumask_subset(cp->subparts_cpus,\n\t\t\t\t\t\t   tmp->new_cpus)) {\n\t\t\t\tcpumask_andnot(cp->subparts_cpus,\n\t\t\t\t\tcp->subparts_cpus, tmp->new_cpus);\n\t\t\t\tcp->nr_subparts_cpus\n\t\t\t\t\t= cpumask_weight(cp->subparts_cpus);\n\t\t\t}\n\t\t}\n\n\t\tif (new_prs != old_prs)\n\t\t\tcp->partition_root_state = new_prs;\n\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cp, old_prs, new_prs);\n\n\t\tWARN_ON(!is_in_v2_mode() &&\n\t\t\t!cpumask_equal(cp->cpus_allowed, cp->effective_cpus));\n\n\t\tupdate_tasks_cpumask(cp);\n\n\t\t/*\n\t\t * On legacy hierarchy, if the effective cpumask of any non-\n\t\t * empty cpuset is changed, we need to rebuild sched domains.\n\t\t * On default hierarchy, the cpuset needs to be a partition\n\t\t * root as well.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    is_sched_load_balance(cp) &&\n\t\t   (!cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t\t    is_partition_root(cp)))\n\t\t\tneed_rebuild_sched_domains = true;\n\n\t\trcu_read_lock();\n\t\tcss_put(&cp->css);\n\t}\n\trcu_read_unlock();\n\n\tif (need_rebuild_sched_domains)\n\t\trebuild_sched_domains_locked();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cs->subparts_cpus"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "cs->subparts_cpus",
            "cs->subparts_cpus",
            "cs->cpus_allowed"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cs->cpus_allowed",
            "trialcs->cpus_allowed"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_parent_subparts_cpumask",
          "args": [
            "cs",
            "partcmd_update",
            "trialcs->cpus_allowed",
            "&tmp"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "update_parent_subparts_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1182-1350",
          "snippet": "static int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,\n\t\t\t\t\t  struct cpumask *newmask,\n\t\t\t\t\t  struct tmpmasks *tmp)\n{\n\tstruct cpuset *parent = parent_cs(cpuset);\n\tint adding;\t/* Moving cpus from effective_cpus to subparts_cpus */\n\tint deleting;\t/* Moving cpus from subparts_cpus to effective_cpus */\n\tint old_prs, new_prs;\n\tbool part_error = false;\t/* Partition error? */\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * The parent must be a partition root.\n\t * The new cpumask, if present, or the current cpus_allowed must\n\t * not be empty.\n\t */\n\tif (!is_partition_root(parent) ||\n\t   (newmask && cpumask_empty(newmask)) ||\n\t   (!newmask && cpumask_empty(cpuset->cpus_allowed)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Enabling/disabling partition root is not allowed if there are\n\t * online children.\n\t */\n\tif ((cmd != partcmd_update) && css_has_online_children(&cpuset->css))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Enabling partition root is not allowed if not all the CPUs\n\t * can be granted from parent's effective_cpus or at least one\n\t * CPU will be left after that.\n\t */\n\tif ((cmd == partcmd_enable) &&\n\t   (!cpumask_subset(cpuset->cpus_allowed, parent->effective_cpus) ||\n\t     cpumask_equal(cpuset->cpus_allowed, parent->effective_cpus)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * A cpumask update cannot make parent's effective_cpus become empty.\n\t */\n\tadding = deleting = false;\n\told_prs = new_prs = cpuset->partition_root_state;\n\tif (cmd == partcmd_enable) {\n\t\tcpumask_copy(tmp->addmask, cpuset->cpus_allowed);\n\t\tadding = true;\n\t} else if (cmd == partcmd_disable) {\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t} else if (newmask) {\n\t\t/*\n\t\t * partcmd_update with newmask:\n\t\t *\n\t\t * delmask = cpus_allowed & ~newmask & parent->subparts_cpus\n\t\t * addmask = newmask & parent->effective_cpus\n\t\t *\t\t     & ~parent->subparts_cpus\n\t\t */\n\t\tcpumask_andnot(tmp->delmask, cpuset->cpus_allowed, newmask);\n\t\tdeleting = cpumask_and(tmp->delmask, tmp->delmask,\n\t\t\t\t       parent->subparts_cpus);\n\n\t\tcpumask_and(tmp->addmask, newmask, parent->effective_cpus);\n\t\tadding = cpumask_andnot(tmp->addmask, tmp->addmask,\n\t\t\t\t\tparent->subparts_cpus);\n\t\t/*\n\t\t * Return error if the new effective_cpus could become empty.\n\t\t */\n\t\tif (adding &&\n\t\t    cpumask_equal(parent->effective_cpus, tmp->addmask)) {\n\t\t\tif (!deleting)\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * As some of the CPUs in subparts_cpus might have\n\t\t\t * been offlined, we need to compute the real delmask\n\t\t\t * to confirm that.\n\t\t\t */\n\t\t\tif (!cpumask_and(tmp->addmask, tmp->delmask,\n\t\t\t\t\t cpu_active_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tcpumask_copy(tmp->addmask, parent->effective_cpus);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * partcmd_update w/o newmask:\n\t\t *\n\t\t * addmask = cpus_allowed & parent->effective_cpus\n\t\t *\n\t\t * Note that parent's subparts_cpus may have been\n\t\t * pre-shrunk in case there is a change in the cpu list.\n\t\t * So no deletion is needed.\n\t\t */\n\t\tadding = cpumask_and(tmp->addmask, cpuset->cpus_allowed,\n\t\t\t\t     parent->effective_cpus);\n\t\tpart_error = cpumask_equal(tmp->addmask,\n\t\t\t\t\t   parent->effective_cpus);\n\t}\n\n\tif (cmd == partcmd_update) {\n\t\tint prev_prs = cpuset->partition_root_state;\n\n\t\t/*\n\t\t * Check for possible transition between PRS_ENABLED\n\t\t * and PRS_ERROR.\n\t\t */\n\t\tswitch (cpuset->partition_root_state) {\n\t\tcase PRS_ENABLED:\n\t\t\tif (part_error)\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\tbreak;\n\t\tcase PRS_ERROR:\n\t\t\tif (!part_error)\n\t\t\t\tnew_prs = PRS_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Set part_error if previously in invalid state.\n\t\t */\n\t\tpart_error = (prev_prs == PRS_ERROR);\n\t}\n\n\tif (!part_error && (new_prs == PRS_ERROR))\n\t\treturn 0;\t/* Nothing need to be done */\n\n\tif (new_prs == PRS_ERROR) {\n\t\t/*\n\t\t * Remove all its cpus from parent's subparts_cpus.\n\t\t */\n\t\tadding = false;\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t}\n\n\tif (!adding && !deleting && (new_prs == old_prs))\n\t\treturn 0;\n\n\t/*\n\t * Change the parent's subparts_cpus.\n\t * Newly added CPUs will be removed from effective_cpus and\n\t * newly deleted ones will be added back to effective_cpus.\n\t */\n\tspin_lock_irq(&callback_lock);\n\tif (adding) {\n\t\tcpumask_or(parent->subparts_cpus,\n\t\t\t   parent->subparts_cpus, tmp->addmask);\n\t\tcpumask_andnot(parent->effective_cpus,\n\t\t\t       parent->effective_cpus, tmp->addmask);\n\t}\n\tif (deleting) {\n\t\tcpumask_andnot(parent->subparts_cpus,\n\t\t\t       parent->subparts_cpus, tmp->delmask);\n\t\t/*\n\t\t * Some of the CPUs in subparts_cpus might have been offlined.\n\t\t */\n\t\tcpumask_and(tmp->delmask, tmp->delmask, cpu_active_mask);\n\t\tcpumask_or(parent->effective_cpus,\n\t\t\t   parent->effective_cpus, tmp->delmask);\n\t}\n\n\tparent->nr_subparts_cpus = cpumask_weight(parent->subparts_cpus);\n\n\tif (old_prs != new_prs)\n\t\tcpuset->partition_root_state = new_prs;\n\n\tspin_unlock_irq(&callback_lock);\n\tnotify_partition_change(cpuset, old_prs, new_prs);\n\n\treturn cmd == partcmd_update;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define PRS_ERROR\t\t-1",
            "#define PRS_ENABLED\t\t1"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n#define PRS_ENABLED\t\t1\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,\n\t\t\t\t\t  struct cpumask *newmask,\n\t\t\t\t\t  struct tmpmasks *tmp)\n{\n\tstruct cpuset *parent = parent_cs(cpuset);\n\tint adding;\t/* Moving cpus from effective_cpus to subparts_cpus */\n\tint deleting;\t/* Moving cpus from subparts_cpus to effective_cpus */\n\tint old_prs, new_prs;\n\tbool part_error = false;\t/* Partition error? */\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * The parent must be a partition root.\n\t * The new cpumask, if present, or the current cpus_allowed must\n\t * not be empty.\n\t */\n\tif (!is_partition_root(parent) ||\n\t   (newmask && cpumask_empty(newmask)) ||\n\t   (!newmask && cpumask_empty(cpuset->cpus_allowed)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Enabling/disabling partition root is not allowed if there are\n\t * online children.\n\t */\n\tif ((cmd != partcmd_update) && css_has_online_children(&cpuset->css))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Enabling partition root is not allowed if not all the CPUs\n\t * can be granted from parent's effective_cpus or at least one\n\t * CPU will be left after that.\n\t */\n\tif ((cmd == partcmd_enable) &&\n\t   (!cpumask_subset(cpuset->cpus_allowed, parent->effective_cpus) ||\n\t     cpumask_equal(cpuset->cpus_allowed, parent->effective_cpus)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * A cpumask update cannot make parent's effective_cpus become empty.\n\t */\n\tadding = deleting = false;\n\told_prs = new_prs = cpuset->partition_root_state;\n\tif (cmd == partcmd_enable) {\n\t\tcpumask_copy(tmp->addmask, cpuset->cpus_allowed);\n\t\tadding = true;\n\t} else if (cmd == partcmd_disable) {\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t} else if (newmask) {\n\t\t/*\n\t\t * partcmd_update with newmask:\n\t\t *\n\t\t * delmask = cpus_allowed & ~newmask & parent->subparts_cpus\n\t\t * addmask = newmask & parent->effective_cpus\n\t\t *\t\t     & ~parent->subparts_cpus\n\t\t */\n\t\tcpumask_andnot(tmp->delmask, cpuset->cpus_allowed, newmask);\n\t\tdeleting = cpumask_and(tmp->delmask, tmp->delmask,\n\t\t\t\t       parent->subparts_cpus);\n\n\t\tcpumask_and(tmp->addmask, newmask, parent->effective_cpus);\n\t\tadding = cpumask_andnot(tmp->addmask, tmp->addmask,\n\t\t\t\t\tparent->subparts_cpus);\n\t\t/*\n\t\t * Return error if the new effective_cpus could become empty.\n\t\t */\n\t\tif (adding &&\n\t\t    cpumask_equal(parent->effective_cpus, tmp->addmask)) {\n\t\t\tif (!deleting)\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * As some of the CPUs in subparts_cpus might have\n\t\t\t * been offlined, we need to compute the real delmask\n\t\t\t * to confirm that.\n\t\t\t */\n\t\t\tif (!cpumask_and(tmp->addmask, tmp->delmask,\n\t\t\t\t\t cpu_active_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tcpumask_copy(tmp->addmask, parent->effective_cpus);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * partcmd_update w/o newmask:\n\t\t *\n\t\t * addmask = cpus_allowed & parent->effective_cpus\n\t\t *\n\t\t * Note that parent's subparts_cpus may have been\n\t\t * pre-shrunk in case there is a change in the cpu list.\n\t\t * So no deletion is needed.\n\t\t */\n\t\tadding = cpumask_and(tmp->addmask, cpuset->cpus_allowed,\n\t\t\t\t     parent->effective_cpus);\n\t\tpart_error = cpumask_equal(tmp->addmask,\n\t\t\t\t\t   parent->effective_cpus);\n\t}\n\n\tif (cmd == partcmd_update) {\n\t\tint prev_prs = cpuset->partition_root_state;\n\n\t\t/*\n\t\t * Check for possible transition between PRS_ENABLED\n\t\t * and PRS_ERROR.\n\t\t */\n\t\tswitch (cpuset->partition_root_state) {\n\t\tcase PRS_ENABLED:\n\t\t\tif (part_error)\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\tbreak;\n\t\tcase PRS_ERROR:\n\t\t\tif (!part_error)\n\t\t\t\tnew_prs = PRS_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Set part_error if previously in invalid state.\n\t\t */\n\t\tpart_error = (prev_prs == PRS_ERROR);\n\t}\n\n\tif (!part_error && (new_prs == PRS_ERROR))\n\t\treturn 0;\t/* Nothing need to be done */\n\n\tif (new_prs == PRS_ERROR) {\n\t\t/*\n\t\t * Remove all its cpus from parent's subparts_cpus.\n\t\t */\n\t\tadding = false;\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t}\n\n\tif (!adding && !deleting && (new_prs == old_prs))\n\t\treturn 0;\n\n\t/*\n\t * Change the parent's subparts_cpus.\n\t * Newly added CPUs will be removed from effective_cpus and\n\t * newly deleted ones will be added back to effective_cpus.\n\t */\n\tspin_lock_irq(&callback_lock);\n\tif (adding) {\n\t\tcpumask_or(parent->subparts_cpus,\n\t\t\t   parent->subparts_cpus, tmp->addmask);\n\t\tcpumask_andnot(parent->effective_cpus,\n\t\t\t       parent->effective_cpus, tmp->addmask);\n\t}\n\tif (deleting) {\n\t\tcpumask_andnot(parent->subparts_cpus,\n\t\t\t       parent->subparts_cpus, tmp->delmask);\n\t\t/*\n\t\t * Some of the CPUs in subparts_cpus might have been offlined.\n\t\t */\n\t\tcpumask_and(tmp->delmask, tmp->delmask, cpu_active_mask);\n\t\tcpumask_or(parent->effective_cpus,\n\t\t\t   parent->effective_cpus, tmp->delmask);\n\t}\n\n\tparent->nr_subparts_cpus = cpumask_weight(parent->subparts_cpus);\n\n\tif (old_prs != new_prs)\n\t\tcpuset->partition_root_state = new_prs;\n\n\tspin_unlock_irq(&callback_lock);\n\tnotify_partition_change(cpuset, old_prs, new_prs);\n\n\treturn cmd == partcmd_update;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "trialcs->cpus_allowed"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_change",
          "args": [
            "cs",
            "trialcs"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "validate_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "613-675",
          "snippet": "static int validate_change(struct cpuset *cur, struct cpuset *trial)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *c, *par;\n\tint ret;\n\n\t/* The checks don't apply to root cpuset */\n\tif (cur == &top_cpuset)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpar = parent_cs(cur);\n\n\t/* On legacy hierarchy, we must be a subset of our parent cpuset. */\n\tret = -EACCES;\n\tif (!is_in_v2_mode() && !is_cpuset_subset(trial, par))\n\t\tgoto out;\n\n\t/*\n\t * If either I or some sibling (!= me) is exclusive, we can't\n\t * overlap\n\t */\n\tret = -EINVAL;\n\tcpuset_for_each_child(c, css, par) {\n\t\tif ((is_cpu_exclusive(trial) || is_cpu_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    cpumask_intersects(trial->cpus_allowed, c->cpus_allowed))\n\t\t\tgoto out;\n\t\tif ((is_mem_exclusive(trial) || is_mem_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    nodes_intersects(trial->mems_allowed, c->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Cpusets with tasks - existing or newly being attached - can't\n\t * be changed to have empty cpus_allowed or mems_allowed.\n\t */\n\tret = -ENOSPC;\n\tif ((cgroup_is_populated(cur->css.cgroup) || cur->attach_in_progress)) {\n\t\tif (!cpumask_empty(cur->cpus_allowed) &&\n\t\t    cpumask_empty(trial->cpus_allowed))\n\t\t\tgoto out;\n\t\tif (!nodes_empty(cur->mems_allowed) &&\n\t\t    nodes_empty(trial->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We can't shrink if we won't have enough room for SCHED_DEADLINE\n\t * tasks.\n\t */\n\tret = -EBUSY;\n\tif (is_cpu_exclusive(cur) &&\n\t    !cpuset_cpumask_can_shrink(cur->cpus_allowed,\n\t\t\t\t       trial->cpus_allowed))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\n\nstatic int validate_change(struct cpuset *cur, struct cpuset *trial)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *c, *par;\n\tint ret;\n\n\t/* The checks don't apply to root cpuset */\n\tif (cur == &top_cpuset)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpar = parent_cs(cur);\n\n\t/* On legacy hierarchy, we must be a subset of our parent cpuset. */\n\tret = -EACCES;\n\tif (!is_in_v2_mode() && !is_cpuset_subset(trial, par))\n\t\tgoto out;\n\n\t/*\n\t * If either I or some sibling (!= me) is exclusive, we can't\n\t * overlap\n\t */\n\tret = -EINVAL;\n\tcpuset_for_each_child(c, css, par) {\n\t\tif ((is_cpu_exclusive(trial) || is_cpu_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    cpumask_intersects(trial->cpus_allowed, c->cpus_allowed))\n\t\t\tgoto out;\n\t\tif ((is_mem_exclusive(trial) || is_mem_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    nodes_intersects(trial->mems_allowed, c->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Cpusets with tasks - existing or newly being attached - can't\n\t * be changed to have empty cpus_allowed or mems_allowed.\n\t */\n\tret = -ENOSPC;\n\tif ((cgroup_is_populated(cur->css.cgroup) || cur->attach_in_progress)) {\n\t\tif (!cpumask_empty(cur->cpus_allowed) &&\n\t\t    cpumask_empty(trial->cpus_allowed))\n\t\t\tgoto out;\n\t\tif (!nodes_empty(cur->mems_allowed) &&\n\t\t    nodes_empty(trial->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We can't shrink if we won't have enough room for SCHED_DEADLINE\n\t * tasks.\n\t */\n\tret = -EBUSY;\n\tif (is_cpu_exclusive(cur) &&\n\t    !cpuset_cpumask_can_shrink(cur->cpus_allowed,\n\t\t\t\t       trial->cpus_allowed))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "cs->cpus_allowed",
            "trialcs->cpus_allowed"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "trialcs->cpus_allowed",
            "top_cpuset.cpus_allowed"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpulist_parse",
          "args": [
            "buf",
            "trialcs->cpus_allowed"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "trialcs->cpus_allowed"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_cpumask(struct cpuset *cs, struct cpuset *trialcs,\n\t\t\t  const char *buf)\n{\n\tint retval;\n\tstruct tmpmasks tmp;\n\n\t/* top_cpuset.cpus_allowed tracks cpu_online_mask; it's read-only */\n\tif (cs == &top_cpuset)\n\t\treturn -EACCES;\n\n\t/*\n\t * An empty cpus_allowed is ok only if the cpuset has no tasks.\n\t * Since cpulist_parse() fails on an empty mask, we special case\n\t * that parsing.  The validate_change() call ensures that cpusets\n\t * with tasks have cpus.\n\t */\n\tif (!*buf) {\n\t\tcpumask_clear(trialcs->cpus_allowed);\n\t} else {\n\t\tretval = cpulist_parse(buf, trialcs->cpus_allowed);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tif (!cpumask_subset(trialcs->cpus_allowed,\n\t\t\t\t    top_cpuset.cpus_allowed))\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* Nothing to do if the cpus didn't change */\n\tif (cpumask_equal(cs->cpus_allowed, trialcs->cpus_allowed))\n\t\treturn 0;\n\n\tretval = validate_change(cs, trialcs);\n\tif (retval < 0)\n\t\treturn retval;\n\n#ifdef CONFIG_CPUMASK_OFFSTACK\n\t/*\n\t * Use the cpumasks in trialcs for tmpmasks when they are pointers\n\t * to allocated cpumasks.\n\t */\n\ttmp.addmask  = trialcs->subparts_cpus;\n\ttmp.delmask  = trialcs->effective_cpus;\n\ttmp.new_cpus = trialcs->cpus_allowed;\n#endif\n\n\tif (cs->partition_root_state) {\n\t\t/* Cpumask of a partition root cannot be empty */\n\t\tif (cpumask_empty(trialcs->cpus_allowed))\n\t\t\treturn -EINVAL;\n\t\tif (update_parent_subparts_cpumask(cs, partcmd_update,\n\t\t\t\t\ttrialcs->cpus_allowed, &tmp) < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->cpus_allowed, trialcs->cpus_allowed);\n\n\t/*\n\t * Make sure that subparts_cpus is a subset of cpus_allowed.\n\t */\n\tif (cs->nr_subparts_cpus) {\n\t\tcpumask_andnot(cs->subparts_cpus, cs->subparts_cpus,\n\t\t\t       cs->cpus_allowed);\n\t\tcs->nr_subparts_cpus = cpumask_weight(cs->subparts_cpus);\n\t}\n\tspin_unlock_irq(&callback_lock);\n\n\tupdate_cpumasks_hier(cs, &tmp);\n\n\tif (cs->partition_root_state) {\n\t\tstruct cpuset *parent = parent_cs(cs);\n\n\t\t/*\n\t\t * For partition root, update the cpumasks of sibling\n\t\t * cpusets if they use parent's effective_cpus.\n\t\t */\n\t\tif (parent->child_ecpus_count)\n\t\t\tupdate_sibling_cpumasks(parent, cs, &tmp);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "update_sibling_cpumasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1519-1540",
    "snippet": "static void update_sibling_cpumasks(struct cpuset *parent, struct cpuset *cs,\n\t\t\t\t    struct tmpmasks *tmp)\n{\n\tstruct cpuset *sibling;\n\tstruct cgroup_subsys_state *pos_css;\n\n\t/*\n\t * Check all its siblings and call update_cpumasks_hier()\n\t * if their use_parent_ecpus flag is set in order for them\n\t * to use the right effective_cpus value.\n\t */\n\trcu_read_lock();\n\tcpuset_for_each_child(sibling, pos_css, parent) {\n\t\tif (sibling == cs)\n\t\t\tcontinue;\n\t\tif (!sibling->use_parent_ecpus)\n\t\t\tcontinue;\n\n\t\tupdate_cpumasks_hier(sibling, tmp);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cpumasks_hier",
          "args": [
            "sibling",
            "tmp"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "update_cpumasks_hier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1364-1511",
          "snippet": "static void update_cpumasks_hier(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\tbool need_rebuild_sched_domains = false;\n\tint old_prs, new_prs;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, cs) {\n\t\tstruct cpuset *parent = parent_cs(cp);\n\n\t\tcompute_effective_cpumask(tmp->new_cpus, cp, parent);\n\n\t\t/*\n\t\t * If it becomes empty, inherit the effective mask of the\n\t\t * parent, which is guaranteed to have some CPUs.\n\t\t */\n\t\tif (is_in_v2_mode() && cpumask_empty(tmp->new_cpus)) {\n\t\t\tcpumask_copy(tmp->new_cpus, parent->effective_cpus);\n\t\t\tif (!cp->use_parent_ecpus) {\n\t\t\t\tcp->use_parent_ecpus = true;\n\t\t\t\tparent->child_ecpus_count++;\n\t\t\t}\n\t\t} else if (cp->use_parent_ecpus) {\n\t\t\tcp->use_parent_ecpus = false;\n\t\t\tWARN_ON_ONCE(!parent->child_ecpus_count);\n\t\t\tparent->child_ecpus_count--;\n\t\t}\n\n\t\t/*\n\t\t * Skip the whole subtree if the cpumask remains the same\n\t\t * and has no partition root state.\n\t\t */\n\t\tif (!cp->partition_root_state &&\n\t\t    cpumask_equal(tmp->new_cpus, cp->effective_cpus)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * update_parent_subparts_cpumask() should have been called\n\t\t * for cs already in update_cpumask(). We should also call\n\t\t * update_tasks_cpumask() again for tasks in the parent\n\t\t * cpuset if the parent's subparts_cpus changes.\n\t\t */\n\t\told_prs = new_prs = cp->partition_root_state;\n\t\tif ((cp != cs) && old_prs) {\n\t\t\tswitch (parent->partition_root_state) {\n\t\t\tcase PRS_DISABLED:\n\t\t\t\t/*\n\t\t\t\t * If parent is not a partition root or an\n\t\t\t\t * invalid partition root, clear its state\n\t\t\t\t * and its CS_CPU_EXCLUSIVE flag.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(cp->partition_root_state\n\t\t\t\t\t     != PRS_ERROR);\n\t\t\t\tnew_prs = PRS_DISABLED;\n\n\t\t\t\t/*\n\t\t\t\t * clear_bit() is an atomic operation and\n\t\t\t\t * readers aren't interested in the state\n\t\t\t\t * of CS_CPU_EXCLUSIVE anyway. So we can\n\t\t\t\t * just update the flag without holding\n\t\t\t\t * the callback_lock.\n\t\t\t\t */\n\t\t\t\tclear_bit(CS_CPU_EXCLUSIVE, &cp->flags);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ENABLED:\n\t\t\t\tif (update_parent_subparts_cpumask(cp, partcmd_update, NULL, tmp))\n\t\t\t\t\tupdate_tasks_cpumask(parent);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ERROR:\n\t\t\t\t/*\n\t\t\t\t * When parent is invalid, it has to be too.\n\t\t\t\t */\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!css_tryget_online(&cp->css))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tspin_lock_irq(&callback_lock);\n\n\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\tif (cp->nr_subparts_cpus && (new_prs != PRS_ENABLED)) {\n\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t} else if (cp->nr_subparts_cpus) {\n\t\t\t/*\n\t\t\t * Make sure that effective_cpus & subparts_cpus\n\t\t\t * are mutually exclusive.\n\t\t\t *\n\t\t\t * In the unlikely event that effective_cpus\n\t\t\t * becomes empty. we clear cp->nr_subparts_cpus and\n\t\t\t * let its child partition roots to compete for\n\t\t\t * CPUs again.\n\t\t\t */\n\t\t\tcpumask_andnot(cp->effective_cpus, cp->effective_cpus,\n\t\t\t\t       cp->subparts_cpus);\n\t\t\tif (cpumask_empty(cp->effective_cpus)) {\n\t\t\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\t} else if (!cpumask_subset(cp->subparts_cpus,\n\t\t\t\t\t\t   tmp->new_cpus)) {\n\t\t\t\tcpumask_andnot(cp->subparts_cpus,\n\t\t\t\t\tcp->subparts_cpus, tmp->new_cpus);\n\t\t\t\tcp->nr_subparts_cpus\n\t\t\t\t\t= cpumask_weight(cp->subparts_cpus);\n\t\t\t}\n\t\t}\n\n\t\tif (new_prs != old_prs)\n\t\t\tcp->partition_root_state = new_prs;\n\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cp, old_prs, new_prs);\n\n\t\tWARN_ON(!is_in_v2_mode() &&\n\t\t\t!cpumask_equal(cp->cpus_allowed, cp->effective_cpus));\n\n\t\tupdate_tasks_cpumask(cp);\n\n\t\t/*\n\t\t * On legacy hierarchy, if the effective cpumask of any non-\n\t\t * empty cpuset is changed, we need to rebuild sched domains.\n\t\t * On default hierarchy, the cpuset needs to be a partition\n\t\t * root as well.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    is_sched_load_balance(cp) &&\n\t\t   (!cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t\t    is_partition_root(cp)))\n\t\t\tneed_rebuild_sched_domains = true;\n\n\t\trcu_read_lock();\n\t\tcss_put(&cp->css);\n\t}\n\trcu_read_unlock();\n\n\tif (need_rebuild_sched_domains)\n\t\trebuild_sched_domains_locked();\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define PRS_ERROR\t\t-1",
            "#define PRS_ENABLED\t\t1",
            "#define PRS_DISABLED\t\t0"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);",
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n#define PRS_ENABLED\t\t1\n#define PRS_DISABLED\t\t0\n\nstatic DEFINE_SPINLOCK(callback_lock);\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic void update_cpumasks_hier(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\tbool need_rebuild_sched_domains = false;\n\tint old_prs, new_prs;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, cs) {\n\t\tstruct cpuset *parent = parent_cs(cp);\n\n\t\tcompute_effective_cpumask(tmp->new_cpus, cp, parent);\n\n\t\t/*\n\t\t * If it becomes empty, inherit the effective mask of the\n\t\t * parent, which is guaranteed to have some CPUs.\n\t\t */\n\t\tif (is_in_v2_mode() && cpumask_empty(tmp->new_cpus)) {\n\t\t\tcpumask_copy(tmp->new_cpus, parent->effective_cpus);\n\t\t\tif (!cp->use_parent_ecpus) {\n\t\t\t\tcp->use_parent_ecpus = true;\n\t\t\t\tparent->child_ecpus_count++;\n\t\t\t}\n\t\t} else if (cp->use_parent_ecpus) {\n\t\t\tcp->use_parent_ecpus = false;\n\t\t\tWARN_ON_ONCE(!parent->child_ecpus_count);\n\t\t\tparent->child_ecpus_count--;\n\t\t}\n\n\t\t/*\n\t\t * Skip the whole subtree if the cpumask remains the same\n\t\t * and has no partition root state.\n\t\t */\n\t\tif (!cp->partition_root_state &&\n\t\t    cpumask_equal(tmp->new_cpus, cp->effective_cpus)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * update_parent_subparts_cpumask() should have been called\n\t\t * for cs already in update_cpumask(). We should also call\n\t\t * update_tasks_cpumask() again for tasks in the parent\n\t\t * cpuset if the parent's subparts_cpus changes.\n\t\t */\n\t\told_prs = new_prs = cp->partition_root_state;\n\t\tif ((cp != cs) && old_prs) {\n\t\t\tswitch (parent->partition_root_state) {\n\t\t\tcase PRS_DISABLED:\n\t\t\t\t/*\n\t\t\t\t * If parent is not a partition root or an\n\t\t\t\t * invalid partition root, clear its state\n\t\t\t\t * and its CS_CPU_EXCLUSIVE flag.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(cp->partition_root_state\n\t\t\t\t\t     != PRS_ERROR);\n\t\t\t\tnew_prs = PRS_DISABLED;\n\n\t\t\t\t/*\n\t\t\t\t * clear_bit() is an atomic operation and\n\t\t\t\t * readers aren't interested in the state\n\t\t\t\t * of CS_CPU_EXCLUSIVE anyway. So we can\n\t\t\t\t * just update the flag without holding\n\t\t\t\t * the callback_lock.\n\t\t\t\t */\n\t\t\t\tclear_bit(CS_CPU_EXCLUSIVE, &cp->flags);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ENABLED:\n\t\t\t\tif (update_parent_subparts_cpumask(cp, partcmd_update, NULL, tmp))\n\t\t\t\t\tupdate_tasks_cpumask(parent);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ERROR:\n\t\t\t\t/*\n\t\t\t\t * When parent is invalid, it has to be too.\n\t\t\t\t */\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!css_tryget_online(&cp->css))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tspin_lock_irq(&callback_lock);\n\n\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\tif (cp->nr_subparts_cpus && (new_prs != PRS_ENABLED)) {\n\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t} else if (cp->nr_subparts_cpus) {\n\t\t\t/*\n\t\t\t * Make sure that effective_cpus & subparts_cpus\n\t\t\t * are mutually exclusive.\n\t\t\t *\n\t\t\t * In the unlikely event that effective_cpus\n\t\t\t * becomes empty. we clear cp->nr_subparts_cpus and\n\t\t\t * let its child partition roots to compete for\n\t\t\t * CPUs again.\n\t\t\t */\n\t\t\tcpumask_andnot(cp->effective_cpus, cp->effective_cpus,\n\t\t\t\t       cp->subparts_cpus);\n\t\t\tif (cpumask_empty(cp->effective_cpus)) {\n\t\t\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\t} else if (!cpumask_subset(cp->subparts_cpus,\n\t\t\t\t\t\t   tmp->new_cpus)) {\n\t\t\t\tcpumask_andnot(cp->subparts_cpus,\n\t\t\t\t\tcp->subparts_cpus, tmp->new_cpus);\n\t\t\t\tcp->nr_subparts_cpus\n\t\t\t\t\t= cpumask_weight(cp->subparts_cpus);\n\t\t\t}\n\t\t}\n\n\t\tif (new_prs != old_prs)\n\t\t\tcp->partition_root_state = new_prs;\n\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cp, old_prs, new_prs);\n\n\t\tWARN_ON(!is_in_v2_mode() &&\n\t\t\t!cpumask_equal(cp->cpus_allowed, cp->effective_cpus));\n\n\t\tupdate_tasks_cpumask(cp);\n\n\t\t/*\n\t\t * On legacy hierarchy, if the effective cpumask of any non-\n\t\t * empty cpuset is changed, we need to rebuild sched domains.\n\t\t * On default hierarchy, the cpuset needs to be a partition\n\t\t * root as well.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    is_sched_load_balance(cp) &&\n\t\t   (!cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t\t    is_partition_root(cp)))\n\t\t\tneed_rebuild_sched_domains = true;\n\n\t\trcu_read_lock();\n\t\tcss_put(&cp->css);\n\t}\n\trcu_read_unlock();\n\n\tif (need_rebuild_sched_domains)\n\t\trebuild_sched_domains_locked();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_for_each_child",
          "args": [
            "sibling",
            "pos_css",
            "parent"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_sibling_cpumasks(struct cpuset *parent, struct cpuset *cs,\n\t\t\t\t    struct tmpmasks *tmp)\n{\n\tstruct cpuset *sibling;\n\tstruct cgroup_subsys_state *pos_css;\n\n\t/*\n\t * Check all its siblings and call update_cpumasks_hier()\n\t * if their use_parent_ecpus flag is set in order for them\n\t * to use the right effective_cpus value.\n\t */\n\trcu_read_lock();\n\tcpuset_for_each_child(sibling, pos_css, parent) {\n\t\tif (sibling == cs)\n\t\t\tcontinue;\n\t\tif (!sibling->use_parent_ecpus)\n\t\t\tcontinue;\n\n\t\tupdate_cpumasks_hier(sibling, tmp);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "update_cpumasks_hier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1364-1511",
    "snippet": "static void update_cpumasks_hier(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\tbool need_rebuild_sched_domains = false;\n\tint old_prs, new_prs;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, cs) {\n\t\tstruct cpuset *parent = parent_cs(cp);\n\n\t\tcompute_effective_cpumask(tmp->new_cpus, cp, parent);\n\n\t\t/*\n\t\t * If it becomes empty, inherit the effective mask of the\n\t\t * parent, which is guaranteed to have some CPUs.\n\t\t */\n\t\tif (is_in_v2_mode() && cpumask_empty(tmp->new_cpus)) {\n\t\t\tcpumask_copy(tmp->new_cpus, parent->effective_cpus);\n\t\t\tif (!cp->use_parent_ecpus) {\n\t\t\t\tcp->use_parent_ecpus = true;\n\t\t\t\tparent->child_ecpus_count++;\n\t\t\t}\n\t\t} else if (cp->use_parent_ecpus) {\n\t\t\tcp->use_parent_ecpus = false;\n\t\t\tWARN_ON_ONCE(!parent->child_ecpus_count);\n\t\t\tparent->child_ecpus_count--;\n\t\t}\n\n\t\t/*\n\t\t * Skip the whole subtree if the cpumask remains the same\n\t\t * and has no partition root state.\n\t\t */\n\t\tif (!cp->partition_root_state &&\n\t\t    cpumask_equal(tmp->new_cpus, cp->effective_cpus)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * update_parent_subparts_cpumask() should have been called\n\t\t * for cs already in update_cpumask(). We should also call\n\t\t * update_tasks_cpumask() again for tasks in the parent\n\t\t * cpuset if the parent's subparts_cpus changes.\n\t\t */\n\t\told_prs = new_prs = cp->partition_root_state;\n\t\tif ((cp != cs) && old_prs) {\n\t\t\tswitch (parent->partition_root_state) {\n\t\t\tcase PRS_DISABLED:\n\t\t\t\t/*\n\t\t\t\t * If parent is not a partition root or an\n\t\t\t\t * invalid partition root, clear its state\n\t\t\t\t * and its CS_CPU_EXCLUSIVE flag.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(cp->partition_root_state\n\t\t\t\t\t     != PRS_ERROR);\n\t\t\t\tnew_prs = PRS_DISABLED;\n\n\t\t\t\t/*\n\t\t\t\t * clear_bit() is an atomic operation and\n\t\t\t\t * readers aren't interested in the state\n\t\t\t\t * of CS_CPU_EXCLUSIVE anyway. So we can\n\t\t\t\t * just update the flag without holding\n\t\t\t\t * the callback_lock.\n\t\t\t\t */\n\t\t\t\tclear_bit(CS_CPU_EXCLUSIVE, &cp->flags);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ENABLED:\n\t\t\t\tif (update_parent_subparts_cpumask(cp, partcmd_update, NULL, tmp))\n\t\t\t\t\tupdate_tasks_cpumask(parent);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ERROR:\n\t\t\t\t/*\n\t\t\t\t * When parent is invalid, it has to be too.\n\t\t\t\t */\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!css_tryget_online(&cp->css))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tspin_lock_irq(&callback_lock);\n\n\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\tif (cp->nr_subparts_cpus && (new_prs != PRS_ENABLED)) {\n\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t} else if (cp->nr_subparts_cpus) {\n\t\t\t/*\n\t\t\t * Make sure that effective_cpus & subparts_cpus\n\t\t\t * are mutually exclusive.\n\t\t\t *\n\t\t\t * In the unlikely event that effective_cpus\n\t\t\t * becomes empty. we clear cp->nr_subparts_cpus and\n\t\t\t * let its child partition roots to compete for\n\t\t\t * CPUs again.\n\t\t\t */\n\t\t\tcpumask_andnot(cp->effective_cpus, cp->effective_cpus,\n\t\t\t\t       cp->subparts_cpus);\n\t\t\tif (cpumask_empty(cp->effective_cpus)) {\n\t\t\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\t} else if (!cpumask_subset(cp->subparts_cpus,\n\t\t\t\t\t\t   tmp->new_cpus)) {\n\t\t\t\tcpumask_andnot(cp->subparts_cpus,\n\t\t\t\t\tcp->subparts_cpus, tmp->new_cpus);\n\t\t\t\tcp->nr_subparts_cpus\n\t\t\t\t\t= cpumask_weight(cp->subparts_cpus);\n\t\t\t}\n\t\t}\n\n\t\tif (new_prs != old_prs)\n\t\t\tcp->partition_root_state = new_prs;\n\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cp, old_prs, new_prs);\n\n\t\tWARN_ON(!is_in_v2_mode() &&\n\t\t\t!cpumask_equal(cp->cpus_allowed, cp->effective_cpus));\n\n\t\tupdate_tasks_cpumask(cp);\n\n\t\t/*\n\t\t * On legacy hierarchy, if the effective cpumask of any non-\n\t\t * empty cpuset is changed, we need to rebuild sched domains.\n\t\t * On default hierarchy, the cpuset needs to be a partition\n\t\t * root as well.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    is_sched_load_balance(cp) &&\n\t\t   (!cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t\t    is_partition_root(cp)))\n\t\t\tneed_rebuild_sched_domains = true;\n\n\t\trcu_read_lock();\n\t\tcss_put(&cp->css);\n\t}\n\trcu_read_unlock();\n\n\tif (need_rebuild_sched_domains)\n\t\trebuild_sched_domains_locked();\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define PRS_ERROR\t\t-1",
      "#define PRS_ENABLED\t\t1",
      "#define PRS_DISABLED\t\t0"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);",
      "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rebuild_sched_domains_locked",
          "args": [],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_sched_domains_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1074-1076",
          "snippet": "static void rebuild_sched_domains_locked(void)\n{\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void rebuild_sched_domains_locked(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&cp->css"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_partition_root",
          "args": [
            "cp"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "is_partition_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "271-274",
          "snippet": "static inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "cpuset_cgrp_subsys"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sched_load_balance",
          "args": [
            "cp"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "is_sched_load_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "251-254",
          "snippet": "static inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cp->cpus_allowed"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_tasks_cpumask",
          "args": [
            "cp"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "update_tasks_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1096-1105",
          "snippet": "static void update_tasks_cpumask(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tset_cpus_allowed_ptr(task, cs->effective_cpus);\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_tasks_cpumask(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tset_cpus_allowed_ptr(task, cs->effective_cpus);\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!is_in_v2_mode() &&\n\t\t\t!cpumask_equal(cp->cpus_allowed, cp->effective_cpus)"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "cp->cpus_allowed",
            "cp->effective_cpus"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_in_v2_mode",
          "args": [],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_v2_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "401-405",
          "snippet": "static inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notify_partition_change",
          "args": [
            "cp",
            "old_prs",
            "new_prs"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "notify_partition_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "279-284",
          "snippet": "static inline void notify_partition_change(struct cpuset *cs,\n\t\t\t\t\t   int old_prs, int new_prs)\n{\n\tif (old_prs != new_prs)\n\t\tcgroup_file_notify(&cs->partition_file);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void notify_partition_change(struct cpuset *cs,\n\t\t\t\t\t   int old_prs, int new_prs)\n{\n\tif (old_prs != new_prs)\n\t\tcgroup_file_notify(&cs->partition_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "cp->subparts_cpus"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "cp->subparts_cpus",
            "cp->subparts_cpus",
            "tmp->new_cpus"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "cp->subparts_cpus",
            "tmp->new_cpus"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "cp->subparts_cpus"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cp->effective_cpus",
            "tmp->new_cpus"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cp->effective_cpus"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "cp->effective_cpus",
            "cp->effective_cpus",
            "cp->subparts_cpus"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "cp->subparts_cpus"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "cp->effective_cpus",
            "tmp->new_cpus"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_tryget_online",
          "args": [
            "&cp->css"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_parent_subparts_cpumask",
          "args": [
            "cp",
            "partcmd_update",
            "NULL",
            "tmp"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "update_parent_subparts_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1182-1350",
          "snippet": "static int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,\n\t\t\t\t\t  struct cpumask *newmask,\n\t\t\t\t\t  struct tmpmasks *tmp)\n{\n\tstruct cpuset *parent = parent_cs(cpuset);\n\tint adding;\t/* Moving cpus from effective_cpus to subparts_cpus */\n\tint deleting;\t/* Moving cpus from subparts_cpus to effective_cpus */\n\tint old_prs, new_prs;\n\tbool part_error = false;\t/* Partition error? */\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * The parent must be a partition root.\n\t * The new cpumask, if present, or the current cpus_allowed must\n\t * not be empty.\n\t */\n\tif (!is_partition_root(parent) ||\n\t   (newmask && cpumask_empty(newmask)) ||\n\t   (!newmask && cpumask_empty(cpuset->cpus_allowed)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Enabling/disabling partition root is not allowed if there are\n\t * online children.\n\t */\n\tif ((cmd != partcmd_update) && css_has_online_children(&cpuset->css))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Enabling partition root is not allowed if not all the CPUs\n\t * can be granted from parent's effective_cpus or at least one\n\t * CPU will be left after that.\n\t */\n\tif ((cmd == partcmd_enable) &&\n\t   (!cpumask_subset(cpuset->cpus_allowed, parent->effective_cpus) ||\n\t     cpumask_equal(cpuset->cpus_allowed, parent->effective_cpus)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * A cpumask update cannot make parent's effective_cpus become empty.\n\t */\n\tadding = deleting = false;\n\told_prs = new_prs = cpuset->partition_root_state;\n\tif (cmd == partcmd_enable) {\n\t\tcpumask_copy(tmp->addmask, cpuset->cpus_allowed);\n\t\tadding = true;\n\t} else if (cmd == partcmd_disable) {\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t} else if (newmask) {\n\t\t/*\n\t\t * partcmd_update with newmask:\n\t\t *\n\t\t * delmask = cpus_allowed & ~newmask & parent->subparts_cpus\n\t\t * addmask = newmask & parent->effective_cpus\n\t\t *\t\t     & ~parent->subparts_cpus\n\t\t */\n\t\tcpumask_andnot(tmp->delmask, cpuset->cpus_allowed, newmask);\n\t\tdeleting = cpumask_and(tmp->delmask, tmp->delmask,\n\t\t\t\t       parent->subparts_cpus);\n\n\t\tcpumask_and(tmp->addmask, newmask, parent->effective_cpus);\n\t\tadding = cpumask_andnot(tmp->addmask, tmp->addmask,\n\t\t\t\t\tparent->subparts_cpus);\n\t\t/*\n\t\t * Return error if the new effective_cpus could become empty.\n\t\t */\n\t\tif (adding &&\n\t\t    cpumask_equal(parent->effective_cpus, tmp->addmask)) {\n\t\t\tif (!deleting)\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * As some of the CPUs in subparts_cpus might have\n\t\t\t * been offlined, we need to compute the real delmask\n\t\t\t * to confirm that.\n\t\t\t */\n\t\t\tif (!cpumask_and(tmp->addmask, tmp->delmask,\n\t\t\t\t\t cpu_active_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tcpumask_copy(tmp->addmask, parent->effective_cpus);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * partcmd_update w/o newmask:\n\t\t *\n\t\t * addmask = cpus_allowed & parent->effective_cpus\n\t\t *\n\t\t * Note that parent's subparts_cpus may have been\n\t\t * pre-shrunk in case there is a change in the cpu list.\n\t\t * So no deletion is needed.\n\t\t */\n\t\tadding = cpumask_and(tmp->addmask, cpuset->cpus_allowed,\n\t\t\t\t     parent->effective_cpus);\n\t\tpart_error = cpumask_equal(tmp->addmask,\n\t\t\t\t\t   parent->effective_cpus);\n\t}\n\n\tif (cmd == partcmd_update) {\n\t\tint prev_prs = cpuset->partition_root_state;\n\n\t\t/*\n\t\t * Check for possible transition between PRS_ENABLED\n\t\t * and PRS_ERROR.\n\t\t */\n\t\tswitch (cpuset->partition_root_state) {\n\t\tcase PRS_ENABLED:\n\t\t\tif (part_error)\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\tbreak;\n\t\tcase PRS_ERROR:\n\t\t\tif (!part_error)\n\t\t\t\tnew_prs = PRS_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Set part_error if previously in invalid state.\n\t\t */\n\t\tpart_error = (prev_prs == PRS_ERROR);\n\t}\n\n\tif (!part_error && (new_prs == PRS_ERROR))\n\t\treturn 0;\t/* Nothing need to be done */\n\n\tif (new_prs == PRS_ERROR) {\n\t\t/*\n\t\t * Remove all its cpus from parent's subparts_cpus.\n\t\t */\n\t\tadding = false;\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t}\n\n\tif (!adding && !deleting && (new_prs == old_prs))\n\t\treturn 0;\n\n\t/*\n\t * Change the parent's subparts_cpus.\n\t * Newly added CPUs will be removed from effective_cpus and\n\t * newly deleted ones will be added back to effective_cpus.\n\t */\n\tspin_lock_irq(&callback_lock);\n\tif (adding) {\n\t\tcpumask_or(parent->subparts_cpus,\n\t\t\t   parent->subparts_cpus, tmp->addmask);\n\t\tcpumask_andnot(parent->effective_cpus,\n\t\t\t       parent->effective_cpus, tmp->addmask);\n\t}\n\tif (deleting) {\n\t\tcpumask_andnot(parent->subparts_cpus,\n\t\t\t       parent->subparts_cpus, tmp->delmask);\n\t\t/*\n\t\t * Some of the CPUs in subparts_cpus might have been offlined.\n\t\t */\n\t\tcpumask_and(tmp->delmask, tmp->delmask, cpu_active_mask);\n\t\tcpumask_or(parent->effective_cpus,\n\t\t\t   parent->effective_cpus, tmp->delmask);\n\t}\n\n\tparent->nr_subparts_cpus = cpumask_weight(parent->subparts_cpus);\n\n\tif (old_prs != new_prs)\n\t\tcpuset->partition_root_state = new_prs;\n\n\tspin_unlock_irq(&callback_lock);\n\tnotify_partition_change(cpuset, old_prs, new_prs);\n\n\treturn cmd == partcmd_update;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define PRS_ERROR\t\t-1",
            "#define PRS_ENABLED\t\t1"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(callback_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n#define PRS_ENABLED\t\t1\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,\n\t\t\t\t\t  struct cpumask *newmask,\n\t\t\t\t\t  struct tmpmasks *tmp)\n{\n\tstruct cpuset *parent = parent_cs(cpuset);\n\tint adding;\t/* Moving cpus from effective_cpus to subparts_cpus */\n\tint deleting;\t/* Moving cpus from subparts_cpus to effective_cpus */\n\tint old_prs, new_prs;\n\tbool part_error = false;\t/* Partition error? */\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * The parent must be a partition root.\n\t * The new cpumask, if present, or the current cpus_allowed must\n\t * not be empty.\n\t */\n\tif (!is_partition_root(parent) ||\n\t   (newmask && cpumask_empty(newmask)) ||\n\t   (!newmask && cpumask_empty(cpuset->cpus_allowed)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Enabling/disabling partition root is not allowed if there are\n\t * online children.\n\t */\n\tif ((cmd != partcmd_update) && css_has_online_children(&cpuset->css))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Enabling partition root is not allowed if not all the CPUs\n\t * can be granted from parent's effective_cpus or at least one\n\t * CPU will be left after that.\n\t */\n\tif ((cmd == partcmd_enable) &&\n\t   (!cpumask_subset(cpuset->cpus_allowed, parent->effective_cpus) ||\n\t     cpumask_equal(cpuset->cpus_allowed, parent->effective_cpus)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * A cpumask update cannot make parent's effective_cpus become empty.\n\t */\n\tadding = deleting = false;\n\told_prs = new_prs = cpuset->partition_root_state;\n\tif (cmd == partcmd_enable) {\n\t\tcpumask_copy(tmp->addmask, cpuset->cpus_allowed);\n\t\tadding = true;\n\t} else if (cmd == partcmd_disable) {\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t} else if (newmask) {\n\t\t/*\n\t\t * partcmd_update with newmask:\n\t\t *\n\t\t * delmask = cpus_allowed & ~newmask & parent->subparts_cpus\n\t\t * addmask = newmask & parent->effective_cpus\n\t\t *\t\t     & ~parent->subparts_cpus\n\t\t */\n\t\tcpumask_andnot(tmp->delmask, cpuset->cpus_allowed, newmask);\n\t\tdeleting = cpumask_and(tmp->delmask, tmp->delmask,\n\t\t\t\t       parent->subparts_cpus);\n\n\t\tcpumask_and(tmp->addmask, newmask, parent->effective_cpus);\n\t\tadding = cpumask_andnot(tmp->addmask, tmp->addmask,\n\t\t\t\t\tparent->subparts_cpus);\n\t\t/*\n\t\t * Return error if the new effective_cpus could become empty.\n\t\t */\n\t\tif (adding &&\n\t\t    cpumask_equal(parent->effective_cpus, tmp->addmask)) {\n\t\t\tif (!deleting)\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * As some of the CPUs in subparts_cpus might have\n\t\t\t * been offlined, we need to compute the real delmask\n\t\t\t * to confirm that.\n\t\t\t */\n\t\t\tif (!cpumask_and(tmp->addmask, tmp->delmask,\n\t\t\t\t\t cpu_active_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tcpumask_copy(tmp->addmask, parent->effective_cpus);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * partcmd_update w/o newmask:\n\t\t *\n\t\t * addmask = cpus_allowed & parent->effective_cpus\n\t\t *\n\t\t * Note that parent's subparts_cpus may have been\n\t\t * pre-shrunk in case there is a change in the cpu list.\n\t\t * So no deletion is needed.\n\t\t */\n\t\tadding = cpumask_and(tmp->addmask, cpuset->cpus_allowed,\n\t\t\t\t     parent->effective_cpus);\n\t\tpart_error = cpumask_equal(tmp->addmask,\n\t\t\t\t\t   parent->effective_cpus);\n\t}\n\n\tif (cmd == partcmd_update) {\n\t\tint prev_prs = cpuset->partition_root_state;\n\n\t\t/*\n\t\t * Check for possible transition between PRS_ENABLED\n\t\t * and PRS_ERROR.\n\t\t */\n\t\tswitch (cpuset->partition_root_state) {\n\t\tcase PRS_ENABLED:\n\t\t\tif (part_error)\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\tbreak;\n\t\tcase PRS_ERROR:\n\t\t\tif (!part_error)\n\t\t\t\tnew_prs = PRS_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Set part_error if previously in invalid state.\n\t\t */\n\t\tpart_error = (prev_prs == PRS_ERROR);\n\t}\n\n\tif (!part_error && (new_prs == PRS_ERROR))\n\t\treturn 0;\t/* Nothing need to be done */\n\n\tif (new_prs == PRS_ERROR) {\n\t\t/*\n\t\t * Remove all its cpus from parent's subparts_cpus.\n\t\t */\n\t\tadding = false;\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t}\n\n\tif (!adding && !deleting && (new_prs == old_prs))\n\t\treturn 0;\n\n\t/*\n\t * Change the parent's subparts_cpus.\n\t * Newly added CPUs will be removed from effective_cpus and\n\t * newly deleted ones will be added back to effective_cpus.\n\t */\n\tspin_lock_irq(&callback_lock);\n\tif (adding) {\n\t\tcpumask_or(parent->subparts_cpus,\n\t\t\t   parent->subparts_cpus, tmp->addmask);\n\t\tcpumask_andnot(parent->effective_cpus,\n\t\t\t       parent->effective_cpus, tmp->addmask);\n\t}\n\tif (deleting) {\n\t\tcpumask_andnot(parent->subparts_cpus,\n\t\t\t       parent->subparts_cpus, tmp->delmask);\n\t\t/*\n\t\t * Some of the CPUs in subparts_cpus might have been offlined.\n\t\t */\n\t\tcpumask_and(tmp->delmask, tmp->delmask, cpu_active_mask);\n\t\tcpumask_or(parent->effective_cpus,\n\t\t\t   parent->effective_cpus, tmp->delmask);\n\t}\n\n\tparent->nr_subparts_cpus = cpumask_weight(parent->subparts_cpus);\n\n\tif (old_prs != new_prs)\n\t\tcpuset->partition_root_state = new_prs;\n\n\tspin_unlock_irq(&callback_lock);\n\tnotify_partition_change(cpuset, old_prs, new_prs);\n\n\treturn cmd == partcmd_update;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "CS_CPU_EXCLUSIVE",
            "&cp->flags"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "cp->partition_root_state\n\t\t\t\t\t     != PRS_ERROR"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_rightmost_descendant",
          "args": [
            "pos_css"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "tmp->new_cpus",
            "cp->effective_cpus"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!parent->child_ecpus_count"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "tmp->new_cpus",
            "parent->effective_cpus"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "tmp->new_cpus"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compute_effective_cpumask",
          "args": [
            "tmp->new_cpus",
            "cp",
            "parent"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "compute_effective_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1118-1129",
          "snippet": "static void compute_effective_cpumask(struct cpumask *new_cpus,\n\t\t\t\t      struct cpuset *cs, struct cpuset *parent)\n{\n\tif (parent->nr_subparts_cpus) {\n\t\tcpumask_or(new_cpus, parent->effective_cpus,\n\t\t\t   parent->subparts_cpus);\n\t\tcpumask_and(new_cpus, new_cpus, cs->cpus_allowed);\n\t\tcpumask_and(new_cpus, new_cpus, cpu_active_mask);\n\t} else {\n\t\tcpumask_and(new_cpus, cs->cpus_allowed, parent->effective_cpus);\n\t}\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void compute_effective_cpumask(struct cpumask *new_cpus,\n\t\t\t\t      struct cpuset *cs, struct cpuset *parent)\n{\n\tif (parent->nr_subparts_cpus) {\n\t\tcpumask_or(new_cpus, parent->effective_cpus,\n\t\t\t   parent->subparts_cpus);\n\t\tcpumask_and(new_cpus, new_cpus, cs->cpus_allowed);\n\t\tcpumask_and(new_cpus, new_cpus, cpu_active_mask);\n\t} else {\n\t\tcpumask_and(new_cpus, cs->cpus_allowed, parent->effective_cpus);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cp"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_for_each_descendant_pre",
          "args": [
            "cp",
            "pos_css",
            "cs"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n#define PRS_ENABLED\t\t1\n#define PRS_DISABLED\t\t0\n\nstatic DEFINE_SPINLOCK(callback_lock);\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic void update_cpumasks_hier(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\tbool need_rebuild_sched_domains = false;\n\tint old_prs, new_prs;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, cs) {\n\t\tstruct cpuset *parent = parent_cs(cp);\n\n\t\tcompute_effective_cpumask(tmp->new_cpus, cp, parent);\n\n\t\t/*\n\t\t * If it becomes empty, inherit the effective mask of the\n\t\t * parent, which is guaranteed to have some CPUs.\n\t\t */\n\t\tif (is_in_v2_mode() && cpumask_empty(tmp->new_cpus)) {\n\t\t\tcpumask_copy(tmp->new_cpus, parent->effective_cpus);\n\t\t\tif (!cp->use_parent_ecpus) {\n\t\t\t\tcp->use_parent_ecpus = true;\n\t\t\t\tparent->child_ecpus_count++;\n\t\t\t}\n\t\t} else if (cp->use_parent_ecpus) {\n\t\t\tcp->use_parent_ecpus = false;\n\t\t\tWARN_ON_ONCE(!parent->child_ecpus_count);\n\t\t\tparent->child_ecpus_count--;\n\t\t}\n\n\t\t/*\n\t\t * Skip the whole subtree if the cpumask remains the same\n\t\t * and has no partition root state.\n\t\t */\n\t\tif (!cp->partition_root_state &&\n\t\t    cpumask_equal(tmp->new_cpus, cp->effective_cpus)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * update_parent_subparts_cpumask() should have been called\n\t\t * for cs already in update_cpumask(). We should also call\n\t\t * update_tasks_cpumask() again for tasks in the parent\n\t\t * cpuset if the parent's subparts_cpus changes.\n\t\t */\n\t\told_prs = new_prs = cp->partition_root_state;\n\t\tif ((cp != cs) && old_prs) {\n\t\t\tswitch (parent->partition_root_state) {\n\t\t\tcase PRS_DISABLED:\n\t\t\t\t/*\n\t\t\t\t * If parent is not a partition root or an\n\t\t\t\t * invalid partition root, clear its state\n\t\t\t\t * and its CS_CPU_EXCLUSIVE flag.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(cp->partition_root_state\n\t\t\t\t\t     != PRS_ERROR);\n\t\t\t\tnew_prs = PRS_DISABLED;\n\n\t\t\t\t/*\n\t\t\t\t * clear_bit() is an atomic operation and\n\t\t\t\t * readers aren't interested in the state\n\t\t\t\t * of CS_CPU_EXCLUSIVE anyway. So we can\n\t\t\t\t * just update the flag without holding\n\t\t\t\t * the callback_lock.\n\t\t\t\t */\n\t\t\t\tclear_bit(CS_CPU_EXCLUSIVE, &cp->flags);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ENABLED:\n\t\t\t\tif (update_parent_subparts_cpumask(cp, partcmd_update, NULL, tmp))\n\t\t\t\t\tupdate_tasks_cpumask(parent);\n\t\t\t\tbreak;\n\n\t\t\tcase PRS_ERROR:\n\t\t\t\t/*\n\t\t\t\t * When parent is invalid, it has to be too.\n\t\t\t\t */\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!css_tryget_online(&cp->css))\n\t\t\tcontinue;\n\t\trcu_read_unlock();\n\n\t\tspin_lock_irq(&callback_lock);\n\n\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\tif (cp->nr_subparts_cpus && (new_prs != PRS_ENABLED)) {\n\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t} else if (cp->nr_subparts_cpus) {\n\t\t\t/*\n\t\t\t * Make sure that effective_cpus & subparts_cpus\n\t\t\t * are mutually exclusive.\n\t\t\t *\n\t\t\t * In the unlikely event that effective_cpus\n\t\t\t * becomes empty. we clear cp->nr_subparts_cpus and\n\t\t\t * let its child partition roots to compete for\n\t\t\t * CPUs again.\n\t\t\t */\n\t\t\tcpumask_andnot(cp->effective_cpus, cp->effective_cpus,\n\t\t\t\t       cp->subparts_cpus);\n\t\t\tif (cpumask_empty(cp->effective_cpus)) {\n\t\t\t\tcpumask_copy(cp->effective_cpus, tmp->new_cpus);\n\t\t\t\tcpumask_clear(cp->subparts_cpus);\n\t\t\t\tcp->nr_subparts_cpus = 0;\n\t\t\t} else if (!cpumask_subset(cp->subparts_cpus,\n\t\t\t\t\t\t   tmp->new_cpus)) {\n\t\t\t\tcpumask_andnot(cp->subparts_cpus,\n\t\t\t\t\tcp->subparts_cpus, tmp->new_cpus);\n\t\t\t\tcp->nr_subparts_cpus\n\t\t\t\t\t= cpumask_weight(cp->subparts_cpus);\n\t\t\t}\n\t\t}\n\n\t\tif (new_prs != old_prs)\n\t\t\tcp->partition_root_state = new_prs;\n\n\t\tspin_unlock_irq(&callback_lock);\n\t\tnotify_partition_change(cp, old_prs, new_prs);\n\n\t\tWARN_ON(!is_in_v2_mode() &&\n\t\t\t!cpumask_equal(cp->cpus_allowed, cp->effective_cpus));\n\n\t\tupdate_tasks_cpumask(cp);\n\n\t\t/*\n\t\t * On legacy hierarchy, if the effective cpumask of any non-\n\t\t * empty cpuset is changed, we need to rebuild sched domains.\n\t\t * On default hierarchy, the cpuset needs to be a partition\n\t\t * root as well.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    is_sched_load_balance(cp) &&\n\t\t   (!cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t\t    is_partition_root(cp)))\n\t\t\tneed_rebuild_sched_domains = true;\n\n\t\trcu_read_lock();\n\t\tcss_put(&cp->css);\n\t}\n\trcu_read_unlock();\n\n\tif (need_rebuild_sched_domains)\n\t\trebuild_sched_domains_locked();\n}"
  },
  {
    "function_name": "update_parent_subparts_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1182-1350",
    "snippet": "static int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,\n\t\t\t\t\t  struct cpumask *newmask,\n\t\t\t\t\t  struct tmpmasks *tmp)\n{\n\tstruct cpuset *parent = parent_cs(cpuset);\n\tint adding;\t/* Moving cpus from effective_cpus to subparts_cpus */\n\tint deleting;\t/* Moving cpus from subparts_cpus to effective_cpus */\n\tint old_prs, new_prs;\n\tbool part_error = false;\t/* Partition error? */\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * The parent must be a partition root.\n\t * The new cpumask, if present, or the current cpus_allowed must\n\t * not be empty.\n\t */\n\tif (!is_partition_root(parent) ||\n\t   (newmask && cpumask_empty(newmask)) ||\n\t   (!newmask && cpumask_empty(cpuset->cpus_allowed)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Enabling/disabling partition root is not allowed if there are\n\t * online children.\n\t */\n\tif ((cmd != partcmd_update) && css_has_online_children(&cpuset->css))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Enabling partition root is not allowed if not all the CPUs\n\t * can be granted from parent's effective_cpus or at least one\n\t * CPU will be left after that.\n\t */\n\tif ((cmd == partcmd_enable) &&\n\t   (!cpumask_subset(cpuset->cpus_allowed, parent->effective_cpus) ||\n\t     cpumask_equal(cpuset->cpus_allowed, parent->effective_cpus)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * A cpumask update cannot make parent's effective_cpus become empty.\n\t */\n\tadding = deleting = false;\n\told_prs = new_prs = cpuset->partition_root_state;\n\tif (cmd == partcmd_enable) {\n\t\tcpumask_copy(tmp->addmask, cpuset->cpus_allowed);\n\t\tadding = true;\n\t} else if (cmd == partcmd_disable) {\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t} else if (newmask) {\n\t\t/*\n\t\t * partcmd_update with newmask:\n\t\t *\n\t\t * delmask = cpus_allowed & ~newmask & parent->subparts_cpus\n\t\t * addmask = newmask & parent->effective_cpus\n\t\t *\t\t     & ~parent->subparts_cpus\n\t\t */\n\t\tcpumask_andnot(tmp->delmask, cpuset->cpus_allowed, newmask);\n\t\tdeleting = cpumask_and(tmp->delmask, tmp->delmask,\n\t\t\t\t       parent->subparts_cpus);\n\n\t\tcpumask_and(tmp->addmask, newmask, parent->effective_cpus);\n\t\tadding = cpumask_andnot(tmp->addmask, tmp->addmask,\n\t\t\t\t\tparent->subparts_cpus);\n\t\t/*\n\t\t * Return error if the new effective_cpus could become empty.\n\t\t */\n\t\tif (adding &&\n\t\t    cpumask_equal(parent->effective_cpus, tmp->addmask)) {\n\t\t\tif (!deleting)\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * As some of the CPUs in subparts_cpus might have\n\t\t\t * been offlined, we need to compute the real delmask\n\t\t\t * to confirm that.\n\t\t\t */\n\t\t\tif (!cpumask_and(tmp->addmask, tmp->delmask,\n\t\t\t\t\t cpu_active_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tcpumask_copy(tmp->addmask, parent->effective_cpus);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * partcmd_update w/o newmask:\n\t\t *\n\t\t * addmask = cpus_allowed & parent->effective_cpus\n\t\t *\n\t\t * Note that parent's subparts_cpus may have been\n\t\t * pre-shrunk in case there is a change in the cpu list.\n\t\t * So no deletion is needed.\n\t\t */\n\t\tadding = cpumask_and(tmp->addmask, cpuset->cpus_allowed,\n\t\t\t\t     parent->effective_cpus);\n\t\tpart_error = cpumask_equal(tmp->addmask,\n\t\t\t\t\t   parent->effective_cpus);\n\t}\n\n\tif (cmd == partcmd_update) {\n\t\tint prev_prs = cpuset->partition_root_state;\n\n\t\t/*\n\t\t * Check for possible transition between PRS_ENABLED\n\t\t * and PRS_ERROR.\n\t\t */\n\t\tswitch (cpuset->partition_root_state) {\n\t\tcase PRS_ENABLED:\n\t\t\tif (part_error)\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\tbreak;\n\t\tcase PRS_ERROR:\n\t\t\tif (!part_error)\n\t\t\t\tnew_prs = PRS_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Set part_error if previously in invalid state.\n\t\t */\n\t\tpart_error = (prev_prs == PRS_ERROR);\n\t}\n\n\tif (!part_error && (new_prs == PRS_ERROR))\n\t\treturn 0;\t/* Nothing need to be done */\n\n\tif (new_prs == PRS_ERROR) {\n\t\t/*\n\t\t * Remove all its cpus from parent's subparts_cpus.\n\t\t */\n\t\tadding = false;\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t}\n\n\tif (!adding && !deleting && (new_prs == old_prs))\n\t\treturn 0;\n\n\t/*\n\t * Change the parent's subparts_cpus.\n\t * Newly added CPUs will be removed from effective_cpus and\n\t * newly deleted ones will be added back to effective_cpus.\n\t */\n\tspin_lock_irq(&callback_lock);\n\tif (adding) {\n\t\tcpumask_or(parent->subparts_cpus,\n\t\t\t   parent->subparts_cpus, tmp->addmask);\n\t\tcpumask_andnot(parent->effective_cpus,\n\t\t\t       parent->effective_cpus, tmp->addmask);\n\t}\n\tif (deleting) {\n\t\tcpumask_andnot(parent->subparts_cpus,\n\t\t\t       parent->subparts_cpus, tmp->delmask);\n\t\t/*\n\t\t * Some of the CPUs in subparts_cpus might have been offlined.\n\t\t */\n\t\tcpumask_and(tmp->delmask, tmp->delmask, cpu_active_mask);\n\t\tcpumask_or(parent->effective_cpus,\n\t\t\t   parent->effective_cpus, tmp->delmask);\n\t}\n\n\tparent->nr_subparts_cpus = cpumask_weight(parent->subparts_cpus);\n\n\tif (old_prs != new_prs)\n\t\tcpuset->partition_root_state = new_prs;\n\n\tspin_unlock_irq(&callback_lock);\n\tnotify_partition_change(cpuset, old_prs, new_prs);\n\n\treturn cmd == partcmd_update;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [
      "#define PRS_ERROR\t\t-1",
      "#define PRS_ENABLED\t\t1"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(callback_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "notify_partition_change",
          "args": [
            "cpuset",
            "old_prs",
            "new_prs"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "notify_partition_change",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "279-284",
          "snippet": "static inline void notify_partition_change(struct cpuset *cs,\n\t\t\t\t\t   int old_prs, int new_prs)\n{\n\tif (old_prs != new_prs)\n\t\tcgroup_file_notify(&cs->partition_file);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void notify_partition_change(struct cpuset *cs,\n\t\t\t\t\t   int old_prs, int new_prs)\n{\n\tif (old_prs != new_prs)\n\t\tcgroup_file_notify(&cs->partition_file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "parent->subparts_cpus"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "parent->effective_cpus",
            "parent->effective_cpus",
            "tmp->delmask"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmp->delmask",
            "tmp->delmask",
            "cpu_active_mask"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "parent->subparts_cpus",
            "parent->subparts_cpus",
            "tmp->delmask"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "parent->effective_cpus",
            "parent->effective_cpus",
            "tmp->addmask"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "parent->subparts_cpus",
            "parent->subparts_cpus",
            "tmp->addmask"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&callback_lock"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "293-300",
          "snippet": "static inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_lock_irqsave(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__bpf_spin_lock(lock);\n\t__this_cpu_write(irqsave_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmp->delmask",
            "cpuset->cpus_allowed",
            "parent->subparts_cpus"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "tmp->addmask",
            "parent->effective_cpus"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmp->addmask",
            "cpuset->cpus_allowed",
            "parent->effective_cpus"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "tmp->addmask",
            "parent->effective_cpus"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmp->addmask",
            "tmp->delmask",
            "cpu_active_mask"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "parent->effective_cpus",
            "tmp->addmask"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "tmp->addmask",
            "tmp->addmask",
            "parent->subparts_cpus"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmp->addmask",
            "newmask",
            "parent->effective_cpus"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmp->delmask",
            "tmp->delmask",
            "parent->subparts_cpus"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "tmp->delmask",
            "cpuset->cpus_allowed",
            "newmask"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "tmp->delmask",
            "cpuset->cpus_allowed",
            "parent->subparts_cpus"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "tmp->addmask",
            "cpuset->cpus_allowed"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "cpuset->cpus_allowed",
            "parent->effective_cpus"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "cpuset->cpus_allowed",
            "parent->effective_cpus"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_has_online_children",
          "args": [
            "&cpuset->css"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpuset->cpus_allowed"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "newmask"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_partition_root",
          "args": [
            "parent"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "is_partition_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "271-274",
          "snippet": "static inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_rwsem_assert_held",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cpuset"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\n#define PRS_ERROR\t\t-1\n#define PRS_ENABLED\t\t1\n\nstatic DEFINE_SPINLOCK(callback_lock);\n\nstatic int update_parent_subparts_cpumask(struct cpuset *cpuset, int cmd,\n\t\t\t\t\t  struct cpumask *newmask,\n\t\t\t\t\t  struct tmpmasks *tmp)\n{\n\tstruct cpuset *parent = parent_cs(cpuset);\n\tint adding;\t/* Moving cpus from effective_cpus to subparts_cpus */\n\tint deleting;\t/* Moving cpus from subparts_cpus to effective_cpus */\n\tint old_prs, new_prs;\n\tbool part_error = false;\t/* Partition error? */\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * The parent must be a partition root.\n\t * The new cpumask, if present, or the current cpus_allowed must\n\t * not be empty.\n\t */\n\tif (!is_partition_root(parent) ||\n\t   (newmask && cpumask_empty(newmask)) ||\n\t   (!newmask && cpumask_empty(cpuset->cpus_allowed)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * Enabling/disabling partition root is not allowed if there are\n\t * online children.\n\t */\n\tif ((cmd != partcmd_update) && css_has_online_children(&cpuset->css))\n\t\treturn -EBUSY;\n\n\t/*\n\t * Enabling partition root is not allowed if not all the CPUs\n\t * can be granted from parent's effective_cpus or at least one\n\t * CPU will be left after that.\n\t */\n\tif ((cmd == partcmd_enable) &&\n\t   (!cpumask_subset(cpuset->cpus_allowed, parent->effective_cpus) ||\n\t     cpumask_equal(cpuset->cpus_allowed, parent->effective_cpus)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * A cpumask update cannot make parent's effective_cpus become empty.\n\t */\n\tadding = deleting = false;\n\told_prs = new_prs = cpuset->partition_root_state;\n\tif (cmd == partcmd_enable) {\n\t\tcpumask_copy(tmp->addmask, cpuset->cpus_allowed);\n\t\tadding = true;\n\t} else if (cmd == partcmd_disable) {\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t} else if (newmask) {\n\t\t/*\n\t\t * partcmd_update with newmask:\n\t\t *\n\t\t * delmask = cpus_allowed & ~newmask & parent->subparts_cpus\n\t\t * addmask = newmask & parent->effective_cpus\n\t\t *\t\t     & ~parent->subparts_cpus\n\t\t */\n\t\tcpumask_andnot(tmp->delmask, cpuset->cpus_allowed, newmask);\n\t\tdeleting = cpumask_and(tmp->delmask, tmp->delmask,\n\t\t\t\t       parent->subparts_cpus);\n\n\t\tcpumask_and(tmp->addmask, newmask, parent->effective_cpus);\n\t\tadding = cpumask_andnot(tmp->addmask, tmp->addmask,\n\t\t\t\t\tparent->subparts_cpus);\n\t\t/*\n\t\t * Return error if the new effective_cpus could become empty.\n\t\t */\n\t\tif (adding &&\n\t\t    cpumask_equal(parent->effective_cpus, tmp->addmask)) {\n\t\t\tif (!deleting)\n\t\t\t\treturn -EINVAL;\n\t\t\t/*\n\t\t\t * As some of the CPUs in subparts_cpus might have\n\t\t\t * been offlined, we need to compute the real delmask\n\t\t\t * to confirm that.\n\t\t\t */\n\t\t\tif (!cpumask_and(tmp->addmask, tmp->delmask,\n\t\t\t\t\t cpu_active_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tcpumask_copy(tmp->addmask, parent->effective_cpus);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * partcmd_update w/o newmask:\n\t\t *\n\t\t * addmask = cpus_allowed & parent->effective_cpus\n\t\t *\n\t\t * Note that parent's subparts_cpus may have been\n\t\t * pre-shrunk in case there is a change in the cpu list.\n\t\t * So no deletion is needed.\n\t\t */\n\t\tadding = cpumask_and(tmp->addmask, cpuset->cpus_allowed,\n\t\t\t\t     parent->effective_cpus);\n\t\tpart_error = cpumask_equal(tmp->addmask,\n\t\t\t\t\t   parent->effective_cpus);\n\t}\n\n\tif (cmd == partcmd_update) {\n\t\tint prev_prs = cpuset->partition_root_state;\n\n\t\t/*\n\t\t * Check for possible transition between PRS_ENABLED\n\t\t * and PRS_ERROR.\n\t\t */\n\t\tswitch (cpuset->partition_root_state) {\n\t\tcase PRS_ENABLED:\n\t\t\tif (part_error)\n\t\t\t\tnew_prs = PRS_ERROR;\n\t\t\tbreak;\n\t\tcase PRS_ERROR:\n\t\t\tif (!part_error)\n\t\t\t\tnew_prs = PRS_ENABLED;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Set part_error if previously in invalid state.\n\t\t */\n\t\tpart_error = (prev_prs == PRS_ERROR);\n\t}\n\n\tif (!part_error && (new_prs == PRS_ERROR))\n\t\treturn 0;\t/* Nothing need to be done */\n\n\tif (new_prs == PRS_ERROR) {\n\t\t/*\n\t\t * Remove all its cpus from parent's subparts_cpus.\n\t\t */\n\t\tadding = false;\n\t\tdeleting = cpumask_and(tmp->delmask, cpuset->cpus_allowed,\n\t\t\t\t       parent->subparts_cpus);\n\t}\n\n\tif (!adding && !deleting && (new_prs == old_prs))\n\t\treturn 0;\n\n\t/*\n\t * Change the parent's subparts_cpus.\n\t * Newly added CPUs will be removed from effective_cpus and\n\t * newly deleted ones will be added back to effective_cpus.\n\t */\n\tspin_lock_irq(&callback_lock);\n\tif (adding) {\n\t\tcpumask_or(parent->subparts_cpus,\n\t\t\t   parent->subparts_cpus, tmp->addmask);\n\t\tcpumask_andnot(parent->effective_cpus,\n\t\t\t       parent->effective_cpus, tmp->addmask);\n\t}\n\tif (deleting) {\n\t\tcpumask_andnot(parent->subparts_cpus,\n\t\t\t       parent->subparts_cpus, tmp->delmask);\n\t\t/*\n\t\t * Some of the CPUs in subparts_cpus might have been offlined.\n\t\t */\n\t\tcpumask_and(tmp->delmask, tmp->delmask, cpu_active_mask);\n\t\tcpumask_or(parent->effective_cpus,\n\t\t\t   parent->effective_cpus, tmp->delmask);\n\t}\n\n\tparent->nr_subparts_cpus = cpumask_weight(parent->subparts_cpus);\n\n\tif (old_prs != new_prs)\n\t\tcpuset->partition_root_state = new_prs;\n\n\tspin_unlock_irq(&callback_lock);\n\tnotify_partition_change(cpuset, old_prs, new_prs);\n\n\treturn cmd == partcmd_update;\n}"
  },
  {
    "function_name": "compute_effective_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1118-1129",
    "snippet": "static void compute_effective_cpumask(struct cpumask *new_cpus,\n\t\t\t\t      struct cpuset *cs, struct cpuset *parent)\n{\n\tif (parent->nr_subparts_cpus) {\n\t\tcpumask_or(new_cpus, parent->effective_cpus,\n\t\t\t   parent->subparts_cpus);\n\t\tcpumask_and(new_cpus, new_cpus, cs->cpus_allowed);\n\t\tcpumask_and(new_cpus, new_cpus, cpu_active_mask);\n\t} else {\n\t\tcpumask_and(new_cpus, cs->cpus_allowed, parent->effective_cpus);\n\t}\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "new_cpus",
            "cs->cpus_allowed",
            "parent->effective_cpus"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "new_cpus",
            "new_cpus",
            "cpu_active_mask"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "new_cpus",
            "new_cpus",
            "cs->cpus_allowed"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "new_cpus",
            "parent->effective_cpus",
            "parent->subparts_cpus"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void compute_effective_cpumask(struct cpumask *new_cpus,\n\t\t\t\t      struct cpuset *cs, struct cpuset *parent)\n{\n\tif (parent->nr_subparts_cpus) {\n\t\tcpumask_or(new_cpus, parent->effective_cpus,\n\t\t\t   parent->subparts_cpus);\n\t\tcpumask_and(new_cpus, new_cpus, cs->cpus_allowed);\n\t\tcpumask_and(new_cpus, new_cpus, cpu_active_mask);\n\t} else {\n\t\tcpumask_and(new_cpus, cs->cpus_allowed, parent->effective_cpus);\n\t}\n}"
  },
  {
    "function_name": "update_tasks_cpumask",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1096-1105",
    "snippet": "static void update_tasks_cpumask(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tset_cpus_allowed_ptr(task, cs->effective_cpus);\n\tcss_task_iter_end(&it);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "task",
            "cs->effective_cpus"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&cs->css",
            "0",
            "&it"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_tasks_cpumask(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\twhile ((task = css_task_iter_next(&it)))\n\t\tset_cpus_allowed_ptr(task, cs->effective_cpus);\n\tcss_task_iter_end(&it);\n}"
  },
  {
    "function_name": "rebuild_sched_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1079-1086",
    "snippet": "void rebuild_sched_domains(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\trebuild_sched_domains_locked();\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuild_sched_domains_locked",
          "args": [],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_sched_domains_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1074-1076",
          "snippet": "static void rebuild_sched_domains_locked(void)\n{\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void rebuild_sched_domains_locked(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid rebuild_sched_domains(void)\n{\n\tcpus_read_lock();\n\tpercpu_down_write(&cpuset_rwsem);\n\trebuild_sched_domains_locked();\n\tpercpu_up_write(&cpuset_rwsem);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "rebuild_sched_domains_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1074-1076",
    "snippet": "static void rebuild_sched_domains_locked(void)\n{\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void rebuild_sched_domains_locked(void)\n{\n}"
  },
  {
    "function_name": "rebuild_sched_domains_locked",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1022-1072",
    "snippet": "static void rebuild_sched_domains_locked(void)\n{\n\tstruct cgroup_subsys_state *pos_css;\n\tstruct sched_domain_attr *attr;\n\tcpumask_var_t *doms;\n\tstruct cpuset *cs;\n\tint ndoms;\n\n\tlockdep_assert_cpus_held();\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * If we have raced with CPU hotplug, return early to avoid\n\t * passing doms with offlined cpu to partition_sched_domains().\n\t * Anyways, cpuset_hotplug_workfn() will rebuild sched domains.\n\t *\n\t * With no CPUs in any subpartitions, top_cpuset's effective CPUs\n\t * should be the same as the active CPUs, so checking only top_cpuset\n\t * is enough to detect racing CPU offlines.\n\t */\n\tif (!top_cpuset.nr_subparts_cpus &&\n\t    !cpumask_equal(top_cpuset.effective_cpus, cpu_active_mask))\n\t\treturn;\n\n\t/*\n\t * With subpartition CPUs, however, the effective CPUs of a partition\n\t * root should be only a subset of the active CPUs.  Since a CPU in any\n\t * partition root could be offlined, all must be checked.\n\t */\n\tif (top_cpuset.nr_subparts_cpus) {\n\t\trcu_read_lock();\n\t\tcpuset_for_each_descendant_pre(cs, pos_css, &top_cpuset) {\n\t\t\tif (!is_partition_root(cs)) {\n\t\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!cpumask_subset(cs->effective_cpus,\n\t\t\t\t\t    cpu_active_mask)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\t/* Generate domain masks and attrs */\n\tndoms = generate_sched_domains(&doms, &attr);\n\n\t/* Have scheduler rebuild the domains */\n\tpartition_and_rebuild_sched_domains(ndoms, doms, attr);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};",
      "static DECLARE_WORK(cpuset_hotplug_work, cpuset_hotplug_workfn);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "partition_and_rebuild_sched_domains",
          "args": [
            "ndoms",
            "doms",
            "attr"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "partition_and_rebuild_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "1001-1009",
          "snippet": "static void\npartition_and_rebuild_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tmutex_lock(&sched_domains_mutex);\n\tpartition_sched_domains_locked(ndoms_new, doms_new, dattr_new);\n\trebuild_root_domains();\n\tmutex_unlock(&sched_domains_mutex);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void\npartition_and_rebuild_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tmutex_lock(&sched_domains_mutex);\n\tpartition_sched_domains_locked(ndoms_new, doms_new, dattr_new);\n\trebuild_root_domains();\n\tmutex_unlock(&sched_domains_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generate_sched_domains",
          "args": [
            "&doms",
            "&attr"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "generate_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "775-950",
          "snippet": "static int generate_sched_domains(cpumask_var_t **domains,\n\t\t\tstruct sched_domain_attr **attributes)\n{\n\tstruct cpuset *cp;\t/* top-down scan of cpusets */\n\tstruct cpuset **csa;\t/* array of all cpuset ptrs */\n\tint csn;\t\t/* how many cpuset ptrs in csa so far */\n\tint i, j, k;\t\t/* indices for partition finding loops */\n\tcpumask_var_t *doms;\t/* resulting partition; i.e. sched domains */\n\tstruct sched_domain_attr *dattr;  /* attributes for custom domains */\n\tint ndoms = 0;\t\t/* number of sched domains in result */\n\tint nslot;\t\t/* next empty doms[] struct cpumask slot */\n\tstruct cgroup_subsys_state *pos_css;\n\tbool root_load_balance = is_sched_load_balance(&top_cpuset);\n\n\tdoms = NULL;\n\tdattr = NULL;\n\tcsa = NULL;\n\n\t/* Special case for the 99% of systems with one, full, sched domain */\n\tif (root_load_balance && !top_cpuset.nr_subparts_cpus) {\n\t\tndoms = 1;\n\t\tdoms = alloc_sched_domains(ndoms);\n\t\tif (!doms)\n\t\t\tgoto done;\n\n\t\tdattr = kmalloc(sizeof(struct sched_domain_attr), GFP_KERNEL);\n\t\tif (dattr) {\n\t\t\t*dattr = SD_ATTR_INIT;\n\t\t\tupdate_domain_attr_tree(dattr, &top_cpuset);\n\t\t}\n\t\tcpumask_and(doms[0], top_cpuset.effective_cpus,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\n\t\tgoto done;\n\t}\n\n\tcsa = kmalloc_array(nr_cpusets(), sizeof(cp), GFP_KERNEL);\n\tif (!csa)\n\t\tgoto done;\n\tcsn = 0;\n\n\trcu_read_lock();\n\tif (root_load_balance)\n\t\tcsa[csn++] = &top_cpuset;\n\tcpuset_for_each_descendant_pre(cp, pos_css, &top_cpuset) {\n\t\tif (cp == &top_cpuset)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Continue traversing beyond @cp iff @cp has some CPUs and\n\t\t * isn't load balancing.  The former is obvious.  The\n\t\t * latter: All child cpusets contain a subset of the\n\t\t * parent's cpus, so just skip them, and then we call\n\t\t * update_domain_attr_tree() to calc relax_domain_level of\n\t\t * the corresponding sched domain.\n\t\t *\n\t\t * If root is load-balancing, we can skip @cp if it\n\t\t * is a subset of the root's effective_cpus.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    !(is_sched_load_balance(cp) &&\n\t\t      cpumask_intersects(cp->cpus_allowed,\n\t\t\t\t\t housekeeping_cpumask(HK_FLAG_DOMAIN))))\n\t\t\tcontinue;\n\n\t\tif (root_load_balance &&\n\t\t    cpumask_subset(cp->cpus_allowed, top_cpuset.effective_cpus))\n\t\t\tcontinue;\n\n\t\tif (is_sched_load_balance(cp) &&\n\t\t    !cpumask_empty(cp->effective_cpus))\n\t\t\tcsa[csn++] = cp;\n\n\t\t/* skip @cp's subtree if not a partition root */\n\t\tif (!is_partition_root(cp))\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t}\n\trcu_read_unlock();\n\n\tfor (i = 0; i < csn; i++)\n\t\tcsa[i]->pn = i;\n\tndoms = csn;\n\nrestart:\n\t/* Find the best partition (set of sched domains) */\n\tfor (i = 0; i < csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tint apn = a->pn;\n\n\t\tfor (j = 0; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\t\t\tint bpn = b->pn;\n\n\t\t\tif (apn != bpn && cpusets_overlap(a, b)) {\n\t\t\t\tfor (k = 0; k < csn; k++) {\n\t\t\t\t\tstruct cpuset *c = csa[k];\n\n\t\t\t\t\tif (c->pn == bpn)\n\t\t\t\t\t\tc->pn = apn;\n\t\t\t\t}\n\t\t\t\tndoms--;\t/* one less element */\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now we know how many domains to create.\n\t * Convert <csn, csa> to <ndoms, doms> and populate cpu masks.\n\t */\n\tdoms = alloc_sched_domains(ndoms);\n\tif (!doms)\n\t\tgoto done;\n\n\t/*\n\t * The rest of the code, including the scheduler, can deal with\n\t * dattr==NULL case. No need to abort if alloc fails.\n\t */\n\tdattr = kmalloc_array(ndoms, sizeof(struct sched_domain_attr),\n\t\t\t      GFP_KERNEL);\n\n\tfor (nslot = 0, i = 0; i < csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tstruct cpumask *dp;\n\t\tint apn = a->pn;\n\n\t\tif (apn < 0) {\n\t\t\t/* Skip completed partitions */\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp = doms[nslot];\n\n\t\tif (nslot == ndoms) {\n\t\t\tstatic int warnings = 10;\n\t\t\tif (warnings) {\n\t\t\t\tpr_warn(\"rebuild_sched_domains confused: nslot %d, ndoms %d, csn %d, i %d, apn %d\\n\",\n\t\t\t\t\tnslot, ndoms, csn, i, apn);\n\t\t\t\twarnings--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpumask_clear(dp);\n\t\tif (dattr)\n\t\t\t*(dattr + nslot) = SD_ATTR_INIT;\n\t\tfor (j = i; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\n\t\t\tif (apn == b->pn) {\n\t\t\t\tcpumask_or(dp, dp, b->effective_cpus);\n\t\t\t\tcpumask_and(dp, dp, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t\t\tif (dattr)\n\t\t\t\t\tupdate_domain_attr_tree(dattr + nslot, b);\n\n\t\t\t\t/* Done with this partition */\n\t\t\t\tb->pn = -1;\n\t\t\t}\n\t\t}\n\t\tnslot++;\n\t}\n\tBUG_ON(nslot != ndoms);\n\ndone:\n\tkfree(csa);\n\n\t/*\n\t * Fallback to the default domain if kmalloc() failed.\n\t * See comments in partition_sched_domains().\n\t */\n\tif (doms == NULL)\n\t\tndoms = 1;\n\n\t*domains    = doms;\n\t*attributes = dattr;\n\treturn ndoms;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\n\nstatic int generate_sched_domains(cpumask_var_t **domains,\n\t\t\tstruct sched_domain_attr **attributes)\n{\n\tstruct cpuset *cp;\t/* top-down scan of cpusets */\n\tstruct cpuset **csa;\t/* array of all cpuset ptrs */\n\tint csn;\t\t/* how many cpuset ptrs in csa so far */\n\tint i, j, k;\t\t/* indices for partition finding loops */\n\tcpumask_var_t *doms;\t/* resulting partition; i.e. sched domains */\n\tstruct sched_domain_attr *dattr;  /* attributes for custom domains */\n\tint ndoms = 0;\t\t/* number of sched domains in result */\n\tint nslot;\t\t/* next empty doms[] struct cpumask slot */\n\tstruct cgroup_subsys_state *pos_css;\n\tbool root_load_balance = is_sched_load_balance(&top_cpuset);\n\n\tdoms = NULL;\n\tdattr = NULL;\n\tcsa = NULL;\n\n\t/* Special case for the 99% of systems with one, full, sched domain */\n\tif (root_load_balance && !top_cpuset.nr_subparts_cpus) {\n\t\tndoms = 1;\n\t\tdoms = alloc_sched_domains(ndoms);\n\t\tif (!doms)\n\t\t\tgoto done;\n\n\t\tdattr = kmalloc(sizeof(struct sched_domain_attr), GFP_KERNEL);\n\t\tif (dattr) {\n\t\t\t*dattr = SD_ATTR_INIT;\n\t\t\tupdate_domain_attr_tree(dattr, &top_cpuset);\n\t\t}\n\t\tcpumask_and(doms[0], top_cpuset.effective_cpus,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\n\t\tgoto done;\n\t}\n\n\tcsa = kmalloc_array(nr_cpusets(), sizeof(cp), GFP_KERNEL);\n\tif (!csa)\n\t\tgoto done;\n\tcsn = 0;\n\n\trcu_read_lock();\n\tif (root_load_balance)\n\t\tcsa[csn++] = &top_cpuset;\n\tcpuset_for_each_descendant_pre(cp, pos_css, &top_cpuset) {\n\t\tif (cp == &top_cpuset)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Continue traversing beyond @cp iff @cp has some CPUs and\n\t\t * isn't load balancing.  The former is obvious.  The\n\t\t * latter: All child cpusets contain a subset of the\n\t\t * parent's cpus, so just skip them, and then we call\n\t\t * update_domain_attr_tree() to calc relax_domain_level of\n\t\t * the corresponding sched domain.\n\t\t *\n\t\t * If root is load-balancing, we can skip @cp if it\n\t\t * is a subset of the root's effective_cpus.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    !(is_sched_load_balance(cp) &&\n\t\t      cpumask_intersects(cp->cpus_allowed,\n\t\t\t\t\t housekeeping_cpumask(HK_FLAG_DOMAIN))))\n\t\t\tcontinue;\n\n\t\tif (root_load_balance &&\n\t\t    cpumask_subset(cp->cpus_allowed, top_cpuset.effective_cpus))\n\t\t\tcontinue;\n\n\t\tif (is_sched_load_balance(cp) &&\n\t\t    !cpumask_empty(cp->effective_cpus))\n\t\t\tcsa[csn++] = cp;\n\n\t\t/* skip @cp's subtree if not a partition root */\n\t\tif (!is_partition_root(cp))\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t}\n\trcu_read_unlock();\n\n\tfor (i = 0; i < csn; i++)\n\t\tcsa[i]->pn = i;\n\tndoms = csn;\n\nrestart:\n\t/* Find the best partition (set of sched domains) */\n\tfor (i = 0; i < csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tint apn = a->pn;\n\n\t\tfor (j = 0; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\t\t\tint bpn = b->pn;\n\n\t\t\tif (apn != bpn && cpusets_overlap(a, b)) {\n\t\t\t\tfor (k = 0; k < csn; k++) {\n\t\t\t\t\tstruct cpuset *c = csa[k];\n\n\t\t\t\t\tif (c->pn == bpn)\n\t\t\t\t\t\tc->pn = apn;\n\t\t\t\t}\n\t\t\t\tndoms--;\t/* one less element */\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now we know how many domains to create.\n\t * Convert <csn, csa> to <ndoms, doms> and populate cpu masks.\n\t */\n\tdoms = alloc_sched_domains(ndoms);\n\tif (!doms)\n\t\tgoto done;\n\n\t/*\n\t * The rest of the code, including the scheduler, can deal with\n\t * dattr==NULL case. No need to abort if alloc fails.\n\t */\n\tdattr = kmalloc_array(ndoms, sizeof(struct sched_domain_attr),\n\t\t\t      GFP_KERNEL);\n\n\tfor (nslot = 0, i = 0; i < csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tstruct cpumask *dp;\n\t\tint apn = a->pn;\n\n\t\tif (apn < 0) {\n\t\t\t/* Skip completed partitions */\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp = doms[nslot];\n\n\t\tif (nslot == ndoms) {\n\t\t\tstatic int warnings = 10;\n\t\t\tif (warnings) {\n\t\t\t\tpr_warn(\"rebuild_sched_domains confused: nslot %d, ndoms %d, csn %d, i %d, apn %d\\n\",\n\t\t\t\t\tnslot, ndoms, csn, i, apn);\n\t\t\t\twarnings--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpumask_clear(dp);\n\t\tif (dattr)\n\t\t\t*(dattr + nslot) = SD_ATTR_INIT;\n\t\tfor (j = i; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\n\t\t\tif (apn == b->pn) {\n\t\t\t\tcpumask_or(dp, dp, b->effective_cpus);\n\t\t\t\tcpumask_and(dp, dp, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t\t\tif (dattr)\n\t\t\t\t\tupdate_domain_attr_tree(dattr + nslot, b);\n\n\t\t\t\t/* Done with this partition */\n\t\t\t\tb->pn = -1;\n\t\t\t}\n\t\t}\n\t\tnslot++;\n\t}\n\tBUG_ON(nslot != ndoms);\n\ndone:\n\tkfree(csa);\n\n\t/*\n\t * Fallback to the default domain if kmalloc() failed.\n\t * See comments in partition_sched_domains().\n\t */\n\tif (doms == NULL)\n\t\tndoms = 1;\n\n\t*domains    = doms;\n\t*attributes = dattr;\n\treturn ndoms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "cs->effective_cpus",
            "cpu_active_mask"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_rightmost_descendant",
          "args": [
            "pos_css"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_partition_root",
          "args": [
            "cs"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "is_partition_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "271-274",
          "snippet": "static inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_for_each_descendant_pre",
          "args": [
            "cs",
            "pos_css",
            "&top_cpuset"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_equal",
          "args": [
            "top_cpuset.effective_cpus",
            "cpu_active_mask"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_rwsem_assert_held",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "335-347",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\nstatic DECLARE_WORK(cpuset_hotplug_work, cpuset_hotplug_workfn);\n\nstatic void rebuild_sched_domains_locked(void)\n{\n\tstruct cgroup_subsys_state *pos_css;\n\tstruct sched_domain_attr *attr;\n\tcpumask_var_t *doms;\n\tstruct cpuset *cs;\n\tint ndoms;\n\n\tlockdep_assert_cpus_held();\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\n\t/*\n\t * If we have raced with CPU hotplug, return early to avoid\n\t * passing doms with offlined cpu to partition_sched_domains().\n\t * Anyways, cpuset_hotplug_workfn() will rebuild sched domains.\n\t *\n\t * With no CPUs in any subpartitions, top_cpuset's effective CPUs\n\t * should be the same as the active CPUs, so checking only top_cpuset\n\t * is enough to detect racing CPU offlines.\n\t */\n\tif (!top_cpuset.nr_subparts_cpus &&\n\t    !cpumask_equal(top_cpuset.effective_cpus, cpu_active_mask))\n\t\treturn;\n\n\t/*\n\t * With subpartition CPUs, however, the effective CPUs of a partition\n\t * root should be only a subset of the active CPUs.  Since a CPU in any\n\t * partition root could be offlined, all must be checked.\n\t */\n\tif (top_cpuset.nr_subparts_cpus) {\n\t\trcu_read_lock();\n\t\tcpuset_for_each_descendant_pre(cs, pos_css, &top_cpuset) {\n\t\t\tif (!is_partition_root(cs)) {\n\t\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!cpumask_subset(cs->effective_cpus,\n\t\t\t\t\t    cpu_active_mask)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\t/* Generate domain masks and attrs */\n\tndoms = generate_sched_domains(&doms, &attr);\n\n\t/* Have scheduler rebuild the domains */\n\tpartition_and_rebuild_sched_domains(ndoms, doms, attr);\n}"
  },
  {
    "function_name": "partition_and_rebuild_sched_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "1001-1009",
    "snippet": "static void\npartition_and_rebuild_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tmutex_lock(&sched_domains_mutex);\n\tpartition_sched_domains_locked(ndoms_new, doms_new, dattr_new);\n\trebuild_root_domains();\n\tmutex_unlock(&sched_domains_mutex);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rebuild_root_domains",
          "args": [],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "rebuild_root_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "965-999",
          "snippet": "static void rebuild_root_domains(void)\n{\n\tstruct cpuset *cs = NULL;\n\tstruct cgroup_subsys_state *pos_css;\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\tlockdep_assert_cpus_held();\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\trcu_read_lock();\n\n\t/*\n\t * Clear default root domain DL accounting, it will be computed again\n\t * if a task belongs to it.\n\t */\n\tdl_clear_root_domain(&def_root_domain);\n\n\tcpuset_for_each_descendant_pre(cs, pos_css, &top_cpuset) {\n\n\t\tif (cpumask_empty(cs->effective_cpus)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcss_get(&cs->css);\n\n\t\trcu_read_unlock();\n\n\t\tupdate_tasks_root_domain(cs);\n\n\t\trcu_read_lock();\n\t\tcss_put(&cs->css);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\n\nstatic void rebuild_root_domains(void)\n{\n\tstruct cpuset *cs = NULL;\n\tstruct cgroup_subsys_state *pos_css;\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\tlockdep_assert_cpus_held();\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\trcu_read_lock();\n\n\t/*\n\t * Clear default root domain DL accounting, it will be computed again\n\t * if a task belongs to it.\n\t */\n\tdl_clear_root_domain(&def_root_domain);\n\n\tcpuset_for_each_descendant_pre(cs, pos_css, &top_cpuset) {\n\n\t\tif (cpumask_empty(cs->effective_cpus)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcss_get(&cs->css);\n\n\t\trcu_read_unlock();\n\n\t\tupdate_tasks_root_domain(cs);\n\n\t\trcu_read_lock();\n\t\tcss_put(&cs->css);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "partition_sched_domains_locked",
          "args": [
            "ndoms_new",
            "doms_new",
            "dattr_new"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "partition_sched_domains_locked",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2421-2522",
          "snippet": "void partition_sched_domains_locked(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tbool __maybe_unused has_eas = false;\n\tint i, j, n;\n\tint new_topology;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\t/* Trigger rebuilding CPU capacity asymmetry data */\n\tif (new_topology)\n\t\tasym_cpu_capacity_scan();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j]) &&\n\t\t\t    dattrs_equal(dattr_cur, i, dattr_new, j)) {\n\t\t\t\tstruct root_domain *rd;\n\n\t\t\t\t/*\n\t\t\t\t * This domain won't be destroyed and as such\n\t\t\t\t * its dl_bw->total_bw needs to be cleared.  It\n\t\t\t\t * will be recomputed in function\n\t\t\t\t * update_tasks_root_domain().\n\t\t\t\t */\n\t\t\t\trd = cpu_rq(cpumask_any(doms_cur[i]))->rd;\n\t\t\t\tdl_clear_root_domain(rd);\n\t\t\t\tgoto match1;\n\t\t\t}\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\n\t/* Build perf. domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !sched_energy_update; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    cpu_rq(cpumask_first(doms_cur[j]))->rd->pd) {\n\t\t\t\thas_eas = true;\n\t\t\t\tgoto match3;\n\t\t\t}\n\t\t}\n\t\t/* No match - add perf. domains for a new rd */\n\t\thas_eas |= build_perf_domains(doms_new[i]);\nmatch3:\n\t\t;\n\t}\n\tsched_energy_set(has_eas);\n#endif\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tupdate_sched_domain_debugfs();\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t\t\t\t*doms_cur;",
            "static int\t\t\t\tndoms_cur;",
            "static struct sched_domain_attr\t\t*dattr_cur;",
            "static cpumask_var_t\t\t\tfallback_doms;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\nstatic cpumask_var_t\t\t\t*doms_cur;\nstatic int\t\t\t\tndoms_cur;\nstatic struct sched_domain_attr\t\t*dattr_cur;\nstatic cpumask_var_t\t\t\tfallback_doms;\n\nvoid partition_sched_domains_locked(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tbool __maybe_unused has_eas = false;\n\tint i, j, n;\n\tint new_topology;\n\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\t/* Let the architecture update CPU core mappings: */\n\tnew_topology = arch_update_cpu_topology();\n\t/* Trigger rebuilding CPU capacity asymmetry data */\n\tif (new_topology)\n\t\tasym_cpu_capacity_scan();\n\n\tif (!doms_new) {\n\t\tWARN_ON_ONCE(dattr_new);\n\t\tn = 0;\n\t\tdoms_new = alloc_sched_domains(1);\n\t\tif (doms_new) {\n\t\t\tn = 1;\n\t\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t}\n\t} else {\n\t\tn = ndoms_new;\n\t}\n\n\t/* Destroy deleted domains: */\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j]) &&\n\t\t\t    dattrs_equal(dattr_cur, i, dattr_new, j)) {\n\t\t\t\tstruct root_domain *rd;\n\n\t\t\t\t/*\n\t\t\t\t * This domain won't be destroyed and as such\n\t\t\t\t * its dl_bw->total_bw needs to be cleared.  It\n\t\t\t\t * will be recomputed in function\n\t\t\t\t * update_tasks_root_domain().\n\t\t\t\t */\n\t\t\t\trd = cpu_rq(cpumask_any(doms_cur[i]))->rd;\n\t\t\t\tdl_clear_root_domain(rd);\n\t\t\t\tgoto match1;\n\t\t\t}\n\t\t}\n\t\t/* No match - a current sched domain not in new doms_new[] */\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (!doms_new) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_and(doms_new[0], cpu_active_mask,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t}\n\n\t/* Build new domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t/* No match - add a new doms_new */\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : NULL);\nmatch2:\n\t\t;\n\t}\n\n#if defined(CONFIG_ENERGY_MODEL) && defined(CONFIG_CPU_FREQ_GOV_SCHEDUTIL)\n\t/* Build perf. domains: */\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !sched_energy_update; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j]) &&\n\t\t\t    cpu_rq(cpumask_first(doms_cur[j]))->rd->pd) {\n\t\t\t\thas_eas = true;\n\t\t\t\tgoto match3;\n\t\t\t}\n\t\t}\n\t\t/* No match - add perf. domains for a new rd */\n\t\thas_eas |= build_perf_domains(doms_new[i]);\nmatch3:\n\t\t;\n\t}\n\tsched_energy_set(has_eas);\n#endif\n\n\t/* Remember the new sched domains: */\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\n\tkfree(dattr_cur);\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tupdate_sched_domain_debugfs();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void\npartition_and_rebuild_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t\t    struct sched_domain_attr *dattr_new)\n{\n\tmutex_lock(&sched_domains_mutex);\n\tpartition_sched_domains_locked(ndoms_new, doms_new, dattr_new);\n\trebuild_root_domains();\n\tmutex_unlock(&sched_domains_mutex);\n}"
  },
  {
    "function_name": "rebuild_root_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "965-999",
    "snippet": "static void rebuild_root_domains(void)\n{\n\tstruct cpuset *cs = NULL;\n\tstruct cgroup_subsys_state *pos_css;\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\tlockdep_assert_cpus_held();\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\trcu_read_lock();\n\n\t/*\n\t * Clear default root domain DL accounting, it will be computed again\n\t * if a task belongs to it.\n\t */\n\tdl_clear_root_domain(&def_root_domain);\n\n\tcpuset_for_each_descendant_pre(cs, pos_css, &top_cpuset) {\n\n\t\tif (cpumask_empty(cs->effective_cpus)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcss_get(&cs->css);\n\n\t\trcu_read_unlock();\n\n\t\tupdate_tasks_root_domain(cs);\n\n\t\trcu_read_lock();\n\t\tcss_put(&cs->css);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "&cs->css"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_tasks_root_domain",
          "args": [
            "cs"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "update_tasks_root_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "952-963",
          "snippet": "static void update_tasks_root_domain(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it)))\n\t\tdl_add_task_root_domain(task);\n\n\tcss_task_iter_end(&it);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_tasks_root_domain(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it)))\n\t\tdl_add_task_root_domain(task);\n\n\tcss_task_iter_end(&it);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_get",
          "args": [
            "&cs->css"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_rightmost_descendant",
          "args": [
            "pos_css"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cs->effective_cpus"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_for_each_descendant_pre",
          "args": [
            "cs",
            "pos_css",
            "&top_cpuset"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_clear_root_domain",
          "args": [
            "&def_root_domain"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "dl_clear_root_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2516-2523",
          "snippet": "void dl_clear_root_domain(struct root_domain *rd)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rd->dl_bw.lock, flags);\n\trd->dl_bw.total_bw = 0;\n\traw_spin_unlock_irqrestore(&rd->dl_bw.lock, flags);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid dl_clear_root_domain(struct root_domain *rd)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rd->dl_bw.lock, flags);\n\trd->dl_bw.total_bw = 0;\n\traw_spin_unlock_irqrestore(&rd->dl_bw.lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&sched_domains_mutex"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "335-347",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_rwsem_assert_held",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\n\nstatic void rebuild_root_domains(void)\n{\n\tstruct cpuset *cs = NULL;\n\tstruct cgroup_subsys_state *pos_css;\n\n\tpercpu_rwsem_assert_held(&cpuset_rwsem);\n\tlockdep_assert_cpus_held();\n\tlockdep_assert_held(&sched_domains_mutex);\n\n\trcu_read_lock();\n\n\t/*\n\t * Clear default root domain DL accounting, it will be computed again\n\t * if a task belongs to it.\n\t */\n\tdl_clear_root_domain(&def_root_domain);\n\n\tcpuset_for_each_descendant_pre(cs, pos_css, &top_cpuset) {\n\n\t\tif (cpumask_empty(cs->effective_cpus)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcss_get(&cs->css);\n\n\t\trcu_read_unlock();\n\n\t\tupdate_tasks_root_domain(cs);\n\n\t\trcu_read_lock();\n\t\tcss_put(&cs->css);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "update_tasks_root_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "952-963",
    "snippet": "static void update_tasks_root_domain(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it)))\n\t\tdl_add_task_root_domain(task);\n\n\tcss_task_iter_end(&it);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_task_iter_end",
          "args": [
            "&it"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4761-4775",
          "snippet": "void css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nvoid css_task_iter_end(struct css_task_iter *it)\n{\n\tif (it->cur_cset) {\n\t\tspin_lock_irq(&css_set_lock);\n\t\tlist_del(&it->iters_node);\n\t\tput_css_set_locked(it->cur_cset);\n\t\tspin_unlock_irq(&css_set_lock);\n\t}\n\n\tif (it->cur_dcset)\n\t\tput_css_set(it->cur_dcset);\n\n\tif (it->cur_task)\n\t\tput_task_struct(it->cur_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_add_task_root_domain",
          "args": [
            "task"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "dl_add_task_root_domain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2492-2514",
          "snippet": "void dl_add_task_root_domain(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tstruct dl_bw *dl_b;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\tif (!dl_task(p)) {\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf.flags);\n\t\treturn;\n\t}\n\n\trq = __task_rq_lock(p, &rf);\n\n\tdl_b = &rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\n\t__dl_add(dl_b, p->dl.dl_bw, cpumask_weight(rq->rd->span));\n\n\traw_spin_unlock(&dl_b->lock);\n\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nvoid dl_add_task_root_domain(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tstruct dl_bw *dl_b;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\tif (!dl_task(p)) {\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf.flags);\n\t\treturn;\n\t}\n\n\trq = __task_rq_lock(p, &rf);\n\n\tdl_b = &rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\n\t__dl_add(dl_b, p->dl.dl_bw, cpumask_weight(rq->rd->span));\n\n\traw_spin_unlock(&dl_b->lock);\n\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_next",
          "args": [
            "&it"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_next",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4730-4753",
          "snippet": "struct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\nstruct task_struct *css_task_iter_next(struct css_task_iter *it)\n{\n\tif (it->cur_task) {\n\t\tput_task_struct(it->cur_task);\n\t\tit->cur_task = NULL;\n\t}\n\n\tspin_lock_irq(&css_set_lock);\n\n\t/* @it may be half-advanced by skips, finish advancing */\n\tif (it->flags & CSS_TASK_ITER_SKIPPED)\n\t\tcss_task_iter_advance(it);\n\n\tif (it->task_pos) {\n\t\tit->cur_task = list_entry(it->task_pos, struct task_struct,\n\t\t\t\t\t  cg_list);\n\t\tget_task_struct(it->cur_task);\n\t\tcss_task_iter_advance(it);\n\t}\n\n\tspin_unlock_irq(&css_set_lock);\n\n\treturn it->cur_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_task_iter_start",
          "args": [
            "&cs->css",
            "0",
            "&it"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "css_task_iter_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cgroup.c",
          "lines": "4700-4720",
          "snippet": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [
            "#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)"
          ],
          "globals_used": [
            "static struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);",
            "static void kill_css(struct cgroup_subsys_state *css);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/fs_parser.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/bpf-cgroup.h>\n#include \"cgroup-internal.h\"\n\n#define CGROUP_HAS_SUBSYS_CONFIG\t(CGROUP_SUBSYS_COUNT > 0)\n\nstatic struct cgroup_subsys_state *css_create(struct cgroup *cgrp,\n\t\t\t\t\t      struct cgroup_subsys *ss);\nstatic void kill_css(struct cgroup_subsys_state *css);\n\nvoid css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_tasks_root_domain(struct cpuset *cs)\n{\n\tstruct css_task_iter it;\n\tstruct task_struct *task;\n\n\tcss_task_iter_start(&cs->css, 0, &it);\n\n\twhile ((task = css_task_iter_next(&it)))\n\t\tdl_add_task_root_domain(task);\n\n\tcss_task_iter_end(&it);\n}"
  },
  {
    "function_name": "generate_sched_domains",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "775-950",
    "snippet": "static int generate_sched_domains(cpumask_var_t **domains,\n\t\t\tstruct sched_domain_attr **attributes)\n{\n\tstruct cpuset *cp;\t/* top-down scan of cpusets */\n\tstruct cpuset **csa;\t/* array of all cpuset ptrs */\n\tint csn;\t\t/* how many cpuset ptrs in csa so far */\n\tint i, j, k;\t\t/* indices for partition finding loops */\n\tcpumask_var_t *doms;\t/* resulting partition; i.e. sched domains */\n\tstruct sched_domain_attr *dattr;  /* attributes for custom domains */\n\tint ndoms = 0;\t\t/* number of sched domains in result */\n\tint nslot;\t\t/* next empty doms[] struct cpumask slot */\n\tstruct cgroup_subsys_state *pos_css;\n\tbool root_load_balance = is_sched_load_balance(&top_cpuset);\n\n\tdoms = NULL;\n\tdattr = NULL;\n\tcsa = NULL;\n\n\t/* Special case for the 99% of systems with one, full, sched domain */\n\tif (root_load_balance && !top_cpuset.nr_subparts_cpus) {\n\t\tndoms = 1;\n\t\tdoms = alloc_sched_domains(ndoms);\n\t\tif (!doms)\n\t\t\tgoto done;\n\n\t\tdattr = kmalloc(sizeof(struct sched_domain_attr), GFP_KERNEL);\n\t\tif (dattr) {\n\t\t\t*dattr = SD_ATTR_INIT;\n\t\t\tupdate_domain_attr_tree(dattr, &top_cpuset);\n\t\t}\n\t\tcpumask_and(doms[0], top_cpuset.effective_cpus,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\n\t\tgoto done;\n\t}\n\n\tcsa = kmalloc_array(nr_cpusets(), sizeof(cp), GFP_KERNEL);\n\tif (!csa)\n\t\tgoto done;\n\tcsn = 0;\n\n\trcu_read_lock();\n\tif (root_load_balance)\n\t\tcsa[csn++] = &top_cpuset;\n\tcpuset_for_each_descendant_pre(cp, pos_css, &top_cpuset) {\n\t\tif (cp == &top_cpuset)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Continue traversing beyond @cp iff @cp has some CPUs and\n\t\t * isn't load balancing.  The former is obvious.  The\n\t\t * latter: All child cpusets contain a subset of the\n\t\t * parent's cpus, so just skip them, and then we call\n\t\t * update_domain_attr_tree() to calc relax_domain_level of\n\t\t * the corresponding sched domain.\n\t\t *\n\t\t * If root is load-balancing, we can skip @cp if it\n\t\t * is a subset of the root's effective_cpus.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    !(is_sched_load_balance(cp) &&\n\t\t      cpumask_intersects(cp->cpus_allowed,\n\t\t\t\t\t housekeeping_cpumask(HK_FLAG_DOMAIN))))\n\t\t\tcontinue;\n\n\t\tif (root_load_balance &&\n\t\t    cpumask_subset(cp->cpus_allowed, top_cpuset.effective_cpus))\n\t\t\tcontinue;\n\n\t\tif (is_sched_load_balance(cp) &&\n\t\t    !cpumask_empty(cp->effective_cpus))\n\t\t\tcsa[csn++] = cp;\n\n\t\t/* skip @cp's subtree if not a partition root */\n\t\tif (!is_partition_root(cp))\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t}\n\trcu_read_unlock();\n\n\tfor (i = 0; i < csn; i++)\n\t\tcsa[i]->pn = i;\n\tndoms = csn;\n\nrestart:\n\t/* Find the best partition (set of sched domains) */\n\tfor (i = 0; i < csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tint apn = a->pn;\n\n\t\tfor (j = 0; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\t\t\tint bpn = b->pn;\n\n\t\t\tif (apn != bpn && cpusets_overlap(a, b)) {\n\t\t\t\tfor (k = 0; k < csn; k++) {\n\t\t\t\t\tstruct cpuset *c = csa[k];\n\n\t\t\t\t\tif (c->pn == bpn)\n\t\t\t\t\t\tc->pn = apn;\n\t\t\t\t}\n\t\t\t\tndoms--;\t/* one less element */\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now we know how many domains to create.\n\t * Convert <csn, csa> to <ndoms, doms> and populate cpu masks.\n\t */\n\tdoms = alloc_sched_domains(ndoms);\n\tif (!doms)\n\t\tgoto done;\n\n\t/*\n\t * The rest of the code, including the scheduler, can deal with\n\t * dattr==NULL case. No need to abort if alloc fails.\n\t */\n\tdattr = kmalloc_array(ndoms, sizeof(struct sched_domain_attr),\n\t\t\t      GFP_KERNEL);\n\n\tfor (nslot = 0, i = 0; i < csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tstruct cpumask *dp;\n\t\tint apn = a->pn;\n\n\t\tif (apn < 0) {\n\t\t\t/* Skip completed partitions */\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp = doms[nslot];\n\n\t\tif (nslot == ndoms) {\n\t\t\tstatic int warnings = 10;\n\t\t\tif (warnings) {\n\t\t\t\tpr_warn(\"rebuild_sched_domains confused: nslot %d, ndoms %d, csn %d, i %d, apn %d\\n\",\n\t\t\t\t\tnslot, ndoms, csn, i, apn);\n\t\t\t\twarnings--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpumask_clear(dp);\n\t\tif (dattr)\n\t\t\t*(dattr + nslot) = SD_ATTR_INIT;\n\t\tfor (j = i; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\n\t\t\tif (apn == b->pn) {\n\t\t\t\tcpumask_or(dp, dp, b->effective_cpus);\n\t\t\t\tcpumask_and(dp, dp, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t\t\tif (dattr)\n\t\t\t\t\tupdate_domain_attr_tree(dattr + nslot, b);\n\n\t\t\t\t/* Done with this partition */\n\t\t\t\tb->pn = -1;\n\t\t\t}\n\t\t}\n\t\tnslot++;\n\t}\n\tBUG_ON(nslot != ndoms);\n\ndone:\n\tkfree(csa);\n\n\t/*\n\t * Fallback to the default domain if kmalloc() failed.\n\t * See comments in partition_sched_domains().\n\t */\n\tif (doms == NULL)\n\t\tndoms = 1;\n\n\t*domains    = doms;\n\t*attributes = dattr;\n\treturn ndoms;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "csa"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nslot != ndoms"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_domain_attr_tree",
          "args": [
            "dattr + nslot",
            "b"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "update_domain_attr_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "695-713",
          "snippet": "static void update_domain_attr_tree(struct sched_domain_attr *dattr,\n\t\t\t\t    struct cpuset *root_cs)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, root_cs) {\n\t\t/* skip the whole subtree if @cp doesn't have any CPU */\n\t\tif (cpumask_empty(cp->cpus_allowed)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_sched_load_balance(cp))\n\t\t\tupdate_domain_attr(dattr, cp);\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_domain_attr_tree(struct sched_domain_attr *dattr,\n\t\t\t\t    struct cpuset *root_cs)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, root_cs) {\n\t\t/* skip the whole subtree if @cp doesn't have any CPU */\n\t\tif (cpumask_empty(cp->cpus_allowed)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_sched_load_balance(cp))\n\t\t\tupdate_domain_attr(dattr, cp);\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "dp",
            "dp",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "housekeeping_cpumask",
          "args": [
            "HK_FLAG_DOMAIN"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "housekeeping_cpumask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/isolation.c",
          "lines": "40-46",
          "snippet": "const struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t housekeeping_mask;",
            "static unsigned int housekeeping_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic cpumask_var_t housekeeping_mask;\nstatic unsigned int housekeeping_flags;\n\nconst struct cpumask *housekeeping_cpumask(enum hk_flags flags)\n{\n\tif (static_branch_unlikely(&housekeeping_overridden))\n\t\tif (housekeeping_flags & flags)\n\t\t\treturn housekeeping_mask;\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_or",
          "args": [
            "dp",
            "dp",
            "b->effective_cpus"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "dp"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"rebuild_sched_domains confused: nslot %d, ndoms %d, csn %d, i %d, apn %d\\n\"",
            "nslot",
            "ndoms",
            "csn",
            "i",
            "apn"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "ndoms",
            "sizeof(struct sched_domain_attr)",
            "GFP_KERNEL"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_sched_domains",
          "args": [
            "ndoms"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_sched_domains",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/topology.c",
          "lines": "2311-2326",
          "snippet": "cpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}",
          "includes": [
            "#include <linux/sched/sd_flags.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/sd_flags.h>\n#include \"sched.h\"\n\ncpumask_var_t *alloc_sched_domains(unsigned int ndoms)\n{\n\tint i;\n\tcpumask_var_t *doms;\n\n\tdoms = kmalloc_array(ndoms, sizeof(*doms), GFP_KERNEL);\n\tif (!doms)\n\t\treturn NULL;\n\tfor (i = 0; i < ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], GFP_KERNEL)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn doms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpusets_overlap",
          "args": [
            "a",
            "b"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "cpusets_overlap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "682-685",
          "snippet": "static int cpusets_overlap(struct cpuset *a, struct cpuset *b)\n{\n\treturn cpumask_intersects(a->effective_cpus, b->effective_cpus);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int cpusets_overlap(struct cpuset *a, struct cpuset *b)\n{\n\treturn cpumask_intersects(a->effective_cpus, b->effective_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_rightmost_descendant",
          "args": [
            "pos_css"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_partition_root",
          "args": [
            "cp"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "is_partition_root",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "271-274",
          "snippet": "static inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cp->effective_cpus"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sched_load_balance",
          "args": [
            "cp"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "is_sched_load_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "251-254",
          "snippet": "static inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "cp->cpus_allowed",
            "top_cpuset.effective_cpus"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "cp->cpus_allowed",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cp->cpus_allowed"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_for_each_descendant_pre",
          "args": [
            "cp",
            "pos_css",
            "&top_cpuset"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_cpusets()",
            "sizeof(cp)",
            "GFP_KERNEL"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_cpusets",
          "args": [],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "nr_cpusets",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "716-720",
          "snippet": "static inline int nr_cpusets(void)\n{\n\t/* jump label reference count + the top-level cpuset */\n\treturn static_key_count(&cpusets_enabled_key.key) + 1;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int nr_cpusets(void)\n{\n\t/* jump label reference count + the top-level cpuset */\n\treturn static_key_count(&cpusets_enabled_key.key) + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "doms[0]",
            "top_cpuset.effective_cpus",
            "housekeeping_cpumask(HK_FLAG_DOMAIN)"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct sched_domain_attr)",
            "GFP_KERNEL"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\n\nstatic int generate_sched_domains(cpumask_var_t **domains,\n\t\t\tstruct sched_domain_attr **attributes)\n{\n\tstruct cpuset *cp;\t/* top-down scan of cpusets */\n\tstruct cpuset **csa;\t/* array of all cpuset ptrs */\n\tint csn;\t\t/* how many cpuset ptrs in csa so far */\n\tint i, j, k;\t\t/* indices for partition finding loops */\n\tcpumask_var_t *doms;\t/* resulting partition; i.e. sched domains */\n\tstruct sched_domain_attr *dattr;  /* attributes for custom domains */\n\tint ndoms = 0;\t\t/* number of sched domains in result */\n\tint nslot;\t\t/* next empty doms[] struct cpumask slot */\n\tstruct cgroup_subsys_state *pos_css;\n\tbool root_load_balance = is_sched_load_balance(&top_cpuset);\n\n\tdoms = NULL;\n\tdattr = NULL;\n\tcsa = NULL;\n\n\t/* Special case for the 99% of systems with one, full, sched domain */\n\tif (root_load_balance && !top_cpuset.nr_subparts_cpus) {\n\t\tndoms = 1;\n\t\tdoms = alloc_sched_domains(ndoms);\n\t\tif (!doms)\n\t\t\tgoto done;\n\n\t\tdattr = kmalloc(sizeof(struct sched_domain_attr), GFP_KERNEL);\n\t\tif (dattr) {\n\t\t\t*dattr = SD_ATTR_INIT;\n\t\t\tupdate_domain_attr_tree(dattr, &top_cpuset);\n\t\t}\n\t\tcpumask_and(doms[0], top_cpuset.effective_cpus,\n\t\t\t    housekeeping_cpumask(HK_FLAG_DOMAIN));\n\n\t\tgoto done;\n\t}\n\n\tcsa = kmalloc_array(nr_cpusets(), sizeof(cp), GFP_KERNEL);\n\tif (!csa)\n\t\tgoto done;\n\tcsn = 0;\n\n\trcu_read_lock();\n\tif (root_load_balance)\n\t\tcsa[csn++] = &top_cpuset;\n\tcpuset_for_each_descendant_pre(cp, pos_css, &top_cpuset) {\n\t\tif (cp == &top_cpuset)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Continue traversing beyond @cp iff @cp has some CPUs and\n\t\t * isn't load balancing.  The former is obvious.  The\n\t\t * latter: All child cpusets contain a subset of the\n\t\t * parent's cpus, so just skip them, and then we call\n\t\t * update_domain_attr_tree() to calc relax_domain_level of\n\t\t * the corresponding sched domain.\n\t\t *\n\t\t * If root is load-balancing, we can skip @cp if it\n\t\t * is a subset of the root's effective_cpus.\n\t\t */\n\t\tif (!cpumask_empty(cp->cpus_allowed) &&\n\t\t    !(is_sched_load_balance(cp) &&\n\t\t      cpumask_intersects(cp->cpus_allowed,\n\t\t\t\t\t housekeeping_cpumask(HK_FLAG_DOMAIN))))\n\t\t\tcontinue;\n\n\t\tif (root_load_balance &&\n\t\t    cpumask_subset(cp->cpus_allowed, top_cpuset.effective_cpus))\n\t\t\tcontinue;\n\n\t\tif (is_sched_load_balance(cp) &&\n\t\t    !cpumask_empty(cp->effective_cpus))\n\t\t\tcsa[csn++] = cp;\n\n\t\t/* skip @cp's subtree if not a partition root */\n\t\tif (!is_partition_root(cp))\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t}\n\trcu_read_unlock();\n\n\tfor (i = 0; i < csn; i++)\n\t\tcsa[i]->pn = i;\n\tndoms = csn;\n\nrestart:\n\t/* Find the best partition (set of sched domains) */\n\tfor (i = 0; i < csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tint apn = a->pn;\n\n\t\tfor (j = 0; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\t\t\tint bpn = b->pn;\n\n\t\t\tif (apn != bpn && cpusets_overlap(a, b)) {\n\t\t\t\tfor (k = 0; k < csn; k++) {\n\t\t\t\t\tstruct cpuset *c = csa[k];\n\n\t\t\t\t\tif (c->pn == bpn)\n\t\t\t\t\t\tc->pn = apn;\n\t\t\t\t}\n\t\t\t\tndoms--;\t/* one less element */\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now we know how many domains to create.\n\t * Convert <csn, csa> to <ndoms, doms> and populate cpu masks.\n\t */\n\tdoms = alloc_sched_domains(ndoms);\n\tif (!doms)\n\t\tgoto done;\n\n\t/*\n\t * The rest of the code, including the scheduler, can deal with\n\t * dattr==NULL case. No need to abort if alloc fails.\n\t */\n\tdattr = kmalloc_array(ndoms, sizeof(struct sched_domain_attr),\n\t\t\t      GFP_KERNEL);\n\n\tfor (nslot = 0, i = 0; i < csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tstruct cpumask *dp;\n\t\tint apn = a->pn;\n\n\t\tif (apn < 0) {\n\t\t\t/* Skip completed partitions */\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp = doms[nslot];\n\n\t\tif (nslot == ndoms) {\n\t\t\tstatic int warnings = 10;\n\t\t\tif (warnings) {\n\t\t\t\tpr_warn(\"rebuild_sched_domains confused: nslot %d, ndoms %d, csn %d, i %d, apn %d\\n\",\n\t\t\t\t\tnslot, ndoms, csn, i, apn);\n\t\t\t\twarnings--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpumask_clear(dp);\n\t\tif (dattr)\n\t\t\t*(dattr + nslot) = SD_ATTR_INIT;\n\t\tfor (j = i; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\n\t\t\tif (apn == b->pn) {\n\t\t\t\tcpumask_or(dp, dp, b->effective_cpus);\n\t\t\t\tcpumask_and(dp, dp, housekeeping_cpumask(HK_FLAG_DOMAIN));\n\t\t\t\tif (dattr)\n\t\t\t\t\tupdate_domain_attr_tree(dattr + nslot, b);\n\n\t\t\t\t/* Done with this partition */\n\t\t\t\tb->pn = -1;\n\t\t\t}\n\t\t}\n\t\tnslot++;\n\t}\n\tBUG_ON(nslot != ndoms);\n\ndone:\n\tkfree(csa);\n\n\t/*\n\t * Fallback to the default domain if kmalloc() failed.\n\t * See comments in partition_sched_domains().\n\t */\n\tif (doms == NULL)\n\t\tndoms = 1;\n\n\t*domains    = doms;\n\t*attributes = dattr;\n\treturn ndoms;\n}"
  },
  {
    "function_name": "nr_cpusets",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "716-720",
    "snippet": "static inline int nr_cpusets(void)\n{\n\t/* jump label reference count + the top-level cpuset */\n\treturn static_key_count(&cpusets_enabled_key.key) + 1;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_count",
          "args": [
            "&cpusets_enabled_key.key"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_count",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "104-113",
          "snippet": "int static_key_count(struct static_key *key)\n{\n\t/*\n\t * -1 means the first static_key_slow_inc() is in progress.\n\t *  static_key_enabled() must return true, so return 1 here.\n\t */\n\tint n = atomic_read(&key->enabled);\n\n\treturn n >= 0 ? n : 1;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void jump_label_update(struct static_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key);\n\nint static_key_count(struct static_key *key)\n{\n\t/*\n\t * -1 means the first static_key_slow_inc() is in progress.\n\t *  static_key_enabled() must return true, so return 1 here.\n\t */\n\tint n = atomic_read(&key->enabled);\n\n\treturn n >= 0 ? n : 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int nr_cpusets(void)\n{\n\t/* jump label reference count + the top-level cpuset */\n\treturn static_key_count(&cpusets_enabled_key.key) + 1;\n}"
  },
  {
    "function_name": "update_domain_attr_tree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "695-713",
    "snippet": "static void update_domain_attr_tree(struct sched_domain_attr *dattr,\n\t\t\t\t    struct cpuset *root_cs)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, root_cs) {\n\t\t/* skip the whole subtree if @cp doesn't have any CPU */\n\t\tif (cpumask_empty(cp->cpus_allowed)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_sched_load_balance(cp))\n\t\t\tupdate_domain_attr(dattr, cp);\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_domain_attr",
          "args": [
            "dattr",
            "cp"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "update_domain_attr_tree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "695-713",
          "snippet": "static void update_domain_attr_tree(struct sched_domain_attr *dattr,\n\t\t\t\t    struct cpuset *root_cs)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, root_cs) {\n\t\t/* skip the whole subtree if @cp doesn't have any CPU */\n\t\tif (cpumask_empty(cp->cpus_allowed)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_sched_load_balance(cp))\n\t\t\tupdate_domain_attr(dattr, cp);\n\t}\n\trcu_read_unlock();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "is_sched_load_balance",
          "args": [
            "cp"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "is_sched_load_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "251-254",
          "snippet": "static inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "css_rightmost_descendant",
          "args": [
            "pos_css"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cp->cpus_allowed"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_for_each_descendant_pre",
          "args": [
            "cp",
            "pos_css",
            "root_cs"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void update_domain_attr_tree(struct sched_domain_attr *dattr,\n\t\t\t\t    struct cpuset *root_cs)\n{\n\tstruct cpuset *cp;\n\tstruct cgroup_subsys_state *pos_css;\n\n\trcu_read_lock();\n\tcpuset_for_each_descendant_pre(cp, pos_css, root_cs) {\n\t\t/* skip the whole subtree if @cp doesn't have any CPU */\n\t\tif (cpumask_empty(cp->cpus_allowed)) {\n\t\t\tpos_css = css_rightmost_descendant(pos_css);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_sched_load_balance(cp))\n\t\t\tupdate_domain_attr(dattr, cp);\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "update_domain_attr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "687-693",
    "snippet": "static void\nupdate_domain_attr(struct sched_domain_attr *dattr, struct cpuset *c)\n{\n\tif (dattr->relax_domain_level < c->relax_domain_level)\n\t\tdattr->relax_domain_level = c->relax_domain_level;\n\treturn;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void\nupdate_domain_attr(struct sched_domain_attr *dattr, struct cpuset *c)\n{\n\tif (dattr->relax_domain_level < c->relax_domain_level)\n\t\tdattr->relax_domain_level = c->relax_domain_level;\n\treturn;\n}"
  },
  {
    "function_name": "cpusets_overlap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "682-685",
    "snippet": "static int cpusets_overlap(struct cpuset *a, struct cpuset *b)\n{\n\treturn cpumask_intersects(a->effective_cpus, b->effective_cpus);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "a->effective_cpus",
            "b->effective_cpus"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int cpusets_overlap(struct cpuset *a, struct cpuset *b)\n{\n\treturn cpumask_intersects(a->effective_cpus, b->effective_cpus);\n}"
  },
  {
    "function_name": "validate_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "613-675",
    "snippet": "static int validate_change(struct cpuset *cur, struct cpuset *trial)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *c, *par;\n\tint ret;\n\n\t/* The checks don't apply to root cpuset */\n\tif (cur == &top_cpuset)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpar = parent_cs(cur);\n\n\t/* On legacy hierarchy, we must be a subset of our parent cpuset. */\n\tret = -EACCES;\n\tif (!is_in_v2_mode() && !is_cpuset_subset(trial, par))\n\t\tgoto out;\n\n\t/*\n\t * If either I or some sibling (!= me) is exclusive, we can't\n\t * overlap\n\t */\n\tret = -EINVAL;\n\tcpuset_for_each_child(c, css, par) {\n\t\tif ((is_cpu_exclusive(trial) || is_cpu_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    cpumask_intersects(trial->cpus_allowed, c->cpus_allowed))\n\t\t\tgoto out;\n\t\tif ((is_mem_exclusive(trial) || is_mem_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    nodes_intersects(trial->mems_allowed, c->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Cpusets with tasks - existing or newly being attached - can't\n\t * be changed to have empty cpus_allowed or mems_allowed.\n\t */\n\tret = -ENOSPC;\n\tif ((cgroup_is_populated(cur->css.cgroup) || cur->attach_in_progress)) {\n\t\tif (!cpumask_empty(cur->cpus_allowed) &&\n\t\t    cpumask_empty(trial->cpus_allowed))\n\t\t\tgoto out;\n\t\tif (!nodes_empty(cur->mems_allowed) &&\n\t\t    nodes_empty(trial->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We can't shrink if we won't have enough room for SCHED_DEADLINE\n\t * tasks.\n\t */\n\tret = -EBUSY;\n\tif (is_cpu_exclusive(cur) &&\n\t    !cpuset_cpumask_can_shrink(cur->cpus_allowed,\n\t\t\t\t       trial->cpus_allowed))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuset_cpumask_can_shrink",
          "args": [
            "cur->cpus_allowed",
            "trial->cpus_allowed"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "cpuset_cpumask_can_shrink",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8705-8716",
          "snippet": "int cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t      const struct cpumask *trial)\n{\n\tint ret = 1;\n\n\tif (!cpumask_weight(cur))\n\t\treturn ret;\n\n\tret = dl_cpuset_cpumask_can_shrink(cur, trial);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t      const struct cpumask *trial)\n{\n\tint ret = 1;\n\n\tif (!cpumask_weight(cur))\n\t\treturn ret;\n\n\tret = dl_cpuset_cpumask_can_shrink(cur, trial);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpu_exclusive",
          "args": [
            "cur"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpu_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "236-239",
          "snippet": "static inline int is_cpu_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_cpu_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "trial->mems_allowed"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_empty",
          "args": [
            "cur->mems_allowed"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "trial->cpus_allowed"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cur->cpus_allowed"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_is_populated",
          "args": [
            "cur->css.cgroup"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodes_intersects",
          "args": [
            "trial->mems_allowed",
            "c->mems_allowed"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mem_exclusive",
          "args": [
            "c"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "is_mem_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "241-244",
          "snippet": "static inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "trial->cpus_allowed",
            "c->cpus_allowed"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuset_for_each_child",
          "args": [
            "c",
            "css",
            "par"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cpuset_subset",
          "args": [
            "trial",
            "par"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpuset_subset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "494-500",
          "snippet": "static int is_cpuset_subset(const struct cpuset *p, const struct cpuset *q)\n{\n\treturn\tcpumask_subset(p->cpus_allowed, q->cpus_allowed) &&\n\t\tnodes_subset(p->mems_allowed, q->mems_allowed) &&\n\t\tis_cpu_exclusive(p) <= is_cpu_exclusive(q) &&\n\t\tis_mem_exclusive(p) <= is_mem_exclusive(q);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int is_cpuset_subset(const struct cpuset *p, const struct cpuset *q)\n{\n\treturn\tcpumask_subset(p->cpus_allowed, q->cpus_allowed) &&\n\t\tnodes_subset(p->mems_allowed, q->mems_allowed) &&\n\t\tis_cpu_exclusive(p) <= is_cpu_exclusive(q) &&\n\t\tis_mem_exclusive(p) <= is_mem_exclusive(q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_in_v2_mode",
          "args": [],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "is_in_v2_mode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "401-405",
          "snippet": "static inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cur"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset top_cpuset = {\n\t.flags = ((1 << CS_ONLINE) | (1 << CS_CPU_EXCLUSIVE) |\n\t\t  (1 << CS_MEM_EXCLUSIVE)),\n\t.partition_root_state = PRS_ENABLED,\n};\n\nstatic int validate_change(struct cpuset *cur, struct cpuset *trial)\n{\n\tstruct cgroup_subsys_state *css;\n\tstruct cpuset *c, *par;\n\tint ret;\n\n\t/* The checks don't apply to root cpuset */\n\tif (cur == &top_cpuset)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tpar = parent_cs(cur);\n\n\t/* On legacy hierarchy, we must be a subset of our parent cpuset. */\n\tret = -EACCES;\n\tif (!is_in_v2_mode() && !is_cpuset_subset(trial, par))\n\t\tgoto out;\n\n\t/*\n\t * If either I or some sibling (!= me) is exclusive, we can't\n\t * overlap\n\t */\n\tret = -EINVAL;\n\tcpuset_for_each_child(c, css, par) {\n\t\tif ((is_cpu_exclusive(trial) || is_cpu_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    cpumask_intersects(trial->cpus_allowed, c->cpus_allowed))\n\t\t\tgoto out;\n\t\tif ((is_mem_exclusive(trial) || is_mem_exclusive(c)) &&\n\t\t    c != cur &&\n\t\t    nodes_intersects(trial->mems_allowed, c->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * Cpusets with tasks - existing or newly being attached - can't\n\t * be changed to have empty cpus_allowed or mems_allowed.\n\t */\n\tret = -ENOSPC;\n\tif ((cgroup_is_populated(cur->css.cgroup) || cur->attach_in_progress)) {\n\t\tif (!cpumask_empty(cur->cpus_allowed) &&\n\t\t    cpumask_empty(trial->cpus_allowed))\n\t\t\tgoto out;\n\t\tif (!nodes_empty(cur->mems_allowed) &&\n\t\t    nodes_empty(trial->mems_allowed))\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t * We can't shrink if we won't have enough room for SCHED_DEADLINE\n\t * tasks.\n\t */\n\tret = -EBUSY;\n\tif (is_cpu_exclusive(cur) &&\n\t    !cpuset_cpumask_can_shrink(cur->cpus_allowed,\n\t\t\t\t       trial->cpus_allowed))\n\t\tgoto out;\n\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "free_cpuset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "587-591",
    "snippet": "static inline void free_cpuset(struct cpuset *cs)\n{\n\tfree_cpumasks(cs, NULL);\n\tkfree(cs);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cs"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cpumasks",
          "args": [
            "cs",
            "NULL"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "free_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "547-559",
          "snippet": "static inline void free_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tif (cs) {\n\t\tfree_cpumask_var(cs->cpus_allowed);\n\t\tfree_cpumask_var(cs->effective_cpus);\n\t\tfree_cpumask_var(cs->subparts_cpus);\n\t}\n\tif (tmp) {\n\t\tfree_cpumask_var(tmp->new_cpus);\n\t\tfree_cpumask_var(tmp->addmask);\n\t\tfree_cpumask_var(tmp->delmask);\n\t}\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void free_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tif (cs) {\n\t\tfree_cpumask_var(cs->cpus_allowed);\n\t\tfree_cpumask_var(cs->effective_cpus);\n\t\tfree_cpumask_var(cs->subparts_cpus);\n\t}\n\tif (tmp) {\n\t\tfree_cpumask_var(tmp->new_cpus);\n\t\tfree_cpumask_var(tmp->addmask);\n\t\tfree_cpumask_var(tmp->delmask);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void free_cpuset(struct cpuset *cs)\n{\n\tfree_cpumasks(cs, NULL);\n\tkfree(cs);\n}"
  },
  {
    "function_name": "alloc_trial_cpuset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "565-581",
    "snippet": "static struct cpuset *alloc_trial_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *trial;\n\n\ttrial = kmemdup(cs, sizeof(*cs), GFP_KERNEL);\n\tif (!trial)\n\t\treturn NULL;\n\n\tif (alloc_cpumasks(trial, NULL)) {\n\t\tkfree(trial);\n\t\treturn NULL;\n\t}\n\n\tcpumask_copy(trial->cpus_allowed, cs->cpus_allowed);\n\tcpumask_copy(trial->effective_cpus, cs->effective_cpus);\n\treturn trial;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "trial->effective_cpus",
            "cs->effective_cpus"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "trial->cpus_allowed",
            "cs->cpus_allowed"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "trial"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cpumasks",
          "args": [
            "trial",
            "NULL"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cpumasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "510-540",
          "snippet": "static inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tcpumask_var_t *pmask1, *pmask2, *pmask3;\n\n\tif (cs) {\n\t\tpmask1 = &cs->cpus_allowed;\n\t\tpmask2 = &cs->effective_cpus;\n\t\tpmask3 = &cs->subparts_cpus;\n\t} else {\n\t\tpmask1 = &tmp->new_cpus;\n\t\tpmask2 = &tmp->addmask;\n\t\tpmask3 = &tmp->delmask;\n\t}\n\n\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))\n\t\tgoto free_one;\n\n\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))\n\t\tgoto free_two;\n\n\treturn 0;\n\nfree_two:\n\tfree_cpumask_var(*pmask2);\nfree_one:\n\tfree_cpumask_var(*pmask1);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tcpumask_var_t *pmask1, *pmask2, *pmask3;\n\n\tif (cs) {\n\t\tpmask1 = &cs->cpus_allowed;\n\t\tpmask2 = &cs->effective_cpus;\n\t\tpmask3 = &cs->subparts_cpus;\n\t} else {\n\t\tpmask1 = &tmp->new_cpus;\n\t\tpmask2 = &tmp->addmask;\n\t\tpmask3 = &tmp->delmask;\n\t}\n\n\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))\n\t\tgoto free_one;\n\n\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))\n\t\tgoto free_two;\n\n\treturn 0;\n\nfree_two:\n\tfree_cpumask_var(*pmask2);\nfree_one:\n\tfree_cpumask_var(*pmask1);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "cs",
            "sizeof(*cs)",
            "GFP_KERNEL"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic struct cpuset *alloc_trial_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *trial;\n\n\ttrial = kmemdup(cs, sizeof(*cs), GFP_KERNEL);\n\tif (!trial)\n\t\treturn NULL;\n\n\tif (alloc_cpumasks(trial, NULL)) {\n\t\tkfree(trial);\n\t\treturn NULL;\n\t}\n\n\tcpumask_copy(trial->cpus_allowed, cs->cpus_allowed);\n\tcpumask_copy(trial->effective_cpus, cs->effective_cpus);\n\treturn trial;\n}"
  },
  {
    "function_name": "free_cpumasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "547-559",
    "snippet": "static inline void free_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tif (cs) {\n\t\tfree_cpumask_var(cs->cpus_allowed);\n\t\tfree_cpumask_var(cs->effective_cpus);\n\t\tfree_cpumask_var(cs->subparts_cpus);\n\t}\n\tif (tmp) {\n\t\tfree_cpumask_var(tmp->new_cpus);\n\t\tfree_cpumask_var(tmp->addmask);\n\t\tfree_cpumask_var(tmp->delmask);\n\t}\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "tmp->delmask"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "tmp->addmask"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "tmp->new_cpus"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cs->subparts_cpus"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cs->effective_cpus"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "cs->cpus_allowed"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void free_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tif (cs) {\n\t\tfree_cpumask_var(cs->cpus_allowed);\n\t\tfree_cpumask_var(cs->effective_cpus);\n\t\tfree_cpumask_var(cs->subparts_cpus);\n\t}\n\tif (tmp) {\n\t\tfree_cpumask_var(tmp->new_cpus);\n\t\tfree_cpumask_var(tmp->addmask);\n\t\tfree_cpumask_var(tmp->delmask);\n\t}\n}"
  },
  {
    "function_name": "alloc_cpumasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "510-540",
    "snippet": "static inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tcpumask_var_t *pmask1, *pmask2, *pmask3;\n\n\tif (cs) {\n\t\tpmask1 = &cs->cpus_allowed;\n\t\tpmask2 = &cs->effective_cpus;\n\t\tpmask3 = &cs->subparts_cpus;\n\t} else {\n\t\tpmask1 = &tmp->new_cpus;\n\t\tpmask2 = &tmp->addmask;\n\t\tpmask3 = &tmp->delmask;\n\t}\n\n\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))\n\t\tgoto free_one;\n\n\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))\n\t\tgoto free_two;\n\n\treturn 0;\n\nfree_two:\n\tfree_cpumask_var(*pmask2);\nfree_one:\n\tfree_cpumask_var(*pmask1);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "*pmask1"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "*pmask2"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "pmask3",
            "GFP_KERNEL"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "pmask2",
            "GFP_KERNEL"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "pmask1",
            "GFP_KERNEL"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int alloc_cpumasks(struct cpuset *cs, struct tmpmasks *tmp)\n{\n\tcpumask_var_t *pmask1, *pmask2, *pmask3;\n\n\tif (cs) {\n\t\tpmask1 = &cs->cpus_allowed;\n\t\tpmask2 = &cs->effective_cpus;\n\t\tpmask3 = &cs->subparts_cpus;\n\t} else {\n\t\tpmask1 = &tmp->new_cpus;\n\t\tpmask2 = &tmp->addmask;\n\t\tpmask3 = &tmp->delmask;\n\t}\n\n\tif (!zalloc_cpumask_var(pmask1, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(pmask2, GFP_KERNEL))\n\t\tgoto free_one;\n\n\tif (!zalloc_cpumask_var(pmask3, GFP_KERNEL))\n\t\tgoto free_two;\n\n\treturn 0;\n\nfree_two:\n\tfree_cpumask_var(*pmask2);\nfree_one:\n\tfree_cpumask_var(*pmask1);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "is_cpuset_subset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "494-500",
    "snippet": "static int is_cpuset_subset(const struct cpuset *p, const struct cpuset *q)\n{\n\treturn\tcpumask_subset(p->cpus_allowed, q->cpus_allowed) &&\n\t\tnodes_subset(p->mems_allowed, q->mems_allowed) &&\n\t\tis_cpu_exclusive(p) <= is_cpu_exclusive(q) &&\n\t\tis_mem_exclusive(p) <= is_mem_exclusive(q);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_mem_exclusive",
          "args": [
            "q"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "is_mem_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "241-244",
          "snippet": "static inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpu_exclusive",
          "args": [
            "q"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpu_exclusive",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "236-239",
          "snippet": "static inline int is_cpu_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_cpu_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_subset",
          "args": [
            "p->mems_allowed",
            "q->mems_allowed"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "p->cpus_allowed",
            "q->cpus_allowed"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic int is_cpuset_subset(const struct cpuset *p, const struct cpuset *q)\n{\n\treturn\tcpumask_subset(p->cpus_allowed, q->cpus_allowed) &&\n\t\tnodes_subset(p->mems_allowed, q->mems_allowed) &&\n\t\tis_cpu_exclusive(p) <= is_cpu_exclusive(q) &&\n\t\tis_mem_exclusive(p) <= is_mem_exclusive(q);\n}"
  },
  {
    "function_name": "cpuset_update_task_spread_flag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "472-484",
    "snippet": "static void cpuset_update_task_spread_flag(struct cpuset *cs,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tif (is_spread_page(cs))\n\t\ttask_set_spread_page(tsk);\n\telse\n\t\ttask_clear_spread_page(tsk);\n\n\tif (is_spread_slab(cs))\n\t\ttask_set_spread_slab(tsk);\n\telse\n\t\ttask_clear_spread_slab(tsk);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_clear_spread_slab",
          "args": [
            "tsk"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_set_spread_slab",
          "args": [
            "tsk"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_spread_slab",
          "args": [
            "cs"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "is_spread_slab",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "266-269",
          "snippet": "static inline int is_spread_slab(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_spread_slab(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_clear_spread_page",
          "args": [
            "tsk"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_set_spread_page",
          "args": [
            "tsk"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_spread_page",
          "args": [
            "cs"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "is_spread_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "261-264",
          "snippet": "static inline int is_spread_page(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_spread_page(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void cpuset_update_task_spread_flag(struct cpuset *cs,\n\t\t\t\t\tstruct task_struct *tsk)\n{\n\tif (is_spread_page(cs))\n\t\ttask_set_spread_page(tsk);\n\telse\n\t\ttask_clear_spread_page(tsk);\n\n\tif (is_spread_slab(cs))\n\t\ttask_set_spread_slab(tsk);\n\telse\n\t\ttask_clear_spread_slab(tsk);\n}"
  },
  {
    "function_name": "guarantee_online_mems",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "460-465",
    "snippet": "static void guarantee_online_mems(struct cpuset *cs, nodemask_t *pmask)\n{\n\twhile (!nodes_intersects(cs->effective_mems, node_states[N_MEMORY]))\n\t\tcs = parent_cs(cs);\n\tnodes_and(*pmask, cs->effective_mems, node_states[N_MEMORY]);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodes_and",
          "args": [
            "*pmask",
            "cs->effective_mems",
            "node_states[N_MEMORY]"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cs"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodes_intersects",
          "args": [
            "cs->effective_mems",
            "node_states[N_MEMORY]"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void guarantee_online_mems(struct cpuset *cs, nodemask_t *pmask)\n{\n\twhile (!nodes_intersects(cs->effective_mems, node_states[N_MEMORY]))\n\t\tcs = parent_cs(cs);\n\tnodes_and(*pmask, cs->effective_mems, node_states[N_MEMORY]);\n}"
  },
  {
    "function_name": "guarantee_online_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "418-447",
    "snippet": "static void guarantee_online_cpus(struct task_struct *tsk,\n\t\t\t\t  struct cpumask *pmask)\n{\n\tconst struct cpumask *possible_mask = task_cpu_possible_mask(tsk);\n\tstruct cpuset *cs;\n\n\tif (WARN_ON(!cpumask_and(pmask, possible_mask, cpu_online_mask)))\n\t\tcpumask_copy(pmask, cpu_online_mask);\n\n\trcu_read_lock();\n\tcs = task_cs(tsk);\n\n\twhile (!cpumask_intersects(cs->effective_cpus, pmask)) {\n\t\tcs = parent_cs(cs);\n\t\tif (unlikely(!cs)) {\n\t\t\t/*\n\t\t\t * The top cpuset doesn't have any online cpu as a\n\t\t\t * consequence of a race between cpuset_hotplug_work\n\t\t\t * and cpu hotplug notifier.  But we know the top\n\t\t\t * cpuset's effective_cpus is on its way to be\n\t\t\t * identical to cpu_online_mask.\n\t\t\t */\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tcpumask_and(pmask, pmask, cs->effective_cpus);\n\nout_unlock:\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "pmask",
            "pmask",
            "cs->effective_cpus"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cs"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent_cs",
          "args": [
            "cs"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "parent_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "213-216",
          "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "cs->effective_cpus",
            "pmask"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cs",
          "args": [
            "tsk"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "task_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "208-211",
          "snippet": "static inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "pmask",
            "cpu_online_mask"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!cpumask_and(pmask, possible_mask, cpu_online_mask)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_and",
          "args": [
            "pmask",
            "possible_mask",
            "cpu_online_mask"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu_possible_mask",
          "args": [
            "tsk"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic void guarantee_online_cpus(struct task_struct *tsk,\n\t\t\t\t  struct cpumask *pmask)\n{\n\tconst struct cpumask *possible_mask = task_cpu_possible_mask(tsk);\n\tstruct cpuset *cs;\n\n\tif (WARN_ON(!cpumask_and(pmask, possible_mask, cpu_online_mask)))\n\t\tcpumask_copy(pmask, cpu_online_mask);\n\n\trcu_read_lock();\n\tcs = task_cs(tsk);\n\n\twhile (!cpumask_intersects(cs->effective_cpus, pmask)) {\n\t\tcs = parent_cs(cs);\n\t\tif (unlikely(!cs)) {\n\t\t\t/*\n\t\t\t * The top cpuset doesn't have any online cpu as a\n\t\t\t * consequence of a race between cpuset_hotplug_work\n\t\t\t * and cpu hotplug notifier.  But we know the top\n\t\t\t * cpuset's effective_cpus is on its way to be\n\t\t\t * identical to cpu_online_mask.\n\t\t\t */\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tcpumask_and(pmask, pmask, cs->effective_cpus);\n\nout_unlock:\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "is_in_v2_mode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "401-405",
    "snippet": "static inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_subsys_on_dfl",
          "args": [
            "cpuset_cgrp_subsys"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstruct cgroup_subsys cpuset_cgrp_subsys = {\n\t.css_alloc\t= cpuset_css_alloc,\n\t.css_online\t= cpuset_css_online,\n\t.css_offline\t= cpuset_css_offline,\n\t.css_free\t= cpuset_css_free,\n\t.can_attach\t= cpuset_can_attach,\n\t.cancel_attach\t= cpuset_cancel_attach,\n\t.attach\t\t= cpuset_attach,\n\t.post_attach\t= cpuset_post_attach,\n\t.bind\t\t= cpuset_bind,\n\t.fork\t\t= cpuset_fork,\n\t.legacy_cftypes\t= legacy_files,\n\t.dfl_cftypes\t= dfl_files,\n\t.early_init\t= true,\n\t.threaded\t= true,\n};\n\nstatic inline bool is_in_v2_mode(void)\n{\n\treturn cgroup_subsys_on_dfl(cpuset_cgrp_subsys) ||\n\t      (cpuset_cgrp_subsys.root->flags & CGRP_ROOT_CPUSET_V2_MODE);\n}"
  },
  {
    "function_name": "check_insane_mems_config",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "382-391",
    "snippet": "static inline void check_insane_mems_config(nodemask_t *nodes)\n{\n\tif (!cpusets_insane_config() &&\n\t\tmovable_only_nodes(nodes)) {\n\t\tstatic_branch_enable(&cpusets_insane_config_key);\n\t\tpr_info(\"Unsupported (movable nodes only) cpuset configuration detected (nmask=%*pbl)!\\n\"\n\t\t\t\"Cpuset allocations might fail even with a lot of memory available.\\n\",\n\t\t\tnodemask_pr_args(nodes));\n\t}\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Unsupported (movable nodes only) cpuset configuration detected (nmask=%*pbl)!\\n\"\n\t\t\t\"Cpuset allocations might fail even with a lot of memory available.\\n\"",
            "nodemask_pr_args(nodes)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodemask_pr_args",
          "args": [
            "nodes"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&cpusets_insane_config_key"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "movable_only_nodes",
          "args": [
            "nodes"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpusets_insane_config",
          "args": [],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void check_insane_mems_config(nodemask_t *nodes)\n{\n\tif (!cpusets_insane_config() &&\n\t\tmovable_only_nodes(nodes)) {\n\t\tstatic_branch_enable(&cpusets_insane_config_key);\n\t\tpr_info(\"Unsupported (movable nodes only) cpuset configuration detected (nmask=%*pbl)!\\n\"\n\t\t\t\"Cpuset allocations might fail even with a lot of memory available.\\n\",\n\t\t\tnodemask_pr_args(nodes));\n\t}\n}"
  },
  {
    "function_name": "cpuset_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "365-368",
    "snippet": "void cpuset_read_unlock(void)\n{\n\tpercpu_up_read(&cpuset_rwsem);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_read",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid cpuset_read_unlock(void)\n{\n\tpercpu_up_read(&cpuset_rwsem);\n}"
  },
  {
    "function_name": "cpuset_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "360-363",
    "snippet": "void cpuset_read_lock(void)\n{\n\tpercpu_down_read(&cpuset_rwsem);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_read",
          "args": [
            "&cpuset_rwsem"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nvoid cpuset_read_lock(void)\n{\n\tpercpu_down_read(&cpuset_rwsem);\n}"
  },
  {
    "function_name": "notify_partition_change",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "279-284",
    "snippet": "static inline void notify_partition_change(struct cpuset *cs,\n\t\t\t\t\t   int old_prs, int new_prs)\n{\n\tif (old_prs != new_prs)\n\t\tcgroup_file_notify(&cs->partition_file);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_file_notify",
          "args": [
            "&cs->partition_file"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline void notify_partition_change(struct cpuset *cs,\n\t\t\t\t\t   int old_prs, int new_prs)\n{\n\tif (old_prs != new_prs)\n\t\tcgroup_file_notify(&cs->partition_file);\n}"
  },
  {
    "function_name": "is_partition_root",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "271-274",
    "snippet": "static inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_partition_root(const struct cpuset *cs)\n{\n\treturn cs->partition_root_state > 0;\n}"
  },
  {
    "function_name": "is_spread_slab",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "266-269",
    "snippet": "static inline int is_spread_slab(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CS_SPREAD_SLAB",
            "&cs->flags"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_spread_slab(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_SLAB, &cs->flags);\n}"
  },
  {
    "function_name": "is_spread_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "261-264",
    "snippet": "static inline int is_spread_page(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CS_SPREAD_PAGE",
            "&cs->flags"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_spread_page(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SPREAD_PAGE, &cs->flags);\n}"
  },
  {
    "function_name": "is_memory_migrate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "256-259",
    "snippet": "static inline int is_memory_migrate(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEMORY_MIGRATE, &cs->flags);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CS_MEMORY_MIGRATE",
            "&cs->flags"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_memory_migrate(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEMORY_MIGRATE, &cs->flags);\n}"
  },
  {
    "function_name": "is_sched_load_balance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "251-254",
    "snippet": "static inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CS_SCHED_LOAD_BALANCE",
            "&cs->flags"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_sched_load_balance(const struct cpuset *cs)\n{\n\treturn test_bit(CS_SCHED_LOAD_BALANCE, &cs->flags);\n}"
  },
  {
    "function_name": "is_mem_hardwall",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "246-249",
    "snippet": "static inline int is_mem_hardwall(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_HARDWALL, &cs->flags);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CS_MEM_HARDWALL",
            "&cs->flags"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_mem_hardwall(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_HARDWALL, &cs->flags);\n}"
  },
  {
    "function_name": "is_mem_exclusive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "241-244",
    "snippet": "static inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CS_MEM_EXCLUSIVE",
            "&cs->flags"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_mem_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_MEM_EXCLUSIVE, &cs->flags);\n}"
  },
  {
    "function_name": "is_cpu_exclusive",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "236-239",
    "snippet": "static inline int is_cpu_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CS_CPU_EXCLUSIVE",
            "&cs->flags"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline int is_cpu_exclusive(const struct cpuset *cs)\n{\n\treturn test_bit(CS_CPU_EXCLUSIVE, &cs->flags);\n}"
  },
  {
    "function_name": "is_cpuset_online",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "231-234",
    "snippet": "static inline bool is_cpuset_online(struct cpuset *cs)\n{\n\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_is_dying",
          "args": [
            "&cs->css"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "CS_ONLINE",
            "&cs->flags"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline bool is_cpuset_online(struct cpuset *cs)\n{\n\treturn test_bit(CS_ONLINE, &cs->flags) && !css_is_dying(&cs->css);\n}"
  },
  {
    "function_name": "parent_cs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "213-216",
    "snippet": "static inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "cs->css.parent"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *parent_cs(struct cpuset *cs)\n{\n\treturn css_cs(cs->css.parent);\n}"
  },
  {
    "function_name": "task_cs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "208-211",
    "snippet": "static inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "css_cs",
          "args": [
            "task_css(task, cpuset_cgrp_id)"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "css_cs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
          "lines": "202-205",
          "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
          "includes": [
            "#include <linux/wait.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/oom.h>",
            "#include <linux/sort.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time64.h>",
            "#include <linux/time.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/memory.h>",
            "#include <linux/mm.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/list.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/err.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_css",
          "args": [
            "task",
            "cpuset_cgrp_id"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *task_cs(struct task_struct *task)\n{\n\treturn css_cs(task_css(task, cpuset_cgrp_id));\n}"
  },
  {
    "function_name": "css_cs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/cpuset.c",
    "lines": "202-205",
    "snippet": "static inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}",
    "includes": [
      "#include <linux/wait.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/mutex.h>",
      "#include <linux/atomic.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/isolation.h>",
      "#include <linux/oom.h>",
      "#include <linux/sort.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/time64.h>",
      "#include <linux/time.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/security.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/sched/deadline.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/mount.h>",
      "#include <linux/export.h>",
      "#include <linux/memory.h>",
      "#include <linux/mm.h>",
      "#include <linux/mempolicy.h>",
      "#include <linux/list.h>",
      "#include <linux/kmod.h>",
      "#include <linux/kernel.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/errno.h>",
      "#include <linux/err.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "css",
            "structcpuset",
            "css"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/wait.h>\n#include <linux/cgroup.h>\n#include <linux/mutex.h>\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sched/isolation.h>\n#include <linux/oom.h>\n#include <linux/sort.h>\n#include <linux/backing-dev.h>\n#include <linux/time64.h>\n#include <linux/time.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/seq_file.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/memory.h>\n#include <linux/mm.h>\n#include <linux/mempolicy.h>\n#include <linux/list.h>\n#include <linux/kmod.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/cpuset.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n\nstatic inline struct cpuset *css_cs(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct cpuset, css) : NULL;\n}"
  }
]