[
  {
    "function_name": "syscall_unregfunc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "775-787",
    "snippet": "void syscall_unregfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tsys_tracepoint_refcount--;\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tclear_task_syscall_work(t, SYSCALL_TRACEPOINT);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_task_syscall_work",
          "args": [
            "t",
            "SYSCALL_TRACEPOINT"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nvoid syscall_unregfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tsys_tracepoint_refcount--;\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tclear_task_syscall_work(t, SYSCALL_TRACEPOINT);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n}"
  },
  {
    "function_name": "syscall_regfunc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "759-773",
    "snippet": "int syscall_regfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tset_task_syscall_work(t, SYSCALL_TRACEPOINT);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tsys_tracepoint_refcount++;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "do_mmap_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/task_iter.c",
          "lines": "634-643",
          "snippet": "static void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}",
          "includes": [
            "#include \"mmap_unlock_work.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/filter.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmap_unlock_work.h\"\n#include <linux/btf_ids.h>\n#include <linux/filter.h>\n#include <linux/fdtable.h>\n#include <linux/fs.h>\n#include <linux/pid_namespace.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n\nstatic void do_mmap_read_unlock(struct irq_work *entry)\n{\n\tstruct mmap_unlock_irq_work *work;\n\n\tif (WARN_ON_ONCE(IS_ENABLED(CONFIG_PREEMPT_RT)))\n\t\treturn;\n\n\twork = container_of(entry, struct mmap_unlock_irq_work, irq_work);\n\tmmap_read_unlock_non_owner(work->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_syscall_work",
          "args": [
            "t",
            "SYSCALL_TRACEPOINT"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/umh.c",
          "lines": "242-266",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/initrd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/initrd.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fs_struct.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint syscall_regfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tset_task_syscall_work(t, SYSCALL_TRACEPOINT);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tsys_tracepoint_refcount++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "for_each_kernel_tracepoint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "746-751",
    "snippet": "void for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern tracepoint_ptr_t __start___tracepoints_ptrs[];",
      "extern tracepoint_ptr_t __stop___tracepoints_ptrs[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_tracepoint_range",
          "args": [
            "__start___tracepoints_ptrs",
            "__stop___tracepoints_ptrs",
            "fct",
            "priv"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "for_each_tracepoint_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "557-568",
          "snippet": "static void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nextern tracepoint_ptr_t __start___tracepoints_ptrs[];\nextern tracepoint_ptr_t __stop___tracepoints_ptrs[];\n\nvoid for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}"
  },
  {
    "function_name": "init_tracepoints",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "728-737",
    "snippet": "static __init int init_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_module_notifier(&tracepoint_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register tracepoint module enter notifier\\n\");\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register tracepoint module enter notifier\\n\""
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&tracepoint_module_nb"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic __init int init_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_module_notifier(&tracepoint_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register tracepoint module enter notifier\\n\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tracepoint_module_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "702-721",
    "snippet": "static int tracepoint_module_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = tracepoint_module_coming(mod);\n\t\tbreak;\n\tcase MODULE_STATE_LIVE:\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\ttracepoint_module_going(mod);\n\t\tbreak;\n\tcase MODULE_STATE_UNFORMED:\n\t\tbreak;\n\t}\n\treturn notifier_from_errno(ret);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_from_errno",
          "args": [
            "ret"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracepoint_module_going",
          "args": [
            "mod"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_module_going",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "669-700",
          "snippet": "static void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tMODULE_STATE_GOING, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t/*\n\t\t\t * Called the going notifier before checking for\n\t\t\t * quiescence.\n\t\t\t */\n\t\t\tfor_each_tracepoint_range(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints,\n\t\t\t\ttp_module_going_check_quiescent, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * In the case of modules that were tainted at \"coming\", we'll simply\n\t * walk through the list without finding it. We cannot use the \"tainted\"\n\t * flag on \"going\", in case a module taints the kernel only after being\n\t * loaded.\n\t */\n\tmutex_unlock(&tracepoint_module_list_mutex);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tMODULE_STATE_GOING, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t/*\n\t\t\t * Called the going notifier before checking for\n\t\t\t * quiescence.\n\t\t\t */\n\t\t\tfor_each_tracepoint_range(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints,\n\t\t\t\ttp_module_going_check_quiescent, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * In the case of modules that were tainted at \"coming\", we'll simply\n\t * walk through the list without finding it. We cannot use the \"tainted\"\n\t * flag on \"going\", in case a module taints the kernel only after being\n\t * loaded.\n\t */\n\tmutex_unlock(&tracepoint_module_list_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_module_coming",
          "args": [
            "mod"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_module_coming",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "639-667",
          "snippet": "static int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\tint ret = 0;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t/*\n\t * We skip modules that taint the kernel, especially those with different\n\t * module headers (for forced load), to make sure we don't cause a crash.\n\t * Staging, out-of-tree, and unsigned GPL modules are fine.\n\t */\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\tmutex_lock(&tracepoint_module_list_mutex);\n\ttp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);\n\tif (!tp_mod) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\ttp_mod->mod = mod;\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tMODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\tint ret = 0;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t/*\n\t * We skip modules that taint the kernel, especially those with different\n\t * module headers (for forced load), to make sure we don't cause a crash.\n\t * Staging, out-of-tree, and unsigned GPL modules are fine.\n\t */\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\tmutex_lock(&tracepoint_module_list_mutex);\n\ttp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);\n\tif (!tp_mod) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\ttp_mod->mod = mod;\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tMODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int tracepoint_module_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = tracepoint_module_coming(mod);\n\t\tbreak;\n\tcase MODULE_STATE_LIVE:\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\ttracepoint_module_going(mod);\n\t\tbreak;\n\tcase MODULE_STATE_UNFORMED:\n\t\tbreak;\n\t}\n\treturn notifier_from_errno(ret);\n}"
  },
  {
    "function_name": "tracepoint_module_going",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "669-700",
    "snippet": "static void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tMODULE_STATE_GOING, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t/*\n\t\t\t * Called the going notifier before checking for\n\t\t\t * quiescence.\n\t\t\t */\n\t\t\tfor_each_tracepoint_range(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints,\n\t\t\t\ttp_module_going_check_quiescent, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * In the case of modules that were tainted at \"coming\", we'll simply\n\t * walk through the list without finding it. We cannot use the \"tainted\"\n\t * flag on \"going\", in case a module taints the kernel only after being\n\t * loaded.\n\t */\n\tmutex_unlock(&tracepoint_module_list_mutex);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_tracepoint_range",
          "args": [
            "mod->tracepoints_ptrs",
            "mod->tracepoints_ptrs + mod->num_tracepoints",
            "tp_module_going_check_quiescent",
            "NULL"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "for_each_tracepoint_range",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "557-568",
          "snippet": "static void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tp_mod"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tp_mod->list"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&tracepoint_notify_list",
            "MODULE_STATE_GOING",
            "tp_mod"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "307-323",
          "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp_mod",
            "&tracepoint_module_list",
            "list"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tMODULE_STATE_GOING, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t/*\n\t\t\t * Called the going notifier before checking for\n\t\t\t * quiescence.\n\t\t\t */\n\t\t\tfor_each_tracepoint_range(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints,\n\t\t\t\ttp_module_going_check_quiescent, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * In the case of modules that were tainted at \"coming\", we'll simply\n\t * walk through the list without finding it. We cannot use the \"tainted\"\n\t * flag on \"going\", in case a module taints the kernel only after being\n\t * loaded.\n\t */\n\tmutex_unlock(&tracepoint_module_list_mutex);\n}"
  },
  {
    "function_name": "tracepoint_module_coming",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "639-667",
    "snippet": "static int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\tint ret = 0;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t/*\n\t * We skip modules that taint the kernel, especially those with different\n\t * module headers (for forced load), to make sure we don't cause a crash.\n\t * Staging, out-of-tree, and unsigned GPL modules are fine.\n\t */\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\tmutex_lock(&tracepoint_module_list_mutex);\n\ttp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);\n\tif (!tp_mod) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\ttp_mod->mod = mod;\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tMODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&tracepoint_notify_list",
            "MODULE_STATE_COMING",
            "tp_mod"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "307-323",
          "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tp_mod->list",
            "&tracepoint_module_list"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct tp_module)",
            "GFP_KERNEL"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_module_has_bad_taint",
          "args": [
            "mod"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "trace_module_has_bad_taint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "571-575",
          "snippet": "bool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nbool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\tint ret = 0;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t/*\n\t * We skip modules that taint the kernel, especially those with different\n\t * module headers (for forced load), to make sure we don't cause a crash.\n\t * Staging, out-of-tree, and unsigned GPL modules are fine.\n\t */\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\tmutex_lock(&tracepoint_module_list_mutex);\n\ttp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);\n\tif (!tp_mod) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\ttp_mod->mod = mod;\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tMODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "tp_module_going_check_quiescent",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "634-637",
    "snippet": "static void tp_module_going_check_quiescent(struct tracepoint *tp, void *priv)\n{\n\tWARN_ON_ONCE(tp->funcs);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tp->funcs"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void tp_module_going_check_quiescent(struct tracepoint *tp, void *priv)\n{\n\tWARN_ON_ONCE(tp->funcs);\n}"
  },
  {
    "function_name": "unregister_tracepoint_module_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "612-627",
    "snippet": "int unregister_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_unregister(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, MODULE_STATE_GOING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "nb",
            "MODULE_STATE_GOING",
            "tp_mod"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "void"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp_mod",
            "&tracepoint_module_list",
            "list"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocking_notifier_chain_unregister",
          "args": [
            "&tracepoint_notify_list",
            "nb"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "252-269",
          "snippet": "int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_unregister(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, MODULE_STATE_GOING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "register_tracepoint_module_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "588-602",
    "snippet": "int register_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_register(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, MODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "nb",
            "MODULE_STATE_COMING",
            "tp_mod"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "void"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp_mod",
            "&tracepoint_module_list",
            "list"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocking_notifier_chain_register",
          "args": [
            "&tracepoint_notify_list",
            "nb"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "222-239",
          "snippet": "int blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint register_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_register(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, MODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_module_has_bad_taint",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "571-575",
    "snippet": "bool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nbool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}"
  },
  {
    "function_name": "for_each_tracepoint_range",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "557-568",
    "snippet": "static void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fct",
          "args": [
            "tracepoint_ptr_deref(iter)",
            "priv"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracepoint_ptr_deref",
          "args": [
            "iter"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}"
  },
  {
    "function_name": "tracepoint_probe_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "543-554",
    "snippet": "int tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(tracepoints_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_remove_func",
          "args": [
            "tp",
            "&tp_func"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_remove_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "396-460",
          "snippet": "static int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (WARN_ON_ONCE(IS_ERR(old)))\n\t\treturn PTR_ERR(old);\n\n\tif (tp_funcs == old)\n\t\t/* Failed allocating new tp_funcs, replaced func with stub */\n\t\treturn 0;\n\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_0:\t\t/* 1->0 */\n\t\t/* Removed last function */\n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tstatic_key_disable(&tp->key);\n\t\t/* Set iterator static call */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/* Both iterator and static call handle NULL tp->funcs */\n\t\trcu_assign_pointer(tp->funcs, NULL);\n\t\t/*\n\t\t * Make sure new static func never uses old data after a\n\t\t * 1->0->1 transition sequence.\n\t\t */\n\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_1_0_1);\n\t\tbreak;\n\tcase TP_FUNC_1:\t\t/* 2->1 */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>2) transition sequence. If the first\n\t\t * element's data has changed, then force the synchronization\n\t\t * to prevent current readers that have loaded the old data\n\t\t * from calling the new function.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_N_2_1);\n\t\t/* Set static call to first function */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t/* N->N-1 (N>2) */\n\t\tfallthrough;\n\tcase TP_FUNC_N:\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>2) transition sequence.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\trelease_probes(old);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nstatic int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (WARN_ON_ONCE(IS_ERR(old)))\n\t\treturn PTR_ERR(old);\n\n\tif (tp_funcs == old)\n\t\t/* Failed allocating new tp_funcs, replaced func with stub */\n\t\treturn 0;\n\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_0:\t\t/* 1->0 */\n\t\t/* Removed last function */\n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tstatic_key_disable(&tp->key);\n\t\t/* Set iterator static call */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/* Both iterator and static call handle NULL tp->funcs */\n\t\trcu_assign_pointer(tp->funcs, NULL);\n\t\t/*\n\t\t * Make sure new static func never uses old data after a\n\t\t * 1->0->1 transition sequence.\n\t\t */\n\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_1_0_1);\n\t\tbreak;\n\tcase TP_FUNC_1:\t\t/* 2->1 */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>2) transition sequence. If the first\n\t\t * element's data has changed, then force the synchronization\n\t\t * to prevent current readers that have loaded the old data\n\t\t * from calling the new function.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_N_2_1);\n\t\t/* Set static call to first function */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t/* N->N-1 (N>2) */\n\t\tfallthrough;\n\tcase TP_FUNC_N:\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>2) transition sequence.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\trelease_probes(old);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "tracepoint_probe_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "529-532",
    "snippet": "int tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracepoint_probe_register_prio",
          "args": [
            "tp",
            "probe",
            "data",
            "TRACEPOINT_DEFAULT_PRIO"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_probe_register_prio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "501-514",
          "snippet": "int tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,\n\t\t\t\t   void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio, true);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,\n\t\t\t\t   void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio, true);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}"
  },
  {
    "function_name": "tracepoint_probe_register_prio",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "501-514",
    "snippet": "int tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,\n\t\t\t\t   void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio, true);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(tracepoints_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_add_func",
          "args": [
            "tp",
            "&tp_func",
            "prio",
            "true"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_add_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "323-388",
          "snippet": "static int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio,\n\t\t\t       bool warn)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(warn && PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_1:\t\t/* 0->1 */\n\t\t/*\n\t\t * Make sure new static func never uses old data after a\n\t\t * 1->0->1 transition sequence.\n\t\t */\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_1_0_1);\n\t\t/* Set static call to first function */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/* Both iterator and static call handle NULL tp->funcs */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\tstatic_key_enable(&tp->key);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t/* 1->2 */\n\t\t/* Set iterator static call */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/*\n\t\t * Iterator callback installed before updating tp->funcs.\n\t\t * Requires ordering between RCU assign/dereference and\n\t\t * static call update/call.\n\t\t */\n\t\tfallthrough;\n\tcase TP_FUNC_N:\t\t/* N->N+1 (N>1) */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>1) transition sequence.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\trelease_probes(old);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nstatic int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio,\n\t\t\t       bool warn)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(warn && PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_1:\t\t/* 0->1 */\n\t\t/*\n\t\t * Make sure new static func never uses old data after a\n\t\t * 1->0->1 transition sequence.\n\t\t */\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_1_0_1);\n\t\t/* Set static call to first function */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/* Both iterator and static call handle NULL tp->funcs */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\tstatic_key_enable(&tp->key);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t/* 1->2 */\n\t\t/* Set iterator static call */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/*\n\t\t * Iterator callback installed before updating tp->funcs.\n\t\t * Requires ordering between RCU assign/dereference and\n\t\t * static call update/call.\n\t\t */\n\t\tfallthrough;\n\tcase TP_FUNC_N:\t\t/* N->N+1 (N>1) */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>1) transition sequence.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\trelease_probes(old);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,\n\t\t\t\t   void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio, true);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "tracepoint_probe_register_prio_may_exist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "472-485",
    "snippet": "int tracepoint_probe_register_prio_may_exist(struct tracepoint *tp, void *probe,\n\t\t\t\t\t     void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio, false);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(tracepoints_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_add_func",
          "args": [
            "tp",
            "&tp_func",
            "prio",
            "false"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_add_func",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "323-388",
          "snippet": "static int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio,\n\t\t\t       bool warn)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(warn && PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_1:\t\t/* 0->1 */\n\t\t/*\n\t\t * Make sure new static func never uses old data after a\n\t\t * 1->0->1 transition sequence.\n\t\t */\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_1_0_1);\n\t\t/* Set static call to first function */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/* Both iterator and static call handle NULL tp->funcs */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\tstatic_key_enable(&tp->key);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t/* 1->2 */\n\t\t/* Set iterator static call */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/*\n\t\t * Iterator callback installed before updating tp->funcs.\n\t\t * Requires ordering between RCU assign/dereference and\n\t\t * static call update/call.\n\t\t */\n\t\tfallthrough;\n\tcase TP_FUNC_N:\t\t/* N->N+1 (N>1) */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>1) transition sequence.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\trelease_probes(old);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nstatic int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio,\n\t\t\t       bool warn)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(warn && PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_1:\t\t/* 0->1 */\n\t\t/*\n\t\t * Make sure new static func never uses old data after a\n\t\t * 1->0->1 transition sequence.\n\t\t */\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_1_0_1);\n\t\t/* Set static call to first function */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/* Both iterator and static call handle NULL tp->funcs */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\tstatic_key_enable(&tp->key);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t/* 1->2 */\n\t\t/* Set iterator static call */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/*\n\t\t * Iterator callback installed before updating tp->funcs.\n\t\t * Requires ordering between RCU assign/dereference and\n\t\t * static call update/call.\n\t\t */\n\t\tfallthrough;\n\tcase TP_FUNC_N:\t\t/* N->N+1 (N>1) */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>1) transition sequence.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\trelease_probes(old);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_register_prio_may_exist(struct tracepoint *tp, void *probe,\n\t\t\t\t\t     void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio, false);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "tracepoint_remove_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "396-460",
    "snippet": "static int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (WARN_ON_ONCE(IS_ERR(old)))\n\t\treturn PTR_ERR(old);\n\n\tif (tp_funcs == old)\n\t\t/* Failed allocating new tp_funcs, replaced func with stub */\n\t\treturn 0;\n\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_0:\t\t/* 1->0 */\n\t\t/* Removed last function */\n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tstatic_key_disable(&tp->key);\n\t\t/* Set iterator static call */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/* Both iterator and static call handle NULL tp->funcs */\n\t\trcu_assign_pointer(tp->funcs, NULL);\n\t\t/*\n\t\t * Make sure new static func never uses old data after a\n\t\t * 1->0->1 transition sequence.\n\t\t */\n\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_1_0_1);\n\t\tbreak;\n\tcase TP_FUNC_1:\t\t/* 2->1 */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>2) transition sequence. If the first\n\t\t * element's data has changed, then force the synchronization\n\t\t * to prevent current readers that have loaded the old data\n\t\t * from calling the new function.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_N_2_1);\n\t\t/* Set static call to first function */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t/* N->N-1 (N>2) */\n\t\tfallthrough;\n\tcase TP_FUNC_N:\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>2) transition sequence.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\trelease_probes(old);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(tracepoints_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_probes",
          "args": [
            "old"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "release_probes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "142-166",
          "snippet": "static inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_head *early_probes;",
            "static bool ok_to_free_tracepoints;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct rcu_head *early_probes;\nstatic bool ok_to_free_tracepoints;\n\nstatic inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_rcu_get_state",
          "args": [
            "TP_TRANSITION_SYNC_N_2_1"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "tp_rcu_get_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "47-55",
          "snippet": "static void tp_rcu_get_state(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\t/* Keep the latest get_state snapshot. */\n\tsnapshot->rcu = get_state_synchronize_rcu();\n\tsnapshot->srcu = start_poll_synchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = true;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];\n\nstatic void tp_rcu_get_state(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\t/* Keep the latest get_state snapshot. */\n\tsnapshot->rcu = get_state_synchronize_rcu();\n\tsnapshot->srcu = start_poll_synchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tp->funcs",
            "tp_funcs"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracepoint_update_call",
          "args": [
            "tp",
            "tp_funcs"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_update_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "308-318",
          "snippet": "static void tracepoint_update_call(struct tracepoint *tp, struct tracepoint_func *tp_funcs)\n{\n\tvoid *func = tp->iterator;\n\n\t/* Synthetic events do not have static call sites */\n\tif (!tp->static_call_key)\n\t\treturn;\n\tif (nr_func_state(tp_funcs) == TP_FUNC_1)\n\t\tfunc = tp_funcs[0].func;\n\t__static_call_update(tp->static_call_key, tp->static_call_tramp, func);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void tracepoint_update_call(struct tracepoint *tp, struct tracepoint_func *tp_funcs)\n{\n\tvoid *func = tp->iterator;\n\n\t/* Synthetic events do not have static call sites */\n\tif (!tp->static_call_key)\n\t\treturn;\n\tif (nr_func_state(tp_funcs) == TP_FUNC_1)\n\t\tfunc = tp_funcs[0].func;\n\t__static_call_update(tp->static_call_key, tp->static_call_tramp, func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_rcu_cond_sync",
          "args": [
            "TP_TRANSITION_SYNC_N_2_1"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "tp_rcu_cond_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "57-67",
          "snippet": "static void tp_rcu_cond_sync(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\tif (!snapshot->ongoing)\n\t\treturn;\n\tcond_synchronize_rcu(snapshot->rcu);\n\tif (!poll_state_synchronize_srcu(&tracepoint_srcu, snapshot->srcu))\n\t\tsynchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = false;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];\n\nstatic void tp_rcu_cond_sync(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\tif (!snapshot->ongoing)\n\t\treturn;\n\tcond_synchronize_rcu(snapshot->rcu);\n\tif (!poll_state_synchronize_srcu(&tracepoint_srcu, snapshot->srcu))\n\t\tsynchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tp->funcs",
            "tp_funcs"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tp->funcs",
            "NULL"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_disable",
          "args": [
            "&tp->key"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "212-217",
          "snippet": "void static_key_disable(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_disable_cpuslocked(key);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void jump_label_update(struct static_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key);\n\nvoid static_key_disable(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_disable_cpuslocked(key);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->unregfunc",
          "args": [],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "&tp->key"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nr_func_state",
          "args": [
            "tp_funcs"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "nr_func_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "297-306",
          "snippet": "static enum tp_func_state nr_func_state(const struct tracepoint_func *tp_funcs)\n{\n\tif (!tp_funcs)\n\t\treturn TP_FUNC_0;\n\tif (!tp_funcs[1].func)\n\t\treturn TP_FUNC_1;\n\tif (!tp_funcs[2].func)\n\t\treturn TP_FUNC_2;\n\treturn TP_FUNC_N;\t/* 3 or more */\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum tp_func_state nr_func_state(const struct tracepoint_func *tp_funcs)\n{\n\tif (!tp_funcs)\n\t\treturn TP_FUNC_0;\n\tif (!tp_funcs[1].func)\n\t\treturn TP_FUNC_1;\n\tif (!tp_funcs[2].func)\n\t\treturn TP_FUNC_2;\n\treturn TP_FUNC_N;\t/* 3 or more */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "IS_ERR(old)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_remove",
          "args": [
            "&tp_funcs",
            "func"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "func_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "232-292",
          "snippet": "static void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdebug_print_probes(*funcs);\n\t/* (N -> M), (N > 1, M >= 0) probes */\n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif ((old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data) ||\n\t\t\t    old[nr_probes].func == tp_stub_func)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t/*\n\t * If probe is NULL, then nr_probes = nr_del = 0, and then the\n\t * entire entry will be removed.\n\t */\n\tif (nr_probes - nr_del == 0) {\n\t\t/* N -> 0, (N > 1) */\n\t\t*funcs = NULL;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t/* N -> M, (N > 1, M > 0) */\n\t\t/* + 1 for NULL */\n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new) {\n\t\t\tfor (i = 0; old[i].func; i++) {\n\t\t\t\tif ((old[i].func != tp_func->func ||\n\t\t\t\t     old[i].data != tp_func->data) &&\n\t\t\t\t    old[i].func != tp_stub_func)\n\t\t\t\t\tnew[j++] = old[i];\n\t\t\t}\n\t\t\tnew[nr_probes - nr_del].func = NULL;\n\t\t\t*funcs = new;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Failed to allocate, replace the old function\n\t\t\t * with calls to tp_stub_func.\n\t\t\t */\n\t\t\tfor (i = 0; old[i].func; i++) {\n\t\t\t\tif (old[i].func == tp_func->func &&\n\t\t\t\t    old[i].data == tp_func->data)\n\t\t\t\t\tWRITE_ONCE(old[i].func, tp_stub_func);\n\t\t\t}\n\t\t\t*funcs = old;\n\t\t}\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdebug_print_probes(*funcs);\n\t/* (N -> M), (N > 1, M >= 0) probes */\n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif ((old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data) ||\n\t\t\t    old[nr_probes].func == tp_stub_func)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t/*\n\t * If probe is NULL, then nr_probes = nr_del = 0, and then the\n\t * entire entry will be removed.\n\t */\n\tif (nr_probes - nr_del == 0) {\n\t\t/* N -> 0, (N > 1) */\n\t\t*funcs = NULL;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t/* N -> M, (N > 1, M > 0) */\n\t\t/* + 1 for NULL */\n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new) {\n\t\t\tfor (i = 0; old[i].func; i++) {\n\t\t\t\tif ((old[i].func != tp_func->func ||\n\t\t\t\t     old[i].data != tp_func->data) &&\n\t\t\t\t    old[i].func != tp_stub_func)\n\t\t\t\t\tnew[j++] = old[i];\n\t\t\t}\n\t\t\tnew[nr_probes - nr_del].func = NULL;\n\t\t\t*funcs = new;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Failed to allocate, replace the old function\n\t\t\t * with calls to tp_stub_func.\n\t\t\t */\n\t\t\tfor (i = 0; old[i].func; i++) {\n\t\t\t\tif (old[i].func == tp_func->func &&\n\t\t\t\t    old[i].data == tp_func->data)\n\t\t\t\t\tWRITE_ONCE(old[i].func, tp_stub_func);\n\t\t\t}\n\t\t\t*funcs = old;\n\t\t}\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tp->funcs",
            "lockdep_is_held(&tracepoints_mutex)"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nstatic int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (WARN_ON_ONCE(IS_ERR(old)))\n\t\treturn PTR_ERR(old);\n\n\tif (tp_funcs == old)\n\t\t/* Failed allocating new tp_funcs, replaced func with stub */\n\t\treturn 0;\n\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_0:\t\t/* 1->0 */\n\t\t/* Removed last function */\n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tstatic_key_disable(&tp->key);\n\t\t/* Set iterator static call */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/* Both iterator and static call handle NULL tp->funcs */\n\t\trcu_assign_pointer(tp->funcs, NULL);\n\t\t/*\n\t\t * Make sure new static func never uses old data after a\n\t\t * 1->0->1 transition sequence.\n\t\t */\n\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_1_0_1);\n\t\tbreak;\n\tcase TP_FUNC_1:\t\t/* 2->1 */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>2) transition sequence. If the first\n\t\t * element's data has changed, then force the synchronization\n\t\t * to prevent current readers that have loaded the old data\n\t\t * from calling the new function.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_N_2_1);\n\t\t/* Set static call to first function */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t/* N->N-1 (N>2) */\n\t\tfallthrough;\n\tcase TP_FUNC_N:\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>2) transition sequence.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\trelease_probes(old);\n\treturn 0;\n}"
  },
  {
    "function_name": "tracepoint_add_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "323-388",
    "snippet": "static int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio,\n\t\t\t       bool warn)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(warn && PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_1:\t\t/* 0->1 */\n\t\t/*\n\t\t * Make sure new static func never uses old data after a\n\t\t * 1->0->1 transition sequence.\n\t\t */\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_1_0_1);\n\t\t/* Set static call to first function */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/* Both iterator and static call handle NULL tp->funcs */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\tstatic_key_enable(&tp->key);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t/* 1->2 */\n\t\t/* Set iterator static call */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/*\n\t\t * Iterator callback installed before updating tp->funcs.\n\t\t * Requires ordering between RCU assign/dereference and\n\t\t * static call update/call.\n\t\t */\n\t\tfallthrough;\n\tcase TP_FUNC_N:\t\t/* N->N+1 (N>1) */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>1) transition sequence.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\trelease_probes(old);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(tracepoints_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_probes",
          "args": [
            "old"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "release_probes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "142-166",
          "snippet": "static inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_head *early_probes;",
            "static bool ok_to_free_tracepoints;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct rcu_head *early_probes;\nstatic bool ok_to_free_tracepoints;\n\nstatic inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_rcu_get_state",
          "args": [
            "TP_TRANSITION_SYNC_N_2_1"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "tp_rcu_get_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "47-55",
          "snippet": "static void tp_rcu_get_state(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\t/* Keep the latest get_state snapshot. */\n\tsnapshot->rcu = get_state_synchronize_rcu();\n\tsnapshot->srcu = start_poll_synchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = true;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];\n\nstatic void tp_rcu_get_state(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\t/* Keep the latest get_state snapshot. */\n\tsnapshot->rcu = get_state_synchronize_rcu();\n\tsnapshot->srcu = start_poll_synchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tp->funcs",
            "tp_funcs"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracepoint_update_call",
          "args": [
            "tp",
            "tp_funcs"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_update_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "308-318",
          "snippet": "static void tracepoint_update_call(struct tracepoint *tp, struct tracepoint_func *tp_funcs)\n{\n\tvoid *func = tp->iterator;\n\n\t/* Synthetic events do not have static call sites */\n\tif (!tp->static_call_key)\n\t\treturn;\n\tif (nr_func_state(tp_funcs) == TP_FUNC_1)\n\t\tfunc = tp_funcs[0].func;\n\t__static_call_update(tp->static_call_key, tp->static_call_tramp, func);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void tracepoint_update_call(struct tracepoint *tp, struct tracepoint_func *tp_funcs)\n{\n\tvoid *func = tp->iterator;\n\n\t/* Synthetic events do not have static call sites */\n\tif (!tp->static_call_key)\n\t\treturn;\n\tif (nr_func_state(tp_funcs) == TP_FUNC_1)\n\t\tfunc = tp_funcs[0].func;\n\t__static_call_update(tp->static_call_key, tp->static_call_tramp, func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_enable",
          "args": [
            "&tp->key"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "187-192",
          "snippet": "void static_key_enable(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_enable_cpuslocked(key);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void jump_label_update(struct static_key *key);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key);\n\nvoid static_key_enable(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_enable_cpuslocked(key);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tp->funcs",
            "tp_funcs"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_rcu_cond_sync",
          "args": [
            "TP_TRANSITION_SYNC_1_0_1"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "tp_rcu_cond_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "57-67",
          "snippet": "static void tp_rcu_cond_sync(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\tif (!snapshot->ongoing)\n\t\treturn;\n\tcond_synchronize_rcu(snapshot->rcu);\n\tif (!poll_state_synchronize_srcu(&tracepoint_srcu, snapshot->srcu))\n\t\tsynchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = false;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];\n\nstatic void tp_rcu_cond_sync(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\tif (!snapshot->ongoing)\n\t\treturn;\n\tcond_synchronize_rcu(snapshot->rcu);\n\tif (!poll_state_synchronize_srcu(&tracepoint_srcu, snapshot->srcu))\n\t\tsynchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_func_state",
          "args": [
            "tp_funcs"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "nr_func_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "297-306",
          "snippet": "static enum tp_func_state nr_func_state(const struct tracepoint_func *tp_funcs)\n{\n\tif (!tp_funcs)\n\t\treturn TP_FUNC_0;\n\tif (!tp_funcs[1].func)\n\t\treturn TP_FUNC_1;\n\tif (!tp_funcs[2].func)\n\t\treturn TP_FUNC_2;\n\treturn TP_FUNC_N;\t/* 3 or more */\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum tp_func_state nr_func_state(const struct tracepoint_func *tp_funcs)\n{\n\tif (!tp_funcs)\n\t\treturn TP_FUNC_0;\n\tif (!tp_funcs[1].func)\n\t\treturn TP_FUNC_1;\n\tif (!tp_funcs[2].func)\n\t\treturn TP_FUNC_2;\n\treturn TP_FUNC_N;\t/* 3 or more */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "warn && PTR_ERR(old) != -ENOMEM"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_add",
          "args": [
            "&tp_funcs",
            "func",
            "prio"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "func_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "179-230",
          "snippet": "static struct tracepoint_func *\nfunc_add(struct tracepoint_func **funcs, struct tracepoint_func *tp_func,\n\t int prio)\n{\n\tstruct tracepoint_func *old, *new;\n\tint iter_probes;\t/* Iterate over old probe array. */\n\tint nr_probes = 0;\t/* Counter for probes */\n\tint pos = -1;\t\t/* Insertion position into new array */\n\n\tif (WARN_ON(!tp_func->func))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t/* (N -> N+1), (N != 0, 1) probes */\n\t\tfor (iter_probes = 0; old[iter_probes].func; iter_probes++) {\n\t\t\tif (old[iter_probes].func == tp_stub_func)\n\t\t\t\tcontinue;\t/* Skip stub functions. */\n\t\t\tif (old[iter_probes].func == tp_func->func &&\n\t\t\t    old[iter_probes].data == tp_func->data)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t\tnr_probes++;\n\t\t}\n\t}\n\t/* + 2 : one for new probe, one for NULL func */\n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (old) {\n\t\tnr_probes = 0;\n\t\tfor (iter_probes = 0; old[iter_probes].func; iter_probes++) {\n\t\t\tif (old[iter_probes].func == tp_stub_func)\n\t\t\t\tcontinue;\n\t\t\t/* Insert before probes of lower priority */\n\t\t\tif (pos < 0 && old[iter_probes].prio < prio)\n\t\t\t\tpos = nr_probes++;\n\t\t\tnew[nr_probes++] = old[iter_probes];\n\t\t}\n\t\tif (pos < 0)\n\t\t\tpos = nr_probes++;\n\t\t/* nr_probes now points to the end of the new array */\n\t} else {\n\t\tpos = 0;\n\t\tnr_probes = 1; /* must point at end of array */\n\t}\n\tnew[pos] = *tp_func;\n\tnew[nr_probes].func = NULL;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct tracepoint_func *\nfunc_add(struct tracepoint_func **funcs, struct tracepoint_func *tp_func,\n\t int prio)\n{\n\tstruct tracepoint_func *old, *new;\n\tint iter_probes;\t/* Iterate over old probe array. */\n\tint nr_probes = 0;\t/* Counter for probes */\n\tint pos = -1;\t\t/* Insertion position into new array */\n\n\tif (WARN_ON(!tp_func->func))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t/* (N -> N+1), (N != 0, 1) probes */\n\t\tfor (iter_probes = 0; old[iter_probes].func; iter_probes++) {\n\t\t\tif (old[iter_probes].func == tp_stub_func)\n\t\t\t\tcontinue;\t/* Skip stub functions. */\n\t\t\tif (old[iter_probes].func == tp_func->func &&\n\t\t\t    old[iter_probes].data == tp_func->data)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t\tnr_probes++;\n\t\t}\n\t}\n\t/* + 2 : one for new probe, one for NULL func */\n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (old) {\n\t\tnr_probes = 0;\n\t\tfor (iter_probes = 0; old[iter_probes].func; iter_probes++) {\n\t\t\tif (old[iter_probes].func == tp_stub_func)\n\t\t\t\tcontinue;\n\t\t\t/* Insert before probes of lower priority */\n\t\t\tif (pos < 0 && old[iter_probes].prio < prio)\n\t\t\t\tpos = nr_probes++;\n\t\t\tnew[nr_probes++] = old[iter_probes];\n\t\t}\n\t\tif (pos < 0)\n\t\t\tpos = nr_probes++;\n\t\t/* nr_probes now points to the end of the new array */\n\t} else {\n\t\tpos = 0;\n\t\tnr_probes = 1; /* must point at end of array */\n\t}\n\tnew[pos] = *tp_func;\n\tnew[nr_probes].func = NULL;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tp->funcs",
            "lockdep_is_held(&tracepoints_mutex)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp->regfunc",
          "args": [],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "&tp->key"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nstatic int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio,\n\t\t\t       bool warn)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(warn && PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\tswitch (nr_func_state(tp_funcs)) {\n\tcase TP_FUNC_1:\t\t/* 0->1 */\n\t\t/*\n\t\t * Make sure new static func never uses old data after a\n\t\t * 1->0->1 transition sequence.\n\t\t */\n\t\ttp_rcu_cond_sync(TP_TRANSITION_SYNC_1_0_1);\n\t\t/* Set static call to first function */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/* Both iterator and static call handle NULL tp->funcs */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\tstatic_key_enable(&tp->key);\n\t\tbreak;\n\tcase TP_FUNC_2:\t\t/* 1->2 */\n\t\t/* Set iterator static call */\n\t\ttracepoint_update_call(tp, tp_funcs);\n\t\t/*\n\t\t * Iterator callback installed before updating tp->funcs.\n\t\t * Requires ordering between RCU assign/dereference and\n\t\t * static call update/call.\n\t\t */\n\t\tfallthrough;\n\tcase TP_FUNC_N:\t\t/* N->N+1 (N>1) */\n\t\trcu_assign_pointer(tp->funcs, tp_funcs);\n\t\t/*\n\t\t * Make sure static func never uses incorrect data after a\n\t\t * N->...->2->1 (N>1) transition sequence.\n\t\t */\n\t\tif (tp_funcs[0].data != old[0].data)\n\t\t\ttp_rcu_get_state(TP_TRANSITION_SYNC_N_2_1);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\trelease_probes(old);\n\treturn 0;\n}"
  },
  {
    "function_name": "tracepoint_update_call",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "308-318",
    "snippet": "static void tracepoint_update_call(struct tracepoint *tp, struct tracepoint_func *tp_funcs)\n{\n\tvoid *func = tp->iterator;\n\n\t/* Synthetic events do not have static call sites */\n\tif (!tp->static_call_key)\n\t\treturn;\n\tif (nr_func_state(tp_funcs) == TP_FUNC_1)\n\t\tfunc = tp_funcs[0].func;\n\t__static_call_update(tp->static_call_key, tp->static_call_tramp, func);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_call_update",
          "args": [
            "tp->static_call_key",
            "tp->static_call_tramp",
            "func"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "__static_call_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "123-206",
          "snippet": "void __static_call_update(struct static_call_key *key, void *tramp, void *func)\n{\n\tstruct static_call_site *site, *stop;\n\tstruct static_call_mod *site_mod, first;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\n\tif (key->func == func)\n\t\tgoto done;\n\n\tkey->func = func;\n\n\tarch_static_call_transform(NULL, tramp, func, false);\n\n\t/*\n\t * If uninitialized, we'll not update the callsites, but they still\n\t * point to the trampoline and we just patched that.\n\t */\n\tif (WARN_ON_ONCE(!static_call_initialized))\n\t\tgoto done;\n\n\tfirst = (struct static_call_mod){\n\t\t.next = static_call_key_next(key),\n\t\t.mod = NULL,\n\t\t.sites = static_call_key_sites(key),\n\t};\n\n\tfor (site_mod = &first; site_mod; site_mod = site_mod->next) {\n\t\tbool init = system_state < SYSTEM_RUNNING;\n\t\tstruct module *mod = site_mod->mod;\n\n\t\tif (!site_mod->sites) {\n\t\t\t/*\n\t\t\t * This can happen if the static call key is defined in\n\t\t\t * a module which doesn't use it.\n\t\t\t *\n\t\t\t * It also happens in the has_mods case, where the\n\t\t\t * 'first' entry has no sites associated with it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tstop = __stop_static_call_sites;\n\n\t\tif (mod) {\n#ifdef CONFIG_MODULES\n\t\t\tstop = mod->static_call_sites +\n\t\t\t       mod->num_static_call_sites;\n\t\t\tinit = mod->state == MODULE_STATE_COMING;\n#endif\n\t\t}\n\n\t\tfor (site = site_mod->sites;\n\t\t     site < stop && static_call_key(site) == key; site++) {\n\t\t\tvoid *site_addr = static_call_addr(site);\n\n\t\t\tif (!init && static_call_is_init(site))\n\t\t\t\tcontinue;\n\n\t\t\tif (!kernel_text_address((unsigned long)site_addr)) {\n\t\t\t\t/*\n\t\t\t\t * This skips patching built-in __exit, which\n\t\t\t\t * is part of init_section_contains() but is\n\t\t\t\t * not part of kernel_text_address().\n\t\t\t\t *\n\t\t\t\t * Skipping built-in __exit is fine since it\n\t\t\t\t * will never be executed.\n\t\t\t\t */\n\t\t\t\tWARN_ONCE(!static_call_is_init(site),\n\t\t\t\t\t  \"can't patch static call site at %pS\",\n\t\t\t\t\t  site_addr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tarch_static_call_transform(site_addr, NULL, func,\n\t\t\t\t\t\t   static_call_is_tail(site));\n\t\t}\n\t}\n\ndone:\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool static_call_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nstatic bool static_call_initialized;\n\nvoid __static_call_update(struct static_call_key *key, void *tramp, void *func)\n{\n\tstruct static_call_site *site, *stop;\n\tstruct static_call_mod *site_mod, first;\n\n\tcpus_read_lock();\n\tstatic_call_lock();\n\n\tif (key->func == func)\n\t\tgoto done;\n\n\tkey->func = func;\n\n\tarch_static_call_transform(NULL, tramp, func, false);\n\n\t/*\n\t * If uninitialized, we'll not update the callsites, but they still\n\t * point to the trampoline and we just patched that.\n\t */\n\tif (WARN_ON_ONCE(!static_call_initialized))\n\t\tgoto done;\n\n\tfirst = (struct static_call_mod){\n\t\t.next = static_call_key_next(key),\n\t\t.mod = NULL,\n\t\t.sites = static_call_key_sites(key),\n\t};\n\n\tfor (site_mod = &first; site_mod; site_mod = site_mod->next) {\n\t\tbool init = system_state < SYSTEM_RUNNING;\n\t\tstruct module *mod = site_mod->mod;\n\n\t\tif (!site_mod->sites) {\n\t\t\t/*\n\t\t\t * This can happen if the static call key is defined in\n\t\t\t * a module which doesn't use it.\n\t\t\t *\n\t\t\t * It also happens in the has_mods case, where the\n\t\t\t * 'first' entry has no sites associated with it.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tstop = __stop_static_call_sites;\n\n\t\tif (mod) {\n#ifdef CONFIG_MODULES\n\t\t\tstop = mod->static_call_sites +\n\t\t\t       mod->num_static_call_sites;\n\t\t\tinit = mod->state == MODULE_STATE_COMING;\n#endif\n\t\t}\n\n\t\tfor (site = site_mod->sites;\n\t\t     site < stop && static_call_key(site) == key; site++) {\n\t\t\tvoid *site_addr = static_call_addr(site);\n\n\t\t\tif (!init && static_call_is_init(site))\n\t\t\t\tcontinue;\n\n\t\t\tif (!kernel_text_address((unsigned long)site_addr)) {\n\t\t\t\t/*\n\t\t\t\t * This skips patching built-in __exit, which\n\t\t\t\t * is part of init_section_contains() but is\n\t\t\t\t * not part of kernel_text_address().\n\t\t\t\t *\n\t\t\t\t * Skipping built-in __exit is fine since it\n\t\t\t\t * will never be executed.\n\t\t\t\t */\n\t\t\t\tWARN_ONCE(!static_call_is_init(site),\n\t\t\t\t\t  \"can't patch static call site at %pS\",\n\t\t\t\t\t  site_addr);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tarch_static_call_transform(site_addr, NULL, func,\n\t\t\t\t\t\t   static_call_is_tail(site));\n\t\t}\n\t}\n\ndone:\n\tstatic_call_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "nr_func_state",
          "args": [
            "tp_funcs"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "nr_func_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "297-306",
          "snippet": "static enum tp_func_state nr_func_state(const struct tracepoint_func *tp_funcs)\n{\n\tif (!tp_funcs)\n\t\treturn TP_FUNC_0;\n\tif (!tp_funcs[1].func)\n\t\treturn TP_FUNC_1;\n\tif (!tp_funcs[2].func)\n\t\treturn TP_FUNC_2;\n\treturn TP_FUNC_N;\t/* 3 or more */\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum tp_func_state nr_func_state(const struct tracepoint_func *tp_funcs)\n{\n\tif (!tp_funcs)\n\t\treturn TP_FUNC_0;\n\tif (!tp_funcs[1].func)\n\t\treturn TP_FUNC_1;\n\tif (!tp_funcs[2].func)\n\t\treturn TP_FUNC_2;\n\treturn TP_FUNC_N;\t/* 3 or more */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void tracepoint_update_call(struct tracepoint *tp, struct tracepoint_func *tp_funcs)\n{\n\tvoid *func = tp->iterator;\n\n\t/* Synthetic events do not have static call sites */\n\tif (!tp->static_call_key)\n\t\treturn;\n\tif (nr_func_state(tp_funcs) == TP_FUNC_1)\n\t\tfunc = tp_funcs[0].func;\n\t__static_call_update(tp->static_call_key, tp->static_call_tramp, func);\n}"
  },
  {
    "function_name": "nr_func_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "297-306",
    "snippet": "static enum tp_func_state nr_func_state(const struct tracepoint_func *tp_funcs)\n{\n\tif (!tp_funcs)\n\t\treturn TP_FUNC_0;\n\tif (!tp_funcs[1].func)\n\t\treturn TP_FUNC_1;\n\tif (!tp_funcs[2].func)\n\t\treturn TP_FUNC_2;\n\treturn TP_FUNC_N;\t/* 3 or more */\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic enum tp_func_state nr_func_state(const struct tracepoint_func *tp_funcs)\n{\n\tif (!tp_funcs)\n\t\treturn TP_FUNC_0;\n\tif (!tp_funcs[1].func)\n\t\treturn TP_FUNC_1;\n\tif (!tp_funcs[2].func)\n\t\treturn TP_FUNC_2;\n\treturn TP_FUNC_N;\t/* 3 or more */\n}"
  },
  {
    "function_name": "func_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "232-292",
    "snippet": "static void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdebug_print_probes(*funcs);\n\t/* (N -> M), (N > 1, M >= 0) probes */\n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif ((old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data) ||\n\t\t\t    old[nr_probes].func == tp_stub_func)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t/*\n\t * If probe is NULL, then nr_probes = nr_del = 0, and then the\n\t * entire entry will be removed.\n\t */\n\tif (nr_probes - nr_del == 0) {\n\t\t/* N -> 0, (N > 1) */\n\t\t*funcs = NULL;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t/* N -> M, (N > 1, M > 0) */\n\t\t/* + 1 for NULL */\n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new) {\n\t\t\tfor (i = 0; old[i].func; i++) {\n\t\t\t\tif ((old[i].func != tp_func->func ||\n\t\t\t\t     old[i].data != tp_func->data) &&\n\t\t\t\t    old[i].func != tp_stub_func)\n\t\t\t\t\tnew[j++] = old[i];\n\t\t\t}\n\t\t\tnew[nr_probes - nr_del].func = NULL;\n\t\t\t*funcs = new;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Failed to allocate, replace the old function\n\t\t\t * with calls to tp_stub_func.\n\t\t\t */\n\t\t\tfor (i = 0; old[i].func; i++) {\n\t\t\t\tif (old[i].func == tp_func->func &&\n\t\t\t\t    old[i].data == tp_func->data)\n\t\t\t\t\tWRITE_ONCE(old[i].func, tp_stub_func);\n\t\t\t}\n\t\t\t*funcs = old;\n\t\t}\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_print_probes",
          "args": [
            "*funcs"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "debug_print_probes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "168-177",
          "snippet": "static void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int tracepoint_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic const int tracepoint_debug;\n\nstatic void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "old[i].func",
            "tp_stub_func"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_probes",
          "args": [
            "nr_probes - nr_del + 1"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_probes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "107-112",
          "snippet": "static inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(struct_size(p, probes, count),\n\t\t\t\t       GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(struct_size(p, probes, count),\n\t\t\t\t       GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdebug_print_probes(*funcs);\n\t/* (N -> M), (N > 1, M >= 0) probes */\n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif ((old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data) ||\n\t\t\t    old[nr_probes].func == tp_stub_func)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t/*\n\t * If probe is NULL, then nr_probes = nr_del = 0, and then the\n\t * entire entry will be removed.\n\t */\n\tif (nr_probes - nr_del == 0) {\n\t\t/* N -> 0, (N > 1) */\n\t\t*funcs = NULL;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t/* N -> M, (N > 1, M > 0) */\n\t\t/* + 1 for NULL */\n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new) {\n\t\t\tfor (i = 0; old[i].func; i++) {\n\t\t\t\tif ((old[i].func != tp_func->func ||\n\t\t\t\t     old[i].data != tp_func->data) &&\n\t\t\t\t    old[i].func != tp_stub_func)\n\t\t\t\t\tnew[j++] = old[i];\n\t\t\t}\n\t\t\tnew[nr_probes - nr_del].func = NULL;\n\t\t\t*funcs = new;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Failed to allocate, replace the old function\n\t\t\t * with calls to tp_stub_func.\n\t\t\t */\n\t\t\tfor (i = 0; old[i].func; i++) {\n\t\t\t\tif (old[i].func == tp_func->func &&\n\t\t\t\t    old[i].data == tp_func->data)\n\t\t\t\t\tWRITE_ONCE(old[i].func, tp_stub_func);\n\t\t\t}\n\t\t\t*funcs = old;\n\t\t}\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}"
  },
  {
    "function_name": "func_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "179-230",
    "snippet": "static struct tracepoint_func *\nfunc_add(struct tracepoint_func **funcs, struct tracepoint_func *tp_func,\n\t int prio)\n{\n\tstruct tracepoint_func *old, *new;\n\tint iter_probes;\t/* Iterate over old probe array. */\n\tint nr_probes = 0;\t/* Counter for probes */\n\tint pos = -1;\t\t/* Insertion position into new array */\n\n\tif (WARN_ON(!tp_func->func))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t/* (N -> N+1), (N != 0, 1) probes */\n\t\tfor (iter_probes = 0; old[iter_probes].func; iter_probes++) {\n\t\t\tif (old[iter_probes].func == tp_stub_func)\n\t\t\t\tcontinue;\t/* Skip stub functions. */\n\t\t\tif (old[iter_probes].func == tp_func->func &&\n\t\t\t    old[iter_probes].data == tp_func->data)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t\tnr_probes++;\n\t\t}\n\t}\n\t/* + 2 : one for new probe, one for NULL func */\n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (old) {\n\t\tnr_probes = 0;\n\t\tfor (iter_probes = 0; old[iter_probes].func; iter_probes++) {\n\t\t\tif (old[iter_probes].func == tp_stub_func)\n\t\t\t\tcontinue;\n\t\t\t/* Insert before probes of lower priority */\n\t\t\tif (pos < 0 && old[iter_probes].prio < prio)\n\t\t\t\tpos = nr_probes++;\n\t\t\tnew[nr_probes++] = old[iter_probes];\n\t\t}\n\t\tif (pos < 0)\n\t\t\tpos = nr_probes++;\n\t\t/* nr_probes now points to the end of the new array */\n\t} else {\n\t\tpos = 0;\n\t\tnr_probes = 1; /* must point at end of array */\n\t}\n\tnew[pos] = *tp_func;\n\tnew[nr_probes].func = NULL;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_print_probes",
          "args": [
            "*funcs"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "debug_print_probes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "168-177",
          "snippet": "static void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int tracepoint_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic const int tracepoint_debug;\n\nstatic void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_probes",
          "args": [
            "nr_probes + 2"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_probes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
          "lines": "107-112",
          "snippet": "static inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(struct_size(p, probes, count),\n\t\t\t\t       GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(struct_size(p, probes, count),\n\t\t\t\t       GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EEXIST"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!tp_func->func"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct tracepoint_func *\nfunc_add(struct tracepoint_func **funcs, struct tracepoint_func *tp_func,\n\t int prio)\n{\n\tstruct tracepoint_func *old, *new;\n\tint iter_probes;\t/* Iterate over old probe array. */\n\tint nr_probes = 0;\t/* Counter for probes */\n\tint pos = -1;\t\t/* Insertion position into new array */\n\n\tif (WARN_ON(!tp_func->func))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t/* (N -> N+1), (N != 0, 1) probes */\n\t\tfor (iter_probes = 0; old[iter_probes].func; iter_probes++) {\n\t\t\tif (old[iter_probes].func == tp_stub_func)\n\t\t\t\tcontinue;\t/* Skip stub functions. */\n\t\t\tif (old[iter_probes].func == tp_func->func &&\n\t\t\t    old[iter_probes].data == tp_func->data)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t\tnr_probes++;\n\t\t}\n\t}\n\t/* + 2 : one for new probe, one for NULL func */\n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (old) {\n\t\tnr_probes = 0;\n\t\tfor (iter_probes = 0; old[iter_probes].func; iter_probes++) {\n\t\t\tif (old[iter_probes].func == tp_stub_func)\n\t\t\t\tcontinue;\n\t\t\t/* Insert before probes of lower priority */\n\t\t\tif (pos < 0 && old[iter_probes].prio < prio)\n\t\t\t\tpos = nr_probes++;\n\t\t\tnew[nr_probes++] = old[iter_probes];\n\t\t}\n\t\tif (pos < 0)\n\t\t\tpos = nr_probes++;\n\t\t/* nr_probes now points to the end of the new array */\n\t} else {\n\t\tpos = 0;\n\t\tnr_probes = 1; /* must point at end of array */\n\t}\n\tnew[pos] = *tp_func;\n\tnew[nr_probes].func = NULL;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}"
  },
  {
    "function_name": "debug_print_probes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "168-177",
    "snippet": "static void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int tracepoint_debug;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Probe %d : %p\\n\"",
            "i",
            "funcs[i].func"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic const int tracepoint_debug;\n\nstatic void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}"
  },
  {
    "function_name": "release_probes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "142-166",
    "snippet": "static inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_head *early_probes;",
      "static bool ok_to_free_tracepoints;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&tp_probes->rcu",
            "rcu_free_old_probes"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ok_to_free_tracepoints"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "old",
            "structtp_probes",
            "probes[0]"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct rcu_head *early_probes;\nstatic bool ok_to_free_tracepoints;\n\nstatic inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}"
  },
  {
    "function_name": "release_early_probes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "124-137",
    "snippet": "static __init int release_early_probes(void)\n{\n\tstruct rcu_head *tmp;\n\n\tok_to_free_tracepoints = true;\n\n\twhile (early_probes) {\n\t\ttmp = early_probes;\n\t\tearly_probes = tmp->next;\n\t\tcall_rcu(tmp, rcu_free_old_probes);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_head *early_probes;",
      "static bool ok_to_free_tracepoints;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "tmp",
            "rcu_free_old_probes"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct rcu_head *early_probes;\nstatic bool ok_to_free_tracepoints;\n\nstatic __init int release_early_probes(void)\n{\n\tstruct rcu_head *tmp;\n\n\tok_to_free_tracepoints = true;\n\n\twhile (early_probes) {\n\t\ttmp = early_probes;\n\t\tearly_probes = tmp->next;\n\t\tcall_rcu(tmp, rcu_free_old_probes);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_free_old_probes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "119-122",
    "snippet": "static void rcu_free_old_probes(struct rcu_head *head)\n{\n\tcall_srcu(&tracepoint_srcu, head, srcu_free_old_probes);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_srcu",
          "args": [
            "&tracepoint_srcu",
            "head",
            "srcu_free_old_probes"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "call_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "903-907",
          "snippet": "void call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(ssp, rhp, func, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(ssp, rhp, func, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void rcu_free_old_probes(struct rcu_head *head)\n{\n\tcall_srcu(&tracepoint_srcu, head, srcu_free_old_probes);\n}"
  },
  {
    "function_name": "srcu_free_old_probes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "114-117",
    "snippet": "static void srcu_free_old_probes(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct tp_probes, rcu));\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void srcu_free_old_probes(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct tp_probes, rcu));\n}"
  },
  {
    "function_name": "allocate_probes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "107-112",
    "snippet": "static inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(struct_size(p, probes, count),\n\t\t\t\t       GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "struct_size(p, probes, count)",
            "GFP_KERNEL"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct_size",
          "args": [
            "p",
            "probes",
            "count"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(struct_size(p, probes, count),\n\t\t\t\t       GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}"
  },
  {
    "function_name": "tp_stub_func",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "102-105",
    "snippet": "static void tp_stub_func(void)\n{\n\treturn;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void tp_stub_func(void)\n{\n\treturn;\n}"
  },
  {
    "function_name": "tp_rcu_cond_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "57-67",
    "snippet": "static void tp_rcu_cond_sync(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\tif (!snapshot->ongoing)\n\t\treturn;\n\tcond_synchronize_rcu(snapshot->rcu);\n\tif (!poll_state_synchronize_srcu(&tracepoint_srcu, snapshot->srcu))\n\t\tsynchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = false;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "&tracepoint_srcu"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "start_poll_synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1044-1047",
          "snippet": "unsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_state_synchronize_srcu",
          "args": [
            "&tracepoint_srcu",
            "snapshot->srcu"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "poll_state_synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1075-1083",
          "snippet": "bool poll_state_synchronize_srcu(struct srcu_struct *ssp, unsigned long cookie)\n{\n\tif (!rcu_seq_done(&ssp->srcu_gp_seq, cookie))\n\t\treturn false;\n\t// Ensure that the end of the SRCU grace period happens before\n\t// any subsequent code that the caller might execute.\n\tsmp_mb(); // ^^^\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nbool poll_state_synchronize_srcu(struct srcu_struct *ssp, unsigned long cookie)\n{\n\tif (!rcu_seq_done(&ssp->srcu_gp_seq, cookie))\n\t\treturn false;\n\t// Ensure that the end of the SRCU grace period happens before\n\t// any subsequent code that the caller might execute.\n\tsmp_mb(); // ^^^\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_synchronize_rcu",
          "args": [
            "snapshot->rcu"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "cond_synchronize_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3896-3900",
          "snippet": "void cond_synchronize_rcu(unsigned long oldstate)\n{\n\tif (!poll_state_synchronize_rcu(oldstate))\n\t\tsynchronize_rcu();\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid cond_synchronize_rcu(unsigned long oldstate)\n{\n\tif (!poll_state_synchronize_rcu(oldstate))\n\t\tsynchronize_rcu();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];\n\nstatic void tp_rcu_cond_sync(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\tif (!snapshot->ongoing)\n\t\treturn;\n\tcond_synchronize_rcu(snapshot->rcu);\n\tif (!poll_state_synchronize_srcu(&tracepoint_srcu, snapshot->srcu))\n\t\tsynchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = false;\n}"
  },
  {
    "function_name": "tp_rcu_get_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/tracepoint.c",
    "lines": "47-55",
    "snippet": "static void tp_rcu_get_state(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\t/* Keep the latest get_state snapshot. */\n\tsnapshot->rcu = get_state_synchronize_rcu();\n\tsnapshot->srcu = start_poll_synchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = true;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_poll_synchronize_srcu",
          "args": [
            "&tracepoint_srcu"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "start_poll_synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1044-1047",
          "snippet": "unsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_state_synchronize_rcu",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "get_state_synchronize_rcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3798-3806",
          "snippet": "unsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct rcu_state rcu_state = {\n\t.level = { &rcu_state.node[0] },\n\t.gp_state = RCU_GP_IDLE,\n\t.gp_seq = (0UL - 300UL) << RCU_SEQ_CTR_SHIFT,\n\t.barrier_mutex = __MUTEX_INITIALIZER(rcu_state.barrier_mutex),\n\t.name = RCU_NAME,\n\t.abbr = RCU_ABBR,\n\t.exp_mutex = __MUTEX_INITIALIZER(rcu_state.exp_mutex),\n\t.exp_wake_mutex = __MUTEX_INITIALIZER(rcu_state.exp_wake_mutex),\n\t.ofl_lock = __RAW_SPIN_LOCK_UNLOCKED(rcu_state.ofl_lock),\n};\n\nunsigned long get_state_synchronize_rcu(void)\n{\n\t/*\n\t * Any prior manipulation of RCU-protected data must happen\n\t * before the load from ->gp_seq.\n\t */\n\tsmp_mb();  /* ^^^ */\n\treturn rcu_seq_snap(&rcu_state.gp_seq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct tp_transition_snapshot tp_transition_snapshot[_NR_TP_TRANSITION_SYNC];\n\nstatic void tp_rcu_get_state(enum tp_transition_sync sync)\n{\n\tstruct tp_transition_snapshot *snapshot = &tp_transition_snapshot[sync];\n\n\t/* Keep the latest get_state snapshot. */\n\tsnapshot->rcu = get_state_synchronize_rcu();\n\tsnapshot->srcu = start_poll_synchronize_srcu(&tracepoint_srcu);\n\tsnapshot->ongoing = true;\n}"
  }
]