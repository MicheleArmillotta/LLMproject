[
  {
    "function_name": "bpf_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "825-838",
    "snippet": "static int __init bpf_init(void)\n{\n\tint ret;\n\n\tret = sysfs_create_mount_point(fs_kobj, \"bpf\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_filesystem(&bpf_fs_type);\n\tif (ret)\n\t\tsysfs_remove_mount_point(fs_kobj, \"bpf\");\n\n\treturn ret;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type bpf_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bpf\",\n\t.init_fs_context = bpf_init_fs_context,\n\t.parameters\t= bpf_fs_parameters,\n\t.kill_sb\t= kill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_remove_mount_point",
          "args": [
            "fs_kobj",
            "\"bpf\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&bpf_fs_type"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_mount_point",
          "args": [
            "fs_kobj",
            "\"bpf\""
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct file_system_type bpf_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bpf\",\n\t.init_fs_context = bpf_init_fs_context,\n\t.parameters\t= bpf_fs_parameters,\n\t.kill_sb\t= kill_litter_super,\n};\n\nstatic int __init bpf_init(void)\n{\n\tint ret;\n\n\tret = sysfs_create_mount_point(fs_kobj, \"bpf\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_filesystem(&bpf_fs_type);\n\tif (ret)\n\t\tsysfs_remove_mount_point(fs_kobj, \"bpf\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_init_fs_context",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "802-815",
    "snippet": "static int bpf_init_fs_context(struct fs_context *fc)\n{\n\tstruct bpf_mount_opts *opts;\n\n\topts = kzalloc(sizeof(struct bpf_mount_opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\topts->mode = S_IRWXUGO;\n\n\tfc->fs_private = opts;\n\tfc->ops = &bpf_context_ops;\n\treturn 0;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fs_context_operations bpf_context_ops = {\n\t.free\t\t= bpf_free_fc,\n\t.parse_param\t= bpf_parse_param,\n\t.get_tree\t= bpf_get_tree,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct bpf_mount_opts)",
            "GFP_KERNEL"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct fs_context_operations bpf_context_ops = {\n\t.free\t\t= bpf_free_fc,\n\t.parse_param\t= bpf_parse_param,\n\t.get_tree\t= bpf_get_tree,\n};\n\nstatic int bpf_init_fs_context(struct fs_context *fc)\n{\n\tstruct bpf_mount_opts *opts;\n\n\topts = kzalloc(sizeof(struct bpf_mount_opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\n\topts->mode = S_IRWXUGO;\n\n\tfc->fs_private = opts;\n\tfc->ops = &bpf_context_ops;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_free_fc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "788-791",
    "snippet": "static void bpf_free_fc(struct fs_context *fc)\n{\n\tkfree(fc->fs_private);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fc->fs_private"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void bpf_free_fc(struct fs_context *fc)\n{\n\tkfree(fc->fs_private);\n}"
  },
  {
    "function_name": "bpf_get_tree",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "783-786",
    "snippet": "static int bpf_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_nodev(fc, bpf_fill_super);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_tree_nodev",
          "args": [
            "fc",
            "bpf_fill_super"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int bpf_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_nodev(fc, bpf_fill_super);\n}"
  },
  {
    "function_name": "bpf_fill_super",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "762-781",
    "snippet": "static int bpf_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstatic const struct tree_descr bpf_rfiles[] = { { \"\" } };\n\tstruct bpf_mount_opts *opts = fc->fs_private;\n\tstruct inode *inode;\n\tint ret;\n\n\tret = simple_fill_super(sb, BPF_FS_MAGIC, bpf_rfiles);\n\tif (ret)\n\t\treturn ret;\n\n\tsb->s_op = &bpf_super_ops;\n\n\tinode = sb->s_root->d_inode;\n\tinode->i_op = &bpf_dir_iops;\n\tinode->i_mode &= ~S_IALLUGO;\n\tpopulate_bpffs(sb->s_root);\n\tinode->i_mode |= S_ISVTX | opts->mode;\n\treturn 0;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations bpf_dir_iops;",
      "static const struct inode_operations bpf_dir_iops = {\n\t.lookup\t\t= bpf_lookup,\n\t.mkdir\t\t= bpf_mkdir,\n\t.symlink\t= bpf_symlink,\n\t.rmdir\t\t= simple_rmdir,\n\t.rename\t\t= simple_rename,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n};",
      "static const struct super_operations bpf_super_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.show_options\t= bpf_show_options,\n\t.free_inode\t= bpf_free_inode,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "populate_bpffs",
          "args": [
            "sb->s_root"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "populate_bpffs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "710-760",
          "snippet": "static int populate_bpffs(struct dentry *parent)\n{\n\tstruct bpf_preload_info objs[BPF_PRELOAD_LINKS] = {};\n\tstruct bpf_link *links[BPF_PRELOAD_LINKS] = {};\n\tint err = 0, i;\n\n\t/* grab the mutex to make sure the kernel interactions with bpf_preload\n\t * UMD are serialized\n\t */\n\tmutex_lock(&bpf_preload_lock);\n\n\t/* if bpf_preload.ko wasn't built into vmlinux then load it */\n\tif (!bpf_preload_mod_get())\n\t\tgoto out;\n\n\tif (!bpf_preload_ops->info.tgid) {\n\t\t/* preload() will start UMD that will load BPF iterator programs */\n\t\terr = bpf_preload_ops->preload(objs);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\t\tlinks[i] = bpf_link_by_id(objs[i].link_id);\n\t\t\tif (IS_ERR(links[i])) {\n\t\t\t\terr = PTR_ERR(links[i]);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\t\terr = bpf_iter_link_pin_kernel(parent,\n\t\t\t\t\t\t       objs[i].link_name, links[i]);\n\t\t\tif (err)\n\t\t\t\tgoto out_put;\n\t\t\t/* do not unlink successfully pinned links even\n\t\t\t * if later link fails to pin\n\t\t\t */\n\t\t\tlinks[i] = NULL;\n\t\t}\n\t\t/* finish() will tell UMD process to exit */\n\t\terr = bpf_preload_ops->finish();\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\nout_put:\n\tbpf_preload_mod_put();\nout:\n\tmutex_unlock(&bpf_preload_lock);\n\tfor (i = 0; i < BPF_PRELOAD_LINKS && err; i++)\n\t\tif (!IS_ERR_OR_NULL(links[i]))\n\t\t\tbpf_link_put(links[i]);\n\treturn err;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct bpf_preload_ops *bpf_preload_ops;",
            "static DEFINE_MUTEX(bpf_preload_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_preload_ops *bpf_preload_ops;\nstatic DEFINE_MUTEX(bpf_preload_lock);\n\nstatic int populate_bpffs(struct dentry *parent)\n{\n\tstruct bpf_preload_info objs[BPF_PRELOAD_LINKS] = {};\n\tstruct bpf_link *links[BPF_PRELOAD_LINKS] = {};\n\tint err = 0, i;\n\n\t/* grab the mutex to make sure the kernel interactions with bpf_preload\n\t * UMD are serialized\n\t */\n\tmutex_lock(&bpf_preload_lock);\n\n\t/* if bpf_preload.ko wasn't built into vmlinux then load it */\n\tif (!bpf_preload_mod_get())\n\t\tgoto out;\n\n\tif (!bpf_preload_ops->info.tgid) {\n\t\t/* preload() will start UMD that will load BPF iterator programs */\n\t\terr = bpf_preload_ops->preload(objs);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\t\tlinks[i] = bpf_link_by_id(objs[i].link_id);\n\t\t\tif (IS_ERR(links[i])) {\n\t\t\t\terr = PTR_ERR(links[i]);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\t\terr = bpf_iter_link_pin_kernel(parent,\n\t\t\t\t\t\t       objs[i].link_name, links[i]);\n\t\t\tif (err)\n\t\t\t\tgoto out_put;\n\t\t\t/* do not unlink successfully pinned links even\n\t\t\t * if later link fails to pin\n\t\t\t */\n\t\t\tlinks[i] = NULL;\n\t\t}\n\t\t/* finish() will tell UMD process to exit */\n\t\terr = bpf_preload_ops->finish();\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\nout_put:\n\tbpf_preload_mod_put();\nout:\n\tmutex_unlock(&bpf_preload_lock);\n\tfor (i = 0; i < BPF_PRELOAD_LINKS && err; i++)\n\t\tif (!IS_ERR_OR_NULL(links[i]))\n\t\t\tbpf_link_put(links[i]);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_fill_super",
          "args": [
            "sb",
            "BPF_FS_MAGIC",
            "bpf_rfiles"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_dir_iops;\nstatic const struct inode_operations bpf_dir_iops = {\n\t.lookup\t\t= bpf_lookup,\n\t.mkdir\t\t= bpf_mkdir,\n\t.symlink\t= bpf_symlink,\n\t.rmdir\t\t= simple_rmdir,\n\t.rename\t\t= simple_rename,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n};\nstatic const struct super_operations bpf_super_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.drop_inode\t= generic_delete_inode,\n\t.show_options\t= bpf_show_options,\n\t.free_inode\t= bpf_free_inode,\n};\n\nstatic int bpf_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstatic const struct tree_descr bpf_rfiles[] = { { \"\" } };\n\tstruct bpf_mount_opts *opts = fc->fs_private;\n\tstruct inode *inode;\n\tint ret;\n\n\tret = simple_fill_super(sb, BPF_FS_MAGIC, bpf_rfiles);\n\tif (ret)\n\t\treturn ret;\n\n\tsb->s_op = &bpf_super_ops;\n\n\tinode = sb->s_root->d_inode;\n\tinode->i_op = &bpf_dir_iops;\n\tinode->i_mode &= ~S_IALLUGO;\n\tpopulate_bpffs(sb->s_root);\n\tinode->i_mode |= S_ISVTX | opts->mode;\n\treturn 0;\n}"
  },
  {
    "function_name": "populate_bpffs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "710-760",
    "snippet": "static int populate_bpffs(struct dentry *parent)\n{\n\tstruct bpf_preload_info objs[BPF_PRELOAD_LINKS] = {};\n\tstruct bpf_link *links[BPF_PRELOAD_LINKS] = {};\n\tint err = 0, i;\n\n\t/* grab the mutex to make sure the kernel interactions with bpf_preload\n\t * UMD are serialized\n\t */\n\tmutex_lock(&bpf_preload_lock);\n\n\t/* if bpf_preload.ko wasn't built into vmlinux then load it */\n\tif (!bpf_preload_mod_get())\n\t\tgoto out;\n\n\tif (!bpf_preload_ops->info.tgid) {\n\t\t/* preload() will start UMD that will load BPF iterator programs */\n\t\terr = bpf_preload_ops->preload(objs);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\t\tlinks[i] = bpf_link_by_id(objs[i].link_id);\n\t\t\tif (IS_ERR(links[i])) {\n\t\t\t\terr = PTR_ERR(links[i]);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\t\terr = bpf_iter_link_pin_kernel(parent,\n\t\t\t\t\t\t       objs[i].link_name, links[i]);\n\t\t\tif (err)\n\t\t\t\tgoto out_put;\n\t\t\t/* do not unlink successfully pinned links even\n\t\t\t * if later link fails to pin\n\t\t\t */\n\t\t\tlinks[i] = NULL;\n\t\t}\n\t\t/* finish() will tell UMD process to exit */\n\t\terr = bpf_preload_ops->finish();\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\nout_put:\n\tbpf_preload_mod_put();\nout:\n\tmutex_unlock(&bpf_preload_lock);\n\tfor (i = 0; i < BPF_PRELOAD_LINKS && err; i++)\n\t\tif (!IS_ERR_OR_NULL(links[i]))\n\t\t\tbpf_link_put(links[i]);\n\treturn err;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct bpf_preload_ops *bpf_preload_ops;",
      "static DEFINE_MUTEX(bpf_preload_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_link_put",
          "args": [
            "links[i]"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2479-2490",
          "snippet": "void bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "links[i]"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bpf_preload_lock"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_preload_mod_put",
          "args": [],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_preload_mod_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "701-706",
          "snippet": "static void bpf_preload_mod_put(void)\n{\n\tif (bpf_preload_ops)\n\t\t/* now user can \"rmmod bpf_preload\" if necessary */\n\t\tmodule_put(bpf_preload_ops->owner);\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct bpf_preload_ops *bpf_preload_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_preload_ops *bpf_preload_ops;\n\nstatic void bpf_preload_mod_put(void)\n{\n\tif (bpf_preload_ops)\n\t\t/* now user can \"rmmod bpf_preload\" if necessary */\n\t\tmodule_put(bpf_preload_ops->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_preload_ops->finish",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "finish",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/bpf_preload_kern.c",
          "lines": "51-70",
          "snippet": "static int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_preload.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int finish(void);",
            "static struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_preload.h\"\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/pid.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int finish(void);\nstatic struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};\n\nstatic int finish(void)\n{\n\tint magic = BPF_PRELOAD_END;\n\tstruct pid *tgid;\n\tloff_t pos = 0;\n\tssize_t n;\n\n\t/* send the last magic to UMD. It will do a normal exit. */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\ttgid = umd_ops.info.tgid;\n\tif (tgid) {\n\t\twait_event(tgid->wait_pidfd, thread_group_exited(tgid));\n\t\tumd_cleanup_helper(&umd_ops.info);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_iter_link_pin_kernel",
          "args": [
            "parent",
            "objs[i].link_name",
            "links[i]"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_iter_link_pin_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "418-436",
          "snippet": "static int bpf_iter_link_pin_kernel(struct dentry *parent,\n\t\t\t\t    const char *name, struct bpf_link *link)\n{\n\tumode_t mode = S_IFREG | S_IRUSR;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tinode_lock(parent->d_inode);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\tinode_unlock(parent->d_inode);\n\t\treturn PTR_ERR(dentry);\n\t}\n\tret = bpf_mkobj_ops(dentry, mode, link, &bpf_link_iops,\n\t\t\t    &bpf_iter_fops);\n\tdput(dentry);\n\tinode_unlock(parent->d_inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bpf_link_iops  = { };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_link_iops  = { };\n\nstatic int bpf_iter_link_pin_kernel(struct dentry *parent,\n\t\t\t\t    const char *name, struct bpf_link *link)\n{\n\tumode_t mode = S_IFREG | S_IRUSR;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tinode_lock(parent->d_inode);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\tinode_unlock(parent->d_inode);\n\t\treturn PTR_ERR(dentry);\n\t}\n\tret = bpf_mkobj_ops(dentry, mode, link, &bpf_link_iops,\n\t\t\t    &bpf_iter_fops);\n\tdput(dentry);\n\tinode_unlock(parent->d_inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "links[i]"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "links[i]"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_by_id",
          "args": [
            "objs[i].link_id"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4406-4426",
          "snippet": "struct bpf_link *bpf_link_by_id(u32 id)\n{\n\tstruct bpf_link *link;\n\n\tif (!id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock_bh(&link_idr_lock);\n\t/* before link is \"settled\", ID is 0, pretend it doesn't exist yet */\n\tlink = idr_find(&link_idr, id);\n\tif (link) {\n\t\tif (link->id)\n\t\t\tlink = bpf_link_inc_not_zero(link);\n\t\telse\n\t\t\tlink = ERR_PTR(-EAGAIN);\n\t} else {\n\t\tlink = ERR_PTR(-ENOENT);\n\t}\n\tspin_unlock_bh(&link_idr_lock);\n\treturn link;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(link_idr);",
            "static DEFINE_SPINLOCK(link_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(link_idr);\nstatic DEFINE_SPINLOCK(link_idr_lock);\n\nstruct bpf_link *bpf_link_by_id(u32 id)\n{\n\tstruct bpf_link *link;\n\n\tif (!id)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tspin_lock_bh(&link_idr_lock);\n\t/* before link is \"settled\", ID is 0, pretend it doesn't exist yet */\n\tlink = idr_find(&link_idr, id);\n\tif (link) {\n\t\tif (link->id)\n\t\t\tlink = bpf_link_inc_not_zero(link);\n\t\telse\n\t\t\tlink = ERR_PTR(-EAGAIN);\n\t} else {\n\t\tlink = ERR_PTR(-ENOENT);\n\t}\n\tspin_unlock_bh(&link_idr_lock);\n\treturn link;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_preload_ops->preload",
          "args": [
            "objs"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "preload",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/bpf_preload_kern.c",
          "lines": "23-49",
          "snippet": "static int preload(struct bpf_preload_info *obj)\n{\n\tint magic = BPF_PRELOAD_START;\n\tloff_t pos = 0;\n\tint i, err;\n\tssize_t n;\n\n\terr = fork_usermode_driver(&umd_ops.info);\n\tif (err)\n\t\treturn err;\n\n\t/* send the start magic to let UMD proceed with loading BPF progs */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\t/* receive bpf_link IDs and names from UMD */\n\tpos = 0;\n\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\tn = kernel_read(umd_ops.info.pipe_from_umh,\n\t\t\t\t&obj[i], sizeof(*obj), &pos);\n\t\tif (n != sizeof(*obj))\n\t\t\treturn -EPIPE;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_preload.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/fs.h>",
            "#include <linux/pid.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int preload(struct bpf_preload_info *obj);",
            "static struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_preload.h\"\n#include <linux/sched/signal.h>\n#include <linux/fs.h>\n#include <linux/pid.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int preload(struct bpf_preload_info *obj);\nstatic struct bpf_preload_ops umd_ops = {\n\t.info.driver_name = \"bpf_preload\",\n\t.preload = preload,\n\t.finish = finish,\n\t.owner = THIS_MODULE,\n};\n\nstatic int preload(struct bpf_preload_info *obj)\n{\n\tint magic = BPF_PRELOAD_START;\n\tloff_t pos = 0;\n\tint i, err;\n\tssize_t n;\n\n\terr = fork_usermode_driver(&umd_ops.info);\n\tif (err)\n\t\treturn err;\n\n\t/* send the start magic to let UMD proceed with loading BPF progs */\n\tn = kernel_write(umd_ops.info.pipe_to_umh,\n\t\t\t &magic, sizeof(magic), &pos);\n\tif (n != sizeof(magic))\n\t\treturn -EPIPE;\n\n\t/* receive bpf_link IDs and names from UMD */\n\tpos = 0;\n\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\tn = kernel_read(umd_ops.info.pipe_from_umh,\n\t\t\t\t&obj[i], sizeof(*obj), &pos);\n\t\tif (n != sizeof(*obj))\n\t\t\treturn -EPIPE;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_preload_mod_get",
          "args": [],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_preload_mod_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "680-699",
          "snippet": "static bool bpf_preload_mod_get(void)\n{\n\t/* If bpf_preload.ko wasn't loaded earlier then load it now.\n\t * When bpf_preload is built into vmlinux the module's __init\n\t * function will populate it.\n\t */\n\tif (!bpf_preload_ops) {\n\t\trequest_module(\"bpf_preload\");\n\t\tif (!bpf_preload_ops)\n\t\t\treturn false;\n\t}\n\t/* And grab the reference, so the module doesn't disappear while the\n\t * kernel is interacting with the kernel module and its UMD.\n\t */\n\tif (!try_module_get(bpf_preload_ops->owner)) {\n\t\tpr_err(\"bpf_preload module get failed.\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct bpf_preload_ops *bpf_preload_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_preload_ops *bpf_preload_ops;\n\nstatic bool bpf_preload_mod_get(void)\n{\n\t/* If bpf_preload.ko wasn't loaded earlier then load it now.\n\t * When bpf_preload is built into vmlinux the module's __init\n\t * function will populate it.\n\t */\n\tif (!bpf_preload_ops) {\n\t\trequest_module(\"bpf_preload\");\n\t\tif (!bpf_preload_ops)\n\t\t\treturn false;\n\t}\n\t/* And grab the reference, so the module doesn't disappear while the\n\t * kernel is interacting with the kernel module and its UMD.\n\t */\n\tif (!try_module_get(bpf_preload_ops->owner)) {\n\t\tpr_err(\"bpf_preload module get failed.\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bpf_preload_lock"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_preload_ops *bpf_preload_ops;\nstatic DEFINE_MUTEX(bpf_preload_lock);\n\nstatic int populate_bpffs(struct dentry *parent)\n{\n\tstruct bpf_preload_info objs[BPF_PRELOAD_LINKS] = {};\n\tstruct bpf_link *links[BPF_PRELOAD_LINKS] = {};\n\tint err = 0, i;\n\n\t/* grab the mutex to make sure the kernel interactions with bpf_preload\n\t * UMD are serialized\n\t */\n\tmutex_lock(&bpf_preload_lock);\n\n\t/* if bpf_preload.ko wasn't built into vmlinux then load it */\n\tif (!bpf_preload_mod_get())\n\t\tgoto out;\n\n\tif (!bpf_preload_ops->info.tgid) {\n\t\t/* preload() will start UMD that will load BPF iterator programs */\n\t\terr = bpf_preload_ops->preload(objs);\n\t\tif (err)\n\t\t\tgoto out_put;\n\t\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\t\tlinks[i] = bpf_link_by_id(objs[i].link_id);\n\t\t\tif (IS_ERR(links[i])) {\n\t\t\t\terr = PTR_ERR(links[i]);\n\t\t\t\tgoto out_put;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < BPF_PRELOAD_LINKS; i++) {\n\t\t\terr = bpf_iter_link_pin_kernel(parent,\n\t\t\t\t\t\t       objs[i].link_name, links[i]);\n\t\t\tif (err)\n\t\t\t\tgoto out_put;\n\t\t\t/* do not unlink successfully pinned links even\n\t\t\t * if later link fails to pin\n\t\t\t */\n\t\t\tlinks[i] = NULL;\n\t\t}\n\t\t/* finish() will tell UMD process to exit */\n\t\terr = bpf_preload_ops->finish();\n\t\tif (err)\n\t\t\tgoto out_put;\n\t}\nout_put:\n\tbpf_preload_mod_put();\nout:\n\tmutex_unlock(&bpf_preload_lock);\n\tfor (i = 0; i < BPF_PRELOAD_LINKS && err; i++)\n\t\tif (!IS_ERR_OR_NULL(links[i]))\n\t\t\tbpf_link_put(links[i]);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_preload_mod_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "701-706",
    "snippet": "static void bpf_preload_mod_put(void)\n{\n\tif (bpf_preload_ops)\n\t\t/* now user can \"rmmod bpf_preload\" if necessary */\n\t\tmodule_put(bpf_preload_ops->owner);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct bpf_preload_ops *bpf_preload_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "bpf_preload_ops->owner"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_trampoline_module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/trampoline.c",
          "lines": "114-118",
          "snippet": "static void bpf_trampoline_module_put(struct bpf_trampoline *tr)\n{\n\tmodule_put(tr->mod);\n\ttr->mod = NULL;\n}",
          "includes": [
            "#include <linux/static_call.h>",
            "#include <linux/module.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_call.h>\n#include <linux/module.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/rbtree_latch.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/hash.h>\n\nstatic void bpf_trampoline_module_put(struct bpf_trampoline *tr)\n{\n\tmodule_put(tr->mod);\n\ttr->mod = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_preload_ops *bpf_preload_ops;\n\nstatic void bpf_preload_mod_put(void)\n{\n\tif (bpf_preload_ops)\n\t\t/* now user can \"rmmod bpf_preload\" if necessary */\n\t\tmodule_put(bpf_preload_ops->owner);\n}"
  },
  {
    "function_name": "bpf_preload_mod_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "680-699",
    "snippet": "static bool bpf_preload_mod_get(void)\n{\n\t/* If bpf_preload.ko wasn't loaded earlier then load it now.\n\t * When bpf_preload is built into vmlinux the module's __init\n\t * function will populate it.\n\t */\n\tif (!bpf_preload_ops) {\n\t\trequest_module(\"bpf_preload\");\n\t\tif (!bpf_preload_ops)\n\t\t\treturn false;\n\t}\n\t/* And grab the reference, so the module doesn't disappear while the\n\t * kernel is interacting with the kernel module and its UMD.\n\t */\n\tif (!try_module_get(bpf_preload_ops->owner)) {\n\t\tpr_err(\"bpf_preload module get failed.\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct bpf_preload_ops *bpf_preload_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bpf_preload module get failed.\\n\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "bpf_preload_ops->owner"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "request_module",
          "args": [
            "\"bpf_preload\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_preload_ops *bpf_preload_ops;\n\nstatic bool bpf_preload_mod_get(void)\n{\n\t/* If bpf_preload.ko wasn't loaded earlier then load it now.\n\t * When bpf_preload is built into vmlinux the module's __init\n\t * function will populate it.\n\t */\n\tif (!bpf_preload_ops) {\n\t\trequest_module(\"bpf_preload\");\n\t\tif (!bpf_preload_ops)\n\t\t\treturn false;\n\t}\n\t/* And grab the reference, so the module doesn't disappear while the\n\t * kernel is interacting with the kernel module and its UMD.\n\t */\n\tif (!try_module_get(bpf_preload_ops->owner)) {\n\t\tpr_err(\"bpf_preload module get failed.\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "bpf_parse_param",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "644-675",
    "snippet": "static int bpf_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct bpf_mount_opts *opts = fc->fs_private;\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, bpf_fs_parameters, param, &result);\n\tif (opt < 0) {\n\t\t/* We might like to report bad mount options here, but\n\t\t * traditionally we've ignored all mount options, so we'd\n\t\t * better continue to ignore non-existing options for bpf.\n\t\t */\n\t\tif (opt == -ENOPARAM) {\n\t\t\topt = vfs_parse_fs_param_source(fc, param);\n\t\t\tif (opt != -ENOPARAM)\n\t\t\t\treturn opt;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (opt < 0)\n\t\t\treturn opt;\n\t}\n\n\tswitch (opt) {\n\tcase OPT_MODE:\n\t\topts->mode = result.uint_32 & S_IALLUGO;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fs_parameter_spec bpf_fs_parameters[] = {\n\tfsparam_u32oct\t(\"mode\",\t\t\tOPT_MODE),\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_parse_fs_param_source",
          "args": [
            "fc",
            "param"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_parse",
          "args": [
            "fc",
            "bpf_fs_parameters",
            "param",
            "&result"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct fs_parameter_spec bpf_fs_parameters[] = {\n\tfsparam_u32oct\t(\"mode\",\t\t\tOPT_MODE),\n\t{}\n};\n\nstatic int bpf_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct bpf_mount_opts *opts = fc->fs_private;\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, bpf_fs_parameters, param, &result);\n\tif (opt < 0) {\n\t\t/* We might like to report bad mount options here, but\n\t\t * traditionally we've ignored all mount options, so we'd\n\t\t * better continue to ignore non-existing options for bpf.\n\t\t */\n\t\tif (opt == -ENOPARAM) {\n\t\t\topt = vfs_parse_fs_param_source(fc, param);\n\t\t\tif (opt != -ENOPARAM)\n\t\t\t\treturn opt;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (opt < 0)\n\t\t\treturn opt;\n\t}\n\n\tswitch (opt) {\n\tcase OPT_MODE:\n\t\topts->mode = result.uint_32 & S_IALLUGO;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_free_inode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "613-622",
    "snippet": "static void bpf_free_inode(struct inode *inode)\n{\n\tenum bpf_type type;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n\tif (!bpf_inode_type(inode, &type))\n\t\tbpf_any_put(inode->i_private, type);\n\tfree_inode_nonrcu(inode);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_inode_nonrcu",
          "args": [
            "inode"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_any_put",
          "args": [
            "inode->i_private",
            "type"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_any_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "52-68",
          "snippet": "static void bpf_any_put(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_put(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_put_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_put(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void bpf_any_put(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_put(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_put_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_put(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_inode_type",
          "args": [
            "inode",
            "&type"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_inode_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "130-143",
          "snippet": "static int bpf_inode_type(const struct inode *inode, enum bpf_type *type)\n{\n\t*type = BPF_TYPE_UNSPEC;\n\tif (inode->i_op == &bpf_prog_iops)\n\t\t*type = BPF_TYPE_PROG;\n\telse if (inode->i_op == &bpf_map_iops)\n\t\t*type = BPF_TYPE_MAP;\n\telse if (inode->i_op == &bpf_link_iops)\n\t\t*type = BPF_TYPE_LINK;\n\telse\n\t\treturn -EACCES;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bpf_prog_iops = { };",
            "static const struct inode_operations bpf_map_iops  = { };",
            "static const struct inode_operations bpf_link_iops  = { };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_prog_iops = { };\nstatic const struct inode_operations bpf_map_iops  = { };\nstatic const struct inode_operations bpf_link_iops  = { };\n\nstatic int bpf_inode_type(const struct inode *inode, enum bpf_type *type)\n{\n\t*type = BPF_TYPE_UNSPEC;\n\tif (inode->i_op == &bpf_prog_iops)\n\t\t*type = BPF_TYPE_PROG;\n\telse if (inode->i_op == &bpf_map_iops)\n\t\t*type = BPF_TYPE_MAP;\n\telse if (inode->i_op == &bpf_link_iops)\n\t\t*type = BPF_TYPE_LINK;\n\telse\n\t\treturn -EACCES;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "inode->i_link"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void bpf_free_inode(struct inode *inode)\n{\n\tenum bpf_type type;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n\tif (!bpf_inode_type(inode, &type))\n\t\tbpf_any_put(inode->i_private, type);\n\tfree_inode_nonrcu(inode);\n}"
  },
  {
    "function_name": "bpf_show_options",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "604-611",
    "snippet": "static int bpf_show_options(struct seq_file *m, struct dentry *root)\n{\n\tumode_t mode = d_inode(root)->i_mode & S_IALLUGO & ~S_ISVTX;\n\n\tif (mode != S_IRWXUGO)\n\t\tseq_printf(m, \",mode=%o\", mode);\n\treturn 0;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\",mode=%o\"",
            "mode"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "root"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int bpf_show_options(struct seq_file *m, struct dentry *root)\n{\n\tumode_t mode = d_inode(root)->i_mode & S_IALLUGO & ~S_ISVTX;\n\n\tif (mode != S_IRWXUGO)\n\t\tseq_printf(m, \",mode=%o\", mode);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_prog_get_type_path",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "586-598",
    "snippet": "struct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_atime",
          "args": [
            "&path"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_prog_inode",
          "args": [
            "d_backing_inode(path.dentry)",
            "type"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "__get_prog_inode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "559-584",
          "snippet": "static struct bpf_prog *__get_prog_inode(struct inode *inode, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tint ret = inode_permission(&init_user_ns, inode, MAY_READ);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (inode->i_op == &bpf_map_iops)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (inode->i_op == &bpf_link_iops)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (inode->i_op != &bpf_prog_iops)\n\t\treturn ERR_PTR(-EACCES);\n\n\tprog = inode->i_private;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (!bpf_prog_get_ok(prog, &type, false))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbpf_prog_inc(prog);\n\treturn prog;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bpf_prog_iops = { };",
            "static const struct inode_operations bpf_map_iops  = { };",
            "static const struct inode_operations bpf_link_iops  = { };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_prog_iops = { };\nstatic const struct inode_operations bpf_map_iops  = { };\nstatic const struct inode_operations bpf_link_iops  = { };\n\nstatic struct bpf_prog *__get_prog_inode(struct inode *inode, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tint ret = inode_permission(&init_user_ns, inode, MAY_READ);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (inode->i_op == &bpf_map_iops)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (inode->i_op == &bpf_link_iops)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (inode->i_op != &bpf_prog_iops)\n\t\treturn ERR_PTR(-EACCES);\n\n\tprog = inode->i_private;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (!bpf_prog_get_ok(prog, &type, false))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbpf_prog_inc(prog);\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path.dentry"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "name",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}"
  },
  {
    "function_name": "__get_prog_inode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "559-584",
    "snippet": "static struct bpf_prog *__get_prog_inode(struct inode *inode, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tint ret = inode_permission(&init_user_ns, inode, MAY_READ);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (inode->i_op == &bpf_map_iops)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (inode->i_op == &bpf_link_iops)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (inode->i_op != &bpf_prog_iops)\n\t\treturn ERR_PTR(-EACCES);\n\n\tprog = inode->i_private;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (!bpf_prog_get_ok(prog, &type, false))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbpf_prog_inc(prog);\n\treturn prog;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations bpf_prog_iops = { };",
      "static const struct inode_operations bpf_map_iops  = { };",
      "static const struct inode_operations bpf_link_iops  = { };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_inc",
          "args": [
            "prog"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1963-1973",
          "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_ok",
          "args": [
            "prog",
            "&type",
            "false"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_ok",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1976-1989",
          "snippet": "bool bpf_prog_get_ok(struct bpf_prog *prog,\n\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)\n{\n\t/* not an attachment, just a refcount inc, always allow */\n\tif (!attach_type)\n\t\treturn true;\n\n\tif (prog->type != *attach_type)\n\t\treturn false;\n\tif (bpf_prog_is_dev_bound(prog->aux) && !attach_drv)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nbool bpf_prog_get_ok(struct bpf_prog *prog,\n\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)\n{\n\t/* not an attachment, just a refcount inc, always allow */\n\tif (!attach_type)\n\t\treturn true;\n\n\tif (prog->type != *attach_type)\n\t\treturn false;\n\tif (bpf_prog_is_dev_bound(prog->aux) && !attach_drv)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bpf_prog",
          "args": [
            "prog"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "&init_user_ns",
            "inode",
            "MAY_READ"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_prog_iops = { };\nstatic const struct inode_operations bpf_map_iops  = { };\nstatic const struct inode_operations bpf_link_iops  = { };\n\nstatic struct bpf_prog *__get_prog_inode(struct inode *inode, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tint ret = inode_permission(&init_user_ns, inode, MAY_READ);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (inode->i_op == &bpf_map_iops)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (inode->i_op == &bpf_link_iops)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (inode->i_op != &bpf_prog_iops)\n\t\treturn ERR_PTR(-EACCES);\n\n\tprog = inode->i_private;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (!bpf_prog_get_ok(prog, &type, false))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbpf_prog_inc(prog);\n\treturn prog;\n}"
  },
  {
    "function_name": "bpf_obj_get_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "530-557",
    "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_any_put",
          "args": [
            "raw",
            "type"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_any_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "52-68",
          "snippet": "static void bpf_any_put(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_put(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_put_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_put(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void bpf_any_put(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_put(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_put_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_put(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_new_fd",
          "args": [
            "raw"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2610-2613",
          "snippet": "int bpf_link_new_fd(struct bpf_link *link)\n{\n\treturn anon_inode_getfd(\"bpf-link\", &bpf_link_fops, link, O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_link_new_fd(struct bpf_link *link)\n{\n\treturn anon_inode_getfd(\"bpf-link\", &bpf_link_fops, link, O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_new_fd",
          "args": [
            "raw",
            "f_flags"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "708-718",
          "snippet": "int bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n\t.mmap\t\t= bpf_map_mmap,\n\t.poll\t\t= bpf_map_poll,\n};\n\nint bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_new_fd",
          "args": [
            "raw"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_new_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1915-1925",
          "snippet": "int bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "raw"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "raw"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_obj_do_get",
          "args": [
            "pathname",
            "&type",
            "f_flags"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_do_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "498-528",
          "snippet": "static void *bpf_obj_do_get(const char __user *pathname,\n\t\t\t    enum bpf_type *type, int flags)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\n\tret = user_path_at(AT_FDCWD, pathname, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tinode = d_backing_inode(path.dentry);\n\tret = path_permission(&path, ACC_MODE(flags));\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\tif (!IS_ERR(raw))\n\t\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void *bpf_obj_do_get(const char __user *pathname,\n\t\t\t    enum bpf_type *type, int flags)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\n\tret = user_path_at(AT_FDCWD, pathname, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tinode = d_backing_inode(path.dentry);\n\tret = path_permission(&path, ACC_MODE(flags));\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\tif (!IS_ERR(raw))\n\t\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_file_flag",
          "args": [
            "flags"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_file_flag",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "720-729",
          "snippet": "int bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nint bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tint f_flags;\n\tvoid *raw;\n\tint ret;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\traw = bpf_obj_do_get(pathname, &type, f_flags);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse if (type == BPF_TYPE_LINK)\n\t\tret = (f_flags != O_RDWR) ? -EINVAL : bpf_link_new_fd(raw);\n\telse\n\t\treturn -ENOENT;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_obj_do_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "498-528",
    "snippet": "static void *bpf_obj_do_get(const char __user *pathname,\n\t\t\t    enum bpf_type *type, int flags)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\n\tret = user_path_at(AT_FDCWD, pathname, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tinode = d_backing_inode(path.dentry);\n\tret = path_permission(&path, ACC_MODE(flags));\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\tif (!IS_ERR(raw))\n\t\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "touch_atime",
          "args": [
            "&path"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "raw"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_any_get",
          "args": [
            "inode->i_private",
            "*type"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_any_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "32-50",
          "snippet": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_inc(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_inc(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn raw;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_inc(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_inc(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn raw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_inode_type",
          "args": [
            "inode",
            "type"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_inode_type",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "130-143",
          "snippet": "static int bpf_inode_type(const struct inode *inode, enum bpf_type *type)\n{\n\t*type = BPF_TYPE_UNSPEC;\n\tif (inode->i_op == &bpf_prog_iops)\n\t\t*type = BPF_TYPE_PROG;\n\telse if (inode->i_op == &bpf_map_iops)\n\t\t*type = BPF_TYPE_MAP;\n\telse if (inode->i_op == &bpf_link_iops)\n\t\t*type = BPF_TYPE_LINK;\n\telse\n\t\treturn -EACCES;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bpf_prog_iops = { };",
            "static const struct inode_operations bpf_map_iops  = { };",
            "static const struct inode_operations bpf_link_iops  = { };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_prog_iops = { };\nstatic const struct inode_operations bpf_map_iops  = { };\nstatic const struct inode_operations bpf_link_iops  = { };\n\nstatic int bpf_inode_type(const struct inode *inode, enum bpf_type *type)\n{\n\t*type = BPF_TYPE_UNSPEC;\n\tif (inode->i_op == &bpf_prog_iops)\n\t\t*type = BPF_TYPE_PROG;\n\telse if (inode->i_op == &bpf_map_iops)\n\t\t*type = BPF_TYPE_MAP;\n\telse if (inode->i_op == &bpf_link_iops)\n\t\t*type = BPF_TYPE_LINK;\n\telse\n\t\treturn -EACCES;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_permission",
          "args": [
            "&path",
            "ACC_MODE(flags)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACC_MODE",
          "args": [
            "flags"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "path.dentry"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void *bpf_obj_do_get(const char __user *pathname,\n\t\t\t    enum bpf_type *type, int flags)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\n\tret = user_path_at(AT_FDCWD, pathname, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tinode = d_backing_inode(path.dentry);\n\tret = path_permission(&path, ACC_MODE(flags));\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\tif (!IS_ERR(raw))\n\t\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "bpf_obj_pin_user",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "481-496",
    "snippet": "int bpf_obj_pin_user(u32 ufd, const char __user *pathname)\n{\n\tenum bpf_type type;\n\tvoid *raw;\n\tint ret;\n\n\traw = bpf_fd_probe_obj(ufd, &type);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tret = bpf_obj_do_pin(pathname, raw, type);\n\tif (ret != 0)\n\t\tbpf_any_put(raw, type);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_any_put",
          "args": [
            "raw",
            "type"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_any_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "52-68",
          "snippet": "static void bpf_any_put(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_put(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_put_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_put(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void bpf_any_put(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_put(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_put_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_put(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_obj_do_pin",
          "args": [
            "pathname",
            "raw",
            "type"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_do_pin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "438-479",
          "snippet": "static int bpf_obj_do_pin(const char __user *pathname, void *raw,\n\t\t\t  enum bpf_type type)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tstruct path path;\n\tumode_t mode;\n\tint ret;\n\n\tdentry = user_path_create(AT_FDCWD, pathname, &path, 0);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());\n\n\tret = security_path_mknod(&path, dentry, mode, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tdir = d_inode(path.dentry);\n\tif (dir->i_op != &bpf_dir_iops) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mkprog, raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mkmap, raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mklink, raw);\n\t\tbreak;\n\tdefault:\n\t\tret = -EPERM;\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\treturn ret;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bpf_dir_iops;",
            "static const struct inode_operations bpf_dir_iops = {\n\t.lookup\t\t= bpf_lookup,\n\t.mkdir\t\t= bpf_mkdir,\n\t.symlink\t= bpf_symlink,\n\t.rmdir\t\t= simple_rmdir,\n\t.rename\t\t= simple_rename,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_dir_iops;\nstatic const struct inode_operations bpf_dir_iops = {\n\t.lookup\t\t= bpf_lookup,\n\t.mkdir\t\t= bpf_mkdir,\n\t.symlink\t= bpf_symlink,\n\t.rmdir\t\t= simple_rmdir,\n\t.rename\t\t= simple_rename,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n};\n\nstatic int bpf_obj_do_pin(const char __user *pathname, void *raw,\n\t\t\t  enum bpf_type type)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tstruct path path;\n\tumode_t mode;\n\tint ret;\n\n\tdentry = user_path_create(AT_FDCWD, pathname, &path, 0);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());\n\n\tret = security_path_mknod(&path, dentry, mode, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tdir = d_inode(path.dentry);\n\tif (dir->i_op != &bpf_dir_iops) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mkprog, raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mkmap, raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mklink, raw);\n\t\tbreak;\n\tdefault:\n\t\tret = -EPERM;\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "raw"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "raw"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_fd_probe_obj",
          "args": [
            "ufd",
            "&type"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_probe_obj",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "70-93",
          "snippet": "static void *bpf_fd_probe_obj(u32 ufd, enum bpf_type *type)\n{\n\tvoid *raw;\n\n\traw = bpf_map_get_with_uref(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_MAP;\n\t\treturn raw;\n\t}\n\n\traw = bpf_prog_get(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_PROG;\n\t\treturn raw;\n\t}\n\n\traw = bpf_link_get_from_fd(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_LINK;\n\t\treturn raw;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void *bpf_fd_probe_obj(u32 ufd, enum bpf_type *type)\n{\n\tvoid *raw;\n\n\traw = bpf_map_get_with_uref(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_MAP;\n\t\treturn raw;\n\t}\n\n\traw = bpf_prog_get(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_PROG;\n\t\treturn raw;\n\t}\n\n\traw = bpf_link_get_from_fd(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_LINK;\n\t\treturn raw;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_pin_user(u32 ufd, const char __user *pathname)\n{\n\tenum bpf_type type;\n\tvoid *raw;\n\tint ret;\n\n\traw = bpf_fd_probe_obj(ufd, &type);\n\tif (IS_ERR(raw))\n\t\treturn PTR_ERR(raw);\n\n\tret = bpf_obj_do_pin(pathname, raw, type);\n\tif (ret != 0)\n\t\tbpf_any_put(raw, type);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_obj_do_pin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "438-479",
    "snippet": "static int bpf_obj_do_pin(const char __user *pathname, void *raw,\n\t\t\t  enum bpf_type type)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tstruct path path;\n\tumode_t mode;\n\tint ret;\n\n\tdentry = user_path_create(AT_FDCWD, pathname, &path, 0);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());\n\n\tret = security_path_mknod(&path, dentry, mode, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tdir = d_inode(path.dentry);\n\tif (dir->i_op != &bpf_dir_iops) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mkprog, raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mkmap, raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mklink, raw);\n\t\tbreak;\n\tdefault:\n\t\tret = -EPERM;\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\treturn ret;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations bpf_dir_iops;",
      "static const struct inode_operations bpf_dir_iops = {\n\t.lookup\t\t= bpf_lookup,\n\t.mkdir\t\t= bpf_mkdir,\n\t.symlink\t= bpf_symlink,\n\t.rmdir\t\t= simple_rmdir,\n\t.rename\t\t= simple_rename,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "done_path_create",
          "args": [
            "&path",
            "dentry"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_mkobj",
          "args": [
            "dentry",
            "mode",
            "bpf_mklink",
            "raw"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_mkobj",
          "args": [
            "dentry",
            "mode",
            "bpf_mkmap",
            "raw"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_mkobj",
          "args": [
            "dentry",
            "mode",
            "bpf_mkprog",
            "raw"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "path.dentry"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_path_mknod",
          "args": [
            "&path",
            "dentry",
            "mode",
            "0"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_path_create",
          "args": [
            "AT_FDCWD",
            "pathname",
            "&path",
            "0"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_dir_iops;\nstatic const struct inode_operations bpf_dir_iops = {\n\t.lookup\t\t= bpf_lookup,\n\t.mkdir\t\t= bpf_mkdir,\n\t.symlink\t= bpf_symlink,\n\t.rmdir\t\t= simple_rmdir,\n\t.rename\t\t= simple_rename,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n};\n\nstatic int bpf_obj_do_pin(const char __user *pathname, void *raw,\n\t\t\t  enum bpf_type type)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir;\n\tstruct path path;\n\tumode_t mode;\n\tint ret;\n\n\tdentry = user_path_create(AT_FDCWD, pathname, &path, 0);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tmode = S_IFREG | ((S_IRUSR | S_IWUSR) & ~current_umask());\n\n\tret = security_path_mknod(&path, dentry, mode, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tdir = d_inode(path.dentry);\n\tif (dir->i_op != &bpf_dir_iops) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mkprog, raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mkmap, raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tret = vfs_mkobj(dentry, mode, bpf_mklink, raw);\n\t\tbreak;\n\tdefault:\n\t\tret = -EPERM;\n\t}\nout:\n\tdone_path_create(&path, dentry);\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_iter_link_pin_kernel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "418-436",
    "snippet": "static int bpf_iter_link_pin_kernel(struct dentry *parent,\n\t\t\t\t    const char *name, struct bpf_link *link)\n{\n\tumode_t mode = S_IFREG | S_IRUSR;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tinode_lock(parent->d_inode);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\tinode_unlock(parent->d_inode);\n\t\treturn PTR_ERR(dentry);\n\t}\n\tret = bpf_mkobj_ops(dentry, mode, link, &bpf_link_iops,\n\t\t\t    &bpf_iter_fops);\n\tdput(dentry);\n\tinode_unlock(parent->d_inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations bpf_link_iops  = { };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "parent->d_inode"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_mkobj_ops",
          "args": [
            "dentry",
            "mode",
            "link",
            "&bpf_link_iops",
            "&bpf_iter_fops"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_mkobj_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "331-346",
          "snippet": "static int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,\n\t\t\t const struct inode_operations *iops,\n\t\t\t const struct file_operations *fops)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = iops;\n\tinode->i_fop = fops;\n\tinode->i_private = raw;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,\n\t\t\t const struct inode_operations *iops,\n\t\t\t const struct file_operations *fops)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = iops;\n\tinode->i_fop = fops;\n\tinode->i_private = raw;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "parent->d_inode"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "parent",
            "strlen(name)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "parent->d_inode"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_link_iops  = { };\n\nstatic int bpf_iter_link_pin_kernel(struct dentry *parent,\n\t\t\t\t    const char *name, struct bpf_link *link)\n{\n\tumode_t mode = S_IFREG | S_IRUSR;\n\tstruct dentry *dentry;\n\tint ret;\n\n\tinode_lock(parent->d_inode);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry)) {\n\t\tinode_unlock(parent->d_inode);\n\t\treturn PTR_ERR(dentry);\n\t}\n\tret = bpf_mkobj_ops(dentry, mode, link, &bpf_link_iops,\n\t\t\t    &bpf_iter_fops);\n\tdput(dentry);\n\tinode_unlock(parent->d_inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_symlink",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "385-405",
    "snippet": "static int bpf_symlink(struct user_namespace *mnt_userns, struct inode *dir,\n\t\t       struct dentry *dentry, const char *target)\n{\n\tchar *link = kstrdup(target, GFP_USER | __GFP_NOWARN);\n\tstruct inode *inode;\n\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tinode = bpf_get_inode(dir->i_sb, dir, S_IRWXUGO | S_IFLNK);\n\tif (IS_ERR(inode)) {\n\t\tkfree(link);\n\t\treturn PTR_ERR(inode);\n\t}\n\n\tinode->i_op = &simple_symlink_inode_operations;\n\tinode->i_link = link;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_dentry_finalize",
          "args": [
            "dentry",
            "inode",
            "dir"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_dentry_finalize",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "145-153",
          "snippet": "static void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,\n\t\t\t\tstruct inode *dir)\n{\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\tdir->i_mtime = current_time(dir);\n\tdir->i_ctime = dir->i_mtime;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,\n\t\t\t\tstruct inode *dir)\n{\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\tdir->i_mtime = current_time(dir);\n\tdir->i_ctime = dir->i_mtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_get_inode",
          "args": [
            "dir->i_sb",
            "dir",
            "S_IRWXUGO | S_IFLNK"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_inode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "101-128",
          "snippet": "static struct inode *bpf_get_inode(struct super_block *sb,\n\t\t\t\t   const struct inode *dir,\n\t\t\t\t   umode_t mode)\n{\n\tstruct inode *inode;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_atime = current_time(inode);\n\tinode->i_mtime = inode->i_atime;\n\tinode->i_ctime = inode->i_atime;\n\n\tinode_init_owner(&init_user_ns, inode, dir, mode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct inode *bpf_get_inode(struct super_block *sb,\n\t\t\t\t   const struct inode *dir,\n\t\t\t\t   umode_t mode)\n{\n\tstruct inode *inode;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_atime = current_time(inode);\n\tinode->i_mtime = inode->i_atime;\n\tinode->i_ctime = inode->i_atime;\n\n\tinode_init_owner(&init_user_ns, inode, dir, mode);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "target",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int bpf_symlink(struct user_namespace *mnt_userns, struct inode *dir,\n\t\t       struct dentry *dentry, const char *target)\n{\n\tchar *link = kstrdup(target, GFP_USER | __GFP_NOWARN);\n\tstruct inode *inode;\n\n\tif (!link)\n\t\treturn -ENOMEM;\n\n\tinode = bpf_get_inode(dir->i_sb, dir, S_IRWXUGO | S_IFLNK);\n\tif (IS_ERR(inode)) {\n\t\tkfree(link);\n\t\treturn PTR_ERR(inode);\n\t}\n\n\tinode->i_op = &simple_symlink_inode_operations;\n\tinode->i_link = link;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_lookup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "372-383",
    "snippet": "static struct dentry *\nbpf_lookup(struct inode *dir, struct dentry *dentry, unsigned flags)\n{\n\t/* Dots in names (e.g. \"/sys/fs/bpf/foo.bar\") are reserved for future\n\t * extensions. That allows popoulate_bpffs() create special files.\n\t */\n\tif ((dir->i_mode & S_IALLUGO) &&\n\t    strchr(dentry->d_name.name, '.'))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn simple_lookup(dir, dentry, flags);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_lookup",
          "args": [
            "dir",
            "dentry",
            "flags"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "dentry->d_name.name",
            "'.'"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct dentry *\nbpf_lookup(struct inode *dir, struct dentry *dentry, unsigned flags)\n{\n\t/* Dots in names (e.g. \"/sys/fs/bpf/foo.bar\") are reserved for future\n\t * extensions. That allows popoulate_bpffs() create special files.\n\t */\n\tif ((dir->i_mode & S_IALLUGO) &&\n\t    strchr(dentry->d_name.name, '.'))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn simple_lookup(dir, dentry, flags);\n}"
  },
  {
    "function_name": "bpf_mklink",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "363-370",
    "snippet": "static int bpf_mklink(struct dentry *dentry, umode_t mode, void *arg)\n{\n\tstruct bpf_link *link = arg;\n\n\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_link_iops,\n\t\t\t     bpf_link_is_iter(link) ?\n\t\t\t     &bpf_iter_fops : &bpffs_obj_fops);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations bpf_link_iops  = { };",
      "static const struct file_operations bpffs_obj_fops = {\n\t.open\t\t= bpffs_obj_open,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_mkobj_ops",
          "args": [
            "dentry",
            "mode",
            "arg",
            "&bpf_link_iops",
            "bpf_link_is_iter(link) ?\n\t\t\t     &bpf_iter_fops : &bpffs_obj_fops"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_mkobj_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "331-346",
          "snippet": "static int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,\n\t\t\t const struct inode_operations *iops,\n\t\t\t const struct file_operations *fops)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = iops;\n\tinode->i_fop = fops;\n\tinode->i_private = raw;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,\n\t\t\t const struct inode_operations *iops,\n\t\t\t const struct file_operations *fops)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = iops;\n\tinode->i_fop = fops;\n\tinode->i_private = raw;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_link_is_iter",
          "args": [
            "link"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_is_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/bpf_iter.c",
          "lines": "493-496",
          "snippet": "bool bpf_link_is_iter(struct bpf_link *link)\n{\n\treturn link->ops == &bpf_iter_link_lops;\n}",
          "includes": [
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/anon_inodes.h>\n#include <linux/fs.h>\n\nstatic const struct bpf_link_ops bpf_iter_link_lops = {\n\t.release = bpf_iter_link_release,\n\t.dealloc = bpf_iter_link_dealloc,\n\t.update_prog = bpf_iter_link_replace,\n\t.show_fdinfo = bpf_iter_link_show_fdinfo,\n\t.fill_link_info = bpf_iter_link_fill_link_info,\n};\n\nbool bpf_link_is_iter(struct bpf_link *link)\n{\n\treturn link->ops == &bpf_iter_link_lops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_link_iops  = { };\nstatic const struct file_operations bpffs_obj_fops = {\n\t.open\t\t= bpffs_obj_open,\n};\n\nstatic int bpf_mklink(struct dentry *dentry, umode_t mode, void *arg)\n{\n\tstruct bpf_link *link = arg;\n\n\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_link_iops,\n\t\t\t     bpf_link_is_iter(link) ?\n\t\t\t     &bpf_iter_fops : &bpffs_obj_fops);\n}"
  },
  {
    "function_name": "bpf_mkmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "354-361",
    "snippet": "static int bpf_mkmap(struct dentry *dentry, umode_t mode, void *arg)\n{\n\tstruct bpf_map *map = arg;\n\n\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_map_iops,\n\t\t\t     bpf_map_support_seq_show(map) ?\n\t\t\t     &bpffs_map_fops : &bpffs_obj_fops);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations bpf_map_iops  = { };",
      "static const struct file_operations bpffs_map_fops = {\n\t.open\t\t= bpffs_map_open,\n\t.read\t\t= seq_read,\n\t.release\t= bpffs_map_release,\n};",
      "static const struct file_operations bpffs_obj_fops = {\n\t.open\t\t= bpffs_obj_open,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_mkobj_ops",
          "args": [
            "dentry",
            "mode",
            "arg",
            "&bpf_map_iops",
            "bpf_map_support_seq_show(map) ?\n\t\t\t     &bpffs_map_fops : &bpffs_obj_fops"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_mkobj_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "331-346",
          "snippet": "static int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,\n\t\t\t const struct inode_operations *iops,\n\t\t\t const struct file_operations *fops)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = iops;\n\tinode->i_fop = fops;\n\tinode->i_private = raw;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,\n\t\t\t const struct inode_operations *iops,\n\t\t\t const struct file_operations *fops)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = iops;\n\tinode->i_fop = fops;\n\tinode->i_private = raw;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_support_seq_show",
          "args": [
            "map"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_map_iops  = { };\nstatic const struct file_operations bpffs_map_fops = {\n\t.open\t\t= bpffs_map_open,\n\t.read\t\t= seq_read,\n\t.release\t= bpffs_map_release,\n};\nstatic const struct file_operations bpffs_obj_fops = {\n\t.open\t\t= bpffs_obj_open,\n};\n\nstatic int bpf_mkmap(struct dentry *dentry, umode_t mode, void *arg)\n{\n\tstruct bpf_map *map = arg;\n\n\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_map_iops,\n\t\t\t     bpf_map_support_seq_show(map) ?\n\t\t\t     &bpffs_map_fops : &bpffs_obj_fops);\n}"
  },
  {
    "function_name": "bpf_mkprog",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "348-352",
    "snippet": "static int bpf_mkprog(struct dentry *dentry, umode_t mode, void *arg)\n{\n\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_prog_iops,\n\t\t\t     &bpffs_obj_fops);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations bpf_prog_iops = { };",
      "static const struct file_operations bpffs_obj_fops = {\n\t.open\t\t= bpffs_obj_open,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_mkobj_ops",
          "args": [
            "dentry",
            "mode",
            "arg",
            "&bpf_prog_iops",
            "&bpffs_obj_fops"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_mkobj_ops",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "331-346",
          "snippet": "static int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,\n\t\t\t const struct inode_operations *iops,\n\t\t\t const struct file_operations *fops)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = iops;\n\tinode->i_fop = fops;\n\tinode->i_private = raw;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,\n\t\t\t const struct inode_operations *iops,\n\t\t\t const struct file_operations *fops)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = iops;\n\tinode->i_fop = fops;\n\tinode->i_private = raw;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_prog_iops = { };\nstatic const struct file_operations bpffs_obj_fops = {\n\t.open\t\t= bpffs_obj_open,\n};\n\nstatic int bpf_mkprog(struct dentry *dentry, umode_t mode, void *arg)\n{\n\treturn bpf_mkobj_ops(dentry, mode, arg, &bpf_prog_iops,\n\t\t\t     &bpffs_obj_fops);\n}"
  },
  {
    "function_name": "bpf_mkobj_ops",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "331-346",
    "snippet": "static int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,\n\t\t\t const struct inode_operations *iops,\n\t\t\t const struct file_operations *fops)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = iops;\n\tinode->i_fop = fops;\n\tinode->i_private = raw;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_dentry_finalize",
          "args": [
            "dentry",
            "inode",
            "dir"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_dentry_finalize",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "145-153",
          "snippet": "static void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,\n\t\t\t\tstruct inode *dir)\n{\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\tdir->i_mtime = current_time(dir);\n\tdir->i_ctime = dir->i_mtime;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,\n\t\t\t\tstruct inode *dir)\n{\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\tdir->i_mtime = current_time(dir);\n\tdir->i_ctime = dir->i_mtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_get_inode",
          "args": [
            "dir->i_sb",
            "dir",
            "mode"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_inode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "101-128",
          "snippet": "static struct inode *bpf_get_inode(struct super_block *sb,\n\t\t\t\t   const struct inode *dir,\n\t\t\t\t   umode_t mode)\n{\n\tstruct inode *inode;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_atime = current_time(inode);\n\tinode->i_mtime = inode->i_atime;\n\tinode->i_ctime = inode->i_atime;\n\n\tinode_init_owner(&init_user_ns, inode, dir, mode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct inode *bpf_get_inode(struct super_block *sb,\n\t\t\t\t   const struct inode *dir,\n\t\t\t\t   umode_t mode)\n{\n\tstruct inode *inode;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_atime = current_time(inode);\n\tinode->i_mtime = inode->i_atime;\n\tinode->i_ctime = inode->i_atime;\n\n\tinode_init_owner(&init_user_ns, inode, dir, mode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int bpf_mkobj_ops(struct dentry *dentry, umode_t mode, void *raw,\n\t\t\t const struct inode_operations *iops,\n\t\t\t const struct file_operations *fops)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tstruct inode *inode = bpf_get_inode(dir->i_sb, dir, mode);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = iops;\n\tinode->i_fop = fops;\n\tinode->i_private = raw;\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpffs_obj_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "322-325",
    "snippet": "static int bpffs_obj_open(struct inode *inode, struct file *file)\n{\n\treturn -EIO;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int bpffs_obj_open(struct inode *inode, struct file *file)\n{\n\treturn -EIO;\n}"
  },
  {
    "function_name": "bpffs_map_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "297-304",
    "snippet": "static int bpffs_map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\n\tmap_iter_free(map_iter(m));\n\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "328-342",
          "snippet": "static int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic int gcov_seq_release(struct inode *inode, struct file *file)\n{\n\tstruct gcov_iterator *iter;\n\tstruct gcov_info *info;\n\tstruct seq_file *seq;\n\n\tseq = file->private_data;\n\titer = seq->private;\n\tinfo = gcov_iter_get_info(iter);\n\tgcov_iter_free(iter);\n\tgcov_info_free(info);\n\tseq_release(inode, file);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_iter_free",
          "args": [
            "map_iter(m)"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "map_iter_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "189-195",
          "snippet": "static void map_iter_free(struct map_iter *iter)\n{\n\tif (iter) {\n\t\tkfree(iter->key);\n\t\tkfree(iter);\n\t}\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void map_iter_free(struct map_iter *iter)\n{\n\tif (iter) {\n\t\tkfree(iter->key);\n\t\tkfree(iter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_iter",
          "args": [
            "m"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "map_iter_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "197-214",
          "snippet": "static struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int bpffs_map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\n\tmap_iter_free(map_iter(m));\n\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "bpffs_map_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "274-295",
    "snippet": "static int bpffs_map_open(struct inode *inode, struct file *file)\n{\n\tstruct bpf_map *map = inode->i_private;\n\tstruct map_iter *iter;\n\tstruct seq_file *m;\n\tint err;\n\n\titer = map_iter_alloc(map);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\terr = seq_open(file, &bpffs_map_seq_ops);\n\tif (err) {\n\t\tmap_iter_free(iter);\n\t\treturn err;\n\t}\n\n\tm = file->private_data;\n\tm->private = iter;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations bpffs_map_seq_ops = {\n\t.start\t= map_seq_start,\n\t.next\t= map_seq_next,\n\t.show\t= map_seq_show,\n\t.stop\t= map_seq_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_iter_free",
          "args": [
            "iter"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "map_iter_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "189-195",
          "snippet": "static void map_iter_free(struct map_iter *iter)\n{\n\tif (iter) {\n\t\tkfree(iter->key);\n\t\tkfree(iter);\n\t}\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void map_iter_free(struct map_iter *iter)\n{\n\tif (iter) {\n\t\tkfree(iter->key);\n\t\tkfree(iter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&bpffs_map_seq_ops"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/gcov/fs.c",
          "lines": "288-322",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/mm.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/mm.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_iter_alloc",
          "args": [
            "map"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "map_iter_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "197-214",
          "snippet": "static struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct seq_operations bpffs_map_seq_ops = {\n\t.start\t= map_seq_start,\n\t.next\t= map_seq_next,\n\t.show\t= map_seq_show,\n\t.stop\t= map_seq_stop,\n};\n\nstatic int bpffs_map_open(struct inode *inode, struct file *file)\n{\n\tstruct bpf_map *map = inode->i_private;\n\tstruct map_iter *iter;\n\tstruct seq_file *m;\n\tint err;\n\n\titer = map_iter_alloc(map);\n\tif (!iter)\n\t\treturn -ENOMEM;\n\n\terr = seq_open(file, &bpffs_map_seq_ops);\n\tif (err) {\n\t\tmap_iter_free(iter);\n\t\treturn err;\n\t}\n\n\tm = file->private_data;\n\tm->private = iter;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "map_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "252-265",
    "snippet": "static int map_seq_show(struct seq_file *m, void *v)\n{\n\tstruct bpf_map *map = seq_file_to_map(m);\n\tvoid *key = map_iter(m)->key;\n\n\tif (unlikely(v == SEQ_START_TOKEN)) {\n\t\tseq_puts(m, \"# WARNING!! The output is for debug purpose only\\n\");\n\t\tseq_puts(m, \"# WARNING!! The output format will change\\n\");\n\t} else {\n\t\tmap->ops->map_seq_show_elem(map, key, m);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_seq_show_elem",
          "args": [
            "map",
            "key",
            "m"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"# WARNING!! The output format will change\\n\""
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "205-220",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "v == SEQ_START_TOKEN"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_iter",
          "args": [
            "m"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "map_iter_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "197-214",
          "snippet": "static struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_file_to_map",
          "args": [
            "m"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "seq_file_to_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "184-187",
          "snippet": "static struct bpf_map *seq_file_to_map(struct seq_file *m)\n{\n\treturn file_inode(m->file)->i_private;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct bpf_map *seq_file_to_map(struct seq_file *m)\n{\n\treturn file_inode(m->file)->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic int map_seq_show(struct seq_file *m, void *v)\n{\n\tstruct bpf_map *map = seq_file_to_map(m);\n\tvoid *key = map_iter(m)->key;\n\n\tif (unlikely(v == SEQ_START_TOKEN)) {\n\t\tseq_puts(m, \"# WARNING!! The output is for debug purpose only\\n\");\n\t\tseq_puts(m, \"# WARNING!! The output format will change\\n\");\n\t} else {\n\t\tmap->ops->map_seq_show_elem(map, key, m);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "map_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "248-250",
    "snippet": "static void map_seq_stop(struct seq_file *m, void *v)\n{\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void map_seq_stop(struct seq_file *m, void *v)\n{\n}"
  },
  {
    "function_name": "map_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "240-246",
    "snippet": "static void *map_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tif (map_iter(m)->done)\n\t\treturn NULL;\n\n\treturn *pos ? map_iter(m)->key : SEQ_START_TOKEN;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_iter",
          "args": [
            "m"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "map_iter_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "197-214",
          "snippet": "static struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void *map_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tif (map_iter(m)->done)\n\t\treturn NULL;\n\n\treturn *pos ? map_iter(m)->key : SEQ_START_TOKEN;\n}"
  },
  {
    "function_name": "map_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "216-238",
    "snippet": "static void *map_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct bpf_map *map = seq_file_to_map(m);\n\tvoid *key = map_iter(m)->key;\n\tvoid *prev_key;\n\n\t(*pos)++;\n\tif (map_iter(m)->done)\n\t\treturn NULL;\n\n\tif (unlikely(v == SEQ_START_TOKEN))\n\t\tprev_key = NULL;\n\telse\n\t\tprev_key = key;\n\n\trcu_read_lock();\n\tif (map->ops->map_get_next_key(map, prev_key, key)) {\n\t\tmap_iter(m)->done = true;\n\t\tkey = NULL;\n\t}\n\trcu_read_unlock();\n\treturn key;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_iter",
          "args": [
            "m"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "map_iter_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "197-214",
          "snippet": "static struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_get_next_key",
          "args": [
            "map",
            "prev_key",
            "key"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "v == SEQ_START_TOKEN"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_file_to_map",
          "args": [
            "m"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "seq_file_to_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "184-187",
          "snippet": "static struct bpf_map *seq_file_to_map(struct seq_file *m)\n{\n\treturn file_inode(m->file)->i_private;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct bpf_map *seq_file_to_map(struct seq_file *m)\n{\n\treturn file_inode(m->file)->i_private;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void *map_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct bpf_map *map = seq_file_to_map(m);\n\tvoid *key = map_iter(m)->key;\n\tvoid *prev_key;\n\n\t(*pos)++;\n\tif (map_iter(m)->done)\n\t\treturn NULL;\n\n\tif (unlikely(v == SEQ_START_TOKEN))\n\t\tprev_key = NULL;\n\telse\n\t\tprev_key = key;\n\n\trcu_read_lock();\n\tif (map->ops->map_get_next_key(map, prev_key, key)) {\n\t\tmap_iter(m)->done = true;\n\t\tkey = NULL;\n\t}\n\trcu_read_unlock();\n\treturn key;\n}"
  },
  {
    "function_name": "map_iter_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "197-214",
    "snippet": "static struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map_iter_free",
          "args": [
            "iter"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "map_iter_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "189-195",
          "snippet": "static void map_iter_free(struct map_iter *iter)\n{\n\tif (iter) {\n\t\tkfree(iter->key);\n\t\tkfree(iter);\n\t}\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void map_iter_free(struct map_iter *iter)\n{\n\tif (iter) {\n\t\tkfree(iter->key);\n\t\tkfree(iter);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "map->key_size",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*iter)",
            "GFP_KERNEL | __GFP_NOWARN"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct map_iter *map_iter_alloc(struct bpf_map *map)\n{\n\tstruct map_iter *iter;\n\n\titer = kzalloc(sizeof(*iter), GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter)\n\t\tgoto error;\n\n\titer->key = kzalloc(map->key_size, GFP_KERNEL | __GFP_NOWARN);\n\tif (!iter->key)\n\t\tgoto error;\n\n\treturn iter;\n\nerror:\n\tmap_iter_free(iter);\n\treturn NULL;\n}"
  },
  {
    "function_name": "map_iter_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "189-195",
    "snippet": "static void map_iter_free(struct map_iter *iter)\n{\n\tif (iter) {\n\t\tkfree(iter->key);\n\t\tkfree(iter);\n\t}\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iter"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void map_iter_free(struct map_iter *iter)\n{\n\tif (iter) {\n\t\tkfree(iter->key);\n\t\tkfree(iter);\n\t}\n}"
  },
  {
    "function_name": "seq_file_to_map",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "184-187",
    "snippet": "static struct bpf_map *seq_file_to_map(struct seq_file *m)\n{\n\treturn file_inode(m->file)->i_private;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "m->file"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct bpf_map *seq_file_to_map(struct seq_file *m)\n{\n\treturn file_inode(m->file)->i_private;\n}"
  },
  {
    "function_name": "map_iter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "179-182",
    "snippet": "static struct map_iter *map_iter(struct seq_file *m)\n{\n\treturn m->private;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct map_iter *map_iter(struct seq_file *m)\n{\n\treturn m->private;\n}"
  },
  {
    "function_name": "bpf_mkdir",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "155-172",
    "snippet": "static int bpf_mkdir(struct user_namespace *mnt_userns, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = bpf_get_inode(dir->i_sb, dir, mode | S_IFDIR);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &bpf_dir_iops;\n\tinode->i_fop = &simple_dir_operations;\n\n\tinc_nlink(inode);\n\tinc_nlink(dir);\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations bpf_dir_iops;",
      "static const struct inode_operations bpf_dir_iops = {\n\t.lookup\t\t= bpf_lookup,\n\t.mkdir\t\t= bpf_mkdir,\n\t.symlink\t= bpf_symlink,\n\t.rmdir\t\t= simple_rmdir,\n\t.rename\t\t= simple_rename,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_dentry_finalize",
          "args": [
            "dentry",
            "inode",
            "dir"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_dentry_finalize",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "145-153",
          "snippet": "static void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,\n\t\t\t\tstruct inode *dir)\n{\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\tdir->i_mtime = current_time(dir);\n\tdir->i_ctime = dir->i_mtime;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,\n\t\t\t\tstruct inode *dir)\n{\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\tdir->i_mtime = current_time(dir);\n\tdir->i_ctime = dir->i_mtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_get_inode",
          "args": [
            "dir->i_sb",
            "dir",
            "mode | S_IFDIR"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_inode",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
          "lines": "101-128",
          "snippet": "static struct inode *bpf_get_inode(struct super_block *sb,\n\t\t\t\t   const struct inode *dir,\n\t\t\t\t   umode_t mode)\n{\n\tstruct inode *inode;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_atime = current_time(inode);\n\tinode->i_mtime = inode->i_atime;\n\tinode->i_ctime = inode->i_atime;\n\n\tinode_init_owner(&init_user_ns, inode, dir, mode);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"preload/bpf_preload.h\"",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs_parser.h>",
            "#include <linux/fs_context.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct inode *bpf_get_inode(struct super_block *sb,\n\t\t\t\t   const struct inode *dir,\n\t\t\t\t   umode_t mode)\n{\n\tstruct inode *inode;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_atime = current_time(inode);\n\tinode->i_mtime = inode->i_atime;\n\tinode->i_ctime = inode->i_atime;\n\n\tinode_init_owner(&init_user_ns, inode, dir, mode);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_dir_iops;\nstatic const struct inode_operations bpf_dir_iops = {\n\t.lookup\t\t= bpf_lookup,\n\t.mkdir\t\t= bpf_mkdir,\n\t.symlink\t= bpf_symlink,\n\t.rmdir\t\t= simple_rmdir,\n\t.rename\t\t= simple_rename,\n\t.link\t\t= simple_link,\n\t.unlink\t\t= simple_unlink,\n};\n\nstatic int bpf_mkdir(struct user_namespace *mnt_userns, struct inode *dir,\n\t\t     struct dentry *dentry, umode_t mode)\n{\n\tstruct inode *inode;\n\n\tinode = bpf_get_inode(dir->i_sb, dir, mode | S_IFDIR);\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tinode->i_op = &bpf_dir_iops;\n\tinode->i_fop = &simple_dir_operations;\n\n\tinc_nlink(inode);\n\tinc_nlink(dir);\n\n\tbpf_dentry_finalize(dentry, inode, dir);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_dentry_finalize",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "145-153",
    "snippet": "static void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,\n\t\t\t\tstruct inode *dir)\n{\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\tdir->i_mtime = current_time(dir);\n\tdir->i_ctime = dir->i_mtime;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "dir"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void bpf_dentry_finalize(struct dentry *dentry, struct inode *inode,\n\t\t\t\tstruct inode *dir)\n{\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\n\tdir->i_mtime = current_time(dir);\n\tdir->i_ctime = dir->i_mtime;\n}"
  },
  {
    "function_name": "bpf_inode_type",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "130-143",
    "snippet": "static int bpf_inode_type(const struct inode *inode, enum bpf_type *type)\n{\n\t*type = BPF_TYPE_UNSPEC;\n\tif (inode->i_op == &bpf_prog_iops)\n\t\t*type = BPF_TYPE_PROG;\n\telse if (inode->i_op == &bpf_map_iops)\n\t\t*type = BPF_TYPE_MAP;\n\telse if (inode->i_op == &bpf_link_iops)\n\t\t*type = BPF_TYPE_LINK;\n\telse\n\t\treturn -EACCES;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations bpf_prog_iops = { };",
      "static const struct inode_operations bpf_map_iops  = { };",
      "static const struct inode_operations bpf_link_iops  = { };"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic const struct inode_operations bpf_prog_iops = { };\nstatic const struct inode_operations bpf_map_iops  = { };\nstatic const struct inode_operations bpf_link_iops  = { };\n\nstatic int bpf_inode_type(const struct inode *inode, enum bpf_type *type)\n{\n\t*type = BPF_TYPE_UNSPEC;\n\tif (inode->i_op == &bpf_prog_iops)\n\t\t*type = BPF_TYPE_PROG;\n\telse if (inode->i_op == &bpf_map_iops)\n\t\t*type = BPF_TYPE_MAP;\n\telse if (inode->i_op == &bpf_link_iops)\n\t\t*type = BPF_TYPE_LINK;\n\telse\n\t\treturn -EACCES;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_get_inode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "101-128",
    "snippet": "static struct inode *bpf_get_inode(struct super_block *sb,\n\t\t\t\t   const struct inode *dir,\n\t\t\t\t   umode_t mode)\n{\n\tstruct inode *inode;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_atime = current_time(inode);\n\tinode->i_mtime = inode->i_atime;\n\tinode->i_ctime = inode->i_atime;\n\n\tinode_init_owner(&init_user_ns, inode, dir, mode);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "&init_user_ns",
            "inode",
            "dir",
            "mode"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic struct inode *bpf_get_inode(struct super_block *sb,\n\t\t\t\t   const struct inode *dir,\n\t\t\t\t   umode_t mode)\n{\n\tstruct inode *inode;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\tcase S_IFREG:\n\tcase S_IFLNK:\n\t\tbreak;\n\tdefault:\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_atime = current_time(inode);\n\tinode->i_mtime = inode->i_atime;\n\tinode->i_ctime = inode->i_atime;\n\n\tinode_init_owner(&init_user_ns, inode, dir, mode);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "bpf_fd_probe_obj",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "70-93",
    "snippet": "static void *bpf_fd_probe_obj(u32 ufd, enum bpf_type *type)\n{\n\tvoid *raw;\n\n\traw = bpf_map_get_with_uref(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_MAP;\n\t\treturn raw;\n\t}\n\n\traw = bpf_prog_get(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_PROG;\n\t\treturn raw;\n\t}\n\n\traw = bpf_link_get_from_fd(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_LINK;\n\t\treturn raw;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "raw"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_get_from_fd",
          "args": [
            "ufd"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_get_from_fd",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2615-2632",
          "snippet": "struct bpf_link *bpf_link_get_from_fd(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_link *link;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_link_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = f.file->private_data;\n\tbpf_link_inc(link);\n\tfdput(f);\n\n\treturn link;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_link_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_link_show_fdinfo,\n#endif\n\t.release\t= bpf_link_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_link *bpf_link_get_from_fd(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_link *link;\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_link_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlink = f.file->private_data;\n\tbpf_link_inc(link);\n\tfdput(f);\n\n\treturn link;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "raw"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "ufd"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "3441-3462",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tprog = bpf_prog_by_id(id);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "raw"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_get_with_uref",
          "args": [
            "ufd"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_get_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "990-1003",
          "snippet": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\tbpf_map_inc_with_uref(map);\n\tfdput(f);\n\n\treturn map;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\tbpf_map_inc_with_uref(map);\n\tfdput(f);\n\n\treturn map;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void *bpf_fd_probe_obj(u32 ufd, enum bpf_type *type)\n{\n\tvoid *raw;\n\n\traw = bpf_map_get_with_uref(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_MAP;\n\t\treturn raw;\n\t}\n\n\traw = bpf_prog_get(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_PROG;\n\t\treturn raw;\n\t}\n\n\traw = bpf_link_get_from_fd(ufd);\n\tif (!IS_ERR(raw)) {\n\t\t*type = BPF_TYPE_LINK;\n\t\treturn raw;\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "bpf_any_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "52-68",
    "snippet": "static void bpf_any_put(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_put(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_put_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_put(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_put",
          "args": [
            "raw"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "2479-2490",
          "snippet": "void bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_link_put(struct bpf_link *link)\n{\n\tif (!atomic64_dec_and_test(&link->refcnt))\n\t\treturn;\n\n\tif (in_atomic()) {\n\t\tINIT_WORK(&link->work, bpf_link_put_deferred);\n\t\tschedule_work(&link->work);\n\t} else {\n\t\tbpf_link_free(link);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_put_with_uref",
          "args": [
            "raw"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "514-518",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "raw"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1828-1831",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void bpf_any_put(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_put(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_put_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_put(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "bpf_any_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/inode.c",
    "lines": "32-50",
    "snippet": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_inc(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_inc(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn raw;\n}",
    "includes": [
      "#include \"preload/bpf_preload.h\"",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>",
      "#include <linux/filter.h>",
      "#include <linux/kdev_t.h>",
      "#include <linux/fs_parser.h>",
      "#include <linux/fs_context.h>",
      "#include <linux/fs.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/major.h>",
      "#include <linux/magic.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link_inc",
          "args": [
            "raw"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_link_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "4401-4404",
          "snippet": "static struct bpf_link *bpf_link_inc_not_zero(struct bpf_link *link)\n{\n\treturn atomic64_fetch_add_unless(&link->refcnt, 1, 0) ? link : ERR_PTR(-ENOENT);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_link *bpf_link_inc_not_zero(struct bpf_link *link)\n{\n\treturn atomic64_fetch_add_unless(&link->refcnt, 1, 0) ? link : ERR_PTR(-ENOENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_inc_with_uref",
          "args": [
            "raw"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_inc_with_uref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "968-972",
          "snippet": "void bpf_map_inc_with_uref(struct bpf_map *map)\n{\n\tatomic64_inc(&map->refcnt);\n\tatomic64_inc(&map->usercnt);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_inc_with_uref(struct bpf_map *map)\n{\n\tatomic64_inc(&map->refcnt);\n\tatomic64_inc(&map->usercnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_inc",
          "args": [
            "raw"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_inc_not_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "1963-1973",
          "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic64_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"preload/bpf_preload.h\"\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/kdev_t.h>\n#include <linux/fs_parser.h>\n#include <linux/fs_context.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstatic void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tbpf_prog_inc(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc_with_uref(raw);\n\t\tbreak;\n\tcase BPF_TYPE_LINK:\n\t\tbpf_link_inc(raw);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn raw;\n}"
  }
]