[
  {
    "function_name": "clockevents_init_sysfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "768-775",
    "snippet": "static int __init clockevents_init_sysfs(void)\n{\n\tint err = subsys_system_register(&clockevents_subsys, NULL);\n\n\tif (!err)\n\t\terr = tick_init_sysfs();\n\treturn err;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_init_sysfs",
          "args": [],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "tick_init_sysfs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "747-766",
          "snippet": "static int __init tick_init_sysfs(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = &per_cpu(tick_percpu_dev, cpu);\n\t\tint err;\n\n\t\tdev->id = cpu;\n\t\tdev->bus = &clockevents_subsys;\n\t\terr = device_register(dev);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_current_device);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_unbind_device);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn tick_broadcast_init_sysfs();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __init tick_init_sysfs(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = &per_cpu(tick_percpu_dev, cpu);\n\t\tint err;\n\n\t\tdev->id = cpu;\n\t\tdev->bus = &clockevents_subsys;\n\t\terr = device_register(dev);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_current_device);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_unbind_device);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn tick_broadcast_init_sysfs();\n}"
        }
      },
      {
        "call_info": {
          "callee": "subsys_system_register",
          "args": [
            "&clockevents_subsys",
            "NULL"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __init clockevents_init_sysfs(void)\n{\n\tint err = subsys_system_register(&clockevents_subsys, NULL);\n\n\tif (!err)\n\t\terr = tick_init_sysfs();\n\treturn err;\n}"
  },
  {
    "function_name": "tick_init_sysfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "747-766",
    "snippet": "static int __init tick_init_sysfs(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = &per_cpu(tick_percpu_dev, cpu);\n\t\tint err;\n\n\t\tdev->id = cpu;\n\t\tdev->bus = &clockevents_subsys;\n\t\terr = device_register(dev);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_current_device);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_unbind_device);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn tick_broadcast_init_sysfs();\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_broadcast_init_sysfs",
          "args": [],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_init_sysfs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "744-744",
          "snippet": "static inline int tick_broadcast_init_sysfs(void) { return 0; }",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic inline int tick_broadcast_init_sysfs(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "dev",
            "&dev_attr_unbind_device"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "dev",
            "&dev_attr_current_device"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_register",
          "args": [
            "dev"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_percpu_dev",
            "cpu"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __init tick_init_sysfs(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *dev = &per_cpu(tick_percpu_dev, cpu);\n\t\tint err;\n\n\t\tdev->id = cpu;\n\t\tdev->bus = &clockevents_subsys;\n\t\terr = device_register(dev);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_current_device);\n\t\tif (!err)\n\t\t\terr = device_create_file(dev, &dev_attr_unbind_device);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn tick_broadcast_init_sysfs();\n}"
  },
  {
    "function_name": "tick_broadcast_init_sysfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "744-744",
    "snippet": "static inline int tick_broadcast_init_sysfs(void) { return 0; }",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic inline int tick_broadcast_init_sysfs(void) { return 0; }"
  },
  {
    "function_name": "tick_get_tick_dev",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "740-743",
    "snippet": "static struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn &per_cpu(tick_cpu_device, dev->id);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "dev->id"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn &per_cpu(tick_cpu_device, dev->id);\n}"
  },
  {
    "function_name": "tick_broadcast_init_sysfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "731-738",
    "snippet": "static __init int tick_broadcast_init_sysfs(void)\n{\n\tint err = device_register(&tick_bc_dev);\n\n\tif (!err)\n\t\terr = device_create_file(&tick_bc_dev, &dev_attr_current_device);\n\treturn err;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_create_file",
          "args": [
            "&tick_bc_dev",
            "&dev_attr_current_device"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_register",
          "args": [
            "&tick_bc_dev"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic __init int tick_broadcast_init_sysfs(void)\n{\n\tint err = device_register(&tick_bc_dev);\n\n\tif (!err)\n\t\terr = device_create_file(&tick_bc_dev, &dev_attr_current_device);\n\treturn err;\n}"
  },
  {
    "function_name": "tick_get_tick_dev",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "725-729",
    "snippet": "static struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn dev == &tick_bc_dev ? tick_get_broadcast_device() :\n\t\t&per_cpu(tick_cpu_device, dev->id);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "dev->id"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_get_broadcast_device",
          "args": [],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_broadcast_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "56-59",
          "snippet": "struct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstruct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn dev == &tick_bc_dev ? tick_get_broadcast_device() :\n\t\t&per_cpu(tick_cpu_device, dev->id);\n}"
  },
  {
    "function_name": "unbind_device_store",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "687-715",
    "snippet": "static ssize_t unbind_device_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tchar name[CS_NAME_LEN];\n\tssize_t ret = sysfs_get_uname(buf, name, count);\n\tstruct clock_event_device *ce;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ENODEV;\n\tmutex_lock(&clockevents_mutex);\n\traw_spin_lock_irq(&clockevents_lock);\n\tlist_for_each_entry(ce, &clockevent_devices, list) {\n\t\tif (!strcmp(ce->name, name)) {\n\t\t\tret = __clockevents_try_unbind(ce, dev->id);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irq(&clockevents_lock);\n\t/*\n\t * We hold clockevents_mutex, so ce can't go away\n\t */\n\tif (ret == -EAGAIN)\n\t\tret = clockevents_unbind(ce, dev->id);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret ? ret : count;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);",
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);",
      "static DEFINE_MUTEX(clockevents_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clockevents_mutex"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_unbind",
          "args": [
            "ce",
            "dev->id"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_unbind_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "428-436",
          "snippet": "int clockevents_unbind_device(struct clock_event_device *ced, int cpu)\n{\n\tint ret;\n\n\tmutex_lock(&clockevents_mutex);\n\tret = clockevents_unbind(ced, cpu);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(clockevents_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic DEFINE_MUTEX(clockevents_mutex);\n\nint clockevents_unbind_device(struct clock_event_device *ced, int cpu)\n{\n\tint ret;\n\n\tmutex_lock(&clockevents_mutex);\n\tret = clockevents_unbind(ced, cpu);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&clockevents_lock"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clockevents_try_unbind",
          "args": [
            "ce",
            "dev->id"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_try_unbind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "386-395",
          "snippet": "static int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ce->name",
            "name"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ce",
            "&clockevent_devices",
            "list"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&clockevents_lock"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clockevents_mutex"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_get_uname",
          "args": [
            "buf",
            "name",
            "count"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_get_uname",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "1288-1303",
          "snippet": "ssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t/* strings from sysfs write are not 0 terminated! */\n\tif (!cnt || cnt >= CS_NAME_LEN)\n\t\treturn -EINVAL;\n\n\t/* strip of \\n: */\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\nstatic DEFINE_MUTEX(clockevents_mutex);\n\nstatic ssize_t unbind_device_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tchar name[CS_NAME_LEN];\n\tssize_t ret = sysfs_get_uname(buf, name, count);\n\tstruct clock_event_device *ce;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -ENODEV;\n\tmutex_lock(&clockevents_mutex);\n\traw_spin_lock_irq(&clockevents_lock);\n\tlist_for_each_entry(ce, &clockevent_devices, list) {\n\t\tif (!strcmp(ce->name, name)) {\n\t\t\tret = __clockevents_try_unbind(ce, dev->id);\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irq(&clockevents_lock);\n\t/*\n\t * We hold clockevents_mutex, so ce can't go away\n\t */\n\tif (ret == -EAGAIN)\n\t\tret = clockevents_unbind(ce, dev->id);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret ? ret : count;\n}"
  },
  {
    "function_name": "current_device_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "670-683",
    "snippet": "static ssize_t current_device_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct tick_device *td;\n\tssize_t count = 0;\n\n\traw_spin_lock_irq(&clockevents_lock);\n\ttd = tick_get_tick_dev(dev);\n\tif (td && td->evtdev)\n\t\tcount = snprintf(buf, PAGE_SIZE, \"%s\\n\", td->evtdev->name);\n\traw_spin_unlock_irq(&clockevents_lock);\n\treturn count;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&clockevents_lock"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "200-203",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "PAGE_SIZE",
            "\"%s\\n\"",
            "td->evtdev->name"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_get_tick_dev",
          "args": [
            "dev"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_tick_dev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "740-743",
          "snippet": "static struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn &per_cpu(tick_cpu_device, dev->id);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic struct tick_device *tick_get_tick_dev(struct device *dev)\n{\n\treturn &per_cpu(tick_cpu_device, dev->id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&clockevents_lock"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "168-171",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nstatic ssize_t current_device_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct tick_device *td;\n\tssize_t count = 0;\n\n\traw_spin_lock_irq(&clockevents_lock);\n\ttd = tick_get_tick_dev(dev);\n\tif (td && td->evtdev)\n\t\tcount = snprintf(buf, PAGE_SIZE, \"%s\\n\", td->evtdev->name);\n\traw_spin_unlock_irq(&clockevents_lock);\n\treturn count;\n}"
  },
  {
    "function_name": "tick_cleanup_dead_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "632-658",
    "snippet": "void tick_cleanup_dead_cpu(int cpu)\n{\n\tstruct clock_event_device *dev, *tmp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\ttick_shutdown(cpu);\n\t/*\n\t * Unregister the clock event devices which were\n\t * released from the users in the notify chain.\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevents_released, list)\n\t\tlist_del(&dev->list);\n\t/*\n\t * Now check whether the CPU has left unused per cpu devices\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevent_devices, list) {\n\t\tif (cpumask_test_cpu(cpu, dev->cpumask) &&\n\t\t    cpumask_weight(dev->cpumask) == 1 &&\n\t\t    !tick_is_broadcast_device(dev)) {\n\t\t\tBUG_ON(!clockevent_state_detached(dev));\n\t\t\tlist_del(&dev->list);\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);",
      "static LIST_HEAD(clockevents_released);",
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&clockevents_lock",
            "flags"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&dev->list"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!clockevent_state_detached(dev)"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "dev"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_is_broadcast_device",
          "args": [
            "dev"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "tick_is_broadcast_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "208-211",
          "snippet": "int tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nint tick_is_broadcast_device(struct clock_event_device *dev)\n{\n\treturn (dev && tick_broadcast_device.evtdev == dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "dev->cpumask"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "dev->cpumask"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dev",
            "tmp",
            "&clockevent_devices",
            "list"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "dev",
            "tmp",
            "&clockevents_released",
            "list"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_shutdown",
          "args": [
            "cpu"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "tick_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "421-437",
          "snippet": "void tick_shutdown(unsigned int cpu)\n{\n\tstruct tick_device *td = &per_cpu(tick_cpu_device, cpu);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttd->mode = TICKDEV_MODE_PERIODIC;\n\tif (dev) {\n\t\t/*\n\t\t * Prevent that the clock events layer tries to call\n\t\t * the set mode function!\n\t\t */\n\t\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\t\tclockevents_exchange_device(dev, NULL);\n\t\tdev->event_handler = clockevents_handle_noop;\n\t\ttd->evtdev = NULL;\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_shutdown(unsigned int cpu)\n{\n\tstruct tick_device *td = &per_cpu(tick_cpu_device, cpu);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttd->mode = TICKDEV_MODE_PERIODIC;\n\tif (dev) {\n\t\t/*\n\t\t * Prevent that the clock events layer tries to call\n\t\t * the set mode function!\n\t\t */\n\t\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\t\tclockevents_exchange_device(dev, NULL);\n\t\tdev->event_handler = clockevents_handle_noop;\n\t\ttd->evtdev = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&clockevents_lock",
            "flags"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic LIST_HEAD(clockevents_released);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid tick_cleanup_dead_cpu(int cpu)\n{\n\tstruct clock_event_device *dev, *tmp;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\ttick_shutdown(cpu);\n\t/*\n\t * Unregister the clock event devices which were\n\t * released from the users in the notify chain.\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevents_released, list)\n\t\tlist_del(&dev->list);\n\t/*\n\t * Now check whether the CPU has left unused per cpu devices\n\t */\n\tlist_for_each_entry_safe(dev, tmp, &clockevent_devices, list) {\n\t\tif (cpumask_test_cpu(cpu, dev->cpumask) &&\n\t\t    cpumask_weight(dev->cpumask) == 1 &&\n\t\t    !tick_is_broadcast_device(dev)) {\n\t\t\tBUG_ON(!clockevent_state_detached(dev));\n\t\t\tlist_del(&dev->list);\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}"
  },
  {
    "function_name": "tick_offline_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "620-625",
    "snippet": "void tick_offline_cpu(unsigned int cpu)\n{\n\traw_spin_lock(&clockevents_lock);\n\ttick_broadcast_offline(cpu);\n\traw_spin_unlock(&clockevents_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&clockevents_lock"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_offline",
          "args": [
            "cpu"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_offline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "536-544",
          "snippet": "void tick_broadcast_offline(unsigned int cpu)\n{\n\traw_spin_lock(&tick_broadcast_lock);\n\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_on);\n\ttick_broadcast_oneshot_offline(cpu);\n\ttick_shutdown_broadcast();\n\traw_spin_unlock(&tick_broadcast_lock);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask",
            "static cpumask_var_t tick_broadcast_on",
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);",
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\nstatic cpumask_var_t tick_broadcast_on;\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nvoid tick_broadcast_offline(unsigned int cpu)\n{\n\traw_spin_lock(&tick_broadcast_lock);\n\tcpumask_clear_cpu(cpu, tick_broadcast_mask);\n\tcpumask_clear_cpu(cpu, tick_broadcast_on);\n\ttick_broadcast_oneshot_offline(cpu);\n\ttick_shutdown_broadcast();\n\traw_spin_unlock(&tick_broadcast_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&clockevents_lock"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid tick_offline_cpu(unsigned int cpu)\n{\n\traw_spin_lock(&clockevents_lock);\n\ttick_broadcast_offline(cpu);\n\traw_spin_unlock(&clockevents_lock);\n}"
  },
  {
    "function_name": "clockevents_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "602-609",
    "snippet": "void clockevents_resume(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list)\n\t\tif (dev->resume && !clockevent_state_detached(dev))\n\t\t\tdev->resume(dev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev->resume",
          "args": [
            "dev"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "dev"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&clockevent_devices",
            "list"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nvoid clockevents_resume(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list)\n\t\tif (dev->resume && !clockevent_state_detached(dev))\n\t\t\tdev->resume(dev);\n}"
  },
  {
    "function_name": "clockevents_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "590-597",
    "snippet": "void clockevents_suspend(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry_reverse(dev, &clockevent_devices, list)\n\t\tif (dev->suspend && !clockevent_state_detached(dev))\n\t\t\tdev->suspend(dev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev->suspend",
          "args": [
            "dev"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "dev"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "dev",
            "&clockevent_devices",
            "list"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nvoid clockevents_suspend(void)\n{\n\tstruct clock_event_device *dev;\n\n\tlist_for_each_entry_reverse(dev, &clockevent_devices, list)\n\t\tif (dev->suspend && !clockevent_state_detached(dev))\n\t\t\tdev->suspend(dev);\n}"
  },
  {
    "function_name": "clockevents_exchange_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "568-585",
    "snippet": "void clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevents_released);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_shutdown",
          "args": [
            "new"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_shutdown",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "171-175",
          "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!clockevent_state_detached(new)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "new"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&old->list",
            "&clockevents_released"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "old",
            "CLOCK_EVT_STATE_DETACHED"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "147-165",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "old->owner"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1087-1098",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevents_released);\n\nvoid clockevents_exchange_device(struct clock_event_device *old,\n\t\t\t\t struct clock_event_device *new)\n{\n\t/*\n\t * Caller releases a clock event device. We queue it into the\n\t * released list and do a notify add later.\n\t */\n\tif (old) {\n\t\tmodule_put(old->owner);\n\t\tclockevents_switch_state(old, CLOCK_EVT_STATE_DETACHED);\n\t\tlist_move(&old->list, &clockevents_released);\n\t}\n\n\tif (new) {\n\t\tBUG_ON(!clockevent_state_detached(new));\n\t\tclockevents_shutdown(new);\n\t}\n}"
  },
  {
    "function_name": "clockevents_handle_noop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "556-558",
    "snippet": "void clockevents_handle_noop(struct clock_event_device *dev)\n{\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_handle_noop(struct clock_event_device *dev)\n{\n}"
  },
  {
    "function_name": "clockevents_update_freq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "540-551",
    "snippet": "int clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = tick_broadcast_update_freq(dev, freq);\n\tif (ret == -ENODEV)\n\t\tret = __clockevents_update_freq(dev, freq);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clockevents_update_freq",
          "args": [
            "dev",
            "freq"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_update_freq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "515-526",
          "snippet": "int __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_broadcast_update_freq",
          "args": [
            "dev",
            "freq"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "tick_broadcast_update_freq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "213-223",
          "snippet": "int tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tint ret = -ENODEV;\n\n\tif (tick_is_broadcast_device(dev)) {\n\t\traw_spin_lock(&tick_broadcast_lock);\n\t\tret = __clockevents_update_freq(dev, freq);\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_RAW_SPINLOCK(tick_broadcast_lock);\n\nint tick_broadcast_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tint ret = -ENODEV;\n\n\tif (tick_is_broadcast_device(dev)) {\n\t\traw_spin_lock(&tick_broadcast_lock);\n\t\tret = __clockevents_update_freq(dev, freq);\n\t\traw_spin_unlock(&tick_broadcast_lock);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = tick_broadcast_update_freq(dev, freq);\n\tif (ret == -ENODEV)\n\t\tret = __clockevents_update_freq(dev, freq);\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "__clockevents_update_freq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "515-526",
    "snippet": "int __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clockevents_switch_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_PERIODIC"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "91-138",
          "snippet": "static int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_periodic",
          "args": [
            "dev"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_program_event",
          "args": [
            "dev",
            "dev->next_event",
            "false"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "303-337",
          "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevents_config",
          "args": [
            "dev",
            "freq"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_config",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "471-493",
          "snippet": "static void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint __clockevents_update_freq(struct clock_event_device *dev, u32 freq)\n{\n\tclockevents_config(dev, freq);\n\n\tif (clockevent_state_oneshot(dev))\n\t\treturn clockevents_program_event(dev, dev->next_event, false);\n\n\tif (clockevent_state_periodic(dev))\n\t\treturn __clockevents_switch_state(dev, CLOCK_EVT_STATE_PERIODIC);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "clockevents_config_and_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "504-512",
    "snippet": "void clockevents_config_and_register(struct clock_event_device *dev,\n\t\t\t\t     u32 freq, unsigned long min_delta,\n\t\t\t\t     unsigned long max_delta)\n{\n\tdev->min_delta_ticks = min_delta;\n\tdev->max_delta_ticks = max_delta;\n\tclockevents_config(dev, freq);\n\tclockevents_register_device(dev);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_register_device",
          "args": [
            "dev"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_register_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "443-468",
          "snippet": "void clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);",
            "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_config",
          "args": [
            "dev",
            "freq"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_config",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "471-493",
          "snippet": "static void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_config_and_register(struct clock_event_device *dev,\n\t\t\t\t     u32 freq, unsigned long min_delta,\n\t\t\t\t     unsigned long max_delta)\n{\n\tdev->min_delta_ticks = min_delta;\n\tdev->max_delta_ticks = max_delta;\n\tclockevents_config(dev, freq);\n\tclockevents_register_device(dev);\n}"
  },
  {
    "function_name": "clockevents_config",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "471-493",
    "snippet": "static void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cev_delta2ns",
          "args": [
            "dev->max_delta_ticks",
            "dev",
            "true"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "cev_delta2ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "32-76",
          "snippet": "static u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (WARN_ON(!evt->mult))\n\t\tevt->mult = 1;\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (WARN_ON(!evt->mult))\n\t\tevt->mult = 1;\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_calc_mult_shift",
          "args": [
            "dev",
            "freq",
            "sec"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "sec",
            "freq"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic void clockevents_config(struct clock_event_device *dev, u32 freq)\n{\n\tu64 sec;\n\n\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\treturn;\n\n\t/*\n\t * Calculate the maximum number of seconds we can sleep. Limit\n\t * to 10 minutes for hardware which can program more than\n\t * 32bit ticks so we still get reasonable conversion values.\n\t */\n\tsec = dev->max_delta_ticks;\n\tdo_div(sec, freq);\n\tif (!sec)\n\t\tsec = 1;\n\telse if (sec > 600 && dev->max_delta_ticks > UINT_MAX)\n\t\tsec = 600;\n\n\tclockevents_calc_mult_shift(dev, freq, sec);\n\tdev->min_delta_ns = cev_delta2ns(dev->min_delta_ticks, dev, false);\n\tdev->max_delta_ns = cev_delta2ns(dev->max_delta_ticks, dev, true);\n}"
  },
  {
    "function_name": "clockevents_register_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "443-468",
    "snippet": "void clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);",
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&clockevents_lock",
            "flags"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_notify_released",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_notify_released",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "343-353",
          "snippet": "static void clockevents_notify_released(void)\n{\n\tstruct clock_event_device *dev;\n\n\twhile (!list_empty(&clockevents_released)) {\n\t\tdev = list_entry(clockevents_released.next,\n\t\t\t\t struct clock_event_device, list);\n\t\tlist_move(&dev->list, &clockevent_devices);\n\t\ttick_check_new_device(dev);\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);",
            "static LIST_HEAD(clockevents_released);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic LIST_HEAD(clockevents_released);\n\nstatic void clockevents_notify_released(void)\n{\n\tstruct clock_event_device *dev;\n\n\twhile (!list_empty(&clockevents_released)) {\n\t\tdev = list_entry(clockevents_released.next,\n\t\t\t\t struct clock_event_device, list);\n\t\tlist_move(&dev->list, &clockevent_devices);\n\t\ttick_check_new_device(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_new_device",
          "args": [
            "dev"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_new_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "341-377",
          "snippet": "void tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\tif (!tick_check_replacement(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev, cpu);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\tif (!tick_check_replacement(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dev->list",
            "&clockevent_devices"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&clockevents_lock",
            "flags"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\"",
            "dev->name"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "smp_processor_id()"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "num_possible_cpus() > 1"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_set_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_DETACHED"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "44-48",
          "snippet": "static inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}"
  },
  {
    "function_name": "clockevents_unbind_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "428-436",
    "snippet": "int clockevents_unbind_device(struct clock_event_device *ced, int cpu)\n{\n\tint ret;\n\n\tmutex_lock(&clockevents_mutex);\n\tret = clockevents_unbind(ced, cpu);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(clockevents_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&clockevents_mutex"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_unbind",
          "args": [
            "ced",
            "cpu"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_unbind_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "428-436",
          "snippet": "int clockevents_unbind_device(struct clock_event_device *ced, int cpu)\n{\n\tint ret;\n\n\tmutex_lock(&clockevents_mutex);\n\tret = clockevents_unbind(ced, cpu);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&clockevents_mutex"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic DEFINE_MUTEX(clockevents_mutex);\n\nint clockevents_unbind_device(struct clock_event_device *ced, int cpu)\n{\n\tint ret;\n\n\tmutex_lock(&clockevents_mutex);\n\tret = clockevents_unbind(ced, cpu);\n\tmutex_unlock(&clockevents_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "clockevents_unbind",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "417-423",
    "snippet": "static int clockevents_unbind(struct clock_event_device *ced, int cpu)\n{\n\tstruct ce_unbind cu = { .ce = ced, .res = -ENODEV };\n\n\tsmp_call_function_single(cpu, __clockevents_unbind, &cu, 1);\n\treturn cu.res;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "__clockevents_unbind",
            "&cu",
            "1"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "12-25",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int clockevents_unbind(struct clock_event_device *ced, int cpu)\n{\n\tstruct ce_unbind cu = { .ce = ced, .res = -ENODEV };\n\n\tsmp_call_function_single(cpu, __clockevents_unbind, &cu, 1);\n\treturn cu.res;\n}"
  },
  {
    "function_name": "__clockevents_unbind",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "400-411",
    "snippet": "static void __clockevents_unbind(void *arg)\n{\n\tstruct ce_unbind *cu = arg;\n\tint res;\n\n\traw_spin_lock(&clockevents_lock);\n\tres = __clockevents_try_unbind(cu->ce, smp_processor_id());\n\tif (res == -EAGAIN)\n\t\tres = clockevents_replace(cu->ce);\n\tcu->res = res;\n\traw_spin_unlock(&clockevents_lock);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&clockevents_lock"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevents_replace",
          "args": [
            "cu->ce"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_replace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "358-381",
          "snippet": "static int clockevents_replace(struct clock_event_device *ced)\n{\n\tstruct clock_event_device *dev, *newdev = NULL;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list) {\n\t\tif (dev == ced || !clockevent_state_detached(dev))\n\t\t\tcontinue;\n\n\t\tif (!tick_check_replacement(newdev, dev))\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(dev->owner))\n\t\t\tcontinue;\n\n\t\tif (newdev)\n\t\t\tmodule_put(newdev->owner);\n\t\tnewdev = dev;\n\t}\n\tif (newdev) {\n\t\ttick_install_replacement(newdev);\n\t\tlist_del_init(&ced->list);\n\t}\n\treturn newdev ? 0 : -EBUSY;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nstatic int clockevents_replace(struct clock_event_device *ced)\n{\n\tstruct clock_event_device *dev, *newdev = NULL;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list) {\n\t\tif (dev == ced || !clockevent_state_detached(dev))\n\t\t\tcontinue;\n\n\t\tif (!tick_check_replacement(newdev, dev))\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(dev->owner))\n\t\t\tcontinue;\n\n\t\tif (newdev)\n\t\t\tmodule_put(newdev->owner);\n\t\tnewdev = dev;\n\t}\n\tif (newdev) {\n\t\ttick_install_replacement(newdev);\n\t\tlist_del_init(&ced->list);\n\t}\n\treturn newdev ? 0 : -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clockevents_try_unbind",
          "args": [
            "cu->ce",
            "smp_processor_id()"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_try_unbind",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "386-395",
          "snippet": "static int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&clockevents_lock"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nstatic void __clockevents_unbind(void *arg)\n{\n\tstruct ce_unbind *cu = arg;\n\tint res;\n\n\traw_spin_lock(&clockevents_lock);\n\tres = __clockevents_try_unbind(cu->ce, smp_processor_id());\n\tif (res == -EAGAIN)\n\t\tres = clockevents_replace(cu->ce);\n\tcu->res = res;\n\traw_spin_unlock(&clockevents_lock);\n}"
  },
  {
    "function_name": "__clockevents_try_unbind",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "386-395",
    "snippet": "static int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "tick_cpu_device",
            "cpu"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ced->list"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "ced"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_try_unbind(struct clock_event_device *ced, int cpu)\n{\n\t/* Fast track. Device is unused */\n\tif (clockevent_state_detached(ced)) {\n\t\tlist_del_init(&ced->list);\n\t\treturn 0;\n\t}\n\n\treturn ced == per_cpu(tick_cpu_device, cpu).evtdev ? -EAGAIN : -EBUSY;\n}"
  },
  {
    "function_name": "clockevents_replace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "358-381",
    "snippet": "static int clockevents_replace(struct clock_event_device *ced)\n{\n\tstruct clock_event_device *dev, *newdev = NULL;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list) {\n\t\tif (dev == ced || !clockevent_state_detached(dev))\n\t\t\tcontinue;\n\n\t\tif (!tick_check_replacement(newdev, dev))\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(dev->owner))\n\t\t\tcontinue;\n\n\t\tif (newdev)\n\t\t\tmodule_put(newdev->owner);\n\t\tnewdev = dev;\n\t}\n\tif (newdev) {\n\t\ttick_install_replacement(newdev);\n\t\tlist_del_init(&ced->list);\n\t}\n\treturn newdev ? 0 : -EBUSY;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ced->list"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_install_replacement",
          "args": [
            "newdev"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "tick_install_replacement",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "277-286",
          "snippet": "void tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "newdev->owner"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1087-1098",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "dev->owner"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_check_replacement",
          "args": [
            "newdev",
            "dev"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_replacement",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "328-335",
          "snippet": "bool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nbool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_detached",
          "args": [
            "dev"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "&clockevent_devices",
            "list"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\n\nstatic int clockevents_replace(struct clock_event_device *ced)\n{\n\tstruct clock_event_device *dev, *newdev = NULL;\n\n\tlist_for_each_entry(dev, &clockevent_devices, list) {\n\t\tif (dev == ced || !clockevent_state_detached(dev))\n\t\t\tcontinue;\n\n\t\tif (!tick_check_replacement(newdev, dev))\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(dev->owner))\n\t\t\tcontinue;\n\n\t\tif (newdev)\n\t\t\tmodule_put(newdev->owner);\n\t\tnewdev = dev;\n\t}\n\tif (newdev) {\n\t\ttick_install_replacement(newdev);\n\t\tlist_del_init(&ced->list);\n\t}\n\treturn newdev ? 0 : -EBUSY;\n}"
  },
  {
    "function_name": "clockevents_notify_released",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "343-353",
    "snippet": "static void clockevents_notify_released(void)\n{\n\tstruct clock_event_device *dev;\n\n\twhile (!list_empty(&clockevents_released)) {\n\t\tdev = list_entry(clockevents_released.next,\n\t\t\t\t struct clock_event_device, list);\n\t\tlist_move(&dev->list, &clockevent_devices);\n\t\ttick_check_new_device(dev);\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(clockevent_devices);",
      "static LIST_HEAD(clockevents_released);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_check_new_device",
          "args": [
            "dev"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "tick_check_new_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "341-377",
          "snippet": "void tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\tif (!tick_check_replacement(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev, cpu);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\tif (!tick_check_replacement(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t/*\n\t * Replace the eventually existing device by the new\n\t * device. If the current device is the broadcast device, do\n\t * not give it back to the clockevents layer !\n\t */\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = NULL;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t/*\n\t * Can the new device be used as a broadcast device ?\n\t */\n\ttick_install_broadcast_device(newdev, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&dev->list",
            "&clockevent_devices"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "clockevents_released.next",
            "structclock_event_device",
            "list"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&clockevents_released"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic LIST_HEAD(clockevents_released);\n\nstatic void clockevents_notify_released(void)\n{\n\tstruct clock_event_device *dev;\n\n\twhile (!list_empty(&clockevents_released)) {\n\t\tdev = list_entry(clockevents_released.next,\n\t\t\t\t struct clock_event_device, list);\n\t\tlist_move(&dev->list, &clockevent_devices);\n\t\ttick_check_new_device(dev);\n\t}\n}"
  },
  {
    "function_name": "clockevents_program_event",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "303-337",
    "snippet": "int clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_program_min_delta",
          "args": [
            "dev"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_program_min_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "272-291",
          "snippet": "static int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta = 0;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tdelta += dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -ETIME;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta = 0;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tdelta += dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -ETIME;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev->set_next_event",
          "args": [
            "(unsigned long) clc",
            "dev"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "delta",
            "(int64_t) dev->min_delta_ns"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "delta",
            "(int64_t) dev->max_delta_ns"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "776-808",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(expires, ktime_get())"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "expires",
            "ktime_get()"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev->set_next_ktime",
          "args": [
            "expires",
            "dev"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!clockevent_state_oneshot(dev)",
            "\"Current state: %d\\n\"",
            "clockevent_get_state(dev)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_get_state",
          "args": [
            "dev"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_get_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "39-42",
          "snippet": "static inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_shutdown",
          "args": [
            "dev"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "expires < 0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_program_event(struct clock_event_device *dev, ktime_t expires,\n\t\t\t      bool force)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint rc;\n\n\tif (WARN_ON_ONCE(expires < 0))\n\t\treturn -ETIME;\n\n\tdev->next_event = expires;\n\n\tif (clockevent_state_shutdown(dev))\n\t\treturn 0;\n\n\t/* We must be in ONESHOT state here */\n\tWARN_ONCE(!clockevent_state_oneshot(dev), \"Current state: %d\\n\",\n\t\t  clockevent_get_state(dev));\n\n\t/* Shortcut for clockevent devices that can deal with ktime. */\n\tif (dev->features & CLOCK_EVT_FEAT_KTIME)\n\t\treturn dev->set_next_ktime(expires, dev);\n\n\tdelta = ktime_to_ns(ktime_sub(expires, ktime_get()));\n\tif (delta <= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -ETIME;\n\n\tdelta = min(delta, (int64_t) dev->max_delta_ns);\n\tdelta = max(delta, (int64_t) dev->min_delta_ns);\n\n\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\trc = dev->set_next_event((unsigned long) clc, dev);\n\n\treturn (rc && force) ? clockevents_program_min_delta(dev) : rc;\n}"
  },
  {
    "function_name": "clockevents_program_min_delta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "272-291",
    "snippet": "static int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta = 0;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tdelta += dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -ETIME;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev->set_next_event",
          "args": [
            "(unsigned long) clc",
            "dev"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_shutdown",
          "args": [
            "dev"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "ktime_get()",
            "delta"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta = 0;\n\tint i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tdelta += dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -ETIME;\n}"
  },
  {
    "function_name": "clockevents_program_min_delta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "233-262",
    "snippet": "static int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint i;\n\n\tfor (i = 0;;) {\n\t\tdelta = dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\n\t\tif (++i > 2) {\n\t\t\t/*\n\t\t\t * We tried 3 times to program the device with the\n\t\t\t * given min_delta_ns. Try to increase the minimum\n\t\t\t * delta, if that fails as well get out of here.\n\t\t\t */\n\t\t\tif (clockevents_increase_min_delta(dev))\n\t\t\t\treturn -ETIME;\n\t\t\ti = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_increase_min_delta",
          "args": [
            "dev"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_increase_min_delta",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "202-225",
          "snippet": "static int clockevents_increase_min_delta(struct clock_event_device *dev)\n{\n\t/* Nothing to do if we already reached the limit */\n\tif (dev->min_delta_ns >= MIN_DELTA_LIMIT) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"CE: Reprogramming failure. Giving up\\n\");\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn -ETIME;\n\t}\n\n\tif (dev->min_delta_ns < 5000)\n\t\tdev->min_delta_ns = 5000;\n\telse\n\t\tdev->min_delta_ns += dev->min_delta_ns >> 1;\n\n\tif (dev->min_delta_ns > MIN_DELTA_LIMIT)\n\t\tdev->min_delta_ns = MIN_DELTA_LIMIT;\n\n\tprintk_deferred(KERN_WARNING\n\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\",\n\t\t\tdev->name ? dev->name : \"?\",\n\t\t\t(unsigned long long) dev->min_delta_ns);\n\treturn 0;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [
            "#define MIN_DELTA_LIMIT\t\t(NSEC_PER_SEC / HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\n#define MIN_DELTA_LIMIT\t\t(NSEC_PER_SEC / HZ)\n\nstatic int clockevents_increase_min_delta(struct clock_event_device *dev)\n{\n\t/* Nothing to do if we already reached the limit */\n\tif (dev->min_delta_ns >= MIN_DELTA_LIMIT) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"CE: Reprogramming failure. Giving up\\n\");\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn -ETIME;\n\t}\n\n\tif (dev->min_delta_ns < 5000)\n\t\tdev->min_delta_ns = 5000;\n\telse\n\t\tdev->min_delta_ns += dev->min_delta_ns >> 1;\n\n\tif (dev->min_delta_ns > MIN_DELTA_LIMIT)\n\t\tdev->min_delta_ns = MIN_DELTA_LIMIT;\n\n\tprintk_deferred(KERN_WARNING\n\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\",\n\t\t\tdev->name ? dev->name : \"?\",\n\t\t\t(unsigned long long) dev->min_delta_ns);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev->set_next_event",
          "args": [
            "(unsigned long) clc",
            "dev"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_shutdown",
          "args": [
            "dev"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "ktime_get()",
            "delta"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int clockevents_program_min_delta(struct clock_event_device *dev)\n{\n\tunsigned long long clc;\n\tint64_t delta;\n\tint i;\n\n\tfor (i = 0;;) {\n\t\tdelta = dev->min_delta_ns;\n\t\tdev->next_event = ktime_add_ns(ktime_get(), delta);\n\n\t\tif (clockevent_state_shutdown(dev))\n\t\t\treturn 0;\n\n\t\tdev->retries++;\n\t\tclc = ((unsigned long long) delta * dev->mult) >> dev->shift;\n\t\tif (dev->set_next_event((unsigned long) clc, dev) == 0)\n\t\t\treturn 0;\n\n\t\tif (++i > 2) {\n\t\t\t/*\n\t\t\t * We tried 3 times to program the device with the\n\t\t\t * given min_delta_ns. Try to increase the minimum\n\t\t\t * delta, if that fails as well get out of here.\n\t\t\t */\n\t\t\tif (clockevents_increase_min_delta(dev))\n\t\t\t\treturn -ETIME;\n\t\t\ti = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "clockevents_increase_min_delta",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "202-225",
    "snippet": "static int clockevents_increase_min_delta(struct clock_event_device *dev)\n{\n\t/* Nothing to do if we already reached the limit */\n\tif (dev->min_delta_ns >= MIN_DELTA_LIMIT) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"CE: Reprogramming failure. Giving up\\n\");\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn -ETIME;\n\t}\n\n\tif (dev->min_delta_ns < 5000)\n\t\tdev->min_delta_ns = 5000;\n\telse\n\t\tdev->min_delta_ns += dev->min_delta_ns >> 1;\n\n\tif (dev->min_delta_ns > MIN_DELTA_LIMIT)\n\t\tdev->min_delta_ns = MIN_DELTA_LIMIT;\n\n\tprintk_deferred(KERN_WARNING\n\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\",\n\t\t\tdev->name ? dev->name : \"?\",\n\t\t\t(unsigned long long) dev->min_delta_ns);\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [
      "#define MIN_DELTA_LIMIT\t\t(NSEC_PER_SEC / HZ)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_WARNING\n\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\"",
            "dev->name ? dev->name : \"?\"",
            "(unsigned long long) dev->min_delta_ns"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "_printk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3285-3295",
          "snippet": "int _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\n#define MIN_DELTA_LIMIT\t\t(NSEC_PER_SEC / HZ)\n\nstatic int clockevents_increase_min_delta(struct clock_event_device *dev)\n{\n\t/* Nothing to do if we already reached the limit */\n\tif (dev->min_delta_ns >= MIN_DELTA_LIMIT) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"CE: Reprogramming failure. Giving up\\n\");\n\t\tdev->next_event = KTIME_MAX;\n\t\treturn -ETIME;\n\t}\n\n\tif (dev->min_delta_ns < 5000)\n\t\tdev->min_delta_ns = 5000;\n\telse\n\t\tdev->min_delta_ns += dev->min_delta_ns >> 1;\n\n\tif (dev->min_delta_ns > MIN_DELTA_LIMIT)\n\t\tdev->min_delta_ns = MIN_DELTA_LIMIT;\n\n\tprintk_deferred(KERN_WARNING\n\t\t\t\"CE: %s increased min_delta_ns to %llu nsec\\n\",\n\t\t\tdev->name ? dev->name : \"?\",\n\t\t\t(unsigned long long) dev->min_delta_ns);\n\treturn 0;\n}"
  },
  {
    "function_name": "clockevents_tick_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "181-189",
    "snippet": "int clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev->tick_resume",
          "args": [
            "dev"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nint clockevents_tick_resume(struct clock_event_device *dev)\n{\n\tint ret = 0;\n\n\tif (dev->tick_resume)\n\t\tret = dev->tick_resume(dev);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "clockevents_shutdown",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "171-175",
    "snippet": "void clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_switch_state",
          "args": [
            "dev",
            "CLOCK_EVT_STATE_SHUTDOWN"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "147-165",
          "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_shutdown(struct clock_event_device *dev)\n{\n\tclockevents_switch_state(dev, CLOCK_EVT_STATE_SHUTDOWN);\n\tdev->next_event = KTIME_MAX;\n}"
  },
  {
    "function_name": "clockevents_switch_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "147-165",
    "snippet": "void clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dev->mult"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_set_state",
          "args": [
            "dev",
            "state"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "44-48",
          "snippet": "static inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline void clockevent_set_state(struct clock_event_device *dev,\n\t\t\t\t\tenum clock_event_state state)\n{\n\tdev->state_use_accessors = state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clockevents_switch_state",
          "args": [
            "dev",
            "state"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "__clockevents_switch_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "91-138",
          "snippet": "static int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_get_state",
          "args": [
            "dev"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_get_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "39-42",
          "snippet": "static inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nvoid clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t      enum clock_event_state state)\n{\n\tif (clockevent_get_state(dev) != state) {\n\t\tif (__clockevents_switch_state(dev, state))\n\t\t\treturn;\n\n\t\tclockevent_set_state(dev, state);\n\n\t\t/*\n\t\t * A nsec2cyc multiplicator of 0 is invalid and we'd crash\n\t\t * on it, so fix it up and emit a warning:\n\t\t */\n\t\tif (clockevent_state_oneshot(dev)) {\n\t\t\tif (WARN_ON(!dev->mult))\n\t\t\t\tdev->mult = 1;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__clockevents_switch_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "91-138",
    "snippet": "static int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev->set_state_oneshot_stopped",
          "args": [
            "dev"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!clockevent_state_oneshot(dev)",
            "\"Current state: %d\\n\"",
            "clockevent_get_state(dev)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_get_state",
          "args": [
            "dev"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_get_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "39-42",
          "snippet": "static inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev->set_state_oneshot",
          "args": [
            "dev"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev->set_state_periodic",
          "args": [
            "dev"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev->set_state_shutdown",
          "args": [
            "dev"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic int __clockevents_switch_state(struct clock_event_device *dev,\n\t\t\t\t      enum clock_event_state state)\n{\n\tif (dev->features & CLOCK_EVT_FEAT_DUMMY)\n\t\treturn 0;\n\n\t/* Transition with new state-specific callbacks */\n\tswitch (state) {\n\tcase CLOCK_EVT_STATE_DETACHED:\n\t\t/* The clockevent device is getting replaced. Shut it down. */\n\n\tcase CLOCK_EVT_STATE_SHUTDOWN:\n\t\tif (dev->set_state_shutdown)\n\t\t\treturn dev->set_state_shutdown(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_PERIODIC:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_PERIODIC))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_periodic)\n\t\t\treturn dev->set_state_periodic(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT:\n\t\t/* Core internal bug */\n\t\tif (!(dev->features & CLOCK_EVT_FEAT_ONESHOT))\n\t\t\treturn -ENOSYS;\n\t\tif (dev->set_state_oneshot)\n\t\t\treturn dev->set_state_oneshot(dev);\n\t\treturn 0;\n\n\tcase CLOCK_EVT_STATE_ONESHOT_STOPPED:\n\t\t/* Core internal bug */\n\t\tif (WARN_ONCE(!clockevent_state_oneshot(dev),\n\t\t\t      \"Current state: %d\\n\",\n\t\t\t      clockevent_get_state(dev)))\n\t\t\treturn -EINVAL;\n\n\t\tif (dev->set_state_oneshot_stopped)\n\t\t\treturn dev->set_state_oneshot_stopped(dev);\n\t\telse\n\t\t\treturn -ENOSYS;\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}"
  },
  {
    "function_name": "clockevent_delta2ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "85-88",
    "snippet": "u64 clockevent_delta2ns(unsigned long latch, struct clock_event_device *evt)\n{\n\treturn cev_delta2ns(latch, evt, false);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cev_delta2ns",
          "args": [
            "latch",
            "evt",
            "false"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "cev_delta2ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
          "lines": "32-76",
          "snippet": "static u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (WARN_ON(!evt->mult))\n\t\tevt->mult = 1;\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (WARN_ON(!evt->mult))\n\t\tevt->mult = 1;\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nu64 clockevent_delta2ns(unsigned long latch, struct clock_event_device *evt)\n{\n\treturn cev_delta2ns(latch, evt, false);\n}"
  },
  {
    "function_name": "cev_delta2ns",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clockevents.c",
    "lines": "32-76",
    "snippet": "static u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (WARN_ON(!evt->mult))\n\t\tevt->mult = 1;\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/device.h>",
      "#include <linux/smp.h>",
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/clockchips.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "clc",
            "evt->mult"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!evt->mult"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic u64 cev_delta2ns(unsigned long latch, struct clock_event_device *evt,\n\t\t\tbool ismax)\n{\n\tu64 clc = (u64) latch << evt->shift;\n\tu64 rnd;\n\n\tif (WARN_ON(!evt->mult))\n\t\tevt->mult = 1;\n\trnd = (u64) evt->mult - 1;\n\n\t/*\n\t * Upper bound sanity check. If the backwards conversion is\n\t * not equal latch, we know that the above shift overflowed.\n\t */\n\tif ((clc >> evt->shift) != (u64)latch)\n\t\tclc = ~0ULL;\n\n\t/*\n\t * Scaled math oddities:\n\t *\n\t * For mult <= (1 << shift) we can safely add mult - 1 to\n\t * prevent integer rounding loss. So the backwards conversion\n\t * from nsec to device ticks will be correct.\n\t *\n\t * For mult > (1 << shift), i.e. device frequency is > 1GHz we\n\t * need to be careful. Adding mult - 1 will result in a value\n\t * which when converted back to device ticks can be larger\n\t * than latch by up to (mult - 1) >> shift. For the min_delta\n\t * calculation we still want to apply this in order to stay\n\t * above the minimum device ticks limit. For the upper limit\n\t * we would end up with a latch value larger than the upper\n\t * limit of the device, so we omit the add to stay below the\n\t * device upper boundary.\n\t *\n\t * Also omit the add if it would overflow the u64 boundary.\n\t */\n\tif ((~0ULL - clc > rnd) &&\n\t    (!ismax || evt->mult <= (1ULL << evt->shift)))\n\t\tclc += rnd;\n\n\tdo_div(clc, evt->mult);\n\n\t/* Deltas less than 1usec are pointless noise */\n\treturn clc > 1000 ? clc : 1000;\n}"
  }
]