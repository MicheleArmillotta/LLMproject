[
  {
    "function_name": "autogroup_path",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.h",
    "lines": "55-58",
    "snippet": "static inline int autogroup_path(struct task_group *tg, char *buf, int buflen)\n{\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline int autogroup_path(struct task_group *tg, char *buf, int buflen)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "autogroup_task_group",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.h",
    "lines": "49-53",
    "snippet": "static inline struct task_group *\nautogroup_task_group(struct task_struct *p, struct task_group *tg)\n{\n\treturn tg;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline struct task_group *\nautogroup_task_group(struct task_struct *p, struct task_group *tg)\n{\n\treturn tg;\n}"
  },
  {
    "function_name": "task_group_is_autogroup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.h",
    "lines": "44-47",
    "snippet": "static inline bool task_group_is_autogroup(struct task_group *tg)\n{\n\treturn 0;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline bool task_group_is_autogroup(struct task_group *tg)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "autogroup_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.h",
    "lines": "43-43",
    "snippet": "static inline void autogroup_free(struct task_group *tg) { }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void autogroup_free(struct task_group *tg) { }"
  },
  {
    "function_name": "autogroup_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.h",
    "lines": "42-42",
    "snippet": "static inline void autogroup_init(struct task_struct *init_task) {  }",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline void autogroup_init(struct task_struct *init_task) {  }"
  },
  {
    "function_name": "autogroup_task_group",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.h",
    "lines": "27-36",
    "snippet": "static inline struct task_group *\nautogroup_task_group(struct task_struct *p, struct task_group *tg)\n{\n\tint enabled = READ_ONCE(sysctl_sched_autogroup_enabled);\n\n\tif (enabled && task_wants_autogroup(p, tg))\n\t\treturn p->signal->autogroup->tg;\n\n\treturn tg;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_wants_autogroup",
          "args": [
            "p",
            "tg"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "task_wants_autogroup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "107-123",
          "snippet": "bool task_wants_autogroup(struct task_struct *p, struct task_group *tg)\n{\n\tif (tg != &root_task_group)\n\t\treturn false;\n\t/*\n\t * If we race with autogroup_move_group() the caller can use the old\n\t * value of signal->autogroup but in this case sched_move_task() will\n\t * be called again before autogroup_kref_put().\n\t *\n\t * However, there is no way sched_autogroup_exit_task() could tell us\n\t * to avoid autogroup->tg, so we abuse PF_EXITING flag for this case.\n\t */\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nbool task_wants_autogroup(struct task_struct *p, struct task_group *tg)\n{\n\tif (tg != &root_task_group)\n\t\treturn false;\n\t/*\n\t * If we race with autogroup_move_group() the caller can use the old\n\t * value of signal->autogroup but in this case sched_move_task() will\n\t * be called again before autogroup_kref_put().\n\t *\n\t * However, there is no way sched_autogroup_exit_task() could tell us\n\t * to avoid autogroup->tg, so we abuse PF_EXITING flag for this case.\n\t */\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sysctl_sched_autogroup_enabled"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static inline struct task_group *\nautogroup_task_group(struct task_struct *p, struct task_group *tg)\n{\n\tint enabled = READ_ONCE(sysctl_sched_autogroup_enabled);\n\n\tif (enabled && task_wants_autogroup(p, tg))\n\t\treturn p->signal->autogroup->tg;\n\n\treturn tg;\n}"
  },
  {
    "function_name": "task_group_is_autogroup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.h",
    "lines": "20-23",
    "snippet": "static inline bool task_group_is_autogroup(struct task_group *tg)\n{\n\treturn !!tg->autogroup;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "static inline bool task_group_is_autogroup(struct task_group *tg)\n{\n\treturn !!tg->autogroup;\n}"
  }
]