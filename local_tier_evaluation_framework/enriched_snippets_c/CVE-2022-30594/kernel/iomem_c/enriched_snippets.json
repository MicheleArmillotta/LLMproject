[
  {
    "function_name": "devm_memunmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
    "lines": "162-166",
    "snippet": "void devm_memunmap(struct device *dev, void *addr)\n{\n\tWARN_ON(devres_release(dev, devm_memremap_release,\n\t\t\t\tdevm_memremap_match, addr));\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/io.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "devres_release(dev, devm_memremap_release,\n\t\t\t\tdevm_memremap_match, addr)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_release",
          "args": [
            "dev",
            "devm_memremap_release",
            "devm_memremap_match",
            "addr"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nvoid devm_memunmap(struct device *dev, void *addr)\n{\n\tWARN_ON(devres_release(dev, devm_memremap_release,\n\t\t\t\tdevm_memremap_match, addr));\n}"
  },
  {
    "function_name": "devm_memremap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
    "lines": "139-159",
    "snippet": "void *devm_memremap(struct device *dev, resource_size_t offset,\n\t\tsize_t size, unsigned long flags)\n{\n\tvoid **ptr, *addr;\n\n\tptr = devres_alloc_node(devm_memremap_release, sizeof(*ptr), GFP_KERNEL,\n\t\t\tdev_to_node(dev));\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\taddr = memremap(offset, size, flags);\n\tif (addr) {\n\t\t*ptr = addr;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\treturn addr;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/io.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENXIO"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_free",
          "args": [
            "ptr"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_add",
          "args": [
            "dev",
            "ptr"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memremap",
          "args": [
            "offset",
            "size",
            "flags"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "devm_memremap_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
          "lines": "134-137",
          "snippet": "static int devm_memremap_match(struct device *dev, void *res, void *match_data)\n{\n\treturn *(void **)res == match_data;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/io.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nstatic int devm_memremap_match(struct device *dev, void *res, void *match_data)\n{\n\treturn *(void **)res == match_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "devres_alloc_node",
          "args": [
            "devm_memremap_release",
            "sizeof(*ptr)",
            "GFP_KERNEL",
            "dev_to_node(dev)"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "dev"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nvoid *devm_memremap(struct device *dev, resource_size_t offset,\n\t\tsize_t size, unsigned long flags)\n{\n\tvoid **ptr, *addr;\n\n\tptr = devres_alloc_node(devm_memremap_release, sizeof(*ptr), GFP_KERNEL,\n\t\t\tdev_to_node(dev));\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\taddr = memremap(offset, size, flags);\n\tif (addr) {\n\t\t*ptr = addr;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t\treturn ERR_PTR(-ENXIO);\n\t}\n\n\treturn addr;\n}"
  },
  {
    "function_name": "devm_memremap_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
    "lines": "134-137",
    "snippet": "static int devm_memremap_match(struct device *dev, void *res, void *match_data)\n{\n\treturn *(void **)res == match_data;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/io.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nstatic int devm_memremap_match(struct device *dev, void *res, void *match_data)\n{\n\treturn *(void **)res == match_data;\n}"
  },
  {
    "function_name": "devm_memremap_release",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
    "lines": "129-132",
    "snippet": "static void devm_memremap_release(struct device *dev, void *res)\n{\n\tmemunmap(*(void **)res);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/io.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memunmap",
          "args": [
            "*(void **)res"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "memunmap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
          "lines": "122-126",
          "snippet": "void memunmap(void *addr)\n{\n\tif (is_ioremap_addr(addr))\n\t\tiounmap((void __iomem *) addr);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/io.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nvoid memunmap(void *addr)\n{\n\tif (is_ioremap_addr(addr))\n\t\tiounmap((void __iomem *) addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nstatic void devm_memremap_release(struct device *dev, void *res)\n{\n\tmemunmap(*(void **)res);\n}"
  },
  {
    "function_name": "memunmap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
    "lines": "122-126",
    "snippet": "void memunmap(void *addr)\n{\n\tif (is_ioremap_addr(addr))\n\t\tiounmap((void __iomem *) addr);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/io.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iounmap",
          "args": [
            "(void __iomem *) addr"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_ioremap_addr",
          "args": [
            "addr"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nvoid memunmap(void *addr)\n{\n\tif (is_ioremap_addr(addr))\n\t\tiounmap((void __iomem *) addr);\n}"
  },
  {
    "function_name": "memremap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
    "lines": "71-119",
    "snippet": "void *memremap(resource_size_t offset, size_t size, unsigned long flags)\n{\n\tint is_ram = region_intersects(offset, size,\n\t\t\t\t       IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);\n\tvoid *addr = NULL;\n\n\tif (!flags)\n\t\treturn NULL;\n\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"memremap attempted on mixed range %pa size: %#lx\\n\",\n\t\t\t\t&offset, (unsigned long) size);\n\t\treturn NULL;\n\t}\n\n\t/* Try all mapping types requested until one returns non-NULL */\n\tif (flags & MEMREMAP_WB) {\n\t\t/*\n\t\t * MEMREMAP_WB is special in that it can be satisfied\n\t\t * from the direct map.  Some archs depend on the\n\t\t * capability of memremap() to autodetect cases where\n\t\t * the requested range is potentially in System RAM.\n\t\t */\n\t\tif (is_ram == REGION_INTERSECTS)\n\t\t\taddr = try_ram_remap(offset, size, flags);\n\t\tif (!addr)\n\t\t\taddr = arch_memremap_wb(offset, size);\n\t}\n\n\t/*\n\t * If we don't have a mapping yet and other request flags are\n\t * present then we will be attempting to establish a new virtual\n\t * address mapping.  Enforce that this mapping is not aliasing\n\t * System RAM.\n\t */\n\tif (!addr && is_ram == REGION_INTERSECTS && flags != MEMREMAP_WB) {\n\t\tWARN_ONCE(1, \"memremap attempted on ram %pa size: %#lx\\n\",\n\t\t\t\t&offset, (unsigned long) size);\n\t\treturn NULL;\n\t}\n\n\tif (!addr && (flags & MEMREMAP_WT))\n\t\taddr = ioremap_wt(offset, size);\n\n\tif (!addr && (flags & MEMREMAP_WC))\n\t\taddr = ioremap_wc(offset, size);\n\n\treturn addr;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/io.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioremap_wc",
          "args": [
            "offset",
            "size"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioremap_wt",
          "args": [
            "offset",
            "size"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"memremap attempted on ram %pa size: %#lx\\n\"",
            "&offset",
            "(unsigned long) size"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_memremap_wb",
          "args": [
            "offset",
            "size"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "arch_memremap_wb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
          "lines": "16-19",
          "snippet": "static void *arch_memremap_wb(resource_size_t offset, unsigned long size)\n{\n\treturn (__force void *)ioremap_cache(offset, size);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/io.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nstatic void *arch_memremap_wb(resource_size_t offset, unsigned long size)\n{\n\treturn (__force void *)ioremap_cache(offset, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_ram_remap",
          "args": [
            "offset",
            "size",
            "flags"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "try_ram_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
          "lines": "30-41",
          "snippet": "static void *try_ram_remap(resource_size_t offset, size_t size,\n\t\t\t   unsigned long flags)\n{\n\tunsigned long pfn = PHYS_PFN(offset);\n\n\t/* In the simple case just return the existing linear address */\n\tif (pfn_valid(pfn) && !PageHighMem(pfn_to_page(pfn)) &&\n\t    arch_memremap_can_ram_remap(offset, size, flags))\n\t\treturn __va(offset);\n\n\treturn NULL; /* fallback to arch_memremap_wb */\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/io.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nstatic void *try_ram_remap(resource_size_t offset, size_t size,\n\t\t\t   unsigned long flags)\n{\n\tunsigned long pfn = PHYS_PFN(offset);\n\n\t/* In the simple case just return the existing linear address */\n\tif (pfn_valid(pfn) && !PageHighMem(pfn_to_page(pfn)) &&\n\t    arch_memremap_can_ram_remap(offset, size, flags))\n\t\treturn __va(offset);\n\n\treturn NULL; /* fallback to arch_memremap_wb */\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"memremap attempted on mixed range %pa size: %#lx\\n\"",
            "&offset",
            "(unsigned long) size"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "region_intersects",
          "args": [
            "offset",
            "size",
            "IORESOURCE_SYSTEM_RAM",
            "IORES_DESC_NONE"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "region_intersects",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/resource.c",
          "lines": "565-575",
          "snippet": "int region_intersects(resource_size_t start, size_t size, unsigned long flags,\n\t\t      unsigned long desc)\n{\n\tint ret;\n\n\tread_lock(&resource_lock);\n\tret = __region_intersects(start, size, flags, desc);\n\tread_unlock(&resource_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <uapi/linux/magic.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/pseudo_fs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(resource_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <uapi/linux/magic.h>\n#include <linux/resource_ext.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/pseudo_fs.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic DEFINE_RWLOCK(resource_lock);\n\nint region_intersects(resource_size_t start, size_t size, unsigned long flags,\n\t\t      unsigned long desc)\n{\n\tint ret;\n\n\tread_lock(&resource_lock);\n\tret = __region_intersects(start, size, flags, desc);\n\tread_unlock(&resource_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nvoid *memremap(resource_size_t offset, size_t size, unsigned long flags)\n{\n\tint is_ram = region_intersects(offset, size,\n\t\t\t\t       IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE);\n\tvoid *addr = NULL;\n\n\tif (!flags)\n\t\treturn NULL;\n\n\tif (is_ram == REGION_MIXED) {\n\t\tWARN_ONCE(1, \"memremap attempted on mixed range %pa size: %#lx\\n\",\n\t\t\t\t&offset, (unsigned long) size);\n\t\treturn NULL;\n\t}\n\n\t/* Try all mapping types requested until one returns non-NULL */\n\tif (flags & MEMREMAP_WB) {\n\t\t/*\n\t\t * MEMREMAP_WB is special in that it can be satisfied\n\t\t * from the direct map.  Some archs depend on the\n\t\t * capability of memremap() to autodetect cases where\n\t\t * the requested range is potentially in System RAM.\n\t\t */\n\t\tif (is_ram == REGION_INTERSECTS)\n\t\t\taddr = try_ram_remap(offset, size, flags);\n\t\tif (!addr)\n\t\t\taddr = arch_memremap_wb(offset, size);\n\t}\n\n\t/*\n\t * If we don't have a mapping yet and other request flags are\n\t * present then we will be attempting to establish a new virtual\n\t * address mapping.  Enforce that this mapping is not aliasing\n\t * System RAM.\n\t */\n\tif (!addr && is_ram == REGION_INTERSECTS && flags != MEMREMAP_WB) {\n\t\tWARN_ONCE(1, \"memremap attempted on ram %pa size: %#lx\\n\",\n\t\t\t\t&offset, (unsigned long) size);\n\t\treturn NULL;\n\t}\n\n\tif (!addr && (flags & MEMREMAP_WT))\n\t\taddr = ioremap_wt(offset, size);\n\n\tif (!addr && (flags & MEMREMAP_WC))\n\t\taddr = ioremap_wc(offset, size);\n\n\treturn addr;\n}"
  },
  {
    "function_name": "try_ram_remap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
    "lines": "30-41",
    "snippet": "static void *try_ram_remap(resource_size_t offset, size_t size,\n\t\t\t   unsigned long flags)\n{\n\tunsigned long pfn = PHYS_PFN(offset);\n\n\t/* In the simple case just return the existing linear address */\n\tif (pfn_valid(pfn) && !PageHighMem(pfn_to_page(pfn)) &&\n\t    arch_memremap_can_ram_remap(offset, size, flags))\n\t\treturn __va(offset);\n\n\treturn NULL; /* fallback to arch_memremap_wb */\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/io.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "offset"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "__var_waitqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/wait_bit.c",
          "lines": "153-156",
          "snippet": "wait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define WAIT_TABLE_BITS 8"
          ],
          "globals_used": [
            "static wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define WAIT_TABLE_BITS 8\n\nstatic wait_queue_head_t bit_wait_table[WAIT_TABLE_SIZE];\n\nwait_queue_head_t *__var_waitqueue(void *p)\n{\n\treturn bit_wait_table + hash_ptr(p, WAIT_TABLE_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_memremap_can_ram_remap",
          "args": [
            "offset",
            "size",
            "flags"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "arch_memremap_can_ram_remap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
          "lines": "23-27",
          "snippet": "static bool arch_memremap_can_ram_remap(resource_size_t offset, size_t size,\n\t\t\t\t\tunsigned long flags)\n{\n\treturn true;\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/io.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nstatic bool arch_memremap_can_ram_remap(resource_size_t offset, size_t size,\n\t\t\t\t\tunsigned long flags)\n{\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageHighMem",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PHYS_PFN",
          "args": [
            "offset"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nstatic void *try_ram_remap(resource_size_t offset, size_t size,\n\t\t\t   unsigned long flags)\n{\n\tunsigned long pfn = PHYS_PFN(offset);\n\n\t/* In the simple case just return the existing linear address */\n\tif (pfn_valid(pfn) && !PageHighMem(pfn_to_page(pfn)) &&\n\t    arch_memremap_can_ram_remap(offset, size, flags))\n\t\treturn __va(offset);\n\n\treturn NULL; /* fallback to arch_memremap_wb */\n}"
  },
  {
    "function_name": "arch_memremap_can_ram_remap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
    "lines": "23-27",
    "snippet": "static bool arch_memremap_can_ram_remap(resource_size_t offset, size_t size,\n\t\t\t\t\tunsigned long flags)\n{\n\treturn true;\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/io.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nstatic bool arch_memremap_can_ram_remap(resource_size_t offset, size_t size,\n\t\t\t\t\tunsigned long flags)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "arch_memremap_wb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
    "lines": "16-19",
    "snippet": "static void *arch_memremap_wb(resource_size_t offset, unsigned long size)\n{\n\treturn (__force void *)ioremap_cache(offset, size);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/io.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioremap_cache",
          "args": [
            "offset",
            "size"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "ioremap_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
          "lines": "9-12",
          "snippet": "__iomem *ioremap_cache(resource_size_t offset, unsigned long size)\n{\n\treturn ioremap(offset, size);\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/io.h>",
            "#include <linux/types.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\n__iomem *ioremap_cache(resource_size_t offset, unsigned long size)\n{\n\treturn ioremap(offset, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\nstatic void *arch_memremap_wb(resource_size_t offset, unsigned long size)\n{\n\treturn (__force void *)ioremap_cache(offset, size);\n}"
  },
  {
    "function_name": "ioremap_cache",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
    "lines": "9-12",
    "snippet": "__iomem *ioremap_cache(resource_size_t offset, unsigned long size)\n{\n\treturn ioremap(offset, size);\n}",
    "includes": [
      "#include <linux/mm.h>",
      "#include <linux/io.h>",
      "#include <linux/types.h>",
      "#include <linux/device.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioremap",
          "args": [
            "offset",
            "size"
          ],
          "line": 11
        },
        "resolved": true,
        "details": {
          "function_name": "ioremap_cache",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/iomem.c",
          "lines": "9-12",
          "snippet": "__iomem *ioremap_cache(resource_size_t offset, unsigned long size)\n{\n\treturn ioremap(offset, size);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/types.h>\n#include <linux/device.h>\n\n__iomem *ioremap_cache(resource_size_t offset, unsigned long size)\n{\n\treturn ioremap(offset, size);\n}"
  }
]