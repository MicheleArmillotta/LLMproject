[
  {
    "function_name": "gdbstub_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "1124-1156",
    "snippet": "void gdbstub_exit(int status)\n{\n\tunsigned char checksum, ch, buffer[3];\n\tint loop;\n\n\tif (!kgdb_connected)\n\t\treturn;\n\tkgdb_connected = 0;\n\n\tif (!dbg_io_ops || dbg_kdb_mode)\n\t\treturn;\n\n\tbuffer[0] = 'W';\n\tbuffer[1] = hex_asc_hi(status);\n\tbuffer[2] = hex_asc_lo(status);\n\n\tdbg_io_ops->write_char('$');\n\tchecksum = 0;\n\n\tfor (loop = 0; loop < 3; loop++) {\n\t\tch = buffer[loop];\n\t\tchecksum += ch;\n\t\tdbg_io_ops->write_char(ch);\n\t}\n\n\tdbg_io_ops->write_char('#');\n\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\n\t/* make sure the output is flushed, lest the bootloader clobber it */\n\tif (dbg_io_ops->flush)\n\t\tdbg_io_ops->flush();\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_io_ops->flush",
          "args": [],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "hex_asc_lo(checksum)"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_lo",
          "args": [
            "checksum"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "hex_asc_hi(checksum)"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_hi",
          "args": [
            "checksum"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "'#'"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "ch"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "'$'"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_lo",
          "args": [
            "status"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_hi",
          "args": [
            "status"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid gdbstub_exit(int status)\n{\n\tunsigned char checksum, ch, buffer[3];\n\tint loop;\n\n\tif (!kgdb_connected)\n\t\treturn;\n\tkgdb_connected = 0;\n\n\tif (!dbg_io_ops || dbg_kdb_mode)\n\t\treturn;\n\n\tbuffer[0] = 'W';\n\tbuffer[1] = hex_asc_hi(status);\n\tbuffer[2] = hex_asc_lo(status);\n\n\tdbg_io_ops->write_char('$');\n\tchecksum = 0;\n\n\tfor (loop = 0; loop < 3; loop++) {\n\t\tch = buffer[loop];\n\t\tchecksum += ch;\n\t\tdbg_io_ops->write_char(ch);\n\t}\n\n\tdbg_io_ops->write_char('#');\n\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\n\t/* make sure the output is flushed, lest the bootloader clobber it */\n\tif (dbg_io_ops->flush)\n\t\tdbg_io_ops->flush();\n}"
  },
  {
    "function_name": "gdbstub_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "1092-1118",
    "snippet": "int gdbstub_state(struct kgdb_state *ks, char *cmd)\n{\n\tint error;\n\n\tswitch (cmd[0]) {\n\tcase 'e':\n\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\t   ks->signo,\n\t\t\t\t\t\t   ks->err_code,\n\t\t\t\t\t\t   remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer,\n\t\t\t\t\t\t   ks->linux_regs);\n\t\treturn error;\n\tcase 's':\n\tcase 'c':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\treturn 0;\n\tcase '$':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\tgdbstub_use_prev_in_buf = strlen(remcom_in_buffer);\n\t\tgdbstub_prev_in_buf_pos = 0;\n\t\treturn 0;\n\t}\n\tdbg_io_ops->write_char('+');\n\tput_packet(remcom_out_buffer);\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];",
      "static int\t\t\tgdbstub_use_prev_in_buf;",
      "static int\t\t\tgdbstub_prev_in_buf_pos;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_packet",
          "args": [
            "remcom_out_buffer"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "put_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "142-191",
          "snippet": "static void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "'+'"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "remcom_in_buffer"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "remcom_in_buffer",
            "cmd",
            "sizeof(remcom_in_buffer)"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "remcom_in_buffer",
            "cmd",
            "sizeof(remcom_in_buffer)"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_arch_handle_exception",
          "args": [
            "ks->ex_vector",
            "ks->signo",
            "ks->err_code",
            "remcom_in_buffer",
            "remcom_out_buffer",
            "ks->linux_regs"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\nstatic int\t\t\tgdbstub_use_prev_in_buf;\nstatic int\t\t\tgdbstub_prev_in_buf_pos;\n\nint gdbstub_state(struct kgdb_state *ks, char *cmd)\n{\n\tint error;\n\n\tswitch (cmd[0]) {\n\tcase 'e':\n\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\t   ks->signo,\n\t\t\t\t\t\t   ks->err_code,\n\t\t\t\t\t\t   remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer,\n\t\t\t\t\t\t   ks->linux_regs);\n\t\treturn error;\n\tcase 's':\n\tcase 'c':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\treturn 0;\n\tcase '$':\n\t\tstrscpy(remcom_in_buffer, cmd, sizeof(remcom_in_buffer));\n\t\tgdbstub_use_prev_in_buf = strlen(remcom_in_buffer);\n\t\tgdbstub_prev_in_buf_pos = 0;\n\t\treturn 0;\n\t}\n\tdbg_io_ops->write_char('+');\n\tput_packet(remcom_out_buffer);\n\treturn 0;\n}"
  },
  {
    "function_name": "gdb_serial_stub",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "954-1090",
    "snippet": "int gdb_serial_stub(struct kgdb_state *ks)\n{\n\tint error = 0;\n\tint tmp;\n\n\t/* Initialize comm buffer and globals. */\n\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\tkgdb_usethread = kgdb_info[ks->cpu].task;\n\tks->kgdb_usethreadid = shadow_pid(kgdb_info[ks->cpu].task->pid);\n\tks->pass_exception = 0;\n\n\tif (kgdb_connected) {\n\t\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\t\tchar *ptr;\n\n\t\t/* Reply to host that an exception has occurred */\n\t\tptr = remcom_out_buffer;\n\t\t*ptr++ = 'T';\n\t\tptr = hex_byte_pack(ptr, ks->signo);\n\t\tptr += strlen(strcpy(ptr, \"thread:\"));\n\t\tint_to_threadref(thref, shadow_pid(current->pid));\n\t\tptr = pack_threadid(ptr, thref);\n\t\t*ptr++ = ';';\n\t\tput_packet(remcom_out_buffer);\n\t}\n\n\twhile (1) {\n\t\terror = 0;\n\n\t\t/* Clear the out buffer. */\n\t\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\n\t\tget_packet(remcom_in_buffer);\n\n\t\tswitch (remcom_in_buffer[0]) {\n\t\tcase '?': /* gdbserial status */\n\t\t\tgdb_cmd_status(ks);\n\t\t\tbreak;\n\t\tcase 'g': /* return the value of the CPU registers */\n\t\t\tgdb_cmd_getregs(ks);\n\t\t\tbreak;\n\t\tcase 'G': /* set the value of the CPU registers - return OK */\n\t\t\tgdb_cmd_setregs(ks);\n\t\t\tbreak;\n\t\tcase 'm': /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memread(ks);\n\t\t\tbreak;\n\t\tcase 'M': /* MAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memwrite(ks);\n\t\t\tbreak;\n#if DBG_MAX_REG_NUM > 0\n\t\tcase 'p': /* pXX Return gdb register XX (in hex) */\n\t\t\tgdb_cmd_reg_get(ks);\n\t\t\tbreak;\n\t\tcase 'P': /* PXX=aaaa Set gdb register XX to aaaa (in hex) */\n\t\t\tgdb_cmd_reg_set(ks);\n\t\t\tbreak;\n#endif /* DBG_MAX_REG_NUM > 0 */\n\t\tcase 'X': /* XAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_binwrite(ks);\n\t\t\tbreak;\n\t\t\t/* kill or detach. KGDB should treat this like a\n\t\t\t * continue.\n\t\t\t */\n\t\tcase 'D': /* Debugger detach */\n\t\tcase 'k': /* Debugger detach via kill */\n\t\t\tgdb_cmd_detachkill(ks);\n\t\t\tgoto default_handle;\n\t\tcase 'R': /* Reboot */\n\t\t\tif (gdb_cmd_reboot(ks))\n\t\t\t\tgoto default_handle;\n\t\t\tbreak;\n\t\tcase 'q': /* query command */\n\t\t\tgdb_cmd_query(ks);\n\t\t\tbreak;\n\t\tcase 'H': /* task related */\n\t\t\tgdb_cmd_task(ks);\n\t\t\tbreak;\n\t\tcase 'T': /* Query thread status */\n\t\t\tgdb_cmd_thread(ks);\n\t\t\tbreak;\n\t\tcase 'z': /* Break point remove */\n\t\tcase 'Z': /* Break point set */\n\t\t\tgdb_cmd_break(ks);\n\t\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\t\tcase '3': /* Escape into back into kdb */\n\t\t\tif (remcom_in_buffer[1] == '\\0') {\n\t\t\t\tgdb_cmd_detachkill(ks);\n\t\t\t\treturn DBG_PASS_EVENT;\n\t\t\t}\n\t\t\tfallthrough;\n#endif\n\t\tcase 'C': /* Exception passing */\n\t\t\ttmp = gdb_cmd_exception_pass(ks);\n\t\t\tif (tmp > 0)\n\t\t\t\tgoto default_handle;\n\t\t\tif (tmp == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\t/* on tmp < 0 */\n\t\tcase 'c': /* Continue packet */\n\t\tcase 's': /* Single step packet */\n\t\t\tif (kgdb_contthread && kgdb_contthread != current) {\n\t\t\t\t/* Can't switch threads in kgdb */\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t/* to default processing */\n\t\tdefault:\ndefault_handle:\n\t\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\tks->signo,\n\t\t\t\t\t\tks->err_code,\n\t\t\t\t\t\tremcom_in_buffer,\n\t\t\t\t\t\tremcom_out_buffer,\n\t\t\t\t\t\tks->linux_regs);\n\t\t\t/*\n\t\t\t * Leave cmd processing on error, detach,\n\t\t\t * kill, continue, or single step.\n\t\t\t */\n\t\t\tif (error >= 0 || remcom_in_buffer[0] == 'D' ||\n\t\t\t    remcom_in_buffer[0] == 'k') {\n\t\t\t\terror = 0;\n\t\t\t\tgoto kgdb_exit;\n\t\t\t}\n\n\t\t}\n\n\t\t/* reply to the request */\n\t\tput_packet(remcom_out_buffer);\n\t}\n\nkgdb_exit:\n\tif (ks->pass_exception)\n\t\terror = 1;\n\treturn error;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BUF_THREAD_ID_SIZE\t8"
    ],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_packet",
          "args": [
            "remcom_out_buffer"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "put_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "142-191",
          "snippet": "static void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_arch_handle_exception",
          "args": [
            "ks->ex_vector",
            "ks->signo",
            "ks->err_code",
            "remcom_in_buffer",
            "remcom_out_buffer",
            "ks->linux_regs"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "-EINVAL"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_exception_pass",
          "args": [
            "ks"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_exception_pass",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "922-949",
          "snippet": "static int gdb_cmd_exception_pass(struct kgdb_state *ks)\n{\n\t/* C09 == pass exception\n\t * C15 == detach kgdb, pass exception\n\t */\n\tif (remcom_in_buffer[1] == '0' && remcom_in_buffer[2] == '9') {\n\n\t\tks->pass_exception = 1;\n\t\tremcom_in_buffer[0] = 'c';\n\n\t} else if (remcom_in_buffer[1] == '1' && remcom_in_buffer[2] == '5') {\n\n\t\tks->pass_exception = 1;\n\t\tremcom_in_buffer[0] = 'D';\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t\treturn 1;\n\n\t} else {\n\t\tgdbstub_msg_write(\"KGDB only knows signal 9 (pass)\"\n\t\t\t\" and 15 (pass and disconnect)\\n\"\n\t\t\t\"Executing a continue without signal passing\\n\", 0);\n\t\tremcom_in_buffer[0] = 'c';\n\t}\n\n\t/* Indicate fall through */\n\treturn -1;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\n\nstatic int gdb_cmd_exception_pass(struct kgdb_state *ks)\n{\n\t/* C09 == pass exception\n\t * C15 == detach kgdb, pass exception\n\t */\n\tif (remcom_in_buffer[1] == '0' && remcom_in_buffer[2] == '9') {\n\n\t\tks->pass_exception = 1;\n\t\tremcom_in_buffer[0] = 'c';\n\n\t} else if (remcom_in_buffer[1] == '1' && remcom_in_buffer[2] == '5') {\n\n\t\tks->pass_exception = 1;\n\t\tremcom_in_buffer[0] = 'D';\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t\treturn 1;\n\n\t} else {\n\t\tgdbstub_msg_write(\"KGDB only knows signal 9 (pass)\"\n\t\t\t\" and 15 (pass and disconnect)\\n\"\n\t\t\t\"Executing a continue without signal passing\\n\", 0);\n\t\tremcom_in_buffer[0] = 'c';\n\t}\n\n\t/* Indicate fall through */\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_detachkill",
          "args": [
            "ks"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_detachkill",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "649-671",
          "snippet": "static void gdb_cmd_detachkill(struct kgdb_state *ks)\n{\n\tint error;\n\n\t/* The detach case */\n\tif (remcom_in_buffer[0] == 'D') {\n\t\terror = dbg_remove_all_break();\n\t\tif (error < 0) {\n\t\t\terror_packet(remcom_out_buffer, error);\n\t\t} else {\n\t\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\t\tkgdb_connected = 0;\n\t\t}\n\t\tput_packet(remcom_out_buffer);\n\t} else {\n\t\t/*\n\t\t * Assume the kill case, with no exit code checking,\n\t\t * trying to force detach the debugger:\n\t\t */\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_detachkill(struct kgdb_state *ks)\n{\n\tint error;\n\n\t/* The detach case */\n\tif (remcom_in_buffer[0] == 'D') {\n\t\terror = dbg_remove_all_break();\n\t\tif (error < 0) {\n\t\t\terror_packet(remcom_out_buffer, error);\n\t\t} else {\n\t\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\t\tkgdb_connected = 0;\n\t\t}\n\t\tput_packet(remcom_out_buffer);\n\t} else {\n\t\t/*\n\t\t * Assume the kill case, with no exit code checking,\n\t\t * trying to force detach the debugger:\n\t\t */\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_break",
          "args": [
            "ks"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_break",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "860-919",
          "snippet": "static void gdb_cmd_break(struct kgdb_state *ks)\n{\n\t/*\n\t * Since GDB-5.3, it's been drafted that '0' is a software\n\t * breakpoint, '1' is a hardware breakpoint, so let's do that.\n\t */\n\tchar *bpt_type = &remcom_in_buffer[1];\n\tchar *ptr = &remcom_in_buffer[2];\n\tunsigned long addr;\n\tunsigned long length;\n\tint error = 0;\n\n\tif (arch_kgdb_ops.set_hw_breakpoint && *bpt_type >= '1') {\n\t\t/* Unsupported */\n\t\tif (*bpt_type > '4')\n\t\t\treturn;\n\t} else {\n\t\tif (*bpt_type != '0' && *bpt_type != '1')\n\t\t\t/* Unsupported. */\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Test if this is a hardware breakpoint, and\n\t * if we support it:\n\t */\n\tif (*bpt_type == '1' && !(arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT))\n\t\t/* Unsupported. */\n\t\treturn;\n\n\tif (*(ptr++) != ',') {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tif (!kgdb_hex2long(&ptr, &addr)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tif (*(ptr++) != ',' ||\n\t\t!kgdb_hex2long(&ptr, &length)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\n\tif (remcom_in_buffer[0] == 'Z' && *bpt_type == '0')\n\t\terror = dbg_set_sw_break(addr);\n\telse if (remcom_in_buffer[0] == 'z' && *bpt_type == '0')\n\t\terror = dbg_remove_sw_break(addr);\n\telse if (remcom_in_buffer[0] == 'Z')\n\t\terror = arch_kgdb_ops.set_hw_breakpoint(addr,\n\t\t\t(int)length, *bpt_type - '0');\n\telse if (remcom_in_buffer[0] == 'z')\n\t\terror = arch_kgdb_ops.remove_hw_breakpoint(addr,\n\t\t\t(int) length, *bpt_type - '0');\n\n\tif (error == 0)\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\telse\n\t\terror_packet(remcom_out_buffer, error);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_break(struct kgdb_state *ks)\n{\n\t/*\n\t * Since GDB-5.3, it's been drafted that '0' is a software\n\t * breakpoint, '1' is a hardware breakpoint, so let's do that.\n\t */\n\tchar *bpt_type = &remcom_in_buffer[1];\n\tchar *ptr = &remcom_in_buffer[2];\n\tunsigned long addr;\n\tunsigned long length;\n\tint error = 0;\n\n\tif (arch_kgdb_ops.set_hw_breakpoint && *bpt_type >= '1') {\n\t\t/* Unsupported */\n\t\tif (*bpt_type > '4')\n\t\t\treturn;\n\t} else {\n\t\tif (*bpt_type != '0' && *bpt_type != '1')\n\t\t\t/* Unsupported. */\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Test if this is a hardware breakpoint, and\n\t * if we support it:\n\t */\n\tif (*bpt_type == '1' && !(arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT))\n\t\t/* Unsupported. */\n\t\treturn;\n\n\tif (*(ptr++) != ',') {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tif (!kgdb_hex2long(&ptr, &addr)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tif (*(ptr++) != ',' ||\n\t\t!kgdb_hex2long(&ptr, &length)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\n\tif (remcom_in_buffer[0] == 'Z' && *bpt_type == '0')\n\t\terror = dbg_set_sw_break(addr);\n\telse if (remcom_in_buffer[0] == 'z' && *bpt_type == '0')\n\t\terror = dbg_remove_sw_break(addr);\n\telse if (remcom_in_buffer[0] == 'Z')\n\t\terror = arch_kgdb_ops.set_hw_breakpoint(addr,\n\t\t\t(int)length, *bpt_type - '0');\n\telse if (remcom_in_buffer[0] == 'z')\n\t\terror = arch_kgdb_ops.remove_hw_breakpoint(addr,\n\t\t\t(int) length, *bpt_type - '0');\n\n\tif (error == 0)\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\telse\n\t\terror_packet(remcom_out_buffer, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_thread",
          "args": [
            "ks"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "846-857",
          "snippet": "static void gdb_cmd_thread(struct kgdb_state *ks)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tstruct task_struct *thread;\n\n\tkgdb_hex2long(&ptr, &ks->threadid);\n\tthread = getthread(ks->linux_regs, ks->threadid);\n\tif (thread)\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\telse\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_thread(struct kgdb_state *ks)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tstruct task_struct *thread;\n\n\tkgdb_hex2long(&ptr, &ks->threadid);\n\tthread = getthread(ks->linux_regs, ks->threadid);\n\tif (thread)\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\telse\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_task",
          "args": [
            "ks"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "809-843",
          "snippet": "static void gdb_cmd_task(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tchar *ptr;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 'g':\n\t\tptr = &remcom_in_buffer[2];\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tthread = getthread(ks->linux_regs, ks->threadid);\n\t\tif (!thread && ks->threadid > 0) {\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tkgdb_usethread = thread;\n\t\tks->kgdb_usethreadid = ks->threadid;\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tbreak;\n\tcase 'c':\n\t\tptr = &remcom_in_buffer[2];\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tif (!ks->threadid) {\n\t\t\tkgdb_contthread = NULL;\n\t\t} else {\n\t\t\tthread = getthread(ks->linux_regs, ks->threadid);\n\t\t\tif (!thread && ks->threadid > 0) {\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkgdb_contthread = thread;\n\t\t}\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_task(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tchar *ptr;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 'g':\n\t\tptr = &remcom_in_buffer[2];\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tthread = getthread(ks->linux_regs, ks->threadid);\n\t\tif (!thread && ks->threadid > 0) {\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tkgdb_usethread = thread;\n\t\tks->kgdb_usethreadid = ks->threadid;\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tbreak;\n\tcase 'c':\n\t\tptr = &remcom_in_buffer[2];\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tif (!ks->threadid) {\n\t\t\tkgdb_contthread = NULL;\n\t\t} else {\n\t\t\tthread = getthread(ks->linux_regs, ks->threadid);\n\t\t\tif (!thread && ks->threadid > 0) {\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkgdb_contthread = thread;\n\t\t}\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_query",
          "args": [
            "ks"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_query",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "695-806",
          "snippet": "static void gdb_cmd_query(struct kgdb_state *ks)\n{\n\tstruct task_struct *g;\n\tstruct task_struct *p;\n\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\tchar *ptr;\n\tint i;\n\tint cpu;\n\tint finished = 0;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 's':\n\tcase 'f':\n\t\tif (memcmp(remcom_in_buffer + 2, \"ThreadInfo\", 10))\n\t\t\tbreak;\n\n\t\ti = 0;\n\t\tremcom_out_buffer[0] = 'm';\n\t\tptr = remcom_out_buffer + 1;\n\t\tif (remcom_in_buffer[1] == 'f') {\n\t\t\t/* Each cpu is a shadow thread */\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tks->thr_query = 0;\n\t\t\t\tint_to_threadref(thref, -cpu - 2);\n\t\t\t\tptr = pack_threadid(ptr, thref);\n\t\t\t\t*(ptr++) = ',';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (i >= ks->thr_query && !finished) {\n\t\t\t\tint_to_threadref(thref, p->pid);\n\t\t\t\tptr = pack_threadid(ptr, thref);\n\t\t\t\t*(ptr++) = ',';\n\t\t\t\tks->thr_query++;\n\t\t\t\tif (ks->thr_query % KGDB_MAX_THREAD_QUERY == 0)\n\t\t\t\t\tfinished = 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t*(--ptr) = '\\0';\n\t\tbreak;\n\n\tcase 'C':\n\t\t/* Current thread id */\n\t\tstrcpy(remcom_out_buffer, \"QC\");\n\t\tks->threadid = shadow_pid(current->pid);\n\t\tint_to_threadref(thref, ks->threadid);\n\t\tpack_threadid(remcom_out_buffer + 2, thref);\n\t\tbreak;\n\tcase 'T':\n\t\tif (memcmp(remcom_in_buffer + 1, \"ThreadExtraInfo,\", 16))\n\t\t\tbreak;\n\n\t\tks->threadid = 0;\n\t\tptr = remcom_in_buffer + 17;\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tif (!getthread(ks->linux_regs, ks->threadid)) {\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tif ((int)ks->threadid > 0) {\n\t\t\tkgdb_mem2hex(getthread(ks->linux_regs,\n\t\t\t\t\tks->threadid)->comm,\n\t\t\t\t\tremcom_out_buffer, 16);\n\t\t} else {\n\t\t\tstatic char tmpstr[23 + BUF_THREAD_ID_SIZE];\n\n\t\t\tsprintf(tmpstr, \"shadowCPU%d\",\n\t\t\t\t\t(int)(-ks->threadid - 2));\n\t\t\tkgdb_mem2hex(tmpstr, remcom_out_buffer, strlen(tmpstr));\n\t\t}\n\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\tcase 'R':\n\t\tif (strncmp(remcom_in_buffer, \"qRcmd,\", 6) == 0) {\n\t\t\tint len = strlen(remcom_in_buffer + 6);\n\n\t\t\tif ((len % 2) != 0) {\n\t\t\t\tstrcpy(remcom_out_buffer, \"E01\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkgdb_hex2mem(remcom_in_buffer + 6,\n\t\t\t\t     remcom_out_buffer, len);\n\t\t\tlen = len / 2;\n\t\t\tremcom_out_buffer[len++] = 0;\n\n\t\t\tkdb_common_init_state(ks);\n\t\t\tkdb_parse(remcom_out_buffer);\n\t\t\tkdb_common_deinit_state();\n\n\t\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\t}\n\t\tbreak;\n#endif\n#ifdef CONFIG_HAVE_ARCH_KGDB_QXFER_PKT\n\tcase 'S':\n\t\tif (!strncmp(remcom_in_buffer, \"qSupported:\", 11))\n\t\t\tstrcpy(remcom_out_buffer, kgdb_arch_gdb_stub_feature);\n\t\tbreak;\n\tcase 'X':\n\t\tif (!strncmp(remcom_in_buffer, \"qXfer:\", 6))\n\t\t\tkgdb_arch_handle_qxfer_pkt(remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BUF_THREAD_ID_SIZE\t8",
            "#define KGDB_MAX_THREAD_QUERY 17"
          ],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BUF_THREAD_ID_SIZE\t8\n#define KGDB_MAX_THREAD_QUERY 17\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_query(struct kgdb_state *ks)\n{\n\tstruct task_struct *g;\n\tstruct task_struct *p;\n\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\tchar *ptr;\n\tint i;\n\tint cpu;\n\tint finished = 0;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 's':\n\tcase 'f':\n\t\tif (memcmp(remcom_in_buffer + 2, \"ThreadInfo\", 10))\n\t\t\tbreak;\n\n\t\ti = 0;\n\t\tremcom_out_buffer[0] = 'm';\n\t\tptr = remcom_out_buffer + 1;\n\t\tif (remcom_in_buffer[1] == 'f') {\n\t\t\t/* Each cpu is a shadow thread */\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tks->thr_query = 0;\n\t\t\t\tint_to_threadref(thref, -cpu - 2);\n\t\t\t\tptr = pack_threadid(ptr, thref);\n\t\t\t\t*(ptr++) = ',';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (i >= ks->thr_query && !finished) {\n\t\t\t\tint_to_threadref(thref, p->pid);\n\t\t\t\tptr = pack_threadid(ptr, thref);\n\t\t\t\t*(ptr++) = ',';\n\t\t\t\tks->thr_query++;\n\t\t\t\tif (ks->thr_query % KGDB_MAX_THREAD_QUERY == 0)\n\t\t\t\t\tfinished = 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t*(--ptr) = '\\0';\n\t\tbreak;\n\n\tcase 'C':\n\t\t/* Current thread id */\n\t\tstrcpy(remcom_out_buffer, \"QC\");\n\t\tks->threadid = shadow_pid(current->pid);\n\t\tint_to_threadref(thref, ks->threadid);\n\t\tpack_threadid(remcom_out_buffer + 2, thref);\n\t\tbreak;\n\tcase 'T':\n\t\tif (memcmp(remcom_in_buffer + 1, \"ThreadExtraInfo,\", 16))\n\t\t\tbreak;\n\n\t\tks->threadid = 0;\n\t\tptr = remcom_in_buffer + 17;\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tif (!getthread(ks->linux_regs, ks->threadid)) {\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tif ((int)ks->threadid > 0) {\n\t\t\tkgdb_mem2hex(getthread(ks->linux_regs,\n\t\t\t\t\tks->threadid)->comm,\n\t\t\t\t\tremcom_out_buffer, 16);\n\t\t} else {\n\t\t\tstatic char tmpstr[23 + BUF_THREAD_ID_SIZE];\n\n\t\t\tsprintf(tmpstr, \"shadowCPU%d\",\n\t\t\t\t\t(int)(-ks->threadid - 2));\n\t\t\tkgdb_mem2hex(tmpstr, remcom_out_buffer, strlen(tmpstr));\n\t\t}\n\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\tcase 'R':\n\t\tif (strncmp(remcom_in_buffer, \"qRcmd,\", 6) == 0) {\n\t\t\tint len = strlen(remcom_in_buffer + 6);\n\n\t\t\tif ((len % 2) != 0) {\n\t\t\t\tstrcpy(remcom_out_buffer, \"E01\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkgdb_hex2mem(remcom_in_buffer + 6,\n\t\t\t\t     remcom_out_buffer, len);\n\t\t\tlen = len / 2;\n\t\t\tremcom_out_buffer[len++] = 0;\n\n\t\t\tkdb_common_init_state(ks);\n\t\t\tkdb_parse(remcom_out_buffer);\n\t\t\tkdb_common_deinit_state();\n\n\t\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\t}\n\t\tbreak;\n#endif\n#ifdef CONFIG_HAVE_ARCH_KGDB_QXFER_PKT\n\tcase 'S':\n\t\tif (!strncmp(remcom_in_buffer, \"qSupported:\", 11))\n\t\t\tstrcpy(remcom_out_buffer, kgdb_arch_gdb_stub_feature);\n\t\tbreak;\n\tcase 'X':\n\t\tif (!strncmp(remcom_in_buffer, \"qXfer:\", 6))\n\t\t\tkgdb_arch_handle_qxfer_pkt(remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_reboot",
          "args": [
            "ks"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_reboot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "674-692",
          "snippet": "static int gdb_cmd_reboot(struct kgdb_state *ks)\n{\n\t/* For now, only honor R0 */\n\tif (strcmp(remcom_in_buffer, \"R0\") == 0) {\n\t\tprintk(KERN_CRIT \"Executing emergency reboot\\n\");\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tput_packet(remcom_out_buffer);\n\n\t\t/*\n\t\t * Execution should not return from\n\t\t * machine_emergency_restart()\n\t\t */\n\t\tmachine_emergency_restart();\n\t\tkgdb_connected = 0;\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic int gdb_cmd_reboot(struct kgdb_state *ks)\n{\n\t/* For now, only honor R0 */\n\tif (strcmp(remcom_in_buffer, \"R0\") == 0) {\n\t\tprintk(KERN_CRIT \"Executing emergency reboot\\n\");\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tput_packet(remcom_out_buffer);\n\n\t\t/*\n\t\t * Execution should not return from\n\t\t * machine_emergency_restart()\n\t\t */\n\t\tmachine_emergency_restart();\n\t\tkgdb_connected = 0;\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_binwrite",
          "args": [
            "ks"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_binwrite",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "638-646",
          "snippet": "static void gdb_cmd_binwrite(struct kgdb_state *ks)\n{\n\tint err = write_mem_msg(1);\n\n\tif (err)\n\t\terror_packet(remcom_out_buffer, err);\n\telse\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_binwrite(struct kgdb_state *ks)\n{\n\tint err = write_mem_msg(1);\n\n\tif (err)\n\t\terror_packet(remcom_out_buffer, err);\n\telse\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_reg_set",
          "args": [
            "ks"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_reg_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "611-634",
          "snippet": "static void gdb_cmd_reg_set(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\tint i = 0;\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (*ptr++ != '=' ||\n\t    !(!kgdb_usethread || kgdb_usethread == current) ||\n\t    !dbg_get_reg(regnum, gdb_regs, ks->linux_regs)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tmemset(gdb_regs, 0, sizeof(gdb_regs));\n\twhile (i < sizeof(gdb_regs) * 2)\n\t\tif (hex_to_bin(ptr[i]) >= 0)\n\t\t\ti++;\n\t\telse\n\t\t\tbreak;\n\ti = i / 2;\n\tkgdb_hex2mem(ptr, (char *)gdb_regs, i);\n\tdbg_set_reg(regnum, gdb_regs, ks->linux_regs);\n\tstrcpy(remcom_out_buffer, \"OK\");\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];",
            "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic void gdb_cmd_reg_set(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\tint i = 0;\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (*ptr++ != '=' ||\n\t    !(!kgdb_usethread || kgdb_usethread == current) ||\n\t    !dbg_get_reg(regnum, gdb_regs, ks->linux_regs)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tmemset(gdb_regs, 0, sizeof(gdb_regs));\n\twhile (i < sizeof(gdb_regs) * 2)\n\t\tif (hex_to_bin(ptr[i]) >= 0)\n\t\t\ti++;\n\t\telse\n\t\t\tbreak;\n\ti = i / 2;\n\tkgdb_hex2mem(ptr, (char *)gdb_regs, i);\n\tdbg_set_reg(regnum, gdb_regs, ks->linux_regs);\n\tstrcpy(remcom_out_buffer, \"OK\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_reg_get",
          "args": [
            "ks"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_reg_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "596-608",
          "snippet": "static void gdb_cmd_reg_get(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (regnum >= DBG_MAX_REG_NUM) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tgdb_get_regs_helper(ks);\n\tgdb_hex_reg_helper(regnum, remcom_out_buffer);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_reg_get(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (regnum >= DBG_MAX_REG_NUM) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tgdb_get_regs_helper(ks);\n\tgdb_hex_reg_helper(regnum, remcom_out_buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_memwrite",
          "args": [
            "ks"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_memwrite",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "573-581",
          "snippet": "static void gdb_cmd_memwrite(struct kgdb_state *ks)\n{\n\tint err = write_mem_msg(0);\n\n\tif (err)\n\t\terror_packet(remcom_out_buffer, err);\n\telse\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_memwrite(struct kgdb_state *ks)\n{\n\tint err = write_mem_msg(0);\n\n\tif (err)\n\t\terror_packet(remcom_out_buffer, err);\n\telse\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_memread",
          "args": [
            "ks"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_memread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "555-570",
          "snippet": "static void gdb_cmd_memread(struct kgdb_state *ks)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long length;\n\tunsigned long addr;\n\tchar *err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *ptr++ == ',' &&\n\t\t\t\t\tkgdb_hex2long(&ptr, &length) > 0) {\n\t\terr = kgdb_mem2hex((char *)addr, remcom_out_buffer, length);\n\t\tif (!err)\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t} else {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_memread(struct kgdb_state *ks)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long length;\n\tunsigned long addr;\n\tchar *err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *ptr++ == ',' &&\n\t\t\t\t\tkgdb_hex2long(&ptr, &length) > 0) {\n\t\terr = kgdb_mem2hex((char *)addr, remcom_out_buffer, length);\n\t\tif (!err)\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t} else {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_setregs",
          "args": [
            "ks"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_setregs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "542-552",
          "snippet": "static void gdb_cmd_setregs(struct kgdb_state *ks)\n{\n\tkgdb_hex2mem(&remcom_in_buffer[1], (char *)gdb_regs, NUMREGBYTES);\n\n\tif (kgdb_usethread && kgdb_usethread != current) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t} else {\n\t\tgdb_regs_to_pt_regs(gdb_regs, ks->linux_regs);\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];",
            "static char\t\t\tremcom_out_buffer[BUFMAX];",
            "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic void gdb_cmd_setregs(struct kgdb_state *ks)\n{\n\tkgdb_hex2mem(&remcom_in_buffer[1], (char *)gdb_regs, NUMREGBYTES);\n\n\tif (kgdb_usethread && kgdb_usethread != current) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t} else {\n\t\tgdb_regs_to_pt_regs(gdb_regs, ks->linux_regs);\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_getregs",
          "args": [
            "ks"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_getregs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "535-539",
          "snippet": "static void gdb_cmd_getregs(struct kgdb_state *ks)\n{\n\tgdb_get_regs_helper(ks);\n\tkgdb_mem2hex((char *)gdb_regs, remcom_out_buffer, NUMREGBYTES);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_out_buffer[BUFMAX];",
            "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic void gdb_cmd_getregs(struct kgdb_state *ks)\n{\n\tgdb_get_regs_helper(ks);\n\tkgdb_mem2hex((char *)gdb_regs, remcom_out_buffer, NUMREGBYTES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_cmd_status",
          "args": [
            "ks"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_cmd_status",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "477-489",
          "snippet": "static void gdb_cmd_status(struct kgdb_state *ks)\n{\n\t/*\n\t * We know that this packet is only sent\n\t * during initial connect.  So to be safe,\n\t * we clear out our breakpoints now in case\n\t * GDB is reconnecting.\n\t */\n\tdbg_remove_all_break();\n\n\tremcom_out_buffer[0] = 'S';\n\thex_byte_pack(&remcom_out_buffer[1], ks->signo);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_out_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_status(struct kgdb_state *ks)\n{\n\t/*\n\t * We know that this packet is only sent\n\t * during initial connect.  So to be safe,\n\t * we clear out our breakpoints now in case\n\t * GDB is reconnecting.\n\t */\n\tdbg_remove_all_break();\n\n\tremcom_out_buffer[0] = 'S';\n\thex_byte_pack(&remcom_out_buffer[1], ks->signo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_packet",
          "args": [
            "remcom_in_buffer"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "get_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "88-136",
          "snippet": "static void get_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tunsigned char xmitcsum;\n\tint count;\n\tchar ch;\n\n\tdo {\n\t\t/*\n\t\t * Spin and wait around for the start character, ignore all\n\t\t * other characters:\n\t\t */\n\t\twhile ((ch = (gdbstub_read_wait())) != '$')\n\t\t\t/* nothing */;\n\n\t\tkgdb_connected = 1;\n\t\tchecksum = 0;\n\t\txmitcsum = -1;\n\n\t\tcount = 0;\n\n\t\t/*\n\t\t * now, read until a # or end of buffer is found:\n\t\t */\n\t\twhile (count < (BUFMAX - 1)) {\n\t\t\tch = gdbstub_read_wait();\n\t\t\tif (ch == '#')\n\t\t\t\tbreak;\n\t\t\tchecksum = checksum + ch;\n\t\t\tbuffer[count] = ch;\n\t\t\tcount = count + 1;\n\t\t}\n\n\t\tif (ch == '#') {\n\t\t\txmitcsum = hex_to_bin(gdbstub_read_wait()) << 4;\n\t\t\txmitcsum += hex_to_bin(gdbstub_read_wait());\n\n\t\t\tif (checksum != xmitcsum)\n\t\t\t\t/* failed checksum */\n\t\t\t\tdbg_io_ops->write_char('-');\n\t\t\telse\n\t\t\t\t/* successful transfer */\n\t\t\t\tdbg_io_ops->write_char('+');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t}\n\t\tbuffer[count] = 0;\n\t} while (checksum != xmitcsum);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void get_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tunsigned char xmitcsum;\n\tint count;\n\tchar ch;\n\n\tdo {\n\t\t/*\n\t\t * Spin and wait around for the start character, ignore all\n\t\t * other characters:\n\t\t */\n\t\twhile ((ch = (gdbstub_read_wait())) != '$')\n\t\t\t/* nothing */;\n\n\t\tkgdb_connected = 1;\n\t\tchecksum = 0;\n\t\txmitcsum = -1;\n\n\t\tcount = 0;\n\n\t\t/*\n\t\t * now, read until a # or end of buffer is found:\n\t\t */\n\t\twhile (count < (BUFMAX - 1)) {\n\t\t\tch = gdbstub_read_wait();\n\t\t\tif (ch == '#')\n\t\t\t\tbreak;\n\t\t\tchecksum = checksum + ch;\n\t\t\tbuffer[count] = ch;\n\t\t\tcount = count + 1;\n\t\t}\n\n\t\tif (ch == '#') {\n\t\t\txmitcsum = hex_to_bin(gdbstub_read_wait()) << 4;\n\t\t\txmitcsum += hex_to_bin(gdbstub_read_wait());\n\n\t\t\tif (checksum != xmitcsum)\n\t\t\t\t/* failed checksum */\n\t\t\t\tdbg_io_ops->write_char('-');\n\t\t\telse\n\t\t\t\t/* successful transfer */\n\t\t\t\tdbg_io_ops->write_char('+');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t}\n\t\tbuffer[count] = 0;\n\t} while (checksum != xmitcsum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "remcom_out_buffer",
            "0",
            "sizeof(remcom_out_buffer)"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pack_threadid",
          "args": [
            "ptr",
            "thref"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "pack_threadid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "405-423",
          "snippet": "static char *pack_threadid(char *pkt, unsigned char *id)\n{\n\tunsigned char *limit;\n\tint lzero = 1;\n\n\tlimit = id + (BUF_THREAD_ID_SIZE / 2);\n\twhile (id < limit) {\n\t\tif (!lzero || *id != 0) {\n\t\t\tpkt = hex_byte_pack(pkt, *id);\n\t\t\tlzero = 0;\n\t\t}\n\t\tid++;\n\t}\n\n\tif (lzero)\n\t\tpkt = hex_byte_pack(pkt, 0);\n\n\treturn pkt;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BUF_THREAD_ID_SIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BUF_THREAD_ID_SIZE\t8\n\nstatic char *pack_threadid(char *pkt, unsigned char *id)\n{\n\tunsigned char *limit;\n\tint lzero = 1;\n\n\tlimit = id + (BUF_THREAD_ID_SIZE / 2);\n\twhile (id < limit) {\n\t\tif (!lzero || *id != 0) {\n\t\t\tpkt = hex_byte_pack(pkt, *id);\n\t\t\tlzero = 0;\n\t\t}\n\t\tid++;\n\t}\n\n\tif (lzero)\n\t\tpkt = hex_byte_pack(pkt, 0);\n\n\treturn pkt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "int_to_threadref",
          "args": [
            "thref",
            "shadow_pid(current->pid)"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "int_to_threadref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "425-428",
          "snippet": "static void int_to_threadref(unsigned char *id, int value)\n{\n\tput_unaligned_be32(value, id);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void int_to_threadref(unsigned char *id, int value)\n{\n\tput_unaligned_be32(value, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shadow_pid",
          "args": [
            "current->pid"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "462-468",
          "snippet": "static inline int shadow_pid(int realpid)\n{\n\tif (realpid)\n\t\treturn realpid;\n\n\treturn -raw_smp_processor_id() - 2;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline int shadow_pid(int realpid)\n{\n\tif (realpid)\n\t\treturn realpid;\n\n\treturn -raw_smp_processor_id() - 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "strcpy(ptr, \"thread:\")"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "ptr",
            "\"thread:\""
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "ptr",
            "ks->signo"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "remcom_out_buffer",
            "0",
            "sizeof(remcom_out_buffer)"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BUF_THREAD_ID_SIZE\t8\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nint gdb_serial_stub(struct kgdb_state *ks)\n{\n\tint error = 0;\n\tint tmp;\n\n\t/* Initialize comm buffer and globals. */\n\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\tkgdb_usethread = kgdb_info[ks->cpu].task;\n\tks->kgdb_usethreadid = shadow_pid(kgdb_info[ks->cpu].task->pid);\n\tks->pass_exception = 0;\n\n\tif (kgdb_connected) {\n\t\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\t\tchar *ptr;\n\n\t\t/* Reply to host that an exception has occurred */\n\t\tptr = remcom_out_buffer;\n\t\t*ptr++ = 'T';\n\t\tptr = hex_byte_pack(ptr, ks->signo);\n\t\tptr += strlen(strcpy(ptr, \"thread:\"));\n\t\tint_to_threadref(thref, shadow_pid(current->pid));\n\t\tptr = pack_threadid(ptr, thref);\n\t\t*ptr++ = ';';\n\t\tput_packet(remcom_out_buffer);\n\t}\n\n\twhile (1) {\n\t\terror = 0;\n\n\t\t/* Clear the out buffer. */\n\t\tmemset(remcom_out_buffer, 0, sizeof(remcom_out_buffer));\n\n\t\tget_packet(remcom_in_buffer);\n\n\t\tswitch (remcom_in_buffer[0]) {\n\t\tcase '?': /* gdbserial status */\n\t\t\tgdb_cmd_status(ks);\n\t\t\tbreak;\n\t\tcase 'g': /* return the value of the CPU registers */\n\t\t\tgdb_cmd_getregs(ks);\n\t\t\tbreak;\n\t\tcase 'G': /* set the value of the CPU registers - return OK */\n\t\t\tgdb_cmd_setregs(ks);\n\t\t\tbreak;\n\t\tcase 'm': /* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memread(ks);\n\t\t\tbreak;\n\t\tcase 'M': /* MAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_memwrite(ks);\n\t\t\tbreak;\n#if DBG_MAX_REG_NUM > 0\n\t\tcase 'p': /* pXX Return gdb register XX (in hex) */\n\t\t\tgdb_cmd_reg_get(ks);\n\t\t\tbreak;\n\t\tcase 'P': /* PXX=aaaa Set gdb register XX to aaaa (in hex) */\n\t\t\tgdb_cmd_reg_set(ks);\n\t\t\tbreak;\n#endif /* DBG_MAX_REG_NUM > 0 */\n\t\tcase 'X': /* XAA..AA,LLLL: Write LLLL bytes at address AA..AA */\n\t\t\tgdb_cmd_binwrite(ks);\n\t\t\tbreak;\n\t\t\t/* kill or detach. KGDB should treat this like a\n\t\t\t * continue.\n\t\t\t */\n\t\tcase 'D': /* Debugger detach */\n\t\tcase 'k': /* Debugger detach via kill */\n\t\t\tgdb_cmd_detachkill(ks);\n\t\t\tgoto default_handle;\n\t\tcase 'R': /* Reboot */\n\t\t\tif (gdb_cmd_reboot(ks))\n\t\t\t\tgoto default_handle;\n\t\t\tbreak;\n\t\tcase 'q': /* query command */\n\t\t\tgdb_cmd_query(ks);\n\t\t\tbreak;\n\t\tcase 'H': /* task related */\n\t\t\tgdb_cmd_task(ks);\n\t\t\tbreak;\n\t\tcase 'T': /* Query thread status */\n\t\t\tgdb_cmd_thread(ks);\n\t\t\tbreak;\n\t\tcase 'z': /* Break point remove */\n\t\tcase 'Z': /* Break point set */\n\t\t\tgdb_cmd_break(ks);\n\t\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\t\tcase '3': /* Escape into back into kdb */\n\t\t\tif (remcom_in_buffer[1] == '\\0') {\n\t\t\t\tgdb_cmd_detachkill(ks);\n\t\t\t\treturn DBG_PASS_EVENT;\n\t\t\t}\n\t\t\tfallthrough;\n#endif\n\t\tcase 'C': /* Exception passing */\n\t\t\ttmp = gdb_cmd_exception_pass(ks);\n\t\t\tif (tmp > 0)\n\t\t\t\tgoto default_handle;\n\t\t\tif (tmp == 0)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\t/* on tmp < 0 */\n\t\tcase 'c': /* Continue packet */\n\t\tcase 's': /* Single step packet */\n\t\t\tif (kgdb_contthread && kgdb_contthread != current) {\n\t\t\t\t/* Can't switch threads in kgdb */\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\t/* to default processing */\n\t\tdefault:\ndefault_handle:\n\t\t\terror = kgdb_arch_handle_exception(ks->ex_vector,\n\t\t\t\t\t\tks->signo,\n\t\t\t\t\t\tks->err_code,\n\t\t\t\t\t\tremcom_in_buffer,\n\t\t\t\t\t\tremcom_out_buffer,\n\t\t\t\t\t\tks->linux_regs);\n\t\t\t/*\n\t\t\t * Leave cmd processing on error, detach,\n\t\t\t * kill, continue, or single step.\n\t\t\t */\n\t\t\tif (error >= 0 || remcom_in_buffer[0] == 'D' ||\n\t\t\t    remcom_in_buffer[0] == 'k') {\n\t\t\t\terror = 0;\n\t\t\t\tgoto kgdb_exit;\n\t\t\t}\n\n\t\t}\n\n\t\t/* reply to the request */\n\t\tput_packet(remcom_out_buffer);\n\t}\n\nkgdb_exit:\n\tif (ks->pass_exception)\n\t\terror = 1;\n\treturn error;\n}"
  },
  {
    "function_name": "gdb_cmd_exception_pass",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "922-949",
    "snippet": "static int gdb_cmd_exception_pass(struct kgdb_state *ks)\n{\n\t/* C09 == pass exception\n\t * C15 == detach kgdb, pass exception\n\t */\n\tif (remcom_in_buffer[1] == '0' && remcom_in_buffer[2] == '9') {\n\n\t\tks->pass_exception = 1;\n\t\tremcom_in_buffer[0] = 'c';\n\n\t} else if (remcom_in_buffer[1] == '1' && remcom_in_buffer[2] == '5') {\n\n\t\tks->pass_exception = 1;\n\t\tremcom_in_buffer[0] = 'D';\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t\treturn 1;\n\n\t} else {\n\t\tgdbstub_msg_write(\"KGDB only knows signal 9 (pass)\"\n\t\t\t\" and 15 (pass and disconnect)\\n\"\n\t\t\t\"Executing a continue without signal passing\\n\", 0);\n\t\tremcom_in_buffer[0] = 'c';\n\t}\n\n\t/* Indicate fall through */\n\treturn -1;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gdbstub_msg_write",
          "args": [
            "\"KGDB only knows signal 9 (pass)\"\n\t\t\t\" and 15 (pass and disconnect)\\n\"\n\t\t\t\"Executing a continue without signal passing\\n\"",
            "0"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_msg_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "195-229",
          "snippet": "void gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char gdbmsgbuf[BUFMAX + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char gdbmsgbuf[BUFMAX + 1];\n\nvoid gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_remove_all_break",
          "args": [],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_remove_all_break",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "431-453",
          "snippet": "int dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\n\nstatic int gdb_cmd_exception_pass(struct kgdb_state *ks)\n{\n\t/* C09 == pass exception\n\t * C15 == detach kgdb, pass exception\n\t */\n\tif (remcom_in_buffer[1] == '0' && remcom_in_buffer[2] == '9') {\n\n\t\tks->pass_exception = 1;\n\t\tremcom_in_buffer[0] = 'c';\n\n\t} else if (remcom_in_buffer[1] == '1' && remcom_in_buffer[2] == '5') {\n\n\t\tks->pass_exception = 1;\n\t\tremcom_in_buffer[0] = 'D';\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t\treturn 1;\n\n\t} else {\n\t\tgdbstub_msg_write(\"KGDB only knows signal 9 (pass)\"\n\t\t\t\" and 15 (pass and disconnect)\\n\"\n\t\t\t\"Executing a continue without signal passing\\n\", 0);\n\t\tremcom_in_buffer[0] = 'c';\n\t}\n\n\t/* Indicate fall through */\n\treturn -1;\n}"
  },
  {
    "function_name": "gdb_cmd_break",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "860-919",
    "snippet": "static void gdb_cmd_break(struct kgdb_state *ks)\n{\n\t/*\n\t * Since GDB-5.3, it's been drafted that '0' is a software\n\t * breakpoint, '1' is a hardware breakpoint, so let's do that.\n\t */\n\tchar *bpt_type = &remcom_in_buffer[1];\n\tchar *ptr = &remcom_in_buffer[2];\n\tunsigned long addr;\n\tunsigned long length;\n\tint error = 0;\n\n\tif (arch_kgdb_ops.set_hw_breakpoint && *bpt_type >= '1') {\n\t\t/* Unsupported */\n\t\tif (*bpt_type > '4')\n\t\t\treturn;\n\t} else {\n\t\tif (*bpt_type != '0' && *bpt_type != '1')\n\t\t\t/* Unsupported. */\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Test if this is a hardware breakpoint, and\n\t * if we support it:\n\t */\n\tif (*bpt_type == '1' && !(arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT))\n\t\t/* Unsupported. */\n\t\treturn;\n\n\tif (*(ptr++) != ',') {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tif (!kgdb_hex2long(&ptr, &addr)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tif (*(ptr++) != ',' ||\n\t\t!kgdb_hex2long(&ptr, &length)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\n\tif (remcom_in_buffer[0] == 'Z' && *bpt_type == '0')\n\t\terror = dbg_set_sw_break(addr);\n\telse if (remcom_in_buffer[0] == 'z' && *bpt_type == '0')\n\t\terror = dbg_remove_sw_break(addr);\n\telse if (remcom_in_buffer[0] == 'Z')\n\t\terror = arch_kgdb_ops.set_hw_breakpoint(addr,\n\t\t\t(int)length, *bpt_type - '0');\n\telse if (remcom_in_buffer[0] == 'z')\n\t\terror = arch_kgdb_ops.remove_hw_breakpoint(addr,\n\t\t\t(int) length, *bpt_type - '0');\n\n\tif (error == 0)\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\telse\n\t\terror_packet(remcom_out_buffer, error);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "error"
          ],
          "line": 918
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kgdb_ops.remove_hw_breakpoint",
          "args": [
            "addr",
            "(int) length",
            "*bpt_type - '0'"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kgdb_ops.set_hw_breakpoint",
          "args": [
            "addr",
            "(int)length",
            "*bpt_type - '0'"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_remove_sw_break",
          "args": [
            "addr"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_remove_sw_break",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "393-405",
          "snippet": "int dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = BP_REMOVED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_set_sw_break",
          "args": [
            "addr"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_set_sw_break",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "329-368",
          "snippet": "int dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -EEXIST;\n\t}\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_REMOVED &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\t\tif (kgdb_break[i].state == BP_UNDEFINED) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -E2BIG;\n\n\tkgdb_break[breakno].state = BP_SET;\n\tkgdb_break[breakno].type = BP_BREAKPOINT;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif ((kgdb_break[i].state == BP_SET) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -EEXIST;\n\t}\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state == BP_REMOVED &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\t\tif (kgdb_break[i].state == BP_UNDEFINED) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -E2BIG;\n\n\tkgdb_break[breakno].state = BP_SET;\n\tkgdb_break[breakno].type = BP_BREAKPOINT;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_hex2long",
          "args": [
            "&ptr",
            "&length"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2long",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "290-316",
          "snippet": "int kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_break(struct kgdb_state *ks)\n{\n\t/*\n\t * Since GDB-5.3, it's been drafted that '0' is a software\n\t * breakpoint, '1' is a hardware breakpoint, so let's do that.\n\t */\n\tchar *bpt_type = &remcom_in_buffer[1];\n\tchar *ptr = &remcom_in_buffer[2];\n\tunsigned long addr;\n\tunsigned long length;\n\tint error = 0;\n\n\tif (arch_kgdb_ops.set_hw_breakpoint && *bpt_type >= '1') {\n\t\t/* Unsupported */\n\t\tif (*bpt_type > '4')\n\t\t\treturn;\n\t} else {\n\t\tif (*bpt_type != '0' && *bpt_type != '1')\n\t\t\t/* Unsupported. */\n\t\t\treturn;\n\t}\n\n\t/*\n\t * Test if this is a hardware breakpoint, and\n\t * if we support it:\n\t */\n\tif (*bpt_type == '1' && !(arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT))\n\t\t/* Unsupported. */\n\t\treturn;\n\n\tif (*(ptr++) != ',') {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tif (!kgdb_hex2long(&ptr, &addr)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tif (*(ptr++) != ',' ||\n\t\t!kgdb_hex2long(&ptr, &length)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\n\tif (remcom_in_buffer[0] == 'Z' && *bpt_type == '0')\n\t\terror = dbg_set_sw_break(addr);\n\telse if (remcom_in_buffer[0] == 'z' && *bpt_type == '0')\n\t\terror = dbg_remove_sw_break(addr);\n\telse if (remcom_in_buffer[0] == 'Z')\n\t\terror = arch_kgdb_ops.set_hw_breakpoint(addr,\n\t\t\t(int)length, *bpt_type - '0');\n\telse if (remcom_in_buffer[0] == 'z')\n\t\terror = arch_kgdb_ops.remove_hw_breakpoint(addr,\n\t\t\t(int) length, *bpt_type - '0');\n\n\tif (error == 0)\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\telse\n\t\terror_packet(remcom_out_buffer, error);\n}"
  },
  {
    "function_name": "gdb_cmd_thread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "846-857",
    "snippet": "static void gdb_cmd_thread(struct kgdb_state *ks)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tstruct task_struct *thread;\n\n\tkgdb_hex2long(&ptr, &ks->threadid);\n\tthread = getthread(ks->linux_regs, ks->threadid);\n\tif (thread)\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\telse\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "-EINVAL"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getthread",
          "args": [
            "ks->linux_regs",
            "ks->threadid"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "getthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "430-455",
          "snippet": "static struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t/*\n\t * Non-positive TIDs are remapped to the cpu shadow information\n\t */\n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid > -NR_CPUS - 2) {\n\t\tif (kgdb_info[-tid - 2].task)\n\t\t\treturn kgdb_info[-tid - 2].task;\n\t\telse\n\t\t\treturn idle_task(-tid - 2);\n\t}\n\tif (tid <= 0) {\n\t\tprintk(KERN_ERR \"KGDB: Internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * find_task_by_pid_ns() does not take the tasklist lock anymore\n\t * but is nicely RCU locked - hence is a pretty resilient\n\t * thing to use:\n\t */\n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t/*\n\t * Non-positive TIDs are remapped to the cpu shadow information\n\t */\n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid > -NR_CPUS - 2) {\n\t\tif (kgdb_info[-tid - 2].task)\n\t\t\treturn kgdb_info[-tid - 2].task;\n\t\telse\n\t\t\treturn idle_task(-tid - 2);\n\t}\n\tif (tid <= 0) {\n\t\tprintk(KERN_ERR \"KGDB: Internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * find_task_by_pid_ns() does not take the tasklist lock anymore\n\t * but is nicely RCU locked - hence is a pretty resilient\n\t * thing to use:\n\t */\n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_hex2long",
          "args": [
            "&ptr",
            "&ks->threadid"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2long",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "290-316",
          "snippet": "int kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_thread(struct kgdb_state *ks)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tstruct task_struct *thread;\n\n\tkgdb_hex2long(&ptr, &ks->threadid);\n\tthread = getthread(ks->linux_regs, ks->threadid);\n\tif (thread)\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\telse\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n}"
  },
  {
    "function_name": "gdb_cmd_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "809-843",
    "snippet": "static void gdb_cmd_task(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tchar *ptr;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 'g':\n\t\tptr = &remcom_in_buffer[2];\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tthread = getthread(ks->linux_regs, ks->threadid);\n\t\tif (!thread && ks->threadid > 0) {\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tkgdb_usethread = thread;\n\t\tks->kgdb_usethreadid = ks->threadid;\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tbreak;\n\tcase 'c':\n\t\tptr = &remcom_in_buffer[2];\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tif (!ks->threadid) {\n\t\t\tkgdb_contthread = NULL;\n\t\t} else {\n\t\t\tthread = getthread(ks->linux_regs, ks->threadid);\n\t\t\tif (!thread && ks->threadid > 0) {\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkgdb_contthread = thread;\n\t\t}\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "-EINVAL"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "getthread",
          "args": [
            "ks->linux_regs",
            "ks->threadid"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "getthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "430-455",
          "snippet": "static struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t/*\n\t * Non-positive TIDs are remapped to the cpu shadow information\n\t */\n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid > -NR_CPUS - 2) {\n\t\tif (kgdb_info[-tid - 2].task)\n\t\t\treturn kgdb_info[-tid - 2].task;\n\t\telse\n\t\t\treturn idle_task(-tid - 2);\n\t}\n\tif (tid <= 0) {\n\t\tprintk(KERN_ERR \"KGDB: Internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * find_task_by_pid_ns() does not take the tasklist lock anymore\n\t * but is nicely RCU locked - hence is a pretty resilient\n\t * thing to use:\n\t */\n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t/*\n\t * Non-positive TIDs are remapped to the cpu shadow information\n\t */\n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid > -NR_CPUS - 2) {\n\t\tif (kgdb_info[-tid - 2].task)\n\t\t\treturn kgdb_info[-tid - 2].task;\n\t\telse\n\t\t\treturn idle_task(-tid - 2);\n\t}\n\tif (tid <= 0) {\n\t\tprintk(KERN_ERR \"KGDB: Internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * find_task_by_pid_ns() does not take the tasklist lock anymore\n\t * but is nicely RCU locked - hence is a pretty resilient\n\t * thing to use:\n\t */\n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_hex2long",
          "args": [
            "&ptr",
            "&ks->threadid"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2long",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "290-316",
          "snippet": "int kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_task(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tchar *ptr;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 'g':\n\t\tptr = &remcom_in_buffer[2];\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tthread = getthread(ks->linux_regs, ks->threadid);\n\t\tif (!thread && ks->threadid > 0) {\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tkgdb_usethread = thread;\n\t\tks->kgdb_usethreadid = ks->threadid;\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tbreak;\n\tcase 'c':\n\t\tptr = &remcom_in_buffer[2];\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tif (!ks->threadid) {\n\t\t\tkgdb_contthread = NULL;\n\t\t} else {\n\t\t\tthread = getthread(ks->linux_regs, ks->threadid);\n\t\t\tif (!thread && ks->threadid > 0) {\n\t\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkgdb_contthread = thread;\n\t\t}\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "gdb_cmd_query",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "695-806",
    "snippet": "static void gdb_cmd_query(struct kgdb_state *ks)\n{\n\tstruct task_struct *g;\n\tstruct task_struct *p;\n\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\tchar *ptr;\n\tint i;\n\tint cpu;\n\tint finished = 0;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 's':\n\tcase 'f':\n\t\tif (memcmp(remcom_in_buffer + 2, \"ThreadInfo\", 10))\n\t\t\tbreak;\n\n\t\ti = 0;\n\t\tremcom_out_buffer[0] = 'm';\n\t\tptr = remcom_out_buffer + 1;\n\t\tif (remcom_in_buffer[1] == 'f') {\n\t\t\t/* Each cpu is a shadow thread */\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tks->thr_query = 0;\n\t\t\t\tint_to_threadref(thref, -cpu - 2);\n\t\t\t\tptr = pack_threadid(ptr, thref);\n\t\t\t\t*(ptr++) = ',';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (i >= ks->thr_query && !finished) {\n\t\t\t\tint_to_threadref(thref, p->pid);\n\t\t\t\tptr = pack_threadid(ptr, thref);\n\t\t\t\t*(ptr++) = ',';\n\t\t\t\tks->thr_query++;\n\t\t\t\tif (ks->thr_query % KGDB_MAX_THREAD_QUERY == 0)\n\t\t\t\t\tfinished = 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t*(--ptr) = '\\0';\n\t\tbreak;\n\n\tcase 'C':\n\t\t/* Current thread id */\n\t\tstrcpy(remcom_out_buffer, \"QC\");\n\t\tks->threadid = shadow_pid(current->pid);\n\t\tint_to_threadref(thref, ks->threadid);\n\t\tpack_threadid(remcom_out_buffer + 2, thref);\n\t\tbreak;\n\tcase 'T':\n\t\tif (memcmp(remcom_in_buffer + 1, \"ThreadExtraInfo,\", 16))\n\t\t\tbreak;\n\n\t\tks->threadid = 0;\n\t\tptr = remcom_in_buffer + 17;\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tif (!getthread(ks->linux_regs, ks->threadid)) {\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tif ((int)ks->threadid > 0) {\n\t\t\tkgdb_mem2hex(getthread(ks->linux_regs,\n\t\t\t\t\tks->threadid)->comm,\n\t\t\t\t\tremcom_out_buffer, 16);\n\t\t} else {\n\t\t\tstatic char tmpstr[23 + BUF_THREAD_ID_SIZE];\n\n\t\t\tsprintf(tmpstr, \"shadowCPU%d\",\n\t\t\t\t\t(int)(-ks->threadid - 2));\n\t\t\tkgdb_mem2hex(tmpstr, remcom_out_buffer, strlen(tmpstr));\n\t\t}\n\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\tcase 'R':\n\t\tif (strncmp(remcom_in_buffer, \"qRcmd,\", 6) == 0) {\n\t\t\tint len = strlen(remcom_in_buffer + 6);\n\n\t\t\tif ((len % 2) != 0) {\n\t\t\t\tstrcpy(remcom_out_buffer, \"E01\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkgdb_hex2mem(remcom_in_buffer + 6,\n\t\t\t\t     remcom_out_buffer, len);\n\t\t\tlen = len / 2;\n\t\t\tremcom_out_buffer[len++] = 0;\n\n\t\t\tkdb_common_init_state(ks);\n\t\t\tkdb_parse(remcom_out_buffer);\n\t\t\tkdb_common_deinit_state();\n\n\t\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\t}\n\t\tbreak;\n#endif\n#ifdef CONFIG_HAVE_ARCH_KGDB_QXFER_PKT\n\tcase 'S':\n\t\tif (!strncmp(remcom_in_buffer, \"qSupported:\", 11))\n\t\t\tstrcpy(remcom_out_buffer, kgdb_arch_gdb_stub_feature);\n\t\tbreak;\n\tcase 'X':\n\t\tif (!strncmp(remcom_in_buffer, \"qXfer:\", 6))\n\t\t\tkgdb_arch_handle_qxfer_pkt(remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BUF_THREAD_ID_SIZE\t8",
      "#define KGDB_MAX_THREAD_QUERY 17"
    ],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_arch_handle_qxfer_pkt",
          "args": [
            "remcom_in_buffer",
            "remcom_out_buffer"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "remcom_in_buffer",
            "\"qXfer:\"",
            "6"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "kgdb_arch_gdb_stub_feature"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "remcom_in_buffer",
            "\"qSupported:\"",
            "11"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_common_deinit_state",
          "args": [],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_common_deinit_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_debugger.c",
          "lines": "45-51",
          "snippet": "int kdb_common_deinit_state(void)\n{\n\tkdb_initial_cpu = -1;\n\tkdb_current_task = NULL;\n\tkdb_current_regs = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"../debug_core.h\"",
            "#include \"kdb_private.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nint kdb_common_deinit_state(void)\n{\n\tkdb_initial_cpu = -1;\n\tkdb_current_task = NULL;\n\tkdb_current_regs = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_parse",
          "args": [
            "remcom_out_buffer"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_parse",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "915-1082",
          "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MAXARGC\t20",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
          ],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
            "static LIST_HEAD(kdb_cmds_head);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic LIST_HEAD(kdb_cmds_head);\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t/*\n\t\t * If this command is allowed to be abbreviated,\n\t\t * check to see if this is it.\n\t\t */\n\t\tif (tp->minlen && (strlen(argv[0]) <= tp->minlen) &&\n\t\t    (strncmp(argv[0], tp->name, tp->minlen) == 0))\n\t\t\tbreak;\n\n\t\tif (strcmp(argv[0], tp->name) == 0)\n\t\t\tbreak;\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tlist_for_each_entry(tp, &kdb_cmds_head, list_node) {\n\t\t\tif (strncmp(argv[0], tp->name, strlen(tp->name)) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!list_entry_is_head(tp, &kdb_cmds_head, list_node)) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_common_init_state",
          "args": [
            "ks"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_common_init_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_debugger.c",
          "lines": "37-43",
          "snippet": "int kdb_common_init_state(struct kgdb_state *ks)\n{\n\tkdb_initial_cpu = atomic_read(&kgdb_active);\n\tkdb_current_task = kgdb_info[ks->cpu].task;\n\tkdb_current_regs = kgdb_info[ks->cpu].debuggerinfo;\n\treturn 0;\n}",
          "includes": [
            "#include \"../debug_core.h\"",
            "#include \"kdb_private.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../debug_core.h\"\n#include \"kdb_private.h\"\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/kdebug.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n\nint kdb_common_init_state(struct kgdb_state *ks)\n{\n\tkdb_initial_cpu = atomic_read(&kgdb_active);\n\tkdb_current_task = kgdb_info[ks->cpu].task;\n\tkdb_current_regs = kgdb_info[ks->cpu].debuggerinfo;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_hex2mem",
          "args": [
            "remcom_in_buffer + 6",
            "remcom_out_buffer",
            "len"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2mem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "265-284",
          "snippet": "int kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory that is converted from hex.\n\t */\n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory that is converted from hex.\n\t */\n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"E01\""
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "remcom_in_buffer + 6"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "remcom_in_buffer",
            "\"qRcmd,\"",
            "6"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_mem2hex",
          "args": [
            "tmpstr",
            "remcom_out_buffer",
            "strlen(tmpstr)"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_mem2hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "236-258",
          "snippet": "char *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory copy.  Hex conversion will work against this one.\n\t */\n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nchar *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory copy.  Hex conversion will work against this one.\n\t */\n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmpstr",
            "\"shadowCPU%d\"",
            "(int)(-ks->threadid - 2)"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getthread",
          "args": [
            "ks->linux_regs",
            "ks->threadid"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "getthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "430-455",
          "snippet": "static struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t/*\n\t * Non-positive TIDs are remapped to the cpu shadow information\n\t */\n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid > -NR_CPUS - 2) {\n\t\tif (kgdb_info[-tid - 2].task)\n\t\t\treturn kgdb_info[-tid - 2].task;\n\t\telse\n\t\t\treturn idle_task(-tid - 2);\n\t}\n\tif (tid <= 0) {\n\t\tprintk(KERN_ERR \"KGDB: Internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * find_task_by_pid_ns() does not take the tasklist lock anymore\n\t * but is nicely RCU locked - hence is a pretty resilient\n\t * thing to use:\n\t */\n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t/*\n\t * Non-positive TIDs are remapped to the cpu shadow information\n\t */\n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid > -NR_CPUS - 2) {\n\t\tif (kgdb_info[-tid - 2].task)\n\t\t\treturn kgdb_info[-tid - 2].task;\n\t\telse\n\t\t\treturn idle_task(-tid - 2);\n\t}\n\tif (tid <= 0) {\n\t\tprintk(KERN_ERR \"KGDB: Internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * find_task_by_pid_ns() does not take the tasklist lock anymore\n\t * but is nicely RCU locked - hence is a pretty resilient\n\t * thing to use:\n\t */\n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "-EINVAL"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_hex2long",
          "args": [
            "&ptr",
            "&ks->threadid"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2long",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "290-316",
          "snippet": "int kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "remcom_in_buffer + 1",
            "\"ThreadExtraInfo,\"",
            "16"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pack_threadid",
          "args": [
            "remcom_out_buffer + 2",
            "thref"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "pack_threadid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "405-423",
          "snippet": "static char *pack_threadid(char *pkt, unsigned char *id)\n{\n\tunsigned char *limit;\n\tint lzero = 1;\n\n\tlimit = id + (BUF_THREAD_ID_SIZE / 2);\n\twhile (id < limit) {\n\t\tif (!lzero || *id != 0) {\n\t\t\tpkt = hex_byte_pack(pkt, *id);\n\t\t\tlzero = 0;\n\t\t}\n\t\tid++;\n\t}\n\n\tif (lzero)\n\t\tpkt = hex_byte_pack(pkt, 0);\n\n\treturn pkt;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define BUF_THREAD_ID_SIZE\t8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BUF_THREAD_ID_SIZE\t8\n\nstatic char *pack_threadid(char *pkt, unsigned char *id)\n{\n\tunsigned char *limit;\n\tint lzero = 1;\n\n\tlimit = id + (BUF_THREAD_ID_SIZE / 2);\n\twhile (id < limit) {\n\t\tif (!lzero || *id != 0) {\n\t\t\tpkt = hex_byte_pack(pkt, *id);\n\t\t\tlzero = 0;\n\t\t}\n\t\tid++;\n\t}\n\n\tif (lzero)\n\t\tpkt = hex_byte_pack(pkt, 0);\n\n\treturn pkt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "int_to_threadref",
          "args": [
            "thref",
            "ks->threadid"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "int_to_threadref",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "425-428",
          "snippet": "static void int_to_threadref(unsigned char *id, int value)\n{\n\tput_unaligned_be32(value, id);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void int_to_threadref(unsigned char *id, int value)\n{\n\tput_unaligned_be32(value, id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shadow_pid",
          "args": [
            "current->pid"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_pid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "462-468",
          "snippet": "static inline int shadow_pid(int realpid)\n{\n\tif (realpid)\n\t\treturn realpid;\n\n\treturn -raw_smp_processor_id() - 2;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline int shadow_pid(int realpid)\n{\n\tif (realpid)\n\t\treturn realpid;\n\n\treturn -raw_smp_processor_id() - 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"QC\""
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "remcom_in_buffer + 2",
            "\"ThreadInfo\"",
            "10"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BUF_THREAD_ID_SIZE\t8\n#define KGDB_MAX_THREAD_QUERY 17\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_query(struct kgdb_state *ks)\n{\n\tstruct task_struct *g;\n\tstruct task_struct *p;\n\tunsigned char thref[BUF_THREAD_ID_SIZE];\n\tchar *ptr;\n\tint i;\n\tint cpu;\n\tint finished = 0;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 's':\n\tcase 'f':\n\t\tif (memcmp(remcom_in_buffer + 2, \"ThreadInfo\", 10))\n\t\t\tbreak;\n\n\t\ti = 0;\n\t\tremcom_out_buffer[0] = 'm';\n\t\tptr = remcom_out_buffer + 1;\n\t\tif (remcom_in_buffer[1] == 'f') {\n\t\t\t/* Each cpu is a shadow thread */\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tks->thr_query = 0;\n\t\t\t\tint_to_threadref(thref, -cpu - 2);\n\t\t\t\tptr = pack_threadid(ptr, thref);\n\t\t\t\t*(ptr++) = ',';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tfor_each_process_thread(g, p) {\n\t\t\tif (i >= ks->thr_query && !finished) {\n\t\t\t\tint_to_threadref(thref, p->pid);\n\t\t\t\tptr = pack_threadid(ptr, thref);\n\t\t\t\t*(ptr++) = ',';\n\t\t\t\tks->thr_query++;\n\t\t\t\tif (ks->thr_query % KGDB_MAX_THREAD_QUERY == 0)\n\t\t\t\t\tfinished = 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t*(--ptr) = '\\0';\n\t\tbreak;\n\n\tcase 'C':\n\t\t/* Current thread id */\n\t\tstrcpy(remcom_out_buffer, \"QC\");\n\t\tks->threadid = shadow_pid(current->pid);\n\t\tint_to_threadref(thref, ks->threadid);\n\t\tpack_threadid(remcom_out_buffer + 2, thref);\n\t\tbreak;\n\tcase 'T':\n\t\tif (memcmp(remcom_in_buffer + 1, \"ThreadExtraInfo,\", 16))\n\t\t\tbreak;\n\n\t\tks->threadid = 0;\n\t\tptr = remcom_in_buffer + 17;\n\t\tkgdb_hex2long(&ptr, &ks->threadid);\n\t\tif (!getthread(ks->linux_regs, ks->threadid)) {\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\t\tbreak;\n\t\t}\n\t\tif ((int)ks->threadid > 0) {\n\t\t\tkgdb_mem2hex(getthread(ks->linux_regs,\n\t\t\t\t\tks->threadid)->comm,\n\t\t\t\t\tremcom_out_buffer, 16);\n\t\t} else {\n\t\t\tstatic char tmpstr[23 + BUF_THREAD_ID_SIZE];\n\n\t\t\tsprintf(tmpstr, \"shadowCPU%d\",\n\t\t\t\t\t(int)(-ks->threadid - 2));\n\t\t\tkgdb_mem2hex(tmpstr, remcom_out_buffer, strlen(tmpstr));\n\t\t}\n\t\tbreak;\n#ifdef CONFIG_KGDB_KDB\n\tcase 'R':\n\t\tif (strncmp(remcom_in_buffer, \"qRcmd,\", 6) == 0) {\n\t\t\tint len = strlen(remcom_in_buffer + 6);\n\n\t\t\tif ((len % 2) != 0) {\n\t\t\t\tstrcpy(remcom_out_buffer, \"E01\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkgdb_hex2mem(remcom_in_buffer + 6,\n\t\t\t\t     remcom_out_buffer, len);\n\t\t\tlen = len / 2;\n\t\t\tremcom_out_buffer[len++] = 0;\n\n\t\t\tkdb_common_init_state(ks);\n\t\t\tkdb_parse(remcom_out_buffer);\n\t\t\tkdb_common_deinit_state();\n\n\t\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\t}\n\t\tbreak;\n#endif\n#ifdef CONFIG_HAVE_ARCH_KGDB_QXFER_PKT\n\tcase 'S':\n\t\tif (!strncmp(remcom_in_buffer, \"qSupported:\", 11))\n\t\t\tstrcpy(remcom_out_buffer, kgdb_arch_gdb_stub_feature);\n\t\tbreak;\n\tcase 'X':\n\t\tif (!strncmp(remcom_in_buffer, \"qXfer:\", 6))\n\t\t\tkgdb_arch_handle_qxfer_pkt(remcom_in_buffer,\n\t\t\t\t\t\t   remcom_out_buffer);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "gdb_cmd_reboot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "674-692",
    "snippet": "static int gdb_cmd_reboot(struct kgdb_state *ks)\n{\n\t/* For now, only honor R0 */\n\tif (strcmp(remcom_in_buffer, \"R0\") == 0) {\n\t\tprintk(KERN_CRIT \"Executing emergency reboot\\n\");\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tput_packet(remcom_out_buffer);\n\n\t\t/*\n\t\t * Execution should not return from\n\t\t * machine_emergency_restart()\n\t\t */\n\t\tmachine_emergency_restart();\n\t\tkgdb_connected = 0;\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "machine_emergency_restart",
          "args": [],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_packet",
          "args": [
            "remcom_out_buffer"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "put_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "142-191",
          "snippet": "static void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"Executing emergency reboot\\n\""
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "remcom_in_buffer",
            "\"R0\""
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic int gdb_cmd_reboot(struct kgdb_state *ks)\n{\n\t/* For now, only honor R0 */\n\tif (strcmp(remcom_in_buffer, \"R0\") == 0) {\n\t\tprintk(KERN_CRIT \"Executing emergency reboot\\n\");\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\tput_packet(remcom_out_buffer);\n\n\t\t/*\n\t\t * Execution should not return from\n\t\t * machine_emergency_restart()\n\t\t */\n\t\tmachine_emergency_restart();\n\t\tkgdb_connected = 0;\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "gdb_cmd_detachkill",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "649-671",
    "snippet": "static void gdb_cmd_detachkill(struct kgdb_state *ks)\n{\n\tint error;\n\n\t/* The detach case */\n\tif (remcom_in_buffer[0] == 'D') {\n\t\terror = dbg_remove_all_break();\n\t\tif (error < 0) {\n\t\t\terror_packet(remcom_out_buffer, error);\n\t\t} else {\n\t\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\t\tkgdb_connected = 0;\n\t\t}\n\t\tput_packet(remcom_out_buffer);\n\t} else {\n\t\t/*\n\t\t * Assume the kill case, with no exit code checking,\n\t\t * trying to force detach the debugger:\n\t\t */\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_remove_all_break",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_remove_all_break",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "431-453",
          "snippet": "int dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_packet",
          "args": [
            "remcom_out_buffer"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "put_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "142-191",
          "snippet": "static void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "error"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_detachkill(struct kgdb_state *ks)\n{\n\tint error;\n\n\t/* The detach case */\n\tif (remcom_in_buffer[0] == 'D') {\n\t\terror = dbg_remove_all_break();\n\t\tif (error < 0) {\n\t\t\terror_packet(remcom_out_buffer, error);\n\t\t} else {\n\t\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t\t\tkgdb_connected = 0;\n\t\t}\n\t\tput_packet(remcom_out_buffer);\n\t} else {\n\t\t/*\n\t\t * Assume the kill case, with no exit code checking,\n\t\t * trying to force detach the debugger:\n\t\t */\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t}\n}"
  },
  {
    "function_name": "gdb_cmd_binwrite",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "638-646",
    "snippet": "static void gdb_cmd_binwrite(struct kgdb_state *ks)\n{\n\tint err = write_mem_msg(1);\n\n\tif (err)\n\t\terror_packet(remcom_out_buffer, err);\n\telse\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "err"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_mem_msg",
          "args": [
            "1"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "write_mem_msg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "365-386",
          "snippet": "static int write_mem_msg(int binary)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\tunsigned long length;\n\tint err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *(ptr++) == ',' &&\n\t    kgdb_hex2long(&ptr, &length) > 0 && *(ptr++) == ':') {\n\t\tif (binary)\n\t\t\terr = kgdb_ebin2mem(ptr, (char *)addr, length);\n\t\telse\n\t\t\terr = kgdb_hex2mem(ptr, (char *)addr, length);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (CACHE_FLUSH_IS_SAFE)\n\t\t\tflush_icache_range(addr, addr + length);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\n\nstatic int write_mem_msg(int binary)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\tunsigned long length;\n\tint err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *(ptr++) == ',' &&\n\t    kgdb_hex2long(&ptr, &length) > 0 && *(ptr++) == ':') {\n\t\tif (binary)\n\t\t\terr = kgdb_ebin2mem(ptr, (char *)addr, length);\n\t\telse\n\t\t\terr = kgdb_hex2mem(ptr, (char *)addr, length);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (CACHE_FLUSH_IS_SAFE)\n\t\t\tflush_icache_range(addr, addr + length);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_binwrite(struct kgdb_state *ks)\n{\n\tint err = write_mem_msg(1);\n\n\tif (err)\n\t\terror_packet(remcom_out_buffer, err);\n\telse\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n}"
  },
  {
    "function_name": "gdb_cmd_reg_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "611-634",
    "snippet": "static void gdb_cmd_reg_set(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\tint i = 0;\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (*ptr++ != '=' ||\n\t    !(!kgdb_usethread || kgdb_usethread == current) ||\n\t    !dbg_get_reg(regnum, gdb_regs, ks->linux_regs)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tmemset(gdb_regs, 0, sizeof(gdb_regs));\n\twhile (i < sizeof(gdb_regs) * 2)\n\t\tif (hex_to_bin(ptr[i]) >= 0)\n\t\t\ti++;\n\t\telse\n\t\t\tbreak;\n\ti = i / 2;\n\tkgdb_hex2mem(ptr, (char *)gdb_regs, i);\n\tdbg_set_reg(regnum, gdb_regs, ks->linux_regs);\n\tstrcpy(remcom_out_buffer, \"OK\");\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];",
      "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_set_reg",
          "args": [
            "regnum",
            "gdb_regs",
            "ks->linux_regs"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_hex2mem",
          "args": [
            "ptr",
            "(char *)gdb_regs",
            "i"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2mem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "265-284",
          "snippet": "int kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory that is converted from hex.\n\t */\n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory that is converted from hex.\n\t */\n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "ptr[i]"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "gdb_regs",
            "0",
            "sizeof(gdb_regs)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "-EINVAL"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_get_reg",
          "args": [
            "regnum",
            "gdb_regs",
            "ks->linux_regs"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_hex2long",
          "args": [
            "&ptr",
            "&regnum"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2long",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "290-316",
          "snippet": "int kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic void gdb_cmd_reg_set(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\tint i = 0;\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (*ptr++ != '=' ||\n\t    !(!kgdb_usethread || kgdb_usethread == current) ||\n\t    !dbg_get_reg(regnum, gdb_regs, ks->linux_regs)) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tmemset(gdb_regs, 0, sizeof(gdb_regs));\n\twhile (i < sizeof(gdb_regs) * 2)\n\t\tif (hex_to_bin(ptr[i]) >= 0)\n\t\t\ti++;\n\t\telse\n\t\t\tbreak;\n\ti = i / 2;\n\tkgdb_hex2mem(ptr, (char *)gdb_regs, i);\n\tdbg_set_reg(regnum, gdb_regs, ks->linux_regs);\n\tstrcpy(remcom_out_buffer, \"OK\");\n}"
  },
  {
    "function_name": "gdb_cmd_reg_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "596-608",
    "snippet": "static void gdb_cmd_reg_get(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (regnum >= DBG_MAX_REG_NUM) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tgdb_get_regs_helper(ks);\n\tgdb_hex_reg_helper(regnum, remcom_out_buffer);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gdb_hex_reg_helper",
          "args": [
            "regnum",
            "remcom_out_buffer"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_hex_reg_helper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "584-593",
          "snippet": "static char *gdb_hex_reg_helper(int regnum, char *out)\n{\n\tint i;\n\tint offset = 0;\n\n\tfor (i = 0; i < regnum; i++)\n\t\toffset += dbg_reg_def[i].size;\n\treturn kgdb_mem2hex((char *)gdb_regs + offset, out,\n\t\t\t    dbg_reg_def[i].size);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic char *gdb_hex_reg_helper(int regnum, char *out)\n{\n\tint i;\n\tint offset = 0;\n\n\tfor (i = 0; i < regnum; i++)\n\t\toffset += dbg_reg_def[i].size;\n\treturn kgdb_mem2hex((char *)gdb_regs + offset, out,\n\t\t\t    dbg_reg_def[i].size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_get_regs_helper",
          "args": [
            "ks"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_get_regs_helper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "491-532",
          "snippet": "static void gdb_get_regs_helper(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tvoid *local_debuggerinfo;\n\tint i;\n\n\tthread = kgdb_usethread;\n\tif (!thread) {\n\t\tthread = kgdb_info[ks->cpu].task;\n\t\tlocal_debuggerinfo = kgdb_info[ks->cpu].debuggerinfo;\n\t} else {\n\t\tlocal_debuggerinfo = NULL;\n\t\tfor_each_online_cpu(i) {\n\t\t\t/*\n\t\t\t * Try to find the task on some other\n\t\t\t * or possibly this node if we do not\n\t\t\t * find the matching task then we try\n\t\t\t * to approximate the results.\n\t\t\t */\n\t\t\tif (thread == kgdb_info[i].task)\n\t\t\t\tlocal_debuggerinfo = kgdb_info[i].debuggerinfo;\n\t\t}\n\t}\n\n\t/*\n\t * All threads that don't have debuggerinfo should be\n\t * in schedule() sleeping, since all other CPUs\n\t * are in kgdb_wait, and thus have debuggerinfo.\n\t */\n\tif (local_debuggerinfo) {\n\t\tpt_regs_to_gdb_regs(gdb_regs, local_debuggerinfo);\n\t} else {\n\t\t/*\n\t\t * Pull stuff saved during switch_to; nothing\n\t\t * else is accessible (or even particularly\n\t\t * relevant).\n\t\t *\n\t\t * This should be enough for a stack trace.\n\t\t */\n\t\tsleeping_thread_to_gdb_regs(gdb_regs, thread);\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic void gdb_get_regs_helper(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tvoid *local_debuggerinfo;\n\tint i;\n\n\tthread = kgdb_usethread;\n\tif (!thread) {\n\t\tthread = kgdb_info[ks->cpu].task;\n\t\tlocal_debuggerinfo = kgdb_info[ks->cpu].debuggerinfo;\n\t} else {\n\t\tlocal_debuggerinfo = NULL;\n\t\tfor_each_online_cpu(i) {\n\t\t\t/*\n\t\t\t * Try to find the task on some other\n\t\t\t * or possibly this node if we do not\n\t\t\t * find the matching task then we try\n\t\t\t * to approximate the results.\n\t\t\t */\n\t\t\tif (thread == kgdb_info[i].task)\n\t\t\t\tlocal_debuggerinfo = kgdb_info[i].debuggerinfo;\n\t\t}\n\t}\n\n\t/*\n\t * All threads that don't have debuggerinfo should be\n\t * in schedule() sleeping, since all other CPUs\n\t * are in kgdb_wait, and thus have debuggerinfo.\n\t */\n\tif (local_debuggerinfo) {\n\t\tpt_regs_to_gdb_regs(gdb_regs, local_debuggerinfo);\n\t} else {\n\t\t/*\n\t\t * Pull stuff saved during switch_to; nothing\n\t\t * else is accessible (or even particularly\n\t\t * relevant).\n\t\t *\n\t\t * This should be enough for a stack trace.\n\t\t */\n\t\tsleeping_thread_to_gdb_regs(gdb_regs, thread);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "-EINVAL"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_hex2long",
          "args": [
            "&ptr",
            "&regnum"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2long",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "290-316",
          "snippet": "int kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_reg_get(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (regnum >= DBG_MAX_REG_NUM) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t\treturn;\n\t}\n\tgdb_get_regs_helper(ks);\n\tgdb_hex_reg_helper(regnum, remcom_out_buffer);\n}"
  },
  {
    "function_name": "gdb_hex_reg_helper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "584-593",
    "snippet": "static char *gdb_hex_reg_helper(int regnum, char *out)\n{\n\tint i;\n\tint offset = 0;\n\n\tfor (i = 0; i < regnum; i++)\n\t\toffset += dbg_reg_def[i].size;\n\treturn kgdb_mem2hex((char *)gdb_regs + offset, out,\n\t\t\t    dbg_reg_def[i].size);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_mem2hex",
          "args": [
            "(char *)gdb_regs + offset",
            "out",
            "dbg_reg_def[i].size"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_mem2hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "236-258",
          "snippet": "char *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory copy.  Hex conversion will work against this one.\n\t */\n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nchar *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory copy.  Hex conversion will work against this one.\n\t */\n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic char *gdb_hex_reg_helper(int regnum, char *out)\n{\n\tint i;\n\tint offset = 0;\n\n\tfor (i = 0; i < regnum; i++)\n\t\toffset += dbg_reg_def[i].size;\n\treturn kgdb_mem2hex((char *)gdb_regs + offset, out,\n\t\t\t    dbg_reg_def[i].size);\n}"
  },
  {
    "function_name": "gdb_cmd_memwrite",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "573-581",
    "snippet": "static void gdb_cmd_memwrite(struct kgdb_state *ks)\n{\n\tint err = write_mem_msg(0);\n\n\tif (err)\n\t\terror_packet(remcom_out_buffer, err);\n\telse\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "err"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_mem_msg",
          "args": [
            "0"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "write_mem_msg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "365-386",
          "snippet": "static int write_mem_msg(int binary)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\tunsigned long length;\n\tint err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *(ptr++) == ',' &&\n\t    kgdb_hex2long(&ptr, &length) > 0 && *(ptr++) == ':') {\n\t\tif (binary)\n\t\t\terr = kgdb_ebin2mem(ptr, (char *)addr, length);\n\t\telse\n\t\t\terr = kgdb_hex2mem(ptr, (char *)addr, length);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (CACHE_FLUSH_IS_SAFE)\n\t\t\tflush_icache_range(addr, addr + length);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char\t\t\tremcom_in_buffer[BUFMAX];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\n\nstatic int write_mem_msg(int binary)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\tunsigned long length;\n\tint err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *(ptr++) == ',' &&\n\t    kgdb_hex2long(&ptr, &length) > 0 && *(ptr++) == ':') {\n\t\tif (binary)\n\t\t\terr = kgdb_ebin2mem(ptr, (char *)addr, length);\n\t\telse\n\t\t\terr = kgdb_hex2mem(ptr, (char *)addr, length);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (CACHE_FLUSH_IS_SAFE)\n\t\t\tflush_icache_range(addr, addr + length);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_memwrite(struct kgdb_state *ks)\n{\n\tint err = write_mem_msg(0);\n\n\tif (err)\n\t\terror_packet(remcom_out_buffer, err);\n\telse\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n}"
  },
  {
    "function_name": "gdb_cmd_memread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "555-570",
    "snippet": "static void gdb_cmd_memread(struct kgdb_state *ks)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long length;\n\tunsigned long addr;\n\tchar *err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *ptr++ == ',' &&\n\t\t\t\t\tkgdb_hex2long(&ptr, &length) > 0) {\n\t\terr = kgdb_mem2hex((char *)addr, remcom_out_buffer, length);\n\t\tif (!err)\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t} else {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "-EINVAL"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_mem2hex",
          "args": [
            "(char *)addr",
            "remcom_out_buffer",
            "length"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_mem2hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "236-258",
          "snippet": "char *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory copy.  Hex conversion will work against this one.\n\t */\n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nchar *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory copy.  Hex conversion will work against this one.\n\t */\n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_hex2long",
          "args": [
            "&ptr",
            "&length"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2long",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "290-316",
          "snippet": "int kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_memread(struct kgdb_state *ks)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long length;\n\tunsigned long addr;\n\tchar *err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *ptr++ == ',' &&\n\t\t\t\t\tkgdb_hex2long(&ptr, &length) > 0) {\n\t\terr = kgdb_mem2hex((char *)addr, remcom_out_buffer, length);\n\t\tif (!err)\n\t\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t} else {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t}\n}"
  },
  {
    "function_name": "gdb_cmd_setregs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "542-552",
    "snippet": "static void gdb_cmd_setregs(struct kgdb_state *ks)\n{\n\tkgdb_hex2mem(&remcom_in_buffer[1], (char *)gdb_regs, NUMREGBYTES);\n\n\tif (kgdb_usethread && kgdb_usethread != current) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t} else {\n\t\tgdb_regs_to_pt_regs(gdb_regs, ks->linux_regs);\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static char\t\t\tremcom_out_buffer[BUFMAX];",
      "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "remcom_out_buffer",
            "\"OK\""
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdb_regs_to_pt_regs",
          "args": [
            "gdb_regs",
            "ks->linux_regs"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_regs_to_pt_regs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "351-361",
          "snippet": "void gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tdbg_set_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nvoid gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tdbg_set_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "error_packet",
          "args": [
            "remcom_out_buffer",
            "-EINVAL"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "error_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "388-395",
          "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_hex2mem",
          "args": [
            "&remcom_in_buffer[1]",
            "(char *)gdb_regs",
            "NUMREGBYTES"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2mem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "265-284",
          "snippet": "int kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory that is converted from hex.\n\t */\n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory that is converted from hex.\n\t */\n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic void gdb_cmd_setregs(struct kgdb_state *ks)\n{\n\tkgdb_hex2mem(&remcom_in_buffer[1], (char *)gdb_regs, NUMREGBYTES);\n\n\tif (kgdb_usethread && kgdb_usethread != current) {\n\t\terror_packet(remcom_out_buffer, -EINVAL);\n\t} else {\n\t\tgdb_regs_to_pt_regs(gdb_regs, ks->linux_regs);\n\t\tstrcpy(remcom_out_buffer, \"OK\");\n\t}\n}"
  },
  {
    "function_name": "gdb_cmd_getregs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "535-539",
    "snippet": "static void gdb_cmd_getregs(struct kgdb_state *ks)\n{\n\tgdb_get_regs_helper(ks);\n\tkgdb_mem2hex((char *)gdb_regs, remcom_out_buffer, NUMREGBYTES);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_out_buffer[BUFMAX];",
      "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kgdb_mem2hex",
          "args": [
            "(char *)gdb_regs",
            "remcom_out_buffer",
            "NUMREGBYTES"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_mem2hex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "236-258",
          "snippet": "char *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory copy.  Hex conversion will work against this one.\n\t */\n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nchar *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory copy.  Hex conversion will work against this one.\n\t */\n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gdb_get_regs_helper",
          "args": [
            "ks"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "gdb_get_regs_helper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "491-532",
          "snippet": "static void gdb_get_regs_helper(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tvoid *local_debuggerinfo;\n\tint i;\n\n\tthread = kgdb_usethread;\n\tif (!thread) {\n\t\tthread = kgdb_info[ks->cpu].task;\n\t\tlocal_debuggerinfo = kgdb_info[ks->cpu].debuggerinfo;\n\t} else {\n\t\tlocal_debuggerinfo = NULL;\n\t\tfor_each_online_cpu(i) {\n\t\t\t/*\n\t\t\t * Try to find the task on some other\n\t\t\t * or possibly this node if we do not\n\t\t\t * find the matching task then we try\n\t\t\t * to approximate the results.\n\t\t\t */\n\t\t\tif (thread == kgdb_info[i].task)\n\t\t\t\tlocal_debuggerinfo = kgdb_info[i].debuggerinfo;\n\t\t}\n\t}\n\n\t/*\n\t * All threads that don't have debuggerinfo should be\n\t * in schedule() sleeping, since all other CPUs\n\t * are in kgdb_wait, and thus have debuggerinfo.\n\t */\n\tif (local_debuggerinfo) {\n\t\tpt_regs_to_gdb_regs(gdb_regs, local_debuggerinfo);\n\t} else {\n\t\t/*\n\t\t * Pull stuff saved during switch_to; nothing\n\t\t * else is accessible (or even particularly\n\t\t * relevant).\n\t\t *\n\t\t * This should be enough for a stack trace.\n\t\t */\n\t\tsleeping_thread_to_gdb_regs(gdb_regs, thread);\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic void gdb_get_regs_helper(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tvoid *local_debuggerinfo;\n\tint i;\n\n\tthread = kgdb_usethread;\n\tif (!thread) {\n\t\tthread = kgdb_info[ks->cpu].task;\n\t\tlocal_debuggerinfo = kgdb_info[ks->cpu].debuggerinfo;\n\t} else {\n\t\tlocal_debuggerinfo = NULL;\n\t\tfor_each_online_cpu(i) {\n\t\t\t/*\n\t\t\t * Try to find the task on some other\n\t\t\t * or possibly this node if we do not\n\t\t\t * find the matching task then we try\n\t\t\t * to approximate the results.\n\t\t\t */\n\t\t\tif (thread == kgdb_info[i].task)\n\t\t\t\tlocal_debuggerinfo = kgdb_info[i].debuggerinfo;\n\t\t}\n\t}\n\n\t/*\n\t * All threads that don't have debuggerinfo should be\n\t * in schedule() sleeping, since all other CPUs\n\t * are in kgdb_wait, and thus have debuggerinfo.\n\t */\n\tif (local_debuggerinfo) {\n\t\tpt_regs_to_gdb_regs(gdb_regs, local_debuggerinfo);\n\t} else {\n\t\t/*\n\t\t * Pull stuff saved during switch_to; nothing\n\t\t * else is accessible (or even particularly\n\t\t * relevant).\n\t\t *\n\t\t * This should be enough for a stack trace.\n\t\t */\n\t\tsleeping_thread_to_gdb_regs(gdb_regs, thread);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic void gdb_cmd_getregs(struct kgdb_state *ks)\n{\n\tgdb_get_regs_helper(ks);\n\tkgdb_mem2hex((char *)gdb_regs, remcom_out_buffer, NUMREGBYTES);\n}"
  },
  {
    "function_name": "gdb_get_regs_helper",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "491-532",
    "snippet": "static void gdb_get_regs_helper(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tvoid *local_debuggerinfo;\n\tint i;\n\n\tthread = kgdb_usethread;\n\tif (!thread) {\n\t\tthread = kgdb_info[ks->cpu].task;\n\t\tlocal_debuggerinfo = kgdb_info[ks->cpu].debuggerinfo;\n\t} else {\n\t\tlocal_debuggerinfo = NULL;\n\t\tfor_each_online_cpu(i) {\n\t\t\t/*\n\t\t\t * Try to find the task on some other\n\t\t\t * or possibly this node if we do not\n\t\t\t * find the matching task then we try\n\t\t\t * to approximate the results.\n\t\t\t */\n\t\t\tif (thread == kgdb_info[i].task)\n\t\t\t\tlocal_debuggerinfo = kgdb_info[i].debuggerinfo;\n\t\t}\n\t}\n\n\t/*\n\t * All threads that don't have debuggerinfo should be\n\t * in schedule() sleeping, since all other CPUs\n\t * are in kgdb_wait, and thus have debuggerinfo.\n\t */\n\tif (local_debuggerinfo) {\n\t\tpt_regs_to_gdb_regs(gdb_regs, local_debuggerinfo);\n\t} else {\n\t\t/*\n\t\t * Pull stuff saved during switch_to; nothing\n\t\t * else is accessible (or even particularly\n\t\t * relevant).\n\t\t *\n\t\t * This should be enough for a stack trace.\n\t\t */\n\t\tsleeping_thread_to_gdb_regs(gdb_regs, thread);\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sleeping_thread_to_gdb_regs",
          "args": [
            "gdb_regs",
            "thread"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt_regs_to_gdb_regs",
          "args": [
            "gdb_regs",
            "local_debuggerinfo"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "pt_regs_to_gdb_regs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "339-349",
          "snippet": "void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tdbg_get_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nvoid pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tdbg_get_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nstatic void gdb_get_regs_helper(struct kgdb_state *ks)\n{\n\tstruct task_struct *thread;\n\tvoid *local_debuggerinfo;\n\tint i;\n\n\tthread = kgdb_usethread;\n\tif (!thread) {\n\t\tthread = kgdb_info[ks->cpu].task;\n\t\tlocal_debuggerinfo = kgdb_info[ks->cpu].debuggerinfo;\n\t} else {\n\t\tlocal_debuggerinfo = NULL;\n\t\tfor_each_online_cpu(i) {\n\t\t\t/*\n\t\t\t * Try to find the task on some other\n\t\t\t * or possibly this node if we do not\n\t\t\t * find the matching task then we try\n\t\t\t * to approximate the results.\n\t\t\t */\n\t\t\tif (thread == kgdb_info[i].task)\n\t\t\t\tlocal_debuggerinfo = kgdb_info[i].debuggerinfo;\n\t\t}\n\t}\n\n\t/*\n\t * All threads that don't have debuggerinfo should be\n\t * in schedule() sleeping, since all other CPUs\n\t * are in kgdb_wait, and thus have debuggerinfo.\n\t */\n\tif (local_debuggerinfo) {\n\t\tpt_regs_to_gdb_regs(gdb_regs, local_debuggerinfo);\n\t} else {\n\t\t/*\n\t\t * Pull stuff saved during switch_to; nothing\n\t\t * else is accessible (or even particularly\n\t\t * relevant).\n\t\t *\n\t\t * This should be enough for a stack trace.\n\t\t */\n\t\tsleeping_thread_to_gdb_regs(gdb_regs, thread);\n\t}\n}"
  },
  {
    "function_name": "gdb_cmd_status",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "477-489",
    "snippet": "static void gdb_cmd_status(struct kgdb_state *ks)\n{\n\t/*\n\t * We know that this packet is only sent\n\t * during initial connect.  So to be safe,\n\t * we clear out our breakpoints now in case\n\t * GDB is reconnecting.\n\t */\n\tdbg_remove_all_break();\n\n\tremcom_out_buffer[0] = 'S';\n\thex_byte_pack(&remcom_out_buffer[1], ks->signo);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_out_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "&remcom_out_buffer[1]",
            "ks->signo"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_remove_all_break",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_remove_all_break",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/debug_core.c",
          "lines": "431-453",
          "snippet": "int dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/irq.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/smp.h>",
            "#include <linux/pid.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/init.h>",
            "#include <linux/reboot.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/threads.h>",
            "#include <linux/console.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/pid_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <linux/atomic.h>\n#include <asm/byteorder.h>\n#include <asm/cacheflush.h>\n#include <linux/irq.h>\n#include <linux/rcupdate.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/pid.h>\n#include <linux/nmi.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/init.h>\n#include <linux/reboot.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n#include <linux/ptrace.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/threads.h>\n#include <linux/console.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/serial_core.h>\n#include <linux/clocksource.h>\n#include <linux/pid_namespace.h>\n\nstatic struct kgdb_bkpt\t\tkgdb_break[KGDB_MAX_BREAKPOINTS] = {\n\t[0 ... KGDB_MAX_BREAKPOINTS-1] = { .state = BP_UNDEFINED }\n};\n\nint dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t/* Clear memory breakpoints. */\n\tfor (i = 0; i < KGDB_MAX_BREAKPOINTS; i++) {\n\t\tif (kgdb_break[i].state != BP_ACTIVE)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = BP_UNDEFINED;\n\t}\n\n\t/* Clear hardware breakpoints. */\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_out_buffer[BUFMAX];\n\nstatic void gdb_cmd_status(struct kgdb_state *ks)\n{\n\t/*\n\t * We know that this packet is only sent\n\t * during initial connect.  So to be safe,\n\t * we clear out our breakpoints now in case\n\t * GDB is reconnecting.\n\t */\n\tdbg_remove_all_break();\n\n\tremcom_out_buffer[0] = 'S';\n\thex_byte_pack(&remcom_out_buffer[1], ks->signo);\n}"
  },
  {
    "function_name": "shadow_pid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "462-468",
    "snippet": "static inline int shadow_pid(int realpid)\n{\n\tif (realpid)\n\t\treturn realpid;\n\n\treturn -raw_smp_processor_id() - 2;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline int shadow_pid(int realpid)\n{\n\tif (realpid)\n\t\treturn realpid;\n\n\treturn -raw_smp_processor_id() - 2;\n}"
  },
  {
    "function_name": "getthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "430-455",
    "snippet": "static struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t/*\n\t * Non-positive TIDs are remapped to the cpu shadow information\n\t */\n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid > -NR_CPUS - 2) {\n\t\tif (kgdb_info[-tid - 2].task)\n\t\t\treturn kgdb_info[-tid - 2].task;\n\t\telse\n\t\t\treturn idle_task(-tid - 2);\n\t}\n\tif (tid <= 0) {\n\t\tprintk(KERN_ERR \"KGDB: Internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * find_task_by_pid_ns() does not take the tasklist lock anymore\n\t * but is nicely RCU locked - hence is a pretty resilient\n\t * thing to use:\n\t */\n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "tid",
            "&init_pid_ns"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_pid_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/pid.c",
          "lines": "413-418",
          "snippet": "struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}",
          "includes": [
            "#include <uapi/linux/pidfd.h>",
            "#include <net/sock.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/refcount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/pidfd.h>\n#include <net/sock.h>\n#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/anon_inodes.h>\n#include <linux/refcount.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"KGDB: Internal thread select error\\n\""
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idle_task",
          "args": [
            "-tid - 2"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "idle_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7058-7061",
          "snippet": "struct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct task_struct *idle_task(int cpu)\n{\n\treturn cpu_rq(cpu)->idle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kgdb_active"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t/*\n\t * Non-positive TIDs are remapped to the cpu shadow information\n\t */\n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid > -NR_CPUS - 2) {\n\t\tif (kgdb_info[-tid - 2].task)\n\t\t\treturn kgdb_info[-tid - 2].task;\n\t\telse\n\t\t\treturn idle_task(-tid - 2);\n\t}\n\tif (tid <= 0) {\n\t\tprintk(KERN_ERR \"KGDB: Internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * find_task_by_pid_ns() does not take the tasklist lock anymore\n\t * but is nicely RCU locked - hence is a pretty resilient\n\t * thing to use:\n\t */\n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}"
  },
  {
    "function_name": "int_to_threadref",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "425-428",
    "snippet": "static void int_to_threadref(unsigned char *id, int value)\n{\n\tput_unaligned_be32(value, id);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_unaligned_be32",
          "args": [
            "value",
            "id"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void int_to_threadref(unsigned char *id, int value)\n{\n\tput_unaligned_be32(value, id);\n}"
  },
  {
    "function_name": "pack_threadid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "405-423",
    "snippet": "static char *pack_threadid(char *pkt, unsigned char *id)\n{\n\tunsigned char *limit;\n\tint lzero = 1;\n\n\tlimit = id + (BUF_THREAD_ID_SIZE / 2);\n\twhile (id < limit) {\n\t\tif (!lzero || *id != 0) {\n\t\t\tpkt = hex_byte_pack(pkt, *id);\n\t\t\tlzero = 0;\n\t\t}\n\t\tid++;\n\t}\n\n\tif (lzero)\n\t\tpkt = hex_byte_pack(pkt, 0);\n\n\treturn pkt;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BUF_THREAD_ID_SIZE\t8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "pkt",
            "0"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "pkt",
            "*id"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define BUF_THREAD_ID_SIZE\t8\n\nstatic char *pack_threadid(char *pkt, unsigned char *id)\n{\n\tunsigned char *limit;\n\tint lzero = 1;\n\n\tlimit = id + (BUF_THREAD_ID_SIZE / 2);\n\twhile (id < limit) {\n\t\tif (!lzero || *id != 0) {\n\t\t\tpkt = hex_byte_pack(pkt, *id);\n\t\t\tlzero = 0;\n\t\t}\n\t\tid++;\n\t}\n\n\tif (lzero)\n\t\tpkt = hex_byte_pack(pkt, 0);\n\n\treturn pkt;\n}"
  },
  {
    "function_name": "error_packet",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "388-395",
    "snippet": "static void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void error_packet(char *pkt, int error)\n{\n\terror = -error;\n\tpkt[0] = 'E';\n\tpkt[1] = hex_asc[(error / 10)];\n\tpkt[2] = hex_asc[(error % 10)];\n\tpkt[3] = '\\0';\n}"
  },
  {
    "function_name": "write_mem_msg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "365-386",
    "snippet": "static int write_mem_msg(int binary)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\tunsigned long length;\n\tint err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *(ptr++) == ',' &&\n\t    kgdb_hex2long(&ptr, &length) > 0 && *(ptr++) == ':') {\n\t\tif (binary)\n\t\t\terr = kgdb_ebin2mem(ptr, (char *)addr, length);\n\t\telse\n\t\t\terr = kgdb_hex2mem(ptr, (char *)addr, length);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (CACHE_FLUSH_IS_SAFE)\n\t\t\tflush_icache_range(addr, addr + length);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "addr",
            "addr + length"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgdb_hex2mem",
          "args": [
            "ptr",
            "(char *)addr",
            "length"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2mem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "265-284",
          "snippet": "int kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory that is converted from hex.\n\t */\n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory that is converted from hex.\n\t */\n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_ebin2mem",
          "args": [
            "ptr",
            "(char *)addr",
            "length"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_ebin2mem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "323-336",
          "snippet": "static int kgdb_ebin2mem(char *buf, char *mem, int count)\n{\n\tint size = 0;\n\tchar *c = buf;\n\n\twhile (count-- > 0) {\n\t\tc[size] = *buf++;\n\t\tif (c[size] == 0x7d)\n\t\t\tc[size] = *buf++ ^ 0x20;\n\t\tsize++;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, c, size);\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_ebin2mem(char *buf, char *mem, int count)\n{\n\tint size = 0;\n\tchar *c = buf;\n\n\twhile (count-- > 0) {\n\t\tc[size] = *buf++;\n\t\tif (c[size] == 0x7d)\n\t\t\tc[size] = *buf++ ^ 0x20;\n\t\tsize++;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, c, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kgdb_hex2long",
          "args": [
            "&ptr",
            "&length"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_hex2long",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "290-316",
          "snippet": "int kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\n\nstatic int write_mem_msg(int binary)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\tunsigned long length;\n\tint err;\n\n\tif (kgdb_hex2long(&ptr, &addr) > 0 && *(ptr++) == ',' &&\n\t    kgdb_hex2long(&ptr, &length) > 0 && *(ptr++) == ':') {\n\t\tif (binary)\n\t\t\terr = kgdb_ebin2mem(ptr, (char *)addr, length);\n\t\telse\n\t\t\terr = kgdb_hex2mem(ptr, (char *)addr, length);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (CACHE_FLUSH_IS_SAFE)\n\t\t\tflush_icache_range(addr, addr + length);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "gdb_regs_to_pt_regs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "351-361",
    "snippet": "void gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tdbg_set_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_set_reg",
          "args": [
            "i",
            "ptr + idx",
            "regs"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nvoid gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tdbg_set_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}"
  },
  {
    "function_name": "pt_regs_to_gdb_regs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "339-349",
    "snippet": "void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tdbg_get_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_get_reg",
          "args": [
            "i",
            "ptr + idx",
            "regs"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic unsigned long\t\tgdb_regs[(NUMREGBYTES +\n\t\t\t\t\tsizeof(unsigned long) - 1) /\n\t\t\t\t\tsizeof(unsigned long)];\n\nvoid pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tdbg_get_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}"
  },
  {
    "function_name": "kgdb_ebin2mem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "323-336",
    "snippet": "static int kgdb_ebin2mem(char *buf, char *mem, int count)\n{\n\tint size = 0;\n\tchar *c = buf;\n\n\twhile (count-- > 0) {\n\t\tc[size] = *buf++;\n\t\tif (c[size] == 0x7d)\n\t\t\tc[size] = *buf++ ^ 0x20;\n\t\tsize++;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, c, size);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_kernel_nofault",
          "args": [
            "mem",
            "c",
            "size"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int kgdb_ebin2mem(char *buf, char *mem, int count)\n{\n\tint size = 0;\n\tchar *c = buf;\n\n\twhile (count-- > 0) {\n\t\tc[size] = *buf++;\n\t\tif (c[size] == 0x7d)\n\t\t\tc[size] = *buf++ ^ 0x20;\n\t\tsize++;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, c, size);\n}"
  },
  {
    "function_name": "kgdb_hex2long",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "290-316",
    "snippet": "int kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "**ptr"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}"
  },
  {
    "function_name": "kgdb_hex2mem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "265-284",
    "snippet": "int kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory that is converted from hex.\n\t */\n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_kernel_nofault",
          "args": [
            "mem",
            "tmp_raw",
            "count"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "*tmp_hex--"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "*tmp_hex--"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint kgdb_hex2mem(char *buf, char *mem, int count)\n{\n\tchar *tmp_raw;\n\tchar *tmp_hex;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory that is converted from hex.\n\t */\n\ttmp_raw = buf + count * 2;\n\n\ttmp_hex = tmp_raw - 1;\n\twhile (tmp_hex >= buf) {\n\t\ttmp_raw--;\n\t\t*tmp_raw = hex_to_bin(*tmp_hex--);\n\t\t*tmp_raw |= hex_to_bin(*tmp_hex--) << 4;\n\t}\n\n\treturn copy_to_kernel_nofault(mem, tmp_raw, count);\n}"
  },
  {
    "function_name": "kgdb_mem2hex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "236-258",
    "snippet": "char *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory copy.  Hex conversion will work against this one.\n\t */\n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "buf",
            "*tmp"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "tmp",
            "mem",
            "count"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nchar *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t/*\n\t * We use the upper half of buf as an intermediate buffer for the\n\t * raw memory copy.  Hex conversion will work against this one.\n\t */\n\ttmp = buf + count;\n\n\terr = copy_from_kernel_nofault(tmp, mem, count);\n\tif (err)\n\t\treturn NULL;\n\twhile (count > 0) {\n\t\tbuf = hex_byte_pack(buf, *tmp);\n\t\ttmp++;\n\t\tcount--;\n\t}\n\t*buf = 0;\n\n\treturn buf;\n}"
  },
  {
    "function_name": "gdbstub_msg_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "195-229",
    "snippet": "void gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char gdbmsgbuf[BUFMAX + 1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_packet",
          "args": [
            "gdbmsgbuf"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "put_packet",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "142-191",
          "snippet": "static void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "bufptr",
            "s[i]"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char gdbmsgbuf[BUFMAX + 1];\n\nvoid gdbstub_msg_write(const char *s, int len)\n{\n\tchar *bufptr;\n\tint wcount;\n\tint i;\n\n\tif (len == 0)\n\t\tlen = strlen(s);\n\n\t/* 'O'utput */\n\tgdbmsgbuf[0] = 'O';\n\n\t/* Fill and send buffers... */\n\twhile (len > 0) {\n\t\tbufptr = gdbmsgbuf + 1;\n\n\t\t/* Calculate how many this time */\n\t\tif ((len << 1) > (BUFMAX - 2))\n\t\t\twcount = (BUFMAX - 2) >> 1;\n\t\telse\n\t\t\twcount = len;\n\n\t\t/* Pack in hex chars */\n\t\tfor (i = 0; i < wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t/* Move up */\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t/* Write packet */\n\t\tput_packet(gdbmsgbuf);\n\t}\n}"
  },
  {
    "function_name": "put_packet",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "142-191",
    "snippet": "static void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_io_ops->flush",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "'-'"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdbstub_read_wait",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_read_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "79-85",
          "snippet": "static int gdbstub_read_wait(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\twhile (ret == NO_POLL_CHAR)\n\t\tret = dbg_io_ops->read_char();\n\treturn ret;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int gdbstub_read_wait(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\twhile (ret == NO_POLL_CHAR)\n\t\tret = dbg_io_ops->read_char();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->flush",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "hex_asc_lo(checksum)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_lo",
          "args": [
            "checksum"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "hex_asc_hi(checksum)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_asc_hi",
          "args": [
            "checksum"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "'#'"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "ch"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "'$'"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void put_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tint count;\n\tchar ch;\n\n\t/*\n\t * $<packet info>#<checksum>.\n\t */\n\twhile (1) {\n\t\tdbg_io_ops->write_char('$');\n\t\tchecksum = 0;\n\t\tcount = 0;\n\n\t\twhile ((ch = buffer[count])) {\n\t\t\tdbg_io_ops->write_char(ch);\n\t\t\tchecksum += ch;\n\t\t\tcount++;\n\t\t}\n\n\t\tdbg_io_ops->write_char('#');\n\t\tdbg_io_ops->write_char(hex_asc_hi(checksum));\n\t\tdbg_io_ops->write_char(hex_asc_lo(checksum));\n\t\tif (dbg_io_ops->flush)\n\t\t\tdbg_io_ops->flush();\n\n\t\t/* Now see what we get in reply. */\n\t\tch = gdbstub_read_wait();\n\n\t\tif (ch == 3)\n\t\t\tch = gdbstub_read_wait();\n\n\t\t/* If we get an ACK, we are done. */\n\t\tif (ch == '+')\n\t\t\treturn;\n\n\t\t/*\n\t\t * If we get the start of another packet, this means\n\t\t * that GDB is attempting to reconnect.  We will NAK\n\t\t * the packet being sent, and stop trying to send this\n\t\t * packet.\n\t\t */\n\t\tif (ch == '$') {\n\t\t\tdbg_io_ops->write_char('-');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_packet",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "88-136",
    "snippet": "static void get_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tunsigned char xmitcsum;\n\tint count;\n\tchar ch;\n\n\tdo {\n\t\t/*\n\t\t * Spin and wait around for the start character, ignore all\n\t\t * other characters:\n\t\t */\n\t\twhile ((ch = (gdbstub_read_wait())) != '$')\n\t\t\t/* nothing */;\n\n\t\tkgdb_connected = 1;\n\t\tchecksum = 0;\n\t\txmitcsum = -1;\n\n\t\tcount = 0;\n\n\t\t/*\n\t\t * now, read until a # or end of buffer is found:\n\t\t */\n\t\twhile (count < (BUFMAX - 1)) {\n\t\t\tch = gdbstub_read_wait();\n\t\t\tif (ch == '#')\n\t\t\t\tbreak;\n\t\t\tchecksum = checksum + ch;\n\t\t\tbuffer[count] = ch;\n\t\t\tcount = count + 1;\n\t\t}\n\n\t\tif (ch == '#') {\n\t\t\txmitcsum = hex_to_bin(gdbstub_read_wait()) << 4;\n\t\t\txmitcsum += hex_to_bin(gdbstub_read_wait());\n\n\t\t\tif (checksum != xmitcsum)\n\t\t\t\t/* failed checksum */\n\t\t\t\tdbg_io_ops->write_char('-');\n\t\t\telse\n\t\t\t\t/* successful transfer */\n\t\t\t\tdbg_io_ops->write_char('+');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t}\n\t\tbuffer[count] = 0;\n\t} while (checksum != xmitcsum);\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_io_ops->flush",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "'+'"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->write_char",
          "args": [
            "'-'"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "gdbstub_read_wait()"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gdbstub_read_wait",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "gdbstub_read_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
          "lines": "79-85",
          "snippet": "static int gdbstub_read_wait(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\twhile (ret == NO_POLL_CHAR)\n\t\tret = dbg_io_ops->read_char();\n\treturn ret;\n}",
          "includes": [
            "#include \"debug_core.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/reboot.h>",
            "#include <linux/serial_core.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int gdbstub_read_wait(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\twhile (ret == NO_POLL_CHAR)\n\t\tret = dbg_io_ops->read_char();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hex_to_bin",
          "args": [
            "gdbstub_read_wait()"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void get_packet(char *buffer)\n{\n\tunsigned char checksum;\n\tunsigned char xmitcsum;\n\tint count;\n\tchar ch;\n\n\tdo {\n\t\t/*\n\t\t * Spin and wait around for the start character, ignore all\n\t\t * other characters:\n\t\t */\n\t\twhile ((ch = (gdbstub_read_wait())) != '$')\n\t\t\t/* nothing */;\n\n\t\tkgdb_connected = 1;\n\t\tchecksum = 0;\n\t\txmitcsum = -1;\n\n\t\tcount = 0;\n\n\t\t/*\n\t\t * now, read until a # or end of buffer is found:\n\t\t */\n\t\twhile (count < (BUFMAX - 1)) {\n\t\t\tch = gdbstub_read_wait();\n\t\t\tif (ch == '#')\n\t\t\t\tbreak;\n\t\t\tchecksum = checksum + ch;\n\t\t\tbuffer[count] = ch;\n\t\t\tcount = count + 1;\n\t\t}\n\n\t\tif (ch == '#') {\n\t\t\txmitcsum = hex_to_bin(gdbstub_read_wait()) << 4;\n\t\t\txmitcsum += hex_to_bin(gdbstub_read_wait());\n\n\t\t\tif (checksum != xmitcsum)\n\t\t\t\t/* failed checksum */\n\t\t\t\tdbg_io_ops->write_char('-');\n\t\t\telse\n\t\t\t\t/* successful transfer */\n\t\t\t\tdbg_io_ops->write_char('+');\n\t\t\tif (dbg_io_ops->flush)\n\t\t\t\tdbg_io_ops->flush();\n\t\t}\n\t\tbuffer[count] = 0;\n\t} while (checksum != xmitcsum);\n}"
  },
  {
    "function_name": "gdbstub_read_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "79-85",
    "snippet": "static int gdbstub_read_wait(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\twhile (ret == NO_POLL_CHAR)\n\t\tret = dbg_io_ops->read_char();\n\treturn ret;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbg_io_ops->read_char",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_io_ops->read_char",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int gdbstub_read_wait(void)\n{\n\tint ret = dbg_io_ops->read_char();\n\twhile (ret == NO_POLL_CHAR)\n\t\tret = dbg_io_ops->read_char();\n\treturn ret;\n}"
  },
  {
    "function_name": "gdbstub_read_wait",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/gdbstub.c",
    "lines": "57-77",
    "snippet": "static int gdbstub_read_wait(void)\n{\n\tint ret = -1;\n\tint i;\n\n\tif (unlikely(gdbstub_use_prev_in_buf)) {\n\t\tif (gdbstub_prev_in_buf_pos < gdbstub_use_prev_in_buf)\n\t\t\treturn remcom_in_buffer[gdbstub_prev_in_buf_pos++];\n\t\telse\n\t\t\tgdbstub_use_prev_in_buf = 0;\n\t}\n\n\t/* poll any additional I/O interfaces that are defined */\n\twhile (ret < 0)\n\t\tfor (i = 0; kdb_poll_funcs[i] != NULL; i++) {\n\t\t\tret = kdb_poll_funcs[i]();\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"debug_core.h\"",
      "#include <asm/unaligned.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/reboot.h>",
      "#include <linux/serial_core.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char\t\t\tremcom_in_buffer[BUFMAX];",
      "static int\t\t\tgdbstub_use_prev_in_buf;",
      "static int\t\t\tgdbstub_prev_in_buf_pos;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_poll_funcs[i]",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gdbstub_use_prev_in_buf"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"debug_core.h\"\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/reboot.h>\n#include <linux/serial_core.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic char\t\t\tremcom_in_buffer[BUFMAX];\nstatic int\t\t\tgdbstub_use_prev_in_buf;\nstatic int\t\t\tgdbstub_prev_in_buf_pos;\n\nstatic int gdbstub_read_wait(void)\n{\n\tint ret = -1;\n\tint i;\n\n\tif (unlikely(gdbstub_use_prev_in_buf)) {\n\t\tif (gdbstub_prev_in_buf_pos < gdbstub_use_prev_in_buf)\n\t\t\treturn remcom_in_buffer[gdbstub_prev_in_buf_pos++];\n\t\telse\n\t\t\tgdbstub_use_prev_in_buf = 0;\n\t}\n\n\t/* poll any additional I/O interfaces that are defined */\n\twhile (ret < 0)\n\t\tfor (i = 0; kdb_poll_funcs[i] != NULL; i++) {\n\t\t\tret = kdb_poll_funcs[i]();\n\t\t\tif (ret > 0)\n\t\t\t\tbreak;\n\t\t}\n\treturn ret;\n}"
  }
]