[
  {
    "function_name": "autogroup_path",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "262-268",
    "snippet": "int autogroup_path(struct task_group *tg, char *buf, int buflen)\n{\n\tif (!task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\treturn snprintf(buf, buflen, \"%s-%ld\", \"/autogroup\", tg->autogroup->id);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "buflen",
            "\"%s-%ld\"",
            "\"/autogroup\"",
            "tg->autogroup->id"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_group_is_autogroup",
          "args": [
            "tg"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_is_autogroup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.h",
          "lines": "44-47",
          "snippet": "static inline bool task_group_is_autogroup(struct task_group *tg)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool task_group_is_autogroup(struct task_group *tg)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nint autogroup_path(struct task_group *tg, char *buf, int buflen)\n{\n\tif (!task_group_is_autogroup(tg))\n\t\treturn 0;\n\n\treturn snprintf(buf, buflen, \"%s-%ld\", \"/autogroup\", tg->autogroup->id);\n}"
  },
  {
    "function_name": "proc_sched_autogroup_show_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "246-259",
    "snippet": "void proc_sched_autogroup_show_task(struct task_struct *p, struct seq_file *m)\n{\n\tstruct autogroup *ag = autogroup_task_get(p);\n\n\tif (!task_group_is_autogroup(ag->tg))\n\t\tgoto out;\n\n\tdown_read(&ag->lock);\n\tseq_printf(m, \"/autogroup-%ld nice %d\\n\", ag->id, ag->nice);\n\tup_read(&ag->lock);\n\nout:\n\tautogroup_kref_put(ag);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autogroup_kref_put",
          "args": [
            "ag"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "38-41",
          "snippet": "static inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ag->lock"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"/autogroup-%ld nice %d\\n\"",
            "ag->id",
            "ag->nice"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ag->lock"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_group_is_autogroup",
          "args": [
            "ag->tg"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "task_group_is_autogroup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.h",
          "lines": "44-47",
          "snippet": "static inline bool task_group_is_autogroup(struct task_group *tg)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool task_group_is_autogroup(struct task_group *tg)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "autogroup_task_get",
          "args": [
            "p"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_task_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "49-61",
          "snippet": "static inline struct autogroup *autogroup_task_get(struct task_struct *p)\n{\n\tstruct autogroup *ag;\n\tunsigned long flags;\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn autogroup_kref_get(&autogroup_default);\n\n\tag = autogroup_kref_get(p->signal->autogroup);\n\tunlock_task_sighand(p, &flags);\n\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct autogroup autogroup_default;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic struct autogroup autogroup_default;\n\nstatic inline struct autogroup *autogroup_task_get(struct task_struct *p)\n{\n\tstruct autogroup *ag;\n\tunsigned long flags;\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn autogroup_kref_get(&autogroup_default);\n\n\tag = autogroup_kref_get(p->signal->autogroup);\n\tunlock_task_sighand(p, &flags);\n\n\treturn ag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nvoid proc_sched_autogroup_show_task(struct task_struct *p, struct seq_file *m)\n{\n\tstruct autogroup *ag = autogroup_task_get(p);\n\n\tif (!task_group_is_autogroup(ag->tg))\n\t\tgoto out;\n\n\tdown_read(&ag->lock);\n\tseq_printf(m, \"/autogroup-%ld nice %d\\n\", ag->id, ag->nice);\n\tup_read(&ag->lock);\n\nout:\n\tautogroup_kref_put(ag);\n}"
  },
  {
    "function_name": "proc_sched_autogroup_set_nice",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "208-244",
    "snippet": "int proc_sched_autogroup_set_nice(struct task_struct *p, int nice)\n{\n\tstatic unsigned long next = INITIAL_JIFFIES;\n\tstruct autogroup *ag;\n\tunsigned long shares;\n\tint err, idx;\n\n\tif (nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn -EINVAL;\n\n\terr = security_task_setnice(current, nice);\n\tif (err)\n\t\treturn err;\n\n\tif (nice < 0 && !can_nice(current, nice))\n\t\treturn -EPERM;\n\n\t/* This is a heavy operation, taking global locks.. */\n\tif (!capable(CAP_SYS_ADMIN) && time_before(jiffies, next))\n\t\treturn -EAGAIN;\n\n\tnext = HZ / 10 + jiffies;\n\tag = autogroup_task_get(p);\n\n\tidx = array_index_nospec(nice + 20, 40);\n\tshares = scale_load(sched_prio_to_weight[idx]);\n\n\tdown_write(&ag->lock);\n\terr = sched_group_set_shares(ag->tg, shares);\n\tif (!err)\n\t\tag->nice = nice;\n\tup_write(&ag->lock);\n\n\tautogroup_kref_put(ag);\n\n\treturn err;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autogroup_kref_put",
          "args": [
            "ag"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "38-41",
          "snippet": "static inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ag->lock"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_group_set_shares",
          "args": [
            "ag->tg",
            "shares"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "sched_group_set_shares",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "11578-11590",
          "snippet": "int sched_group_set_shares(struct task_group *tg, unsigned long shares)\n{\n\tint ret;\n\n\tmutex_lock(&shares_mutex);\n\tif (tg_is_idle(tg))\n\t\tret = -EINVAL;\n\telse\n\t\tret = __sched_group_set_shares(tg, shares);\n\tmutex_unlock(&shares_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nint sched_group_set_shares(struct task_group *tg, unsigned long shares)\n{\n\tint ret;\n\n\tmutex_lock(&shares_mutex);\n\tif (tg_is_idle(tg))\n\t\tret = -EINVAL;\n\telse\n\t\tret = __sched_group_set_shares(tg, shares);\n\tmutex_unlock(&shares_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ag->lock"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scale_load",
          "args": [
            "sched_prio_to_weight[idx]"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "nice + 20",
            "40"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autogroup_task_get",
          "args": [
            "p"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_task_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "49-61",
          "snippet": "static inline struct autogroup *autogroup_task_get(struct task_struct *p)\n{\n\tstruct autogroup *ag;\n\tunsigned long flags;\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn autogroup_kref_get(&autogroup_default);\n\n\tag = autogroup_kref_get(p->signal->autogroup);\n\tunlock_task_sighand(p, &flags);\n\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct autogroup autogroup_default;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic struct autogroup autogroup_default;\n\nstatic inline struct autogroup *autogroup_task_get(struct task_struct *p)\n{\n\tstruct autogroup *ag;\n\tunsigned long flags;\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn autogroup_kref_get(&autogroup_default);\n\n\tag = autogroup_kref_get(p->signal->autogroup);\n\tunlock_task_sighand(p, &flags);\n\n\treturn ag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "next"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "can_nice",
          "args": [
            "current",
            "nice"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "can_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6950-6957",
          "snippet": "int can_nice(const struct task_struct *p, const int nice)\n{\n\t/* Convert nice value [19,-20] to rlimit style value [1,40]: */\n\tint nice_rlim = nice_to_rlimit(nice);\n\n\treturn (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||\n\t\tcapable(CAP_SYS_NICE));\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint can_nice(const struct task_struct *p, const int nice)\n{\n\t/* Convert nice value [19,-20] to rlimit style value [1,40]: */\n\tint nice_rlim = nice_to_rlimit(nice);\n\n\treturn (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||\n\t\tcapable(CAP_SYS_NICE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_setnice",
          "args": [
            "current",
            "nice"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nint proc_sched_autogroup_set_nice(struct task_struct *p, int nice)\n{\n\tstatic unsigned long next = INITIAL_JIFFIES;\n\tstruct autogroup *ag;\n\tunsigned long shares;\n\tint err, idx;\n\n\tif (nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn -EINVAL;\n\n\terr = security_task_setnice(current, nice);\n\tif (err)\n\t\treturn err;\n\n\tif (nice < 0 && !can_nice(current, nice))\n\t\treturn -EPERM;\n\n\t/* This is a heavy operation, taking global locks.. */\n\tif (!capable(CAP_SYS_ADMIN) && time_before(jiffies, next))\n\t\treturn -EAGAIN;\n\n\tnext = HZ / 10 + jiffies;\n\tag = autogroup_task_get(p);\n\n\tidx = array_index_nospec(nice + 20, 40);\n\tshares = scale_load(sched_prio_to_weight[idx]);\n\n\tdown_write(&ag->lock);\n\terr = sched_group_set_shares(ag->tg, shares);\n\tif (!err)\n\t\tag->nice = nice;\n\tup_write(&ag->lock);\n\n\tautogroup_kref_put(ag);\n\n\treturn err;\n}"
  },
  {
    "function_name": "setup_autogroup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "198-203",
    "snippet": "static int __init setup_autogroup(char *str)\n{\n\tsysctl_sched_autogroup_enabled = 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic int __init setup_autogroup(char *str)\n{\n\tsysctl_sched_autogroup_enabled = 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "sched_autogroup_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "193-196",
    "snippet": "void sched_autogroup_exit(struct signal_struct *sig)\n{\n\tautogroup_kref_put(sig->autogroup);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autogroup_kref_put",
          "args": [
            "sig->autogroup"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "38-41",
          "snippet": "static inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nvoid sched_autogroup_exit(struct signal_struct *sig)\n{\n\tautogroup_kref_put(sig->autogroup);\n}"
  },
  {
    "function_name": "sched_autogroup_fork",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "188-191",
    "snippet": "void sched_autogroup_fork(struct signal_struct *sig)\n{\n\tsig->autogroup = autogroup_task_get(current);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autogroup_task_get",
          "args": [
            "current"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_task_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "49-61",
          "snippet": "static inline struct autogroup *autogroup_task_get(struct task_struct *p)\n{\n\tstruct autogroup *ag;\n\tunsigned long flags;\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn autogroup_kref_get(&autogroup_default);\n\n\tag = autogroup_kref_get(p->signal->autogroup);\n\tunlock_task_sighand(p, &flags);\n\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct autogroup autogroup_default;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic struct autogroup autogroup_default;\n\nstatic inline struct autogroup *autogroup_task_get(struct task_struct *p)\n{\n\tstruct autogroup *ag;\n\tunsigned long flags;\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn autogroup_kref_get(&autogroup_default);\n\n\tag = autogroup_kref_get(p->signal->autogroup);\n\tunlock_task_sighand(p, &flags);\n\n\treturn ag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nvoid sched_autogroup_fork(struct signal_struct *sig)\n{\n\tsig->autogroup = autogroup_task_get(current);\n}"
  },
  {
    "function_name": "sched_autogroup_detach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "182-185",
    "snippet": "void sched_autogroup_detach(struct task_struct *p)\n{\n\tautogroup_move_group(p, &autogroup_default);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct autogroup autogroup_default;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "autogroup_move_group",
          "args": [
            "p",
            "&autogroup_default"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_move_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "135-167",
          "snippet": "static void\nautogroup_move_group(struct task_struct *p, struct autogroup *ag)\n{\n\tstruct autogroup *prev;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tBUG_ON(!lock_task_sighand(p, &flags));\n\n\tprev = p->signal->autogroup;\n\tif (prev == ag) {\n\t\tunlock_task_sighand(p, &flags);\n\t\treturn;\n\t}\n\n\tp->signal->autogroup = autogroup_kref_get(ag);\n\t/*\n\t * We can't avoid sched_move_task() after we changed signal->autogroup,\n\t * this process can already run with task_group() == prev->tg or we can\n\t * race with cgroup code which can read autogroup = prev under rq->lock.\n\t * In the latter case for_each_thread() can not miss a migrating thread,\n\t * cpu_cgroup_attach() must not be possible after cgroup_exit() and it\n\t * can't be removed from thread list, we hold ->siglock.\n\t *\n\t * If an exiting thread was already removed from thread list we rely on\n\t * sched_autogroup_exit_task().\n\t */\n\tfor_each_thread(p, t)\n\t\tsched_move_task(t);\n\n\tunlock_task_sighand(p, &flags);\n\tautogroup_kref_put(prev);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic void\nautogroup_move_group(struct task_struct *p, struct autogroup *ag)\n{\n\tstruct autogroup *prev;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tBUG_ON(!lock_task_sighand(p, &flags));\n\n\tprev = p->signal->autogroup;\n\tif (prev == ag) {\n\t\tunlock_task_sighand(p, &flags);\n\t\treturn;\n\t}\n\n\tp->signal->autogroup = autogroup_kref_get(ag);\n\t/*\n\t * We can't avoid sched_move_task() after we changed signal->autogroup,\n\t * this process can already run with task_group() == prev->tg or we can\n\t * race with cgroup code which can read autogroup = prev under rq->lock.\n\t * In the latter case for_each_thread() can not miss a migrating thread,\n\t * cpu_cgroup_attach() must not be possible after cgroup_exit() and it\n\t * can't be removed from thread list, we hold ->siglock.\n\t *\n\t * If an exiting thread was already removed from thread list we rely on\n\t * sched_autogroup_exit_task().\n\t */\n\tfor_each_thread(p, t)\n\t\tsched_move_task(t);\n\n\tunlock_task_sighand(p, &flags);\n\tautogroup_kref_put(prev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic struct autogroup autogroup_default;\n\nvoid sched_autogroup_detach(struct task_struct *p)\n{\n\tautogroup_move_group(p, &autogroup_default);\n}"
  },
  {
    "function_name": "sched_autogroup_create_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "170-178",
    "snippet": "void sched_autogroup_create_attach(struct task_struct *p)\n{\n\tstruct autogroup *ag = autogroup_create();\n\n\tautogroup_move_group(p, ag);\n\n\t/* Drop extra reference added by autogroup_create(): */\n\tautogroup_kref_put(ag);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autogroup_kref_put",
          "args": [
            "ag"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "38-41",
          "snippet": "static inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autogroup_move_group",
          "args": [
            "p",
            "ag"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_move_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "135-167",
          "snippet": "static void\nautogroup_move_group(struct task_struct *p, struct autogroup *ag)\n{\n\tstruct autogroup *prev;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tBUG_ON(!lock_task_sighand(p, &flags));\n\n\tprev = p->signal->autogroup;\n\tif (prev == ag) {\n\t\tunlock_task_sighand(p, &flags);\n\t\treturn;\n\t}\n\n\tp->signal->autogroup = autogroup_kref_get(ag);\n\t/*\n\t * We can't avoid sched_move_task() after we changed signal->autogroup,\n\t * this process can already run with task_group() == prev->tg or we can\n\t * race with cgroup code which can read autogroup = prev under rq->lock.\n\t * In the latter case for_each_thread() can not miss a migrating thread,\n\t * cpu_cgroup_attach() must not be possible after cgroup_exit() and it\n\t * can't be removed from thread list, we hold ->siglock.\n\t *\n\t * If an exiting thread was already removed from thread list we rely on\n\t * sched_autogroup_exit_task().\n\t */\n\tfor_each_thread(p, t)\n\t\tsched_move_task(t);\n\n\tunlock_task_sighand(p, &flags);\n\tautogroup_kref_put(prev);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic void\nautogroup_move_group(struct task_struct *p, struct autogroup *ag)\n{\n\tstruct autogroup *prev;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tBUG_ON(!lock_task_sighand(p, &flags));\n\n\tprev = p->signal->autogroup;\n\tif (prev == ag) {\n\t\tunlock_task_sighand(p, &flags);\n\t\treturn;\n\t}\n\n\tp->signal->autogroup = autogroup_kref_get(ag);\n\t/*\n\t * We can't avoid sched_move_task() after we changed signal->autogroup,\n\t * this process can already run with task_group() == prev->tg or we can\n\t * race with cgroup code which can read autogroup = prev under rq->lock.\n\t * In the latter case for_each_thread() can not miss a migrating thread,\n\t * cpu_cgroup_attach() must not be possible after cgroup_exit() and it\n\t * can't be removed from thread list, we hold ->siglock.\n\t *\n\t * If an exiting thread was already removed from thread list we rely on\n\t * sched_autogroup_exit_task().\n\t */\n\tfor_each_thread(p, t)\n\t\tsched_move_task(t);\n\n\tunlock_task_sighand(p, &flags);\n\tautogroup_kref_put(prev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "autogroup_create",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_create",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "63-105",
          "snippet": "static inline struct autogroup *autogroup_create(void)\n{\n\tstruct autogroup *ag = kzalloc(sizeof(*ag), GFP_KERNEL);\n\tstruct task_group *tg;\n\n\tif (!ag)\n\t\tgoto out_fail;\n\n\ttg = sched_create_group(&root_task_group);\n\tif (IS_ERR(tg))\n\t\tgoto out_free;\n\n\tkref_init(&ag->kref);\n\tinit_rwsem(&ag->lock);\n\tag->id = atomic_inc_return(&autogroup_seq_nr);\n\tag->tg = tg;\n#ifdef CONFIG_RT_GROUP_SCHED\n\t/*\n\t * Autogroup RT tasks are redirected to the root task group\n\t * so we don't have to move tasks around upon policy change,\n\t * or flail around trying to allocate bandwidth on the fly.\n\t * A bandwidth exception in __sched_setscheduler() allows\n\t * the policy change to proceed.\n\t */\n\tfree_rt_sched_group(tg);\n\ttg->rt_se = root_task_group.rt_se;\n\ttg->rt_rq = root_task_group.rt_rq;\n#endif\n\ttg->autogroup = ag;\n\n\tsched_online_group(tg, &root_task_group);\n\treturn ag;\n\nout_free:\n\tkfree(ag);\nout_fail:\n\tif (printk_ratelimit()) {\n\t\tprintk(KERN_WARNING \"autogroup_create: %s failure.\\n\",\n\t\t\tag ? \"sched_create_group()\" : \"kzalloc()\");\n\t}\n\n\treturn autogroup_kref_get(&autogroup_default);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct autogroup autogroup_default;",
            "static atomic_t autogroup_seq_nr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic struct autogroup autogroup_default;\nstatic atomic_t autogroup_seq_nr;\n\nstatic inline struct autogroup *autogroup_create(void)\n{\n\tstruct autogroup *ag = kzalloc(sizeof(*ag), GFP_KERNEL);\n\tstruct task_group *tg;\n\n\tif (!ag)\n\t\tgoto out_fail;\n\n\ttg = sched_create_group(&root_task_group);\n\tif (IS_ERR(tg))\n\t\tgoto out_free;\n\n\tkref_init(&ag->kref);\n\tinit_rwsem(&ag->lock);\n\tag->id = atomic_inc_return(&autogroup_seq_nr);\n\tag->tg = tg;\n#ifdef CONFIG_RT_GROUP_SCHED\n\t/*\n\t * Autogroup RT tasks are redirected to the root task group\n\t * so we don't have to move tasks around upon policy change,\n\t * or flail around trying to allocate bandwidth on the fly.\n\t * A bandwidth exception in __sched_setscheduler() allows\n\t * the policy change to proceed.\n\t */\n\tfree_rt_sched_group(tg);\n\ttg->rt_se = root_task_group.rt_se;\n\ttg->rt_rq = root_task_group.rt_rq;\n#endif\n\ttg->autogroup = ag;\n\n\tsched_online_group(tg, &root_task_group);\n\treturn ag;\n\nout_free:\n\tkfree(ag);\nout_fail:\n\tif (printk_ratelimit()) {\n\t\tprintk(KERN_WARNING \"autogroup_create: %s failure.\\n\",\n\t\t\tag ? \"sched_create_group()\" : \"kzalloc()\");\n\t}\n\n\treturn autogroup_kref_get(&autogroup_default);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nvoid sched_autogroup_create_attach(struct task_struct *p)\n{\n\tstruct autogroup *ag = autogroup_create();\n\n\tautogroup_move_group(p, ag);\n\n\t/* Drop extra reference added by autogroup_create(): */\n\tautogroup_kref_put(ag);\n}"
  },
  {
    "function_name": "autogroup_move_group",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "135-167",
    "snippet": "static void\nautogroup_move_group(struct task_struct *p, struct autogroup *ag)\n{\n\tstruct autogroup *prev;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tBUG_ON(!lock_task_sighand(p, &flags));\n\n\tprev = p->signal->autogroup;\n\tif (prev == ag) {\n\t\tunlock_task_sighand(p, &flags);\n\t\treturn;\n\t}\n\n\tp->signal->autogroup = autogroup_kref_get(ag);\n\t/*\n\t * We can't avoid sched_move_task() after we changed signal->autogroup,\n\t * this process can already run with task_group() == prev->tg or we can\n\t * race with cgroup code which can read autogroup = prev under rq->lock.\n\t * In the latter case for_each_thread() can not miss a migrating thread,\n\t * cpu_cgroup_attach() must not be possible after cgroup_exit() and it\n\t * can't be removed from thread list, we hold ->siglock.\n\t *\n\t * If an exiting thread was already removed from thread list we rely on\n\t * sched_autogroup_exit_task().\n\t */\n\tfor_each_thread(p, t)\n\t\tsched_move_task(t);\n\n\tunlock_task_sighand(p, &flags);\n\tautogroup_kref_put(prev);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "autogroup_kref_put",
          "args": [
            "prev"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "38-41",
          "snippet": "static inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_move_task",
          "args": [
            "t"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "sched_move_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "9886-9919",
          "snippet": "void sched_move_task(struct task_struct *tsk)\n{\n\tint queued, running, queue_flags =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(tsk, &rf);\n\tupdate_rq_clock(rq);\n\n\trunning = task_current(rq, tsk);\n\tqueued = task_on_rq_queued(tsk);\n\n\tif (queued)\n\t\tdequeue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, tsk);\n\n\tsched_change_group(tsk, TASK_MOVE_GROUP);\n\n\tif (queued)\n\t\tenqueue_task(rq, tsk, queue_flags);\n\tif (running) {\n\t\tset_next_task(rq, tsk);\n\t\t/*\n\t\t * After changing group, the running task may have joined a\n\t\t * throttled one but it's still the running task. Trigger a\n\t\t * resched to make sure that task can still run.\n\t\t */\n\t\tresched_curr(rq);\n\t}\n\n\ttask_rq_unlock(rq, tsk, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_move_task(struct task_struct *tsk)\n{\n\tint queued, running, queue_flags =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(tsk, &rf);\n\tupdate_rq_clock(rq);\n\n\trunning = task_current(rq, tsk);\n\tqueued = task_on_rq_queued(tsk);\n\n\tif (queued)\n\t\tdequeue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, tsk);\n\n\tsched_change_group(tsk, TASK_MOVE_GROUP);\n\n\tif (queued)\n\t\tenqueue_task(rq, tsk, queue_flags);\n\tif (running) {\n\t\tset_next_task(rq, tsk);\n\t\t/*\n\t\t * After changing group, the running task may have joined a\n\t\t * throttled one but it's still the running task. Trigger a\n\t\t * resched to make sure that task can still run.\n\t\t */\n\t\tresched_curr(rq);\n\t}\n\n\ttask_rq_unlock(rq, tsk, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autogroup_kref_get",
          "args": [
            "ag"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "43-47",
          "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lock_task_sighand(p, &flags)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic void\nautogroup_move_group(struct task_struct *p, struct autogroup *ag)\n{\n\tstruct autogroup *prev;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\n\tBUG_ON(!lock_task_sighand(p, &flags));\n\n\tprev = p->signal->autogroup;\n\tif (prev == ag) {\n\t\tunlock_task_sighand(p, &flags);\n\t\treturn;\n\t}\n\n\tp->signal->autogroup = autogroup_kref_get(ag);\n\t/*\n\t * We can't avoid sched_move_task() after we changed signal->autogroup,\n\t * this process can already run with task_group() == prev->tg or we can\n\t * race with cgroup code which can read autogroup = prev under rq->lock.\n\t * In the latter case for_each_thread() can not miss a migrating thread,\n\t * cpu_cgroup_attach() must not be possible after cgroup_exit() and it\n\t * can't be removed from thread list, we hold ->siglock.\n\t *\n\t * If an exiting thread was already removed from thread list we rely on\n\t * sched_autogroup_exit_task().\n\t */\n\tfor_each_thread(p, t)\n\t\tsched_move_task(t);\n\n\tunlock_task_sighand(p, &flags);\n\tautogroup_kref_put(prev);\n}"
  },
  {
    "function_name": "sched_autogroup_exit_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "125-133",
    "snippet": "void sched_autogroup_exit_task(struct task_struct *p)\n{\n\t/*\n\t * We are going to call exit_notify() and autogroup_move_group() can't\n\t * see this thread after that: we can no longer use signal->autogroup.\n\t * See the PF_EXITING check in task_wants_autogroup().\n\t */\n\tsched_move_task(p);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_move_task",
          "args": [
            "p"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "sched_move_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "9886-9919",
          "snippet": "void sched_move_task(struct task_struct *tsk)\n{\n\tint queued, running, queue_flags =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(tsk, &rf);\n\tupdate_rq_clock(rq);\n\n\trunning = task_current(rq, tsk);\n\tqueued = task_on_rq_queued(tsk);\n\n\tif (queued)\n\t\tdequeue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, tsk);\n\n\tsched_change_group(tsk, TASK_MOVE_GROUP);\n\n\tif (queued)\n\t\tenqueue_task(rq, tsk, queue_flags);\n\tif (running) {\n\t\tset_next_task(rq, tsk);\n\t\t/*\n\t\t * After changing group, the running task may have joined a\n\t\t * throttled one but it's still the running task. Trigger a\n\t\t * resched to make sure that task can still run.\n\t\t */\n\t\tresched_curr(rq);\n\t}\n\n\ttask_rq_unlock(rq, tsk, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_move_task(struct task_struct *tsk)\n{\n\tint queued, running, queue_flags =\n\t\tDEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(tsk, &rf);\n\tupdate_rq_clock(rq);\n\n\trunning = task_current(rq, tsk);\n\tqueued = task_on_rq_queued(tsk);\n\n\tif (queued)\n\t\tdequeue_task(rq, tsk, queue_flags);\n\tif (running)\n\t\tput_prev_task(rq, tsk);\n\n\tsched_change_group(tsk, TASK_MOVE_GROUP);\n\n\tif (queued)\n\t\tenqueue_task(rq, tsk, queue_flags);\n\tif (running) {\n\t\tset_next_task(rq, tsk);\n\t\t/*\n\t\t * After changing group, the running task may have joined a\n\t\t * throttled one but it's still the running task. Trigger a\n\t\t * resched to make sure that task can still run.\n\t\t */\n\t\tresched_curr(rq);\n\t}\n\n\ttask_rq_unlock(rq, tsk, &rf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nvoid sched_autogroup_exit_task(struct task_struct *p)\n{\n\t/*\n\t * We are going to call exit_notify() and autogroup_move_group() can't\n\t * see this thread after that: we can no longer use signal->autogroup.\n\t * See the PF_EXITING check in task_wants_autogroup().\n\t */\n\tsched_move_task(p);\n}"
  },
  {
    "function_name": "task_wants_autogroup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "107-123",
    "snippet": "bool task_wants_autogroup(struct task_struct *p, struct task_group *tg)\n{\n\tif (tg != &root_task_group)\n\t\treturn false;\n\t/*\n\t * If we race with autogroup_move_group() the caller can use the old\n\t * value of signal->autogroup but in this case sched_move_task() will\n\t * be called again before autogroup_kref_put().\n\t *\n\t * However, there is no way sched_autogroup_exit_task() could tell us\n\t * to avoid autogroup->tg, so we abuse PF_EXITING flag for this case.\n\t */\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nbool task_wants_autogroup(struct task_struct *p, struct task_group *tg)\n{\n\tif (tg != &root_task_group)\n\t\treturn false;\n\t/*\n\t * If we race with autogroup_move_group() the caller can use the old\n\t * value of signal->autogroup but in this case sched_move_task() will\n\t * be called again before autogroup_kref_put().\n\t *\n\t * However, there is no way sched_autogroup_exit_task() could tell us\n\t * to avoid autogroup->tg, so we abuse PF_EXITING flag for this case.\n\t */\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "autogroup_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "63-105",
    "snippet": "static inline struct autogroup *autogroup_create(void)\n{\n\tstruct autogroup *ag = kzalloc(sizeof(*ag), GFP_KERNEL);\n\tstruct task_group *tg;\n\n\tif (!ag)\n\t\tgoto out_fail;\n\n\ttg = sched_create_group(&root_task_group);\n\tif (IS_ERR(tg))\n\t\tgoto out_free;\n\n\tkref_init(&ag->kref);\n\tinit_rwsem(&ag->lock);\n\tag->id = atomic_inc_return(&autogroup_seq_nr);\n\tag->tg = tg;\n#ifdef CONFIG_RT_GROUP_SCHED\n\t/*\n\t * Autogroup RT tasks are redirected to the root task group\n\t * so we don't have to move tasks around upon policy change,\n\t * or flail around trying to allocate bandwidth on the fly.\n\t * A bandwidth exception in __sched_setscheduler() allows\n\t * the policy change to proceed.\n\t */\n\tfree_rt_sched_group(tg);\n\ttg->rt_se = root_task_group.rt_se;\n\ttg->rt_rq = root_task_group.rt_rq;\n#endif\n\ttg->autogroup = ag;\n\n\tsched_online_group(tg, &root_task_group);\n\treturn ag;\n\nout_free:\n\tkfree(ag);\nout_fail:\n\tif (printk_ratelimit()) {\n\t\tprintk(KERN_WARNING \"autogroup_create: %s failure.\\n\",\n\t\t\tag ? \"sched_create_group()\" : \"kzalloc()\");\n\t}\n\n\treturn autogroup_kref_get(&autogroup_default);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct autogroup autogroup_default;",
      "static atomic_t autogroup_seq_nr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "autogroup_kref_get",
          "args": [
            "&autogroup_default"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "43-47",
          "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"autogroup_create: %s failure.\\n\"",
            "ag ? \"sched_create_group()\" : \"kzalloc()\""
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimit",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ag"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_online_group",
          "args": [
            "tg",
            "&root_task_group"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "sched_online_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "9803-9819",
          "snippet": "void sched_online_group(struct task_group *tg, struct task_group *parent)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_add_rcu(&tg->list, &task_groups);\n\n\t/* Root should already exist: */\n\tWARN_ON(!parent);\n\n\ttg->parent = parent;\n\tINIT_LIST_HEAD(&tg->children);\n\tlist_add_rcu(&tg->siblings, &parent->children);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n\n\tonline_fair_sched_group(tg);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static DEFINE_SPINLOCK(task_group_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(task_group_lock);\n\nvoid sched_online_group(struct task_group *tg, struct task_group *parent)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_add_rcu(&tg->list, &task_groups);\n\n\t/* Root should already exist: */\n\tWARN_ON(!parent);\n\n\ttg->parent = parent;\n\tINIT_LIST_HEAD(&tg->children);\n\tlist_add_rcu(&tg->siblings, &parent->children);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n\n\tonline_fair_sched_group(tg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_rt_sched_group",
          "args": [
            "tg"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "free_rt_sched_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/rt.c",
          "lines": "264-264",
          "snippet": "void free_rt_sched_group(struct task_group *tg) { }",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid free_rt_sched_group(struct task_group *tg) { }"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&autogroup_seq_nr"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&ag->lock"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&ag->kref"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tg"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_create_group",
          "args": [
            "&root_task_group"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "sched_create_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "9780-9801",
          "snippet": "struct task_group *sched_create_group(struct task_group *parent)\n{\n\tstruct task_group *tg;\n\n\ttg = kmem_cache_alloc(task_group_cache, GFP_KERNEL | __GFP_ZERO);\n\tif (!tg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!alloc_fair_sched_group(tg, parent))\n\t\tgoto err;\n\n\tif (!alloc_rt_sched_group(tg, parent))\n\t\tgoto err;\n\n\talloc_uclamp_sched_group(tg, parent);\n\n\treturn tg;\n\nerr:\n\tsched_free_group(tg);\n\treturn ERR_PTR(-ENOMEM);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct task_group *sched_create_group(struct task_group *parent)\n{\n\tstruct task_group *tg;\n\n\ttg = kmem_cache_alloc(task_group_cache, GFP_KERNEL | __GFP_ZERO);\n\tif (!tg)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!alloc_fair_sched_group(tg, parent))\n\t\tgoto err;\n\n\tif (!alloc_rt_sched_group(tg, parent))\n\t\tgoto err;\n\n\talloc_uclamp_sched_group(tg, parent);\n\n\treturn tg;\n\nerr:\n\tsched_free_group(tg);\n\treturn ERR_PTR(-ENOMEM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ag)",
            "GFP_KERNEL"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic struct autogroup autogroup_default;\nstatic atomic_t autogroup_seq_nr;\n\nstatic inline struct autogroup *autogroup_create(void)\n{\n\tstruct autogroup *ag = kzalloc(sizeof(*ag), GFP_KERNEL);\n\tstruct task_group *tg;\n\n\tif (!ag)\n\t\tgoto out_fail;\n\n\ttg = sched_create_group(&root_task_group);\n\tif (IS_ERR(tg))\n\t\tgoto out_free;\n\n\tkref_init(&ag->kref);\n\tinit_rwsem(&ag->lock);\n\tag->id = atomic_inc_return(&autogroup_seq_nr);\n\tag->tg = tg;\n#ifdef CONFIG_RT_GROUP_SCHED\n\t/*\n\t * Autogroup RT tasks are redirected to the root task group\n\t * so we don't have to move tasks around upon policy change,\n\t * or flail around trying to allocate bandwidth on the fly.\n\t * A bandwidth exception in __sched_setscheduler() allows\n\t * the policy change to proceed.\n\t */\n\tfree_rt_sched_group(tg);\n\ttg->rt_se = root_task_group.rt_se;\n\ttg->rt_rq = root_task_group.rt_rq;\n#endif\n\ttg->autogroup = ag;\n\n\tsched_online_group(tg, &root_task_group);\n\treturn ag;\n\nout_free:\n\tkfree(ag);\nout_fail:\n\tif (printk_ratelimit()) {\n\t\tprintk(KERN_WARNING \"autogroup_create: %s failure.\\n\",\n\t\t\tag ? \"sched_create_group()\" : \"kzalloc()\");\n\t}\n\n\treturn autogroup_kref_get(&autogroup_default);\n}"
  },
  {
    "function_name": "autogroup_task_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "49-61",
    "snippet": "static inline struct autogroup *autogroup_task_get(struct task_struct *p)\n{\n\tstruct autogroup *ag;\n\tunsigned long flags;\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn autogroup_kref_get(&autogroup_default);\n\n\tag = autogroup_kref_get(p->signal->autogroup);\n\tunlock_task_sighand(p, &flags);\n\n\treturn ag;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct autogroup autogroup_default;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "autogroup_kref_get",
          "args": [
            "p->signal->autogroup"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "43-47",
          "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
          "includes": [
            "#include \"sched.h\"",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1384-1414",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == rcu_access_pointer(tsk->sighand)))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic struct autogroup autogroup_default;\n\nstatic inline struct autogroup *autogroup_task_get(struct task_struct *p)\n{\n\tstruct autogroup *ag;\n\tunsigned long flags;\n\n\tif (!lock_task_sighand(p, &flags))\n\t\treturn autogroup_kref_get(&autogroup_default);\n\n\tag = autogroup_kref_get(p->signal->autogroup);\n\tunlock_task_sighand(p, &flags);\n\n\treturn ag;\n}"
  },
  {
    "function_name": "autogroup_kref_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "43-47",
    "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&ag->kref"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "autogroup_kref_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
          "lines": "43-47",
          "snippet": "static inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline struct autogroup *autogroup_kref_get(struct autogroup *ag)\n{\n\tkref_get(&ag->kref);\n\treturn ag;\n}"
  },
  {
    "function_name": "autogroup_kref_put",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "38-41",
    "snippet": "static inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&ag->kref",
            "autogroup_destroy"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline void autogroup_kref_put(struct autogroup *ag)\n{\n\tkref_put(&ag->kref, autogroup_destroy);\n}"
  },
  {
    "function_name": "autogroup_destroy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "25-36",
    "snippet": "static inline void autogroup_destroy(struct kref *kref)\n{\n\tstruct autogroup *ag = container_of(kref, struct autogroup, kref);\n\n#ifdef CONFIG_RT_GROUP_SCHED\n\t/* We've redirected RT tasks to the root task group... */\n\tag->tg->rt_se = NULL;\n\tag->tg->rt_rq = NULL;\n#endif\n\tsched_release_group(ag->tg);\n\tsched_destroy_group(ag->tg);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_destroy_group",
          "args": [
            "ag->tg"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "sched_destroy_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "9828-9832",
          "snippet": "void sched_destroy_group(struct task_group *tg)\n{\n\t/* Wait for possible concurrent references to cfs_rqs complete: */\n\tcall_rcu(&tg->rcu, sched_unregister_group_rcu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_destroy_group(struct task_group *tg)\n{\n\t/* Wait for possible concurrent references to cfs_rqs complete: */\n\tcall_rcu(&tg->rcu, sched_unregister_group_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_release_group",
          "args": [
            "ag->tg"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "sched_release_group",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "9834-9855",
          "snippet": "void sched_release_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Unlink first, to avoid walk_tg_tree_from() from finding us (via\n\t * sched_cfs_period_timer()).\n\t *\n\t * For this to be effective, we have to wait for all pending users of\n\t * this task group to leave their RCU critical section to ensure no new\n\t * user will see our dying task group any more. Specifically ensure\n\t * that tg_unthrottle_up() won't add decayed cfs_rq's to it.\n\t *\n\t * We therefore defer calling unregister_fair_sched_group() to\n\t * sched_unregister_group() which is guarantied to get called only after the\n\t * current RCU grace period has expired.\n\t */\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_del_rcu(&tg->list);\n\tlist_del_rcu(&tg->siblings);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static DEFINE_SPINLOCK(task_group_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\nstatic DEFINE_SPINLOCK(task_group_lock);\n\nvoid sched_release_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Unlink first, to avoid walk_tg_tree_from() from finding us (via\n\t * sched_cfs_period_timer()).\n\t *\n\t * For this to be effective, we have to wait for all pending users of\n\t * this task group to leave their RCU critical section to ensure no new\n\t * user will see our dying task group any more. Specifically ensure\n\t * that tg_unthrottle_up() won't add decayed cfs_rq's to it.\n\t *\n\t * We therefore defer calling unregister_fair_sched_group() to\n\t * sched_unregister_group() which is guarantied to get called only after the\n\t * current RCU grace period has expired.\n\t */\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_del_rcu(&tg->list);\n\tlist_del_rcu(&tg->siblings);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structautogroup",
            "kref"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic inline void autogroup_destroy(struct kref *kref)\n{\n\tstruct autogroup *ag = container_of(kref, struct autogroup, kref);\n\n#ifdef CONFIG_RT_GROUP_SCHED\n\t/* We've redirected RT tasks to the root task group... */\n\tag->tg->rt_se = NULL;\n\tag->tg->rt_rq = NULL;\n#endif\n\tsched_release_group(ag->tg);\n\tsched_destroy_group(ag->tg);\n}"
  },
  {
    "function_name": "autogroup_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "20-23",
    "snippet": "void autogroup_free(struct task_group *tg)\n{\n\tkfree(tg->autogroup);\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tg->autogroup"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nvoid autogroup_free(struct task_group *tg)\n{\n\tkfree(tg->autogroup);\n}"
  },
  {
    "function_name": "autogroup_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/autogroup.c",
    "lines": "12-18",
    "snippet": "void __init autogroup_init(struct task_struct *init_task)\n{\n\tautogroup_default.tg = &root_task_group;\n\tkref_init(&autogroup_default.kref);\n\tinit_rwsem(&autogroup_default.lock);\n\tinit_task->signal->autogroup = &autogroup_default;\n}",
    "includes": [
      "#include \"sched.h\"",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct autogroup autogroup_default;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&autogroup_default.lock"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&autogroup_default.kref"
          ],
          "line": 15
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sched.h\"\n#include <linux/nospec.h>\n\nstatic struct autogroup autogroup_default;\n\nvoid __init autogroup_init(struct task_struct *init_task)\n{\n\tautogroup_default.tg = &root_task_group;\n\tkref_init(&autogroup_default.kref);\n\tinit_rwsem(&autogroup_default.lock);\n\tinit_task->signal->autogroup = &autogroup_default;\n}"
  }
]