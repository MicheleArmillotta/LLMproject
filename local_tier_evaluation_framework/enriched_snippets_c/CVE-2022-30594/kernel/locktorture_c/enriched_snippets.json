[
  {
    "function_name": "lock_torture_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "900-1114",
    "snippet": "static int __init lock_torture_init(void)\n{\n\tint i, j;\n\tint firsterr = 0;\n\tstatic struct lock_torture_ops *torture_ops[] = {\n\t\t&lock_busted_ops,\n\t\t&spin_lock_ops, &spin_lock_irq_ops,\n\t\t&rw_lock_ops, &rw_lock_irq_ops,\n\t\t&mutex_lock_ops,\n\t\t&ww_mutex_lock_ops,\n#ifdef CONFIG_RT_MUTEXES\n\t\t&rtmutex_lock_ops,\n#endif\n\t\t&rwsem_lock_ops,\n\t\t&percpu_rwsem_lock_ops,\n\t};\n\n\tif (!torture_init_begin(torture_type, verbose))\n\t\treturn -EBUSY;\n\n\t/* Process args and tell the world that the torturer is on the job. */\n\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {\n\t\tcxt.cur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cxt.cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(torture_ops)) {\n\t\tpr_alert(\"lock-torture: invalid torture type: \\\"%s\\\"\\n\",\n\t\t\t torture_type);\n\t\tpr_alert(\"lock-torture types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)\n\t\t\tpr_alert(\" %s\", torture_ops[i]->name);\n\t\tpr_alert(\"\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\n\tif (nwriters_stress == 0 &&\n\t    (!cxt.cur_ops->readlock || nreaders_stress == 0)) {\n\t\tpr_alert(\"lock-torture: must run at least one locking thread\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\n\tif (nwriters_stress >= 0)\n\t\tcxt.nrealwriters_stress = nwriters_stress;\n\telse\n\t\tcxt.nrealwriters_stress = 2 * num_online_cpus();\n\n\tif (cxt.cur_ops->init) {\n\t\tcxt.cur_ops->init();\n\t\tcxt.init_called = true;\n\t}\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tif (str_has_prefix(torture_type, \"mutex\"))\n\t\tcxt.debug_lock = true;\n#endif\n#ifdef CONFIG_DEBUG_RT_MUTEXES\n\tif (str_has_prefix(torture_type, \"rtmutex\"))\n\t\tcxt.debug_lock = true;\n#endif\n#ifdef CONFIG_DEBUG_SPINLOCK\n\tif ((str_has_prefix(torture_type, \"spin\")) ||\n\t    (str_has_prefix(torture_type, \"rw_lock\")))\n\t\tcxt.debug_lock = true;\n#endif\n\n\t/* Initialize the statistics so that each run gets its own numbers. */\n\tif (nwriters_stress) {\n\t\tlock_is_write_held = false;\n\t\tcxt.lwsa = kmalloc_array(cxt.nrealwriters_stress,\n\t\t\t\t\t sizeof(*cxt.lwsa),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (cxt.lwsa == NULL) {\n\t\t\tVERBOSE_TOROUT_STRING(\"cxt.lwsa: Out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++) {\n\t\t\tcxt.lwsa[i].n_lock_fail = 0;\n\t\t\tcxt.lwsa[i].n_lock_acquired = 0;\n\t\t}\n\t}\n\n\tif (cxt.cur_ops->readlock) {\n\t\tif (nreaders_stress >= 0)\n\t\t\tcxt.nrealreaders_stress = nreaders_stress;\n\t\telse {\n\t\t\t/*\n\t\t\t * By default distribute evenly the number of\n\t\t\t * readers and writers. We still run the same number\n\t\t\t * of threads as the writer-only locks default.\n\t\t\t */\n\t\t\tif (nwriters_stress < 0) /* user doesn't care */\n\t\t\t\tcxt.nrealwriters_stress = num_online_cpus();\n\t\t\tcxt.nrealreaders_stress = cxt.nrealwriters_stress;\n\t\t}\n\n\t\tif (nreaders_stress) {\n\t\t\tcxt.lrsa = kmalloc_array(cxt.nrealreaders_stress,\n\t\t\t\t\t\t sizeof(*cxt.lrsa),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (cxt.lrsa == NULL) {\n\t\t\t\tVERBOSE_TOROUT_STRING(\"cxt.lrsa: Out of memory\");\n\t\t\t\tfirsterr = -ENOMEM;\n\t\t\t\tkfree(cxt.lwsa);\n\t\t\t\tcxt.lwsa = NULL;\n\t\t\t\tgoto unwind;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++) {\n\t\t\t\tcxt.lrsa[i].n_lock_fail = 0;\n\t\t\t\tcxt.lrsa[i].n_lock_acquired = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tlock_torture_print_module_parms(cxt.cur_ops, \"Start of test\");\n\n\t/* Prepare torture context. */\n\tif (onoff_interval > 0) {\n\t\tfirsterr = torture_onoff_init(onoff_holdoff * HZ,\n\t\t\t\t\t      onoff_interval * HZ, NULL);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (shuffle_interval > 0) {\n\t\tfirsterr = torture_shuffle_init(shuffle_interval);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (shutdown_secs > 0) {\n\t\tfirsterr = torture_shutdown_init(shutdown_secs,\n\t\t\t\t\t\t lock_torture_cleanup);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stutter > 0) {\n\t\tfirsterr = torture_stutter_init(stutter, stutter);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\tif (nwriters_stress) {\n\t\twriter_tasks = kcalloc(cxt.nrealwriters_stress,\n\t\t\t\t       sizeof(writer_tasks[0]),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (writer_tasks == NULL) {\n\t\t\tTOROUT_ERRSTRING(\"writer_tasks: Out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\tif (cxt.cur_ops->readlock) {\n\t\treader_tasks = kcalloc(cxt.nrealreaders_stress,\n\t\t\t\t       sizeof(reader_tasks[0]),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (reader_tasks == NULL) {\n\t\t\tTOROUT_ERRSTRING(\"reader_tasks: Out of memory\");\n\t\t\tkfree(writer_tasks);\n\t\t\twriter_tasks = NULL;\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\t/*\n\t * Create the kthreads and start torturing (oh, those poor little locks).\n\t *\n\t * TODO: Note that we interleave writers with readers, giving writers a\n\t * slight advantage, by creating its kthread first. This can be modified\n\t * for very specific needs, or even let the user choose the policy, if\n\t * ever wanted.\n\t */\n\tfor (i = 0, j = 0; i < cxt.nrealwriters_stress ||\n\t\t    j < cxt.nrealreaders_stress; i++, j++) {\n\t\tif (i >= cxt.nrealwriters_stress)\n\t\t\tgoto create_reader;\n\n\t\t/* Create writer. */\n\t\tfirsterr = torture_create_kthread(lock_torture_writer, &cxt.lwsa[i],\n\t\t\t\t\t\t  writer_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\n\tcreate_reader:\n\t\tif (cxt.cur_ops->readlock == NULL || (j >= cxt.nrealreaders_stress))\n\t\t\tcontinue;\n\t\t/* Create reader. */\n\t\tfirsterr = torture_create_kthread(lock_torture_reader, &cxt.lrsa[j],\n\t\t\t\t\t\t  reader_tasks[j]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(lock_torture_stats, NULL,\n\t\t\t\t\t\t  stats_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tlock_torture_cleanup();\n\tif (shutdown_secs) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_LOCK_TORTURE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *torture_type = \"spin_lock\";",
      "static struct task_struct *stats_task;",
      "static struct task_struct **writer_tasks;",
      "static struct task_struct **reader_tasks;",
      "static bool lock_is_write_held;",
      "static void lock_torture_cleanup(void);",
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static struct lock_torture_ops lock_busted_ops = {\n\t.writelock\t= torture_lock_busted_write_lock,\n\t.write_delay\t= torture_lock_busted_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_lock_busted_write_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"lock_busted\"\n};",
      "static struct lock_torture_ops spin_lock_ops = {\n\t.writelock\t= torture_spin_lock_write_lock,\n\t.write_delay\t= torture_spin_lock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_spin_lock_write_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"spin_lock\"\n};",
      "static struct lock_torture_ops spin_lock_irq_ops = {\n\t.writelock\t= torture_spin_lock_write_lock_irq,\n\t.write_delay\t= torture_spin_lock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_lock_spin_write_unlock_irq,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"spin_lock_irq\"\n};",
      "static struct lock_torture_ops rw_lock_ops = {\n\t.writelock\t= torture_rwlock_write_lock,\n\t.write_delay\t= torture_rwlock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwlock_write_unlock,\n\t.readlock       = torture_rwlock_read_lock,\n\t.read_delay     = torture_rwlock_read_delay,\n\t.readunlock     = torture_rwlock_read_unlock,\n\t.name\t\t= \"rw_lock\"\n};",
      "static struct lock_torture_ops rw_lock_irq_ops = {\n\t.writelock\t= torture_rwlock_write_lock_irq,\n\t.write_delay\t= torture_rwlock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwlock_write_unlock_irq,\n\t.readlock       = torture_rwlock_read_lock_irq,\n\t.read_delay     = torture_rwlock_read_delay,\n\t.readunlock     = torture_rwlock_read_unlock_irq,\n\t.name\t\t= \"rw_lock_irq\"\n};",
      "static struct lock_torture_ops mutex_lock_ops = {\n\t.writelock\t= torture_mutex_lock,\n\t.write_delay\t= torture_mutex_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_mutex_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"mutex_lock\"\n};",
      "static struct lock_torture_ops ww_mutex_lock_ops = {\n\t.init\t\t= torture_ww_mutex_init,\n\t.exit\t\t= torture_ww_mutex_exit,\n\t.writelock\t= torture_ww_mutex_lock,\n\t.write_delay\t= torture_mutex_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_ww_mutex_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"ww_mutex_lock\"\n};",
      "static struct lock_torture_ops rwsem_lock_ops = {\n\t.writelock\t= torture_rwsem_down_write,\n\t.write_delay\t= torture_rwsem_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwsem_up_write,\n\t.readlock       = torture_rwsem_down_read,\n\t.read_delay     = torture_rwsem_read_delay,\n\t.readunlock     = torture_rwsem_up_read,\n\t.name\t\t= \"rwsem_lock\"\n};",
      "static struct lock_torture_ops percpu_rwsem_lock_ops = {\n\t.init\t\t= torture_percpu_rwsem_init,\n\t.exit\t\t= torture_percpu_rwsem_exit,\n\t.writelock\t= torture_percpu_rwsem_down_write,\n\t.write_delay\t= torture_rwsem_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_percpu_rwsem_up_write,\n\t.readlock       = torture_percpu_rwsem_down_read,\n\t.read_delay     = torture_rwsem_read_delay,\n\t.readunlock     = torture_percpu_rwsem_up_read,\n\t.name\t\t= \"percpu_rwsem_lock\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!IS_MODULE(CONFIG_LOCK_TORTURE_TEST)"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MODULE",
          "args": [
            "CONFIG_LOCK_TORTURE_TEST"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_torture_cleanup",
          "args": [],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "lock_torture_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "840-898",
          "snippet": "static void lock_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\t/*\n\t * Indicates early cleanup, meaning that the test has not run,\n\t * such as when passing bogus args when loading the module.\n\t * However cxt->cur_ops.init() may have been invoked, so beside\n\t * perform the underlying torture-specific cleanups, cur_ops.exit()\n\t * will be invoked if needed.\n\t */\n\tif (!cxt.lwsa && !cxt.lrsa)\n\t\tgoto end;\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\tkfree(writer_tasks);\n\t\twriter_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\n\ttorture_stop_kthread(lock_torture_stats, stats_task);\n\tlock_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (atomic_read(&cxt.n_lock_torture_errors))\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: SUCCESS\");\n\n\tkfree(cxt.lwsa);\n\tcxt.lwsa = NULL;\n\tkfree(cxt.lrsa);\n\tcxt.lrsa = NULL;\n\nend:\n\tif (cxt.init_called) {\n\t\tif (cxt.cur_ops->exit)\n\t\t\tcxt.cur_ops->exit();\n\t\tcxt.init_called = false;\n\t}\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *stats_task;",
            "static struct task_struct **writer_tasks;",
            "static struct task_struct **reader_tasks;",
            "static void lock_torture_cleanup(void);",
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct task_struct *stats_task;\nstatic struct task_struct **writer_tasks;\nstatic struct task_struct **reader_tasks;\nstatic void lock_torture_cleanup(void);\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void lock_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\t/*\n\t * Indicates early cleanup, meaning that the test has not run,\n\t * such as when passing bogus args when loading the module.\n\t * However cxt->cur_ops.init() may have been invoked, so beside\n\t * perform the underlying torture-specific cleanups, cur_ops.exit()\n\t * will be invoked if needed.\n\t */\n\tif (!cxt.lwsa && !cxt.lrsa)\n\t\tgoto end;\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\tkfree(writer_tasks);\n\t\twriter_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\n\ttorture_stop_kthread(lock_torture_stats, stats_task);\n\tlock_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (atomic_read(&cxt.n_lock_torture_errors))\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: SUCCESS\");\n\n\tkfree(cxt.lwsa);\n\tcxt.lwsa = NULL;\n\tkfree(cxt.lrsa);\n\tcxt.lrsa = NULL;\n\nend:\n\tif (cxt.init_called) {\n\t\tif (cxt.cur_ops->exit)\n\t\t\tcxt.cur_ops->exit();\n\t\tcxt.init_called = false;\n\t}\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_end",
          "args": [],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "835-839",
          "snippet": "void torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(fullstop_mutex);",
            "static struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(fullstop_mutex);\nstatic struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};\n\nvoid torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "lock_torture_stats",
            "NULL",
            "stats_task"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "lock_torture_reader",
            "&cxt.lrsa[j]",
            "reader_tasks[j]"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "lock_torture_writer",
            "&cxt.lwsa[i]",
            "writer_tasks[i]"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "writer_tasks"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TOROUT_ERRSTRING",
          "args": [
            "\"reader_tasks: Out of memory\""
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "cxt.nrealreaders_stress",
            "sizeof(reader_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TOROUT_ERRSTRING",
          "args": [
            "\"writer_tasks: Out of memory\""
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "cxt.nrealwriters_stress",
            "sizeof(writer_tasks[0])",
            "GFP_KERNEL"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_stutter_init",
          "args": [
            "stutter",
            "stutter"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "torture_stutter_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "786-791",
          "snippet": "int torture_stutter_init(const int s, const int sgap)\n{\n\tstutter = s;\n\tstutter_gap = sgap;\n\treturn torture_create_kthread(torture_stutter, NULL, stutter_task);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *stutter_task;",
            "static int stutter;",
            "static int stutter_gap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stutter_task;\nstatic int stutter;\nstatic int stutter_gap;\n\nint torture_stutter_init(const int s, const int sgap)\n{\n\tstutter = s;\n\tstutter_gap = sgap;\n\treturn torture_create_kthread(torture_stutter, NULL, stutter_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_shutdown_init",
          "args": [
            "shutdown_secs",
            "lock_torture_cleanup"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "661-670",
          "snippet": "int torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\treturn torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *shutdown_task;",
            "static ktime_t shutdown_time;",
            "static void (*torture_shutdown_hook)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *shutdown_task;\nstatic ktime_t shutdown_time;\nstatic void (*torture_shutdown_hook)(void);\n\nint torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\treturn torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_shuffle_init",
          "args": [
            "shuffle_interval"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shuffle_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "566-579",
          "snippet": "int torture_shuffle_init(long shuffint)\n{\n\tshuffle_interval = shuffint;\n\n\tshuffle_idle_cpu = -1;\n\n\tif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\n\t\tTOROUT_ERRSTRING(\"Failed to alloc mask\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Create the shuffler thread */\n\treturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long shuffle_interval;",
            "static struct task_struct *shuffler_task;",
            "static cpumask_var_t shuffle_tmp_mask;",
            "static int shuffle_idle_cpu;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic long shuffle_interval;\nstatic struct task_struct *shuffler_task;\nstatic cpumask_var_t shuffle_tmp_mask;\nstatic int shuffle_idle_cpu;\n\nint torture_shuffle_init(long shuffint)\n{\n\tshuffle_interval = shuffint;\n\n\tshuffle_idle_cpu = -1;\n\n\tif (!alloc_cpumask_var(&shuffle_tmp_mask, GFP_KERNEL)) {\n\t\tTOROUT_ERRSTRING(\"Failed to alloc mask\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Create the shuffler thread */\n\treturn torture_create_kthread(torture_shuffle, NULL, shuffler_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_onoff_init",
          "args": [
            "onoff_holdoff * HZ",
            "onoff_interval * HZ",
            "NULL"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "382-394",
          "snippet": "int torture_onoff_init(long ooholdoff, long oointerval, torture_ofl_func *f)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tonoff_f = f;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(torture_onoff, NULL, onoff_task);\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn 0;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_onoff_init(long ooholdoff, long oointerval, torture_ofl_func *f)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tonoff_f = f;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(torture_onoff, NULL, onoff_task);\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn 0;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_torture_print_module_parms",
          "args": [
            "cxt.cur_ops",
            "\"Start of test\""
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "lock_torture_print_module_parms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "828-838",
          "snippet": "static inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type = \"spin_lock\";",
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic char *torture_type = \"spin_lock\";\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"cxt.lrsa: Out of memory\""
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "cxt.nrealreaders_stress",
            "sizeof(*cxt.lrsa)",
            "GFP_KERNEL"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"cxt.lwsa: Out of memory\""
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "cxt.nrealwriters_stress",
            "sizeof(*cxt.lwsa)",
            "GFP_KERNEL"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "torture_type",
            "\"rw_lock\""
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "torture_type",
            "\"spin\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "torture_type",
            "\"rtmutex\""
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str_has_prefix",
          "args": [
            "torture_type",
            "\"mutex\""
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->init",
          "args": [],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"lock-torture: must run at least one locking thread\\n\""
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"\\n\""
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\" %s\"",
            "torture_ops[i]->name"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"lock-torture types:\""
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"lock-torture: invalid torture type: \\\"%s\\\"\\n\"",
            "torture_type"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "torture_type",
            "cxt.cur_ops->name"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "torture_ops"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_begin",
          "args": [
            "torture_type",
            "verbose"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "815-829",
          "snippet": "bool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static char *torture_type;",
            "static int verbose;",
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic char *torture_type;\nstatic int verbose;\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic char *torture_type = \"spin_lock\";\nstatic struct task_struct *stats_task;\nstatic struct task_struct **writer_tasks;\nstatic struct task_struct **reader_tasks;\nstatic bool lock_is_write_held;\nstatic void lock_torture_cleanup(void);\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic struct lock_torture_ops lock_busted_ops = {\n\t.writelock\t= torture_lock_busted_write_lock,\n\t.write_delay\t= torture_lock_busted_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_lock_busted_write_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"lock_busted\"\n};\nstatic struct lock_torture_ops spin_lock_ops = {\n\t.writelock\t= torture_spin_lock_write_lock,\n\t.write_delay\t= torture_spin_lock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_spin_lock_write_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"spin_lock\"\n};\nstatic struct lock_torture_ops spin_lock_irq_ops = {\n\t.writelock\t= torture_spin_lock_write_lock_irq,\n\t.write_delay\t= torture_spin_lock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_lock_spin_write_unlock_irq,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"spin_lock_irq\"\n};\nstatic struct lock_torture_ops rw_lock_ops = {\n\t.writelock\t= torture_rwlock_write_lock,\n\t.write_delay\t= torture_rwlock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwlock_write_unlock,\n\t.readlock       = torture_rwlock_read_lock,\n\t.read_delay     = torture_rwlock_read_delay,\n\t.readunlock     = torture_rwlock_read_unlock,\n\t.name\t\t= \"rw_lock\"\n};\nstatic struct lock_torture_ops rw_lock_irq_ops = {\n\t.writelock\t= torture_rwlock_write_lock_irq,\n\t.write_delay\t= torture_rwlock_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwlock_write_unlock_irq,\n\t.readlock       = torture_rwlock_read_lock_irq,\n\t.read_delay     = torture_rwlock_read_delay,\n\t.readunlock     = torture_rwlock_read_unlock_irq,\n\t.name\t\t= \"rw_lock_irq\"\n};\nstatic struct lock_torture_ops mutex_lock_ops = {\n\t.writelock\t= torture_mutex_lock,\n\t.write_delay\t= torture_mutex_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_mutex_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"mutex_lock\"\n};\nstatic struct lock_torture_ops ww_mutex_lock_ops = {\n\t.init\t\t= torture_ww_mutex_init,\n\t.exit\t\t= torture_ww_mutex_exit,\n\t.writelock\t= torture_ww_mutex_lock,\n\t.write_delay\t= torture_mutex_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_ww_mutex_unlock,\n\t.readlock       = NULL,\n\t.read_delay     = NULL,\n\t.readunlock     = NULL,\n\t.name\t\t= \"ww_mutex_lock\"\n};\nstatic struct lock_torture_ops rwsem_lock_ops = {\n\t.writelock\t= torture_rwsem_down_write,\n\t.write_delay\t= torture_rwsem_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_rwsem_up_write,\n\t.readlock       = torture_rwsem_down_read,\n\t.read_delay     = torture_rwsem_read_delay,\n\t.readunlock     = torture_rwsem_up_read,\n\t.name\t\t= \"rwsem_lock\"\n};\nstatic struct lock_torture_ops percpu_rwsem_lock_ops = {\n\t.init\t\t= torture_percpu_rwsem_init,\n\t.exit\t\t= torture_percpu_rwsem_exit,\n\t.writelock\t= torture_percpu_rwsem_down_write,\n\t.write_delay\t= torture_rwsem_write_delay,\n\t.task_boost     = torture_boost_dummy,\n\t.writeunlock\t= torture_percpu_rwsem_up_write,\n\t.readlock       = torture_percpu_rwsem_down_read,\n\t.read_delay     = torture_rwsem_read_delay,\n\t.readunlock     = torture_percpu_rwsem_up_read,\n\t.name\t\t= \"percpu_rwsem_lock\"\n};\n\nstatic int __init lock_torture_init(void)\n{\n\tint i, j;\n\tint firsterr = 0;\n\tstatic struct lock_torture_ops *torture_ops[] = {\n\t\t&lock_busted_ops,\n\t\t&spin_lock_ops, &spin_lock_irq_ops,\n\t\t&rw_lock_ops, &rw_lock_irq_ops,\n\t\t&mutex_lock_ops,\n\t\t&ww_mutex_lock_ops,\n#ifdef CONFIG_RT_MUTEXES\n\t\t&rtmutex_lock_ops,\n#endif\n\t\t&rwsem_lock_ops,\n\t\t&percpu_rwsem_lock_ops,\n\t};\n\n\tif (!torture_init_begin(torture_type, verbose))\n\t\treturn -EBUSY;\n\n\t/* Process args and tell the world that the torturer is on the job. */\n\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {\n\t\tcxt.cur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cxt.cur_ops->name) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(torture_ops)) {\n\t\tpr_alert(\"lock-torture: invalid torture type: \\\"%s\\\"\\n\",\n\t\t\t torture_type);\n\t\tpr_alert(\"lock-torture types:\");\n\t\tfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)\n\t\t\tpr_alert(\" %s\", torture_ops[i]->name);\n\t\tpr_alert(\"\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\n\tif (nwriters_stress == 0 &&\n\t    (!cxt.cur_ops->readlock || nreaders_stress == 0)) {\n\t\tpr_alert(\"lock-torture: must run at least one locking thread\\n\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\n\tif (nwriters_stress >= 0)\n\t\tcxt.nrealwriters_stress = nwriters_stress;\n\telse\n\t\tcxt.nrealwriters_stress = 2 * num_online_cpus();\n\n\tif (cxt.cur_ops->init) {\n\t\tcxt.cur_ops->init();\n\t\tcxt.init_called = true;\n\t}\n\n#ifdef CONFIG_DEBUG_MUTEXES\n\tif (str_has_prefix(torture_type, \"mutex\"))\n\t\tcxt.debug_lock = true;\n#endif\n#ifdef CONFIG_DEBUG_RT_MUTEXES\n\tif (str_has_prefix(torture_type, \"rtmutex\"))\n\t\tcxt.debug_lock = true;\n#endif\n#ifdef CONFIG_DEBUG_SPINLOCK\n\tif ((str_has_prefix(torture_type, \"spin\")) ||\n\t    (str_has_prefix(torture_type, \"rw_lock\")))\n\t\tcxt.debug_lock = true;\n#endif\n\n\t/* Initialize the statistics so that each run gets its own numbers. */\n\tif (nwriters_stress) {\n\t\tlock_is_write_held = false;\n\t\tcxt.lwsa = kmalloc_array(cxt.nrealwriters_stress,\n\t\t\t\t\t sizeof(*cxt.lwsa),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (cxt.lwsa == NULL) {\n\t\t\tVERBOSE_TOROUT_STRING(\"cxt.lwsa: Out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++) {\n\t\t\tcxt.lwsa[i].n_lock_fail = 0;\n\t\t\tcxt.lwsa[i].n_lock_acquired = 0;\n\t\t}\n\t}\n\n\tif (cxt.cur_ops->readlock) {\n\t\tif (nreaders_stress >= 0)\n\t\t\tcxt.nrealreaders_stress = nreaders_stress;\n\t\telse {\n\t\t\t/*\n\t\t\t * By default distribute evenly the number of\n\t\t\t * readers and writers. We still run the same number\n\t\t\t * of threads as the writer-only locks default.\n\t\t\t */\n\t\t\tif (nwriters_stress < 0) /* user doesn't care */\n\t\t\t\tcxt.nrealwriters_stress = num_online_cpus();\n\t\t\tcxt.nrealreaders_stress = cxt.nrealwriters_stress;\n\t\t}\n\n\t\tif (nreaders_stress) {\n\t\t\tcxt.lrsa = kmalloc_array(cxt.nrealreaders_stress,\n\t\t\t\t\t\t sizeof(*cxt.lrsa),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (cxt.lrsa == NULL) {\n\t\t\t\tVERBOSE_TOROUT_STRING(\"cxt.lrsa: Out of memory\");\n\t\t\t\tfirsterr = -ENOMEM;\n\t\t\t\tkfree(cxt.lwsa);\n\t\t\t\tcxt.lwsa = NULL;\n\t\t\t\tgoto unwind;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++) {\n\t\t\t\tcxt.lrsa[i].n_lock_fail = 0;\n\t\t\t\tcxt.lrsa[i].n_lock_acquired = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tlock_torture_print_module_parms(cxt.cur_ops, \"Start of test\");\n\n\t/* Prepare torture context. */\n\tif (onoff_interval > 0) {\n\t\tfirsterr = torture_onoff_init(onoff_holdoff * HZ,\n\t\t\t\t\t      onoff_interval * HZ, NULL);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (shuffle_interval > 0) {\n\t\tfirsterr = torture_shuffle_init(shuffle_interval);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (shutdown_secs > 0) {\n\t\tfirsterr = torture_shutdown_init(shutdown_secs,\n\t\t\t\t\t\t lock_torture_cleanup);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stutter > 0) {\n\t\tfirsterr = torture_stutter_init(stutter, stutter);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\tif (nwriters_stress) {\n\t\twriter_tasks = kcalloc(cxt.nrealwriters_stress,\n\t\t\t\t       sizeof(writer_tasks[0]),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (writer_tasks == NULL) {\n\t\t\tTOROUT_ERRSTRING(\"writer_tasks: Out of memory\");\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\tif (cxt.cur_ops->readlock) {\n\t\treader_tasks = kcalloc(cxt.nrealreaders_stress,\n\t\t\t\t       sizeof(reader_tasks[0]),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (reader_tasks == NULL) {\n\t\t\tTOROUT_ERRSTRING(\"reader_tasks: Out of memory\");\n\t\t\tkfree(writer_tasks);\n\t\t\twriter_tasks = NULL;\n\t\t\tfirsterr = -ENOMEM;\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\t/*\n\t * Create the kthreads and start torturing (oh, those poor little locks).\n\t *\n\t * TODO: Note that we interleave writers with readers, giving writers a\n\t * slight advantage, by creating its kthread first. This can be modified\n\t * for very specific needs, or even let the user choose the policy, if\n\t * ever wanted.\n\t */\n\tfor (i = 0, j = 0; i < cxt.nrealwriters_stress ||\n\t\t    j < cxt.nrealreaders_stress; i++, j++) {\n\t\tif (i >= cxt.nrealwriters_stress)\n\t\t\tgoto create_reader;\n\n\t\t/* Create writer. */\n\t\tfirsterr = torture_create_kthread(lock_torture_writer, &cxt.lwsa[i],\n\t\t\t\t\t\t  writer_tasks[i]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\n\tcreate_reader:\n\t\tif (cxt.cur_ops->readlock == NULL || (j >= cxt.nrealreaders_stress))\n\t\t\tcontinue;\n\t\t/* Create reader. */\n\t\tfirsterr = torture_create_kthread(lock_torture_reader, &cxt.lrsa[j],\n\t\t\t\t\t\t  reader_tasks[j]);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(lock_torture_stats, NULL,\n\t\t\t\t\t\t  stats_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tlock_torture_cleanup();\n\tif (shutdown_secs) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_LOCK_TORTURE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}"
  },
  {
    "function_name": "lock_torture_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "840-898",
    "snippet": "static void lock_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\t/*\n\t * Indicates early cleanup, meaning that the test has not run,\n\t * such as when passing bogus args when loading the module.\n\t * However cxt->cur_ops.init() may have been invoked, so beside\n\t * perform the underlying torture-specific cleanups, cur_ops.exit()\n\t * will be invoked if needed.\n\t */\n\tif (!cxt.lwsa && !cxt.lrsa)\n\t\tgoto end;\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\tkfree(writer_tasks);\n\t\twriter_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\n\ttorture_stop_kthread(lock_torture_stats, stats_task);\n\tlock_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (atomic_read(&cxt.n_lock_torture_errors))\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: SUCCESS\");\n\n\tkfree(cxt.lwsa);\n\tcxt.lwsa = NULL;\n\tkfree(cxt.lrsa);\n\tcxt.lrsa = NULL;\n\nend:\n\tif (cxt.init_called) {\n\t\tif (cxt.cur_ops->exit)\n\t\t\tcxt.cur_ops->exit();\n\t\tcxt.init_called = false;\n\t}\n\ttorture_cleanup_end();\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *stats_task;",
      "static struct task_struct **writer_tasks;",
      "static struct task_struct **reader_tasks;",
      "static void lock_torture_cleanup(void);",
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_cleanup_end",
          "args": [],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "876-881",
          "snippet": "void torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nvoid torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->exit",
          "args": [],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cxt.lrsa"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_torture_print_module_parms",
          "args": [
            "cxt.cur_ops",
            "\"End of test: SUCCESS\""
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "lock_torture_print_module_parms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "828-838",
          "snippet": "static inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type = \"spin_lock\";",
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic char *torture_type = \"spin_lock\";\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_onoff_failures",
          "args": [],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_failures",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "430-438",
          "snippet": "bool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn false;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn false;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cxt.n_lock_torture_errors"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_torture_stats_print",
          "args": [],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "lock_torture_stats_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "776-807",
          "snippet": "static void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "lock_torture_stats",
            "stats_task"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_cleanup_begin",
          "args": [],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "857-873",
          "snippet": "bool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */",
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct task_struct *stats_task;\nstatic struct task_struct **writer_tasks;\nstatic struct task_struct **reader_tasks;\nstatic void lock_torture_cleanup(void);\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void lock_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\t/*\n\t * Indicates early cleanup, meaning that the test has not run,\n\t * such as when passing bogus args when loading the module.\n\t * However cxt->cur_ops.init() may have been invoked, so beside\n\t * perform the underlying torture-specific cleanups, cur_ops.exit()\n\t * will be invoked if needed.\n\t */\n\tif (!cxt.lwsa && !cxt.lrsa)\n\t\tgoto end;\n\n\tif (writer_tasks) {\n\t\tfor (i = 0; i < cxt.nrealwriters_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\tkfree(writer_tasks);\n\t\twriter_tasks = NULL;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = NULL;\n\t}\n\n\ttorture_stop_kthread(lock_torture_stats, stats_task);\n\tlock_torture_stats_print();  /* -After- the stats thread is stopped! */\n\n\tif (atomic_read(&cxt.n_lock_torture_errors))\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"End of test: SUCCESS\");\n\n\tkfree(cxt.lwsa);\n\tcxt.lwsa = NULL;\n\tkfree(cxt.lrsa);\n\tcxt.lrsa = NULL;\n\nend:\n\tif (cxt.init_called) {\n\t\tif (cxt.cur_ops->exit)\n\t\t\tcxt.cur_ops->exit();\n\t\tcxt.init_called = false;\n\t}\n\ttorture_cleanup_end();\n}"
  },
  {
    "function_name": "lock_torture_print_module_parms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "828-838",
    "snippet": "static inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *torture_type = \"spin_lock\";",
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\"",
            "torture_type",
            "tag",
            "cxt.debug_lock ? \" [debug]\": \"\"",
            "cxt.nrealwriters_stress",
            "cxt.nrealreaders_stress",
            "stat_interval",
            "verbose",
            "shuffle_interval",
            "stutter",
            "shutdown_secs",
            "onoff_interval",
            "onoff_holdoff"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic char *torture_type = \"spin_lock\";\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic inline void\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\n\t\t\t\tconst char *tag)\n{\n\tpr_alert(\"%s\" TORTURE_FLAG\n\t\t \"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\",\n\t\t torture_type, tag, cxt.debug_lock ? \" [debug]\": \"\",\n\t\t cxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\n\t\t verbose, shuffle_interval, stutter, shutdown_secs,\n\t\t onoff_interval, onoff_holdoff);\n}"
  },
  {
    "function_name": "lock_torture_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "816-826",
    "snippet": "static int lock_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"lock_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\tlock_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"lock_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"lock_torture_stats\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"lock_torture_stats\""
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_absorb",
          "args": [
            "\"lock_torture_stats\""
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_torture_stats_print",
          "args": [],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "lock_torture_stats_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "776-807",
          "snippet": "static void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "stat_interval * HZ"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"lock_torture_stats task started\""
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int lock_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"lock_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\tlock_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"lock_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"lock_torture_stats\");\n\treturn 0;\n}"
  },
  {
    "function_name": "lock_torture_stats_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "776-807",
    "snippet": "static void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\"",
            "buf"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__torture_print_stats",
          "args": [
            "buf",
            "cxt.lrsa",
            "false"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "__torture_print_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "738-766",
          "snippet": "static void __torture_print_stats(char *page,\n\t\t\t\t  struct lock_stress_stats *statp, bool write)\n{\n\tlong cur;\n\tbool fail = false;\n\tint i, n_stress;\n\tlong max = 0, min = statp ? data_race(statp[0].n_lock_acquired) : 0;\n\tlong long sum = 0;\n\n\tn_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;\n\tfor (i = 0; i < n_stress; i++) {\n\t\tif (data_race(statp[i].n_lock_fail))\n\t\t\tfail = true;\n\t\tcur = data_race(statp[i].n_lock_acquired);\n\t\tsum += cur;\n\t\tif (max < cur)\n\t\t\tmax = cur;\n\t\tif (min > cur)\n\t\t\tmin = cur;\n\t}\n\tpage += sprintf(page,\n\t\t\t\"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\\n\",\n\t\t\twrite ? \"Writes\" : \"Reads \",\n\t\t\tsum, max, min,\n\t\t\t!onoff_interval && max / 2 > min ? \"???\" : \"\",\n\t\t\tfail, fail ? \"!!!\" : \"\");\n\tif (fail)\n\t\tatomic_inc(&cxt.n_lock_torture_errors);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void __torture_print_stats(char *page,\n\t\t\t\t  struct lock_stress_stats *statp, bool write)\n{\n\tlong cur;\n\tbool fail = false;\n\tint i, n_stress;\n\tlong max = 0, min = statp ? data_race(statp[0].n_lock_acquired) : 0;\n\tlong long sum = 0;\n\n\tn_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;\n\tfor (i = 0; i < n_stress; i++) {\n\t\tif (data_race(statp[i].n_lock_fail))\n\t\t\tfail = true;\n\t\tcur = data_race(statp[i].n_lock_acquired);\n\t\tsum += cur;\n\t\tif (max < cur)\n\t\t\tmax = cur;\n\t\tif (min > cur)\n\t\t\tmin = cur;\n\t}\n\tpage += sprintf(page,\n\t\t\t\"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\\n\",\n\t\t\twrite ? \"Writes\" : \"Reads \",\n\t\t\tsum, max, min,\n\t\t\t!onoff_interval && max / 2 > min ? \"???\" : \"\",\n\t\t\tfail, fail ? \"!!!\" : \"\");\n\tif (fail)\n\t\tatomic_inc(&cxt.n_lock_torture_errors);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"lock_torture_stats_print: Out of memory, need: %d\"",
            "size"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s\"",
            "buf"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"lock_torture_stats_print: Out of memory, need: %d\"",
            "size"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void lock_torture_stats_print(void)\n{\n\tint size = cxt.nrealwriters_stress * 200 + 8192;\n\tchar *buf;\n\n\tif (cxt.cur_ops->readlock)\n\t\tsize += cxt.nrealreaders_stress * 200 + 8192;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t       size);\n\t\treturn;\n\t}\n\n\t__torture_print_stats(buf, cxt.lwsa, true);\n\tpr_alert(\"%s\", buf);\n\tkfree(buf);\n\n\tif (cxt.cur_ops->readlock) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tpr_err(\"lock_torture_stats_print: Out of memory, need: %d\",\n\t\t\t       size);\n\t\t\treturn;\n\t\t}\n\n\t\t__torture_print_stats(buf, cxt.lrsa, false);\n\t\tpr_alert(\"%s\", buf);\n\t\tkfree(buf);\n\t}\n}"
  },
  {
    "function_name": "__torture_print_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "738-766",
    "snippet": "static void __torture_print_stats(char *page,\n\t\t\t\t  struct lock_stress_stats *statp, bool write)\n{\n\tlong cur;\n\tbool fail = false;\n\tint i, n_stress;\n\tlong max = 0, min = statp ? data_race(statp[0].n_lock_acquired) : 0;\n\tlong long sum = 0;\n\n\tn_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;\n\tfor (i = 0; i < n_stress; i++) {\n\t\tif (data_race(statp[i].n_lock_fail))\n\t\t\tfail = true;\n\t\tcur = data_race(statp[i].n_lock_acquired);\n\t\tsum += cur;\n\t\tif (max < cur)\n\t\t\tmax = cur;\n\t\tif (min > cur)\n\t\t\tmin = cur;\n\t}\n\tpage += sprintf(page,\n\t\t\t\"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\\n\",\n\t\t\twrite ? \"Writes\" : \"Reads \",\n\t\t\tsum, max, min,\n\t\t\t!onoff_interval && max / 2 > min ? \"???\" : \"\",\n\t\t\tfail, fail ? \"!!!\" : \"\");\n\tif (fail)\n\t\tatomic_inc(&cxt.n_lock_torture_errors);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cxt.n_lock_torture_errors"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\\n\"",
            "write ? \"Writes\" : \"Reads \"",
            "sum",
            "max",
            "min",
            "!onoff_interval && max / 2 > min ? \"???\" : \"\"",
            "fail",
            "fail ? \"!!!\" : \"\""
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "statp[i].n_lock_acquired"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void __torture_print_stats(char *page,\n\t\t\t\t  struct lock_stress_stats *statp, bool write)\n{\n\tlong cur;\n\tbool fail = false;\n\tint i, n_stress;\n\tlong max = 0, min = statp ? data_race(statp[0].n_lock_acquired) : 0;\n\tlong long sum = 0;\n\n\tn_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;\n\tfor (i = 0; i < n_stress; i++) {\n\t\tif (data_race(statp[i].n_lock_fail))\n\t\t\tfail = true;\n\t\tcur = data_race(statp[i].n_lock_acquired);\n\t\tsum += cur;\n\t\tif (max < cur)\n\t\t\tmax = cur;\n\t\tif (min > cur)\n\t\t\tmin = cur;\n\t}\n\tpage += sprintf(page,\n\t\t\t\"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\\n\",\n\t\t\twrite ? \"Writes\" : \"Reads \",\n\t\t\tsum, max, min,\n\t\t\t!onoff_interval && max / 2 > min ? \"???\" : \"\",\n\t\t\tfail, fail ? \"!!!\" : \"\");\n\tif (fail)\n\t\tatomic_inc(&cxt.n_lock_torture_errors);\n}"
  },
  {
    "function_name": "lock_torture_reader",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "706-733",
    "snippet": "static int lock_torture_reader(void *arg)\n{\n\tstruct lock_stress_stats *lrsp = arg;\n\tint tid = lrsp - cxt.lrsa;\n\tDEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"lock_torture_reader task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\tif ((torture_random(&rand) & 0xfffff) == 0)\n\t\t\tschedule_timeout_uninterruptible(1);\n\n\t\tcxt.cur_ops->readlock(tid);\n\t\tatomic_inc(&lock_is_read_held);\n\t\tif (WARN_ON_ONCE(lock_is_write_held))\n\t\t\tlrsp->n_lock_fail++; /* rare, but... */\n\n\t\tlrsp->n_lock_acquired++;\n\t\tcxt.cur_ops->read_delay(&rand);\n\t\tatomic_dec(&lock_is_read_held);\n\t\tcxt.cur_ops->readunlock(tid);\n\n\t\tstutter_wait(\"lock_torture_reader\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"lock_torture_reader\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lock_is_write_held;",
      "static atomic_t lock_is_read_held;",
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"lock_torture_reader\""
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"lock_torture_reader\""
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->readunlock",
          "args": [
            "tid"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&lock_is_read_held"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->read_delay",
          "args": [
            "&rand"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lock_is_write_held"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&lock_is_read_held"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->readlock",
          "args": [
            "tid"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&rand"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"lock_torture_reader task started\""
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_TORTURE_RANDOM",
          "args": [
            "rand"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic bool lock_is_write_held;\nstatic atomic_t lock_is_read_held;\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic int lock_torture_reader(void *arg)\n{\n\tstruct lock_stress_stats *lrsp = arg;\n\tint tid = lrsp - cxt.lrsa;\n\tDEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"lock_torture_reader task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\tif ((torture_random(&rand) & 0xfffff) == 0)\n\t\t\tschedule_timeout_uninterruptible(1);\n\n\t\tcxt.cur_ops->readlock(tid);\n\t\tatomic_inc(&lock_is_read_held);\n\t\tif (WARN_ON_ONCE(lock_is_write_held))\n\t\t\tlrsp->n_lock_fail++; /* rare, but... */\n\n\t\tlrsp->n_lock_acquired++;\n\t\tcxt.cur_ops->read_delay(&rand);\n\t\tatomic_dec(&lock_is_read_held);\n\t\tcxt.cur_ops->readunlock(tid);\n\n\t\tstutter_wait(\"lock_torture_reader\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"lock_torture_reader\");\n\treturn 0;\n}"
  },
  {
    "function_name": "lock_torture_writer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "667-700",
    "snippet": "static int lock_torture_writer(void *arg)\n{\n\tstruct lock_stress_stats *lwsp = arg;\n\tint tid = lwsp - cxt.lwsa;\n\tDEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"lock_torture_writer task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\tif ((torture_random(&rand) & 0xfffff) == 0)\n\t\t\tschedule_timeout_uninterruptible(1);\n\n\t\tcxt.cur_ops->task_boost(&rand);\n\t\tcxt.cur_ops->writelock(tid);\n\t\tif (WARN_ON_ONCE(lock_is_write_held))\n\t\t\tlwsp->n_lock_fail++;\n\t\tlock_is_write_held = true;\n\t\tif (WARN_ON_ONCE(atomic_read(&lock_is_read_held)))\n\t\t\tlwsp->n_lock_fail++; /* rare, but... */\n\n\t\tlwsp->n_lock_acquired++;\n\t\tcxt.cur_ops->write_delay(&rand);\n\t\tlock_is_write_held = false;\n\t\tWRITE_ONCE(last_lock_release, jiffies);\n\t\tcxt.cur_ops->writeunlock(tid);\n\n\t\tstutter_wait(\"lock_torture_writer\");\n\t} while (!torture_must_stop());\n\n\tcxt.cur_ops->task_boost(NULL); /* reset prio */\n\ttorture_kthread_stopping(\"lock_torture_writer\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lock_is_write_held;",
      "static atomic_t lock_is_read_held;",
      "static unsigned long last_lock_release;",
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"lock_torture_writer\""
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->task_boost",
          "args": [
            "NULL"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"lock_torture_writer\""
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->writeunlock",
          "args": [
            "tid"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "last_lock_release",
            "jiffies"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->write_delay",
          "args": [
            "&rand"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&lock_is_read_held)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&lock_is_read_held"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "lock_is_write_held"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->writelock",
          "args": [
            "tid"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cxt.cur_ops->task_boost",
          "args": [
            "&rand"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "&rand"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"lock_torture_writer task started\""
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_TORTURE_RANDOM",
          "args": [
            "rand"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic bool lock_is_write_held;\nstatic atomic_t lock_is_read_held;\nstatic unsigned long last_lock_release;\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic int lock_torture_writer(void *arg)\n{\n\tstruct lock_stress_stats *lwsp = arg;\n\tint tid = lwsp - cxt.lwsa;\n\tDEFINE_TORTURE_RANDOM(rand);\n\n\tVERBOSE_TOROUT_STRING(\"lock_torture_writer task started\");\n\tset_user_nice(current, MAX_NICE);\n\n\tdo {\n\t\tif ((torture_random(&rand) & 0xfffff) == 0)\n\t\t\tschedule_timeout_uninterruptible(1);\n\n\t\tcxt.cur_ops->task_boost(&rand);\n\t\tcxt.cur_ops->writelock(tid);\n\t\tif (WARN_ON_ONCE(lock_is_write_held))\n\t\t\tlwsp->n_lock_fail++;\n\t\tlock_is_write_held = true;\n\t\tif (WARN_ON_ONCE(atomic_read(&lock_is_read_held)))\n\t\t\tlwsp->n_lock_fail++; /* rare, but... */\n\n\t\tlwsp->n_lock_acquired++;\n\t\tcxt.cur_ops->write_delay(&rand);\n\t\tlock_is_write_held = false;\n\t\tWRITE_ONCE(last_lock_release, jiffies);\n\t\tcxt.cur_ops->writeunlock(tid);\n\n\t\tstutter_wait(\"lock_torture_writer\");\n\t} while (!torture_must_stop());\n\n\tcxt.cur_ops->task_boost(NULL); /* reset prio */\n\ttorture_kthread_stopping(\"lock_torture_writer\");\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_up_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "644-648",
    "snippet": "static void torture_percpu_rwsem_up_read(int tid __maybe_unused)\n__releases(pcpu_rwsem)\n{\n\tpercpu_up_read(&pcpu_rwsem);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_read",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "pcpu_rwsem"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic void torture_percpu_rwsem_up_read(int tid __maybe_unused)\n__releases(pcpu_rwsem)\n{\n\tpercpu_up_read(&pcpu_rwsem);\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_down_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "637-642",
    "snippet": "static int torture_percpu_rwsem_down_read(int tid __maybe_unused)\n__acquires(pcpu_rwsem)\n{\n\tpercpu_down_read(&pcpu_rwsem);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_read",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "pcpu_rwsem"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic int torture_percpu_rwsem_down_read(int tid __maybe_unused)\n__acquires(pcpu_rwsem)\n{\n\tpercpu_down_read(&pcpu_rwsem);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_up_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "631-635",
    "snippet": "static void torture_percpu_rwsem_up_write(int tid __maybe_unused)\n__releases(pcpu_rwsem)\n{\n\tpercpu_up_write(&pcpu_rwsem);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "pcpu_rwsem"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic void torture_percpu_rwsem_up_write(int tid __maybe_unused)\n__releases(pcpu_rwsem)\n{\n\tpercpu_up_write(&pcpu_rwsem);\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_down_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "624-629",
    "snippet": "static int torture_percpu_rwsem_down_write(int tid __maybe_unused)\n__acquires(pcpu_rwsem)\n{\n\tpercpu_down_write(&pcpu_rwsem);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "pcpu_rwsem"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic int torture_percpu_rwsem_down_write(int tid __maybe_unused)\n__acquires(pcpu_rwsem)\n{\n\tpercpu_down_write(&pcpu_rwsem);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "619-622",
    "snippet": "static void torture_percpu_rwsem_exit(void)\n{\n\tpercpu_free_rwsem(&pcpu_rwsem);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_free_rwsem",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_free_rwsem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "31-43",
          "snippet": "void percpu_free_rwsem(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * XXX: temporary kludge. The error path in alloc_super()\n\t * assumes that percpu_free_rwsem() is safe after kzalloc().\n\t */\n\tif (!sem->read_count)\n\t\treturn;\n\n\trcu_sync_dtor(&sem->rss);\n\tfree_percpu(sem->read_count);\n\tsem->read_count = NULL; /* catch use after free bugs */\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_free_rwsem(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * XXX: temporary kludge. The error path in alloc_super()\n\t * assumes that percpu_free_rwsem() is safe after kzalloc().\n\t */\n\tif (!sem->read_count)\n\t\treturn;\n\n\trcu_sync_dtor(&sem->rss);\n\tfree_percpu(sem->read_count);\n\tsem->read_count = NULL; /* catch use after free bugs */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic void torture_percpu_rwsem_exit(void)\n{\n\tpercpu_free_rwsem(&pcpu_rwsem);\n}"
  },
  {
    "function_name": "torture_percpu_rwsem_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "614-617",
    "snippet": "static void torture_percpu_rwsem_init(void)\n{\n\tBUG_ON(percpu_init_rwsem(&pcpu_rwsem));\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_rw_semaphore pcpu_rwsem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "percpu_init_rwsem(&pcpu_rwsem)"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_init_rwsem",
          "args": [
            "&pcpu_rwsem"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic void torture_percpu_rwsem_init(void)\n{\n\tBUG_ON(percpu_init_rwsem(&pcpu_rwsem));\n}"
  },
  {
    "function_name": "torture_rwsem_up_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "594-598",
    "snippet": "static void torture_rwsem_up_read(int tid __maybe_unused)\n__releases(torture_rwsem)\n{\n\tup_read(&torture_rwsem);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(torture_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&torture_rwsem"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "torture_percpu_rwsem_up_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "644-648",
          "snippet": "static void torture_percpu_rwsem_up_read(int tid __maybe_unused)\n__releases(pcpu_rwsem)\n{\n\tpercpu_up_read(&pcpu_rwsem);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_rw_semaphore pcpu_rwsem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic void torture_percpu_rwsem_up_read(int tid __maybe_unused)\n__releases(pcpu_rwsem)\n{\n\tpercpu_up_read(&pcpu_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwsem"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(torture_rwsem);\n\nstatic void torture_rwsem_up_read(int tid __maybe_unused)\n__releases(torture_rwsem)\n{\n\tup_read(&torture_rwsem);\n}"
  },
  {
    "function_name": "torture_rwsem_read_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "580-592",
    "snippet": "static void torture_rwsem_read_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealreaders_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 2);\n\telse\n\t\tmdelay(longdelay_ms / 2);\n\tif (!(torture_random(trsp) % (cxt.nrealreaders_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms / 2"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms * 2"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rwsem_read_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealreaders_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 2);\n\telse\n\t\tmdelay(longdelay_ms / 2);\n\tif (!(torture_random(trsp) % (cxt.nrealreaders_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_rwsem_down_read",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "573-578",
    "snippet": "static int torture_rwsem_down_read(int tid __maybe_unused)\n__acquires(torture_rwsem)\n{\n\tdown_read(&torture_rwsem);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(torture_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&torture_rwsem"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "torture_percpu_rwsem_down_read",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "637-642",
          "snippet": "static int torture_percpu_rwsem_down_read(int tid __maybe_unused)\n__acquires(pcpu_rwsem)\n{\n\tpercpu_down_read(&pcpu_rwsem);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_rw_semaphore pcpu_rwsem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic int torture_percpu_rwsem_down_read(int tid __maybe_unused)\n__acquires(pcpu_rwsem)\n{\n\tpercpu_down_read(&pcpu_rwsem);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwsem"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(torture_rwsem);\n\nstatic int torture_rwsem_down_read(int tid __maybe_unused)\n__acquires(torture_rwsem)\n{\n\tdown_read(&torture_rwsem);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rwsem_up_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "567-571",
    "snippet": "static void torture_rwsem_up_write(int tid __maybe_unused)\n__releases(torture_rwsem)\n{\n\tup_write(&torture_rwsem);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(torture_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&torture_rwsem"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "torture_percpu_rwsem_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "631-635",
          "snippet": "static void torture_percpu_rwsem_up_write(int tid __maybe_unused)\n__releases(pcpu_rwsem)\n{\n\tpercpu_up_write(&pcpu_rwsem);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_rw_semaphore pcpu_rwsem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic void torture_percpu_rwsem_up_write(int tid __maybe_unused)\n__releases(pcpu_rwsem)\n{\n\tpercpu_up_write(&pcpu_rwsem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwsem"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(torture_rwsem);\n\nstatic void torture_rwsem_up_write(int tid __maybe_unused)\n__releases(torture_rwsem)\n{\n\tup_write(&torture_rwsem);\n}"
  },
  {
    "function_name": "torture_rwsem_write_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "553-565",
    "snippet": "static void torture_rwsem_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 10);\n\telse\n\t\tmdelay(longdelay_ms / 10);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms / 10"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms * 10"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rwsem_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 10);\n\telse\n\t\tmdelay(longdelay_ms / 10);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_rwsem_down_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "546-551",
    "snippet": "static int torture_rwsem_down_write(int tid __maybe_unused)\n__acquires(torture_rwsem)\n{\n\tdown_write(&torture_rwsem);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(torture_rwsem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&torture_rwsem"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "torture_percpu_rwsem_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "624-629",
          "snippet": "static int torture_percpu_rwsem_down_write(int tid __maybe_unused)\n__acquires(pcpu_rwsem)\n{\n\tpercpu_down_write(&pcpu_rwsem);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_rw_semaphore pcpu_rwsem;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct percpu_rw_semaphore pcpu_rwsem;\n\nstatic int torture_percpu_rwsem_down_write(int tid __maybe_unused)\n__acquires(pcpu_rwsem)\n{\n\tpercpu_down_write(&pcpu_rwsem);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwsem"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DECLARE_RWSEM(torture_rwsem);\n\nstatic int torture_rwsem_down_write(int tid __maybe_unused)\n__acquires(torture_rwsem)\n{\n\tdown_write(&torture_rwsem);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rtmutex_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "527-531",
    "snippet": "static void torture_rtmutex_unlock(int tid __maybe_unused)\n__releases(torture_rtmutex)\n{\n\trt_mutex_unlock(&torture_rtmutex);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rt_mutex_unlock",
          "args": [
            "&torture_rtmutex"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rtmutex"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void torture_rtmutex_unlock(int tid __maybe_unused)\n__releases(torture_rtmutex)\n{\n\trt_mutex_unlock(&torture_rtmutex);\n}"
  },
  {
    "function_name": "torture_rtmutex_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "508-525",
    "snippet": "static void torture_rtmutex_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/*\n\t * We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2 * shortdelay_us)))\n\t\tudelay(shortdelay_us);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "shortdelay_us"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rtmutex_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/*\n\t * We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2 * shortdelay_us)))\n\t\tudelay(shortdelay_us);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_rtmutex_boost",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "477-506",
    "snippet": "static void torture_rtmutex_boost(struct torture_random_state *trsp)\n{\n\tconst unsigned int factor = 50000; /* yes, quite arbitrary */\n\n\tif (!rt_task(current)) {\n\t\t/*\n\t\t * Boost priority once every ~50k operations. When the\n\t\t * task tries to take the lock, the rtmutex it will account\n\t\t * for the new priority, and do any corresponding pi-dance.\n\t\t */\n\t\tif (trsp && !(torture_random(trsp) %\n\t\t\t      (cxt.nrealwriters_stress * factor))) {\n\t\t\tsched_set_fifo(current);\n\t\t} else /* common case, do nothing */\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * The task will remain boosted for another ~500k operations,\n\t\t * then restored back to its original prio, and so forth.\n\t\t *\n\t\t * When @trsp is nil, we want to force-reset the task for\n\t\t * stopping the kthread.\n\t\t */\n\t\tif (!trsp || !(torture_random(trsp) %\n\t\t\t       (cxt.nrealwriters_stress * factor * 2))) {\n\t\t\tsched_set_normal(current, 0);\n\t\t} else /* common case, do nothing */\n\t\t\treturn;\n\t}\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_set_normal",
          "args": [
            "current",
            "0"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7606-7613",
          "snippet": "void sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_normal(struct task_struct *p, int nice)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy = SCHED_NORMAL,\n\t\t.sched_nice = nice,\n\t};\n\tWARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_set_fifo",
          "args": [
            "current"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "sched_set_fifo_low",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "7599-7603",
          "snippet": "void sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid sched_set_fifo_low(struct task_struct *p)\n{\n\tstruct sched_param sp = { .sched_priority = 1 };\n\tWARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "current"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_task_sighand_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/signal.c",
          "lines": "1417-1428",
          "snippet": "void lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(task->sighand);\n\tif (sighand)\n\t\tlockdep_assert_held(&sighand->siglock);\n\telse\n\t\tWARN_ON_ONCE(1);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include <asm/syscall.h>\t/* for syscall_get_* */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/audit.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/task_work.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/audit.h>\n#include <linux/cgroup.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/task_work.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tsighand = rcu_dereference(task->sighand);\n\tif (sighand)\n\t\tlockdep_assert_held(&sighand->siglock);\n\telse\n\t\tWARN_ON_ONCE(1);\n\trcu_read_unlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rtmutex_boost(struct torture_random_state *trsp)\n{\n\tconst unsigned int factor = 50000; /* yes, quite arbitrary */\n\n\tif (!rt_task(current)) {\n\t\t/*\n\t\t * Boost priority once every ~50k operations. When the\n\t\t * task tries to take the lock, the rtmutex it will account\n\t\t * for the new priority, and do any corresponding pi-dance.\n\t\t */\n\t\tif (trsp && !(torture_random(trsp) %\n\t\t\t      (cxt.nrealwriters_stress * factor))) {\n\t\t\tsched_set_fifo(current);\n\t\t} else /* common case, do nothing */\n\t\t\treturn;\n\t} else {\n\t\t/*\n\t\t * The task will remain boosted for another ~500k operations,\n\t\t * then restored back to its original prio, and so forth.\n\t\t *\n\t\t * When @trsp is nil, we want to force-reset the task for\n\t\t * stopping the kthread.\n\t\t */\n\t\tif (!trsp || !(torture_random(trsp) %\n\t\t\t       (cxt.nrealwriters_stress * factor * 2))) {\n\t\t\tsched_set_normal(current, 0);\n\t\t} else /* common case, do nothing */\n\t\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "torture_rtmutex_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "470-475",
    "snippet": "static int torture_rtmutex_lock(int tid __maybe_unused)\n__acquires(torture_rtmutex)\n{\n\trt_mutex_lock(&torture_rtmutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rt_mutex_lock",
          "args": [
            "&torture_rtmutex"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_killable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "100-103",
          "snippet": "int __sched rt_mutex_lock_killable(struct rt_mutex *lock)\n{\n\treturn __rt_mutex_lock_common(lock, TASK_KILLABLE, NULL, 0);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_killable(struct rt_mutex *lock)\n{\n\treturn __rt_mutex_lock_common(lock, TASK_KILLABLE, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rtmutex"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int torture_rtmutex_lock(int tid __maybe_unused)\n__acquires(torture_rtmutex)\n{\n\trt_mutex_lock(&torture_rtmutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_ww_mutex_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "441-452",
    "snippet": "static void torture_ww_mutex_unlock(int tid)\n__releases(torture_ww_mutex_0)\n__releases(torture_ww_mutex_1)\n__releases(torture_ww_mutex_2)\n{\n\tstruct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];\n\n\tww_mutex_unlock(&torture_ww_mutex_0);\n\tww_mutex_unlock(&torture_ww_mutex_1);\n\tww_mutex_unlock(&torture_ww_mutex_2);\n\tww_acquire_fini(ctx);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ww_mutex torture_ww_mutex_0, torture_ww_mutex_1, torture_ww_mutex_2;",
      "static struct ww_acquire_ctx *ww_acquire_ctxs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "ctx"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&torture_ww_mutex_2"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "torture_ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "441-452",
          "snippet": "static void torture_ww_mutex_unlock(int tid)\n__releases(torture_ww_mutex_0)\n__releases(torture_ww_mutex_1)\n__releases(torture_ww_mutex_2)\n{\n\tstruct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];\n\n\tww_mutex_unlock(&torture_ww_mutex_0);\n\tww_mutex_unlock(&torture_ww_mutex_1);\n\tww_mutex_unlock(&torture_ww_mutex_2);\n\tww_acquire_fini(ctx);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_ww_mutex_2"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_ww_mutex_1"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_ww_mutex_0"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct ww_mutex torture_ww_mutex_0, torture_ww_mutex_1, torture_ww_mutex_2;\nstatic struct ww_acquire_ctx *ww_acquire_ctxs;\n\nstatic void torture_ww_mutex_unlock(int tid)\n__releases(torture_ww_mutex_0)\n__releases(torture_ww_mutex_1)\n__releases(torture_ww_mutex_2)\n{\n\tstruct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];\n\n\tww_mutex_unlock(&torture_ww_mutex_0);\n\tww_mutex_unlock(&torture_ww_mutex_1);\n\tww_mutex_unlock(&torture_ww_mutex_2);\n\tww_acquire_fini(ctx);\n}"
  },
  {
    "function_name": "torture_ww_mutex_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "397-439",
    "snippet": "static int torture_ww_mutex_lock(int tid)\n__acquires(torture_ww_mutex_0)\n__acquires(torture_ww_mutex_1)\n__acquires(torture_ww_mutex_2)\n{\n\tLIST_HEAD(list);\n\tstruct reorder_lock {\n\t\tstruct list_head link;\n\t\tstruct ww_mutex *lock;\n\t} locks[3], *ll, *ln;\n\tstruct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];\n\n\tlocks[0].lock = &torture_ww_mutex_0;\n\tlist_add(&locks[0].link, &list);\n\n\tlocks[1].lock = &torture_ww_mutex_1;\n\tlist_add(&locks[1].link, &list);\n\n\tlocks[2].lock = &torture_ww_mutex_2;\n\tlist_add(&locks[2].link, &list);\n\n\tww_acquire_init(ctx, &torture_ww_class);\n\n\tlist_for_each_entry(ll, &list, link) {\n\t\tint err;\n\n\t\terr = ww_mutex_lock(ll->lock, ctx);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\tln = ll;\n\t\tlist_for_each_entry_continue_reverse(ln, &list, link)\n\t\t\tww_mutex_unlock(ln->lock);\n\n\t\tif (err != -EDEADLK)\n\t\t\treturn err;\n\n\t\tww_mutex_lock_slow(ll->lock, ctx);\n\t\tlist_move(&ll->link, &list);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(torture_ww_class);",
      "static struct ww_mutex torture_ww_mutex_0, torture_ww_mutex_1, torture_ww_mutex_2;",
      "static struct ww_acquire_ctx *ww_acquire_ctxs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&ll->link",
            "&list"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "ll->lock",
            "ctx"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/mutex.c",
          "lines": "1036-1041",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "#include \"ww_mutex.h\"",
            "#include \"mutex.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ww_mutex.h\"\n#include \"mutex.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "ln->lock"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "torture_ww_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "441-452",
          "snippet": "static void torture_ww_mutex_unlock(int tid)\n__releases(torture_ww_mutex_0)\n__releases(torture_ww_mutex_1)\n__releases(torture_ww_mutex_2)\n{\n\tstruct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];\n\n\tww_mutex_unlock(&torture_ww_mutex_0);\n\tww_mutex_unlock(&torture_ww_mutex_1);\n\tww_mutex_unlock(&torture_ww_mutex_2);\n\tww_acquire_fini(ctx);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ww_mutex torture_ww_mutex_0, torture_ww_mutex_1, torture_ww_mutex_2;",
            "static struct ww_acquire_ctx *ww_acquire_ctxs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct ww_mutex torture_ww_mutex_0, torture_ww_mutex_1, torture_ww_mutex_2;\nstatic struct ww_acquire_ctx *ww_acquire_ctxs;\n\nstatic void torture_ww_mutex_unlock(int tid)\n__releases(torture_ww_mutex_0)\n__releases(torture_ww_mutex_1)\n__releases(torture_ww_mutex_2)\n{\n\tstruct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];\n\n\tww_mutex_unlock(&torture_ww_mutex_0);\n\tww_mutex_unlock(&torture_ww_mutex_1);\n\tww_mutex_unlock(&torture_ww_mutex_2);\n\tww_acquire_fini(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue_reverse",
          "args": [
            "ln",
            "&list",
            "link"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "ll->lock",
            "ctx"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_acquired",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "45-48",
          "snippet": "static inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline void ww_mutex_lock_acquired(struct ww_mutex *lock,\n\t\t\t\t\t  struct ww_acquire_ctx *ww_ctx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ll",
            "&list",
            "link"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "ctx",
            "&torture_ww_class"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&locks[2].link",
            "&list"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_ww_mutex_2"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_ww_mutex_1"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_ww_mutex_0"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(torture_ww_class);\nstatic struct ww_mutex torture_ww_mutex_0, torture_ww_mutex_1, torture_ww_mutex_2;\nstatic struct ww_acquire_ctx *ww_acquire_ctxs;\n\nstatic int torture_ww_mutex_lock(int tid)\n__acquires(torture_ww_mutex_0)\n__acquires(torture_ww_mutex_1)\n__acquires(torture_ww_mutex_2)\n{\n\tLIST_HEAD(list);\n\tstruct reorder_lock {\n\t\tstruct list_head link;\n\t\tstruct ww_mutex *lock;\n\t} locks[3], *ll, *ln;\n\tstruct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];\n\n\tlocks[0].lock = &torture_ww_mutex_0;\n\tlist_add(&locks[0].link, &list);\n\n\tlocks[1].lock = &torture_ww_mutex_1;\n\tlist_add(&locks[1].link, &list);\n\n\tlocks[2].lock = &torture_ww_mutex_2;\n\tlist_add(&locks[2].link, &list);\n\n\tww_acquire_init(ctx, &torture_ww_class);\n\n\tlist_for_each_entry(ll, &list, link) {\n\t\tint err;\n\n\t\terr = ww_mutex_lock(ll->lock, ctx);\n\t\tif (!err)\n\t\t\tcontinue;\n\n\t\tln = ll;\n\t\tlist_for_each_entry_continue_reverse(ln, &list, link)\n\t\t\tww_mutex_unlock(ln->lock);\n\n\t\tif (err != -EDEADLK)\n\t\t\treturn err;\n\n\t\tww_mutex_lock_slow(ll->lock, ctx);\n\t\tlist_move(&ll->link, &list);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_ww_mutex_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "392-395",
    "snippet": "static void torture_ww_mutex_exit(void)\n{\n\tkfree(ww_acquire_ctxs);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ww_acquire_ctx *ww_acquire_ctxs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ww_acquire_ctxs"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct ww_acquire_ctx *ww_acquire_ctxs;\n\nstatic void torture_ww_mutex_exit(void)\n{\n\tkfree(ww_acquire_ctxs);\n}"
  },
  {
    "function_name": "torture_ww_mutex_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "379-390",
    "snippet": "static void torture_ww_mutex_init(void)\n{\n\tww_mutex_init(&torture_ww_mutex_0, &torture_ww_class);\n\tww_mutex_init(&torture_ww_mutex_1, &torture_ww_class);\n\tww_mutex_init(&torture_ww_mutex_2, &torture_ww_class);\n\n\tww_acquire_ctxs = kmalloc_array(cxt.nrealwriters_stress,\n\t\t\t\t\tsizeof(*ww_acquire_ctxs),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ww_acquire_ctxs)\n\t\tVERBOSE_TOROUT_STRING(\"ww_acquire_ctx: Out of memory\");\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_WD_CLASS(torture_ww_class);",
      "static struct ww_mutex torture_ww_mutex_0, torture_ww_mutex_1, torture_ww_mutex_2;",
      "static struct ww_acquire_ctx *ww_acquire_ctxs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"ww_acquire_ctx: Out of memory\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "cxt.nrealwriters_stress",
            "sizeof(*ww_acquire_ctxs)",
            "GFP_KERNEL"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&torture_ww_mutex_2",
            "&torture_ww_class"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&torture_ww_mutex_1",
            "&torture_ww_class"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&torture_ww_mutex_0",
            "&torture_ww_class"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_WD_CLASS(torture_ww_class);\nstatic struct ww_mutex torture_ww_mutex_0, torture_ww_mutex_1, torture_ww_mutex_2;\nstatic struct ww_acquire_ctx *ww_acquire_ctxs;\n\nstatic void torture_ww_mutex_init(void)\n{\n\tww_mutex_init(&torture_ww_mutex_0, &torture_ww_class);\n\tww_mutex_init(&torture_ww_mutex_1, &torture_ww_class);\n\tww_mutex_init(&torture_ww_mutex_2, &torture_ww_class);\n\n\tww_acquire_ctxs = kmalloc_array(cxt.nrealwriters_stress,\n\t\t\t\t\tsizeof(*ww_acquire_ctxs),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!ww_acquire_ctxs)\n\t\tVERBOSE_TOROUT_STRING(\"ww_acquire_ctx: Out of memory\");\n}"
  },
  {
    "function_name": "torture_mutex_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "352-356",
    "snippet": "static void torture_mutex_unlock(int tid __maybe_unused)\n__releases(torture_mutex)\n{\n\tmutex_unlock(&torture_mutex);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(torture_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&torture_mutex"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "torture_rtmutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "527-531",
          "snippet": "static void torture_rtmutex_unlock(int tid __maybe_unused)\n__releases(torture_rtmutex)\n{\n\trt_mutex_unlock(&torture_rtmutex);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void torture_rtmutex_unlock(int tid __maybe_unused)\n__releases(torture_rtmutex)\n{\n\trt_mutex_unlock(&torture_rtmutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_mutex"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(torture_mutex);\n\nstatic void torture_mutex_unlock(int tid __maybe_unused)\n__releases(torture_mutex)\n{\n\tmutex_unlock(&torture_mutex);\n}"
  },
  {
    "function_name": "torture_mutex_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "338-350",
    "snippet": "static void torture_mutex_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 5);\n\telse\n\t\tmdelay(longdelay_ms / 5);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms / 5"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms * 5"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_mutex_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms * 5);\n\telse\n\t\tmdelay(longdelay_ms / 5);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_mutex_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "331-336",
    "snippet": "static int torture_mutex_lock(int tid __maybe_unused)\n__acquires(torture_mutex)\n{\n\tmutex_lock(&torture_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(torture_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&torture_mutex"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "torture_rtmutex_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "470-475",
          "snippet": "static int torture_rtmutex_lock(int tid __maybe_unused)\n__acquires(torture_rtmutex)\n{\n\trt_mutex_lock(&torture_rtmutex);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int torture_rtmutex_lock(int tid __maybe_unused)\n__acquires(torture_rtmutex)\n{\n\trt_mutex_lock(&torture_rtmutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_mutex"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(torture_mutex);\n\nstatic int torture_mutex_lock(int tid __maybe_unused)\n__acquires(torture_mutex)\n{\n\tmutex_lock(&torture_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rwlock_read_unlock_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "312-316",
    "snippet": "static void torture_rwlock_read_unlock_irq(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\tread_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&torture_rwlock",
            "cxt.cur_ops->flags"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_read_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "266-269",
          "snippet": "void __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_read_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_read_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwlock"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic void torture_rwlock_read_unlock_irq(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\tread_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}"
  },
  {
    "function_name": "torture_rwlock_read_lock_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "302-310",
    "snippet": "static int torture_rwlock_read_lock_irq(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\tread_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&torture_rwlock",
            "flags"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwlock"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic int torture_rwlock_read_lock_irq(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\tread_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rwlock_write_unlock_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "296-300",
    "snippet": "static void torture_rwlock_write_unlock_irq(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\twrite_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&torture_rwlock",
            "cxt.cur_ops->flags"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_write_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "348-351",
          "snippet": "void __lockfunc _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_write_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_write_unlock_irqrestore(rwlock_t *lock, unsigned long flags)\n{\n\t__raw_write_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwlock"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic void torture_rwlock_write_unlock_irq(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\twrite_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}"
  },
  {
    "function_name": "torture_rwlock_write_lock_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "286-294",
    "snippet": "static int torture_rwlock_write_lock_irq(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&torture_rwlock",
            "flags"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwlock"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic int torture_rwlock_write_lock_irq(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rwlock_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "269-273",
    "snippet": "static void torture_rwlock_read_unlock(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\tread_unlock(&torture_rwlock);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&torture_rwlock"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "torture_rwlock_read_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "312-316",
          "snippet": "static void torture_rwlock_read_unlock_irq(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\tread_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
            "static DEFINE_RWLOCK(torture_rwlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic void torture_rwlock_read_unlock_irq(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\tread_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwlock"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic void torture_rwlock_read_unlock(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\tread_unlock(&torture_rwlock);\n}"
  },
  {
    "function_name": "torture_rwlock_read_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "254-267",
    "snippet": "static void torture_rwlock_read_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 10;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealreaders_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\telse\n\t\tudelay(shortdelay_us);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "shortdelay_us"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rwlock_read_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 10;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealreaders_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\telse\n\t\tudelay(shortdelay_us);\n}"
  },
  {
    "function_name": "torture_rwlock_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "247-252",
    "snippet": "static int torture_rwlock_read_lock(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\tread_lock(&torture_rwlock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&torture_rwlock"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "torture_rwlock_read_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "302-310",
          "snippet": "static int torture_rwlock_read_lock_irq(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\tread_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
            "static DEFINE_RWLOCK(torture_rwlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic int torture_rwlock_read_lock_irq(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\tread_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwlock"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic int torture_rwlock_read_lock(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\tread_lock(&torture_rwlock);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_rwlock_write_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "241-245",
    "snippet": "static void torture_rwlock_write_unlock(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\twrite_unlock(&torture_rwlock);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&torture_rwlock"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "torture_rwlock_write_unlock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "296-300",
          "snippet": "static void torture_rwlock_write_unlock_irq(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\twrite_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
            "static DEFINE_RWLOCK(torture_rwlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic void torture_rwlock_write_unlock_irq(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\twrite_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_rwlock"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic void torture_rwlock_write_unlock(int tid __maybe_unused)\n__releases(torture_rwlock)\n{\n\twrite_unlock(&torture_rwlock);\n}"
  },
  {
    "function_name": "torture_rwlock_write_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "226-239",
    "snippet": "static void torture_rwlock_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\telse\n\t\tudelay(shortdelay_us);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "shortdelay_us"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_rwlock_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\telse\n\t\tudelay(shortdelay_us);\n}"
  },
  {
    "function_name": "torture_rwlock_write_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "219-224",
    "snippet": "static int torture_rwlock_write_lock(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\twrite_lock(&torture_rwlock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(torture_rwlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&torture_rwlock"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "torture_rwlock_write_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "286-294",
          "snippet": "static int torture_rwlock_write_lock_irq(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
            "static DEFINE_RWLOCK(torture_rwlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic int torture_rwlock_write_lock_irq(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&torture_rwlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_rwlock"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(torture_rwlock);\n\nstatic int torture_rwlock_write_lock(int tid __maybe_unused)\n__acquires(torture_rwlock)\n{\n\twrite_lock(&torture_rwlock);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_lock_spin_write_unlock_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "200-204",
    "snippet": "static void torture_lock_spin_write_unlock_irq(int tid __maybe_unused)\n__releases(torture_spinlock)\n{\n\tspin_unlock_irqrestore(&torture_spinlock, cxt.cur_ops->flags);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_SPINLOCK(torture_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&torture_spinlock",
            "cxt.cur_ops->flags"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_spinlock"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_SPINLOCK(torture_spinlock);\n\nstatic void torture_lock_spin_write_unlock_irq(int tid __maybe_unused)\n__releases(torture_spinlock)\n{\n\tspin_unlock_irqrestore(&torture_spinlock, cxt.cur_ops->flags);\n}"
  },
  {
    "function_name": "torture_spin_lock_write_lock_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "190-198",
    "snippet": "static int torture_spin_lock_write_lock_irq(int tid __maybe_unused)\n__acquires(torture_spinlock)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&torture_spinlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
      "static DEFINE_SPINLOCK(torture_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&torture_spinlock",
            "flags"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_spinlock"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_SPINLOCK(torture_spinlock);\n\nstatic int torture_spin_lock_write_lock_irq(int tid __maybe_unused)\n__acquires(torture_spinlock)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&torture_spinlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_spin_lock_write_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "173-177",
    "snippet": "static void torture_spin_lock_write_unlock(int tid __maybe_unused)\n__releases(torture_spinlock)\n{\n\tspin_unlock(&torture_spinlock);\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(torture_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&torture_spinlock"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "547-561",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "torture_spinlock"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(torture_spinlock);\n\nstatic void torture_spin_lock_write_unlock(int tid __maybe_unused)\n__releases(torture_spinlock)\n{\n\tspin_unlock(&torture_spinlock);\n}"
  },
  {
    "function_name": "torture_spin_lock_write_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "155-171",
    "snippet": "static void torture_spin_lock_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2 * shortdelay_us)))\n\t\tudelay(shortdelay_us);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "shortdelay_us"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_spin_lock_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long shortdelay_us = 2;\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a short delay mostly to emulate likely code, and\n\t * we want a long delay occasionally to force massive contention.\n\t */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2 * shortdelay_us)))\n\t\tudelay(shortdelay_us);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_spin_lock_write_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "148-153",
    "snippet": "static int torture_spin_lock_write_lock(int tid __maybe_unused)\n__acquires(torture_spinlock)\n{\n\tspin_lock(&torture_spinlock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(torture_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&torture_spinlock"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "torture_spin_lock_write_lock_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
          "lines": "190-198",
          "snippet": "static int torture_spin_lock_write_lock_irq(int tid __maybe_unused)\n__acquires(torture_spinlock)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&torture_spinlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/reboot.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/atomic.h>",
            "#include <linux/rtmutex.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mutex.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};",
            "static DEFINE_SPINLOCK(torture_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\nstatic DEFINE_SPINLOCK(torture_spinlock);\n\nstatic int torture_spin_lock_write_lock_irq(int tid __maybe_unused)\n__acquires(torture_spinlock)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&torture_spinlock, flags);\n\tcxt.cur_ops->flags = flags;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "torture_spinlock"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(torture_spinlock);\n\nstatic int torture_spin_lock_write_lock(int tid __maybe_unused)\n__acquires(torture_spinlock)\n{\n\tspin_lock(&torture_spinlock);\n\treturn 0;\n}"
  },
  {
    "function_name": "torture_boost_dummy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "130-133",
    "snippet": "static void torture_boost_dummy(struct torture_random_state *trsp)\n{\n\t/* Only rtmutexes care about priority */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void torture_boost_dummy(struct torture_random_state *trsp)\n{\n\t/* Only rtmutexes care about priority */\n}"
  },
  {
    "function_name": "torture_lock_busted_write_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "125-128",
    "snippet": "static void torture_lock_busted_write_unlock(int tid __maybe_unused)\n{\n\t  /* BUGGY, do not use in real life!!! */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void torture_lock_busted_write_unlock(int tid __maybe_unused)\n{\n\t  /* BUGGY, do not use in real life!!! */\n}"
  },
  {
    "function_name": "torture_lock_busted_write_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "113-123",
    "snippet": "static void torture_lock_busted_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_preempt_schedule",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "longdelay_ms"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct lock_torture_cxt cxt = { 0, 0, false, false,\n\t\t\t\t       ATOMIC_INIT(0),\n\t\t\t\t       NULL, NULL};\n\nstatic void torture_lock_busted_write_delay(struct torture_random_state *trsp)\n{\n\tconst unsigned long longdelay_ms = 100;\n\n\t/* We want a long delay occasionally to force massive contention.  */\n\tif (!(torture_random(trsp) %\n\t      (cxt.nrealwriters_stress * 2000 * longdelay_ms)))\n\t\tmdelay(longdelay_ms);\n\tif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\n\t\ttorture_preempt_schedule();  /* Allow test to be preempted. */\n}"
  },
  {
    "function_name": "torture_lock_busted_write_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/locktorture.c",
    "lines": "108-111",
    "snippet": "static int torture_lock_busted_write_lock(int tid __maybe_unused)\n{\n\treturn 0;  /* BUGGY, do not use in real life!!! */\n}",
    "includes": [
      "#include <linux/percpu-rwsem.h>",
      "#include <linux/ww_mutex.h>",
      "#include <linux/reboot.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/delay.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/atomic.h>",
      "#include <linux/rtmutex.h>",
      "#include <uapi/linux/sched/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/smp.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/mutex.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/percpu-rwsem.h>\n#include <linux/ww_mutex.h>\n#include <linux/reboot.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/atomic.h>\n#include <linux/rtmutex.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/rwsem.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/sched/rt.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int torture_lock_busted_write_lock(int tid __maybe_unused)\n{\n\treturn 0;  /* BUGGY, do not use in real life!!! */\n}"
  }
]