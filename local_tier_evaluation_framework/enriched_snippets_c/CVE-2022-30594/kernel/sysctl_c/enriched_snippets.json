[
  {
    "function_name": "printk_sysctl_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/sysctl.c",
    "lines": "82-85",
    "snippet": "void __init printk_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", printk_sysctls);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/printk.h>",
      "#include <linux/sysctl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table printk_sysctls[] = {\n\t{\n\t\t.procname\t= \"printk\",\n\t\t.data\t\t= &console_loglevel,\n\t\t.maxlen\t\t= 4*sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"printk_ratelimit\",\n\t\t.data\t\t= &printk_ratelimit_state.interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"printk_ratelimit_burst\",\n\t\t.data\t\t= &printk_ratelimit_state.burst,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"printk_delay\",\n\t\t.data\t\t= &printk_delay_msec,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= (void *)&ten_thousand,\n\t},\n\t{\n\t\t.procname\t= \"printk_devkmsg\",\n\t\t.data\t\t= devkmsg_log_str,\n\t\t.maxlen\t\t= DEVKMSG_STR_MAX_SIZE,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= devkmsg_sysctl_set_loglvl,\n\t},\n\t{\n\t\t.procname\t= \"dmesg_restrict\",\n\t\t.data\t\t= &dmesg_restrict,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax_sysadmin,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"kptr_restrict\",\n\t\t.data\t\t= &kptr_restrict,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax_sysadmin,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_init",
          "args": [
            "\"kernel\"",
            "printk_sysctls"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/printk.h>\n#include <linux/sysctl.h>\n\nstatic struct ctl_table printk_sysctls[] = {\n\t{\n\t\t.procname\t= \"printk\",\n\t\t.data\t\t= &console_loglevel,\n\t\t.maxlen\t\t= 4*sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"printk_ratelimit\",\n\t\t.data\t\t= &printk_ratelimit_state.interval,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_jiffies,\n\t},\n\t{\n\t\t.procname\t= \"printk_ratelimit_burst\",\n\t\t.data\t\t= &printk_ratelimit_state.burst,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec,\n\t},\n\t{\n\t\t.procname\t= \"printk_delay\",\n\t\t.data\t\t= &printk_delay_msec,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= (void *)&ten_thousand,\n\t},\n\t{\n\t\t.procname\t= \"printk_devkmsg\",\n\t\t.data\t\t= devkmsg_log_str,\n\t\t.maxlen\t\t= DEVKMSG_STR_MAX_SIZE,\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= devkmsg_sysctl_set_loglvl,\n\t},\n\t{\n\t\t.procname\t= \"dmesg_restrict\",\n\t\t.data\t\t= &dmesg_restrict,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax_sysadmin,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_ONE,\n\t},\n\t{\n\t\t.procname\t= \"kptr_restrict\",\n\t\t.data\t\t= &kptr_restrict,\n\t\t.maxlen\t\t= sizeof(int),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_dointvec_minmax_sysadmin,\n\t\t.extra1\t\t= SYSCTL_ZERO,\n\t\t.extra2\t\t= SYSCTL_TWO,\n\t},\n\t{}\n};\n\nvoid __init printk_sysctl_init(void)\n{\n\tregister_sysctl_init(\"kernel\", printk_sysctls);\n}"
  },
  {
    "function_name": "proc_dointvec_minmax_sysadmin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/sysctl.c",
    "lines": "14-21",
    "snippet": "static int proc_dointvec_minmax_sysadmin(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/ratelimit.h>",
      "#include <linux/capability.h>",
      "#include <linux/printk.h>",
      "#include <linux/sysctl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax_sysadmin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/sysctl.c",
          "lines": "14-21",
          "snippet": "static int proc_dointvec_minmax_sysadmin(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/printk.h>\n#include <linux/sysctl.h>\n\nstatic int proc_dointvec_minmax_sysadmin(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n}"
  }
]