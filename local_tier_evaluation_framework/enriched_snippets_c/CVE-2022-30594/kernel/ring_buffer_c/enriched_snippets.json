[
  {
    "function_name": "perf_mmap_to_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "948-964",
    "snippet": "struct page *\nperf_mmap_to_page(struct perf_buffer *rb, unsigned long pgoff)\n{\n\tif (rb->aux_nr_pages) {\n\t\t/* above AUX space */\n\t\tif (pgoff > rb->aux_pgoff + rb->aux_nr_pages)\n\t\t\treturn NULL;\n\n\t\t/* AUX space */\n\t\tif (pgoff >= rb->aux_pgoff) {\n\t\t\tint aux_pgoff = array_index_nospec(pgoff - rb->aux_pgoff, rb->aux_nr_pages);\n\t\t\treturn virt_to_page(rb->aux_pages[aux_pgoff]);\n\t\t}\n\t}\n\n\treturn __perf_mmap_to_page(rb, pgoff);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__perf_mmap_to_page",
          "args": [
            "rb",
            "pgoff"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "__perf_mmap_to_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "867-875",
          "snippet": "static struct page *\n__perf_mmap_to_page(struct perf_buffer *rb, unsigned long pgoff)\n{\n\t/* The '>' counts in the user page. */\n\tif (pgoff > data_page_nr(rb))\n\t\treturn NULL;\n\n\treturn vmalloc_to_page((void *)rb->user_page + pgoff * PAGE_SIZE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic struct page *\n__perf_mmap_to_page(struct perf_buffer *rb, unsigned long pgoff)\n{\n\t/* The '>' counts in the user page. */\n\tif (pgoff > data_page_nr(rb))\n\t\treturn NULL;\n\n\treturn vmalloc_to_page((void *)rb->user_page + pgoff * PAGE_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "rb->aux_pages[aux_pgoff]"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "pgoff - rb->aux_pgoff",
            "rb->aux_nr_pages"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstruct page *\nperf_mmap_to_page(struct perf_buffer *rb, unsigned long pgoff)\n{\n\tif (rb->aux_nr_pages) {\n\t\t/* above AUX space */\n\t\tif (pgoff > rb->aux_pgoff + rb->aux_nr_pages)\n\t\t\treturn NULL;\n\n\t\t/* AUX space */\n\t\tif (pgoff >= rb->aux_pgoff) {\n\t\t\tint aux_pgoff = array_index_nospec(pgoff - rb->aux_pgoff, rb->aux_nr_pages);\n\t\t\treturn virt_to_page(rb->aux_pages[aux_pgoff]);\n\t\t}\n\t}\n\n\treturn __perf_mmap_to_page(rb, pgoff);\n}"
  },
  {
    "function_name": "rb_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "907-944",
    "snippet": "struct perf_buffer *rb_alloc(int nr_pages, long watermark, int cpu, int flags)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long size;\n\tvoid *all_buf;\n\tint node;\n\n\tsize = sizeof(struct perf_buffer);\n\tsize += sizeof(void *);\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\trb = kzalloc_node(size, GFP_KERNEL, node);\n\tif (!rb)\n\t\tgoto fail;\n\n\tINIT_WORK(&rb->work, rb_free_work);\n\n\tall_buf = vmalloc_user((nr_pages + 1) * PAGE_SIZE);\n\tif (!all_buf)\n\t\tgoto fail_all_buf;\n\n\trb->user_page = all_buf;\n\trb->data_pages[0] = all_buf + PAGE_SIZE;\n\tif (nr_pages) {\n\t\trb->nr_pages = 1;\n\t\trb->page_order = ilog2(nr_pages);\n\t}\n\n\tring_buffer_init(rb, watermark, flags);\n\n\treturn rb;\n\nfail_all_buf:\n\tkfree(rb);\n\nfail:\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_init",
          "args": [
            "rb",
            "watermark",
            "flags"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "305-332",
          "snippet": "static void\nring_buffer_init(struct perf_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\trefcount_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void\nring_buffer_init(struct perf_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\trefcount_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "nr_pages"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc_user",
          "args": [
            "(nr_pages + 1) * PAGE_SIZE"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&rb->work",
            "rb_free_work"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "size",
            "GFP_KERNEL",
            "node"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstruct perf_buffer *rb_alloc(int nr_pages, long watermark, int cpu, int flags)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long size;\n\tvoid *all_buf;\n\tint node;\n\n\tsize = sizeof(struct perf_buffer);\n\tsize += sizeof(void *);\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\trb = kzalloc_node(size, GFP_KERNEL, node);\n\tif (!rb)\n\t\tgoto fail;\n\n\tINIT_WORK(&rb->work, rb_free_work);\n\n\tall_buf = vmalloc_user((nr_pages + 1) * PAGE_SIZE);\n\tif (!all_buf)\n\t\tgoto fail_all_buf;\n\n\trb->user_page = all_buf;\n\trb->data_pages[0] = all_buf + PAGE_SIZE;\n\tif (nr_pages) {\n\t\trb->nr_pages = 1;\n\t\trb->page_order = ilog2(nr_pages);\n\t}\n\n\tring_buffer_init(rb, watermark, flags);\n\n\treturn rb;\n\nfail_all_buf:\n\tkfree(rb);\n\nfail:\n\treturn NULL;\n}"
  },
  {
    "function_name": "rb_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "902-905",
    "snippet": "void rb_free(struct perf_buffer *rb)\n{\n\tschedule_work(&rb->work);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&rb->work"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid rb_free(struct perf_buffer *rb)\n{\n\tschedule_work(&rb->work);\n}"
  },
  {
    "function_name": "rb_free_work",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "884-900",
    "snippet": "static void rb_free_work(struct work_struct *work)\n{\n\tstruct perf_buffer *rb;\n\tvoid *base;\n\tint i, nr;\n\n\trb = container_of(work, struct perf_buffer, work);\n\tnr = data_page_nr(rb);\n\n\tbase = rb->user_page;\n\t/* The '<=' counts in the user page. */\n\tfor (i = 0; i <= nr; i++)\n\t\tperf_mmap_unmark_page(base + (i * PAGE_SIZE));\n\n\tvfree(base);\n\tkfree(rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "base"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_mmap_unmark_page",
          "args": [
            "base + (i * PAGE_SIZE)"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mmap_unmark_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "877-882",
          "snippet": "static void perf_mmap_unmark_page(void *addr)\n{\n\tstruct page *page = vmalloc_to_page(addr);\n\n\tpage->mapping = NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_mmap_unmark_page(void *addr)\n{\n\tstruct page *page = vmalloc_to_page(addr);\n\n\tpage->mapping = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_page_nr",
          "args": [
            "rb"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "data_page_nr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "862-865",
          "snippet": "static int data_page_nr(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic int data_page_nr(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structperf_buffer",
            "work"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void rb_free_work(struct work_struct *work)\n{\n\tstruct perf_buffer *rb;\n\tvoid *base;\n\tint i, nr;\n\n\trb = container_of(work, struct perf_buffer, work);\n\tnr = data_page_nr(rb);\n\n\tbase = rb->user_page;\n\t/* The '<=' counts in the user page. */\n\tfor (i = 0; i <= nr; i++)\n\t\tperf_mmap_unmark_page(base + (i * PAGE_SIZE));\n\n\tvfree(base);\n\tkfree(rb);\n}"
  },
  {
    "function_name": "perf_mmap_unmark_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "877-882",
    "snippet": "static void perf_mmap_unmark_page(void *addr)\n{\n\tstruct page *page = vmalloc_to_page(addr);\n\n\tpage->mapping = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "addr"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_mmap_unmark_page(void *addr)\n{\n\tstruct page *page = vmalloc_to_page(addr);\n\n\tpage->mapping = NULL;\n}"
  },
  {
    "function_name": "__perf_mmap_to_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "867-875",
    "snippet": "static struct page *\n__perf_mmap_to_page(struct perf_buffer *rb, unsigned long pgoff)\n{\n\t/* The '>' counts in the user page. */\n\tif (pgoff > data_page_nr(rb))\n\t\treturn NULL;\n\n\treturn vmalloc_to_page((void *)rb->user_page + pgoff * PAGE_SIZE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmalloc_to_page",
          "args": [
            "(void *)rb->user_page + pgoff * PAGE_SIZE"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_page_nr",
          "args": [
            "rb"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "data_page_nr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "862-865",
          "snippet": "static int data_page_nr(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic int data_page_nr(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic struct page *\n__perf_mmap_to_page(struct perf_buffer *rb, unsigned long pgoff)\n{\n\t/* The '>' counts in the user page. */\n\tif (pgoff > data_page_nr(rb))\n\t\treturn NULL;\n\n\treturn vmalloc_to_page((void *)rb->user_page + pgoff * PAGE_SIZE);\n}"
  },
  {
    "function_name": "data_page_nr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "862-865",
    "snippet": "static int data_page_nr(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "rb"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "page_order",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "113-116",
          "snippet": "static inline int page_order(struct perf_buffer *rb)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline int page_order(struct perf_buffer *rb)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic int data_page_nr(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << page_order(rb);\n}"
  },
  {
    "function_name": "rb_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "851-859",
    "snippet": "void rb_free(struct perf_buffer *rb)\n{\n\tint i;\n\n\tperf_mmap_free_page(rb->user_page);\n\tfor (i = 0; i < rb->nr_pages; i++)\n\t\tperf_mmap_free_page(rb->data_pages[i]);\n\tkfree(rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_mmap_free_page",
          "args": [
            "rb->data_pages[i]"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mmap_free_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "797-803",
          "snippet": "static void perf_mmap_free_page(void *addr)\n{\n\tstruct page *page = virt_to_page(addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_mmap_free_page(void *addr)\n{\n\tstruct page *page = virt_to_page(addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid rb_free(struct perf_buffer *rb)\n{\n\tint i;\n\n\tperf_mmap_free_page(rb->user_page);\n\tfor (i = 0; i < rb->nr_pages; i++)\n\t\tperf_mmap_free_page(rb->data_pages[i]);\n\tkfree(rb);\n}"
  },
  {
    "function_name": "rb_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "805-849",
    "snippet": "struct perf_buffer *rb_alloc(int nr_pages, long watermark, int cpu, int flags)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long size;\n\tint i, node;\n\n\tsize = sizeof(struct perf_buffer);\n\tsize += nr_pages * sizeof(void *);\n\n\tif (order_base_2(size) >= PAGE_SHIFT+MAX_ORDER)\n\t\tgoto fail;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\trb = kzalloc_node(size, GFP_KERNEL, node);\n\tif (!rb)\n\t\tgoto fail;\n\n\trb->user_page = perf_mmap_alloc_page(cpu);\n\tif (!rb->user_page)\n\t\tgoto fail_user_page;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\trb->data_pages[i] = perf_mmap_alloc_page(cpu);\n\t\tif (!rb->data_pages[i])\n\t\t\tgoto fail_data_pages;\n\t}\n\n\trb->nr_pages = nr_pages;\n\n\tring_buffer_init(rb, watermark, flags);\n\n\treturn rb;\n\nfail_data_pages:\n\tfor (i--; i >= 0; i--)\n\t\tperf_mmap_free_page(rb->data_pages[i]);\n\n\tperf_mmap_free_page(rb->user_page);\n\nfail_user_page:\n\tkfree(rb);\n\nfail:\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_mmap_free_page",
          "args": [
            "rb->user_page"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mmap_free_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "797-803",
          "snippet": "static void perf_mmap_free_page(void *addr)\n{\n\tstruct page *page = virt_to_page(addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_mmap_free_page(void *addr)\n{\n\tstruct page *page = virt_to_page(addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_init",
          "args": [
            "rb",
            "watermark",
            "flags"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "305-332",
          "snippet": "static void\nring_buffer_init(struct perf_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\trefcount_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void\nring_buffer_init(struct perf_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\trefcount_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_mmap_alloc_page",
          "args": [
            "cpu"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mmap_alloc_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "784-795",
          "snippet": "static void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "size",
            "GFP_KERNEL",
            "node"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "order_base_2",
          "args": [
            "size"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstruct perf_buffer *rb_alloc(int nr_pages, long watermark, int cpu, int flags)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long size;\n\tint i, node;\n\n\tsize = sizeof(struct perf_buffer);\n\tsize += nr_pages * sizeof(void *);\n\n\tif (order_base_2(size) >= PAGE_SHIFT+MAX_ORDER)\n\t\tgoto fail;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\trb = kzalloc_node(size, GFP_KERNEL, node);\n\tif (!rb)\n\t\tgoto fail;\n\n\trb->user_page = perf_mmap_alloc_page(cpu);\n\tif (!rb->user_page)\n\t\tgoto fail_user_page;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\trb->data_pages[i] = perf_mmap_alloc_page(cpu);\n\t\tif (!rb->data_pages[i])\n\t\t\tgoto fail_data_pages;\n\t}\n\n\trb->nr_pages = nr_pages;\n\n\tring_buffer_init(rb, watermark, flags);\n\n\treturn rb;\n\nfail_data_pages:\n\tfor (i--; i >= 0; i--)\n\t\tperf_mmap_free_page(rb->data_pages[i]);\n\n\tperf_mmap_free_page(rb->user_page);\n\nfail_user_page:\n\tkfree(rb);\n\nfail:\n\treturn NULL;\n}"
  },
  {
    "function_name": "perf_mmap_free_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "797-803",
    "snippet": "static void perf_mmap_free_page(void *addr)\n{\n\tstruct page *page = virt_to_page(addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "addr"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_mmap_free_page(void *addr)\n{\n\tstruct page *page = virt_to_page(addr);\n\n\tpage->mapping = NULL;\n\t__free_page(page);\n}"
  },
  {
    "function_name": "perf_mmap_alloc_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "784-795",
    "snippet": "static void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "GFP_KERNEL | __GFP_ZERO",
            "0"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void *perf_mmap_alloc_page(int cpu)\n{\n\tstruct page *page;\n\tint node;\n\n\tnode = (cpu == -1) ? cpu : cpu_to_node(cpu);\n\tpage = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\n\tif (!page)\n\t\treturn NULL;\n\n\treturn page_address(page);\n}"
  },
  {
    "function_name": "__perf_mmap_to_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "772-782",
    "snippet": "static struct page *\n__perf_mmap_to_page(struct perf_buffer *rb, unsigned long pgoff)\n{\n\tif (pgoff > rb->nr_pages)\n\t\treturn NULL;\n\n\tif (pgoff == 0)\n\t\treturn virt_to_page(rb->user_page);\n\n\treturn virt_to_page(rb->data_pages[pgoff - 1]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "rb->data_pages[pgoff - 1]"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "rb->user_page"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic struct page *\n__perf_mmap_to_page(struct perf_buffer *rb, unsigned long pgoff)\n{\n\tif (pgoff > rb->nr_pages)\n\t\treturn NULL;\n\n\tif (pgoff == 0)\n\t\treturn virt_to_page(rb->user_page);\n\n\treturn virt_to_page(rb->data_pages[pgoff - 1]);\n}"
  },
  {
    "function_name": "rb_free_aux",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "760-764",
    "snippet": "void rb_free_aux(struct perf_buffer *rb)\n{\n\tif (refcount_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rb_free_aux",
          "args": [
            "rb"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "__rb_free_aux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "640-665",
          "snippet": "static void __rb_free_aux(struct perf_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void __rb_free_aux(struct perf_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&rb->aux_refcount"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid rb_free_aux(struct perf_buffer *rb)\n{\n\tif (refcount_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}"
  },
  {
    "function_name": "rb_alloc_aux",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "667-758",
    "snippet": "int rb_alloc_aux(struct perf_buffer *rb, struct perf_event *event,\n\t\t pgoff_t pgoff, int nr_pages, long watermark, int flags)\n{\n\tbool overwrite = !(flags & RING_BUFFER_WRITABLE);\n\tint node = (event->cpu == -1) ? -1 : cpu_to_node(event->cpu);\n\tint ret = -ENOMEM, max_order;\n\n\tif (!has_aux(event))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!overwrite) {\n\t\t/*\n\t\t * Watermark defaults to half the buffer, and so does the\n\t\t * max_order, to aid PMU drivers in double buffering.\n\t\t */\n\t\tif (!watermark)\n\t\t\twatermark = nr_pages << (PAGE_SHIFT - 1);\n\n\t\t/*\n\t\t * Use aux_watermark as the basis for chunking to\n\t\t * help PMU drivers honor the watermark.\n\t\t */\n\t\tmax_order = get_order(watermark);\n\t} else {\n\t\t/*\n\t\t * We need to start with the max_order that fits in nr_pages,\n\t\t * not the other way around, hence ilog2() and not get_order.\n\t\t */\n\t\tmax_order = ilog2(nr_pages);\n\t\twatermark = 0;\n\t}\n\n\trb->aux_pages = kcalloc_node(nr_pages, sizeof(void *), GFP_KERNEL,\n\t\t\t\t     node);\n\tif (!rb->aux_pages)\n\t\treturn -ENOMEM;\n\n\trb->free_aux = event->pmu->free_aux;\n\tfor (rb->aux_nr_pages = 0; rb->aux_nr_pages < nr_pages;) {\n\t\tstruct page *page;\n\t\tint last, order;\n\n\t\torder = min(max_order, ilog2(nr_pages - rb->aux_nr_pages));\n\t\tpage = rb_alloc_aux_page(node, order);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\tfor (last = rb->aux_nr_pages + (1 << page_private(page));\n\t\t     last > rb->aux_nr_pages; rb->aux_nr_pages++)\n\t\t\trb->aux_pages[rb->aux_nr_pages] = page_address(page++);\n\t}\n\n\t/*\n\t * In overwrite mode, PMUs that don't support SG may not handle more\n\t * than one contiguous allocation, since they rely on PMI to do double\n\t * buffering. In this case, the entire buffer has to be one contiguous\n\t * chunk.\n\t */\n\tif ((event->pmu->capabilities & PERF_PMU_CAP_AUX_NO_SG) &&\n\t    overwrite) {\n\t\tstruct page *page = virt_to_page(rb->aux_pages[0]);\n\n\t\tif (page_private(page) != max_order)\n\t\t\tgoto out;\n\t}\n\n\trb->aux_priv = event->pmu->setup_aux(event, rb->aux_pages, nr_pages,\n\t\t\t\t\t     overwrite);\n\tif (!rb->aux_priv)\n\t\tgoto out;\n\n\tret = 0;\n\n\t/*\n\t * aux_pages (and pmu driver's private data, aux_priv) will be\n\t * referenced in both producer's and consumer's contexts, thus\n\t * we keep a refcount here to make sure either of the two can\n\t * reference them safely.\n\t */\n\trefcount_set(&rb->aux_refcount, 1);\n\n\trb->aux_overwrite = overwrite;\n\trb->aux_watermark = watermark;\n\nout:\n\tif (!ret)\n\t\trb->aux_pgoff = pgoff;\n\telse\n\t\t__rb_free_aux(rb);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rb_free_aux",
          "args": [
            "rb"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "__rb_free_aux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "640-665",
          "snippet": "static void __rb_free_aux(struct perf_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void __rb_free_aux(struct perf_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&rb->aux_refcount",
            "1"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event->pmu->setup_aux",
          "args": [
            "event",
            "rb->aux_pages",
            "nr_pages",
            "overwrite"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "rb->aux_pages[0]"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page++"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_private",
          "args": [
            "page"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_alloc_aux_page",
          "args": [
            "node",
            "order"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "rb_alloc_aux_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "605-629",
          "snippet": "static struct page *rb_alloc_aux_page(int node, int order)\n{\n\tstruct page *page;\n\n\tif (order > MAX_ORDER)\n\t\torder = MAX_ORDER;\n\n\tdo {\n\t\tpage = alloc_pages_node(node, PERF_AUX_GFP, order);\n\t} while (!page && order--);\n\n\tif (page && order) {\n\t\t/*\n\t\t * Communicate the allocation size to the driver:\n\t\t * if we managed to secure a high-order allocation,\n\t\t * set its first page's private to this order;\n\t\t * !PagePrivate(page) means it's just a normal page.\n\t\t */\n\t\tsplit_page(page, order);\n\t\tSetPagePrivate(page);\n\t\tset_page_private(page, order);\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [
            "#define PERF_AUX_GFP\t(GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\n#define PERF_AUX_GFP\t(GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY)\n\nstatic struct page *rb_alloc_aux_page(int node, int order)\n{\n\tstruct page *page;\n\n\tif (order > MAX_ORDER)\n\t\torder = MAX_ORDER;\n\n\tdo {\n\t\tpage = alloc_pages_node(node, PERF_AUX_GFP, order);\n\t} while (!page && order--);\n\n\tif (page && order) {\n\t\t/*\n\t\t * Communicate the allocation size to the driver:\n\t\t * if we managed to secure a high-order allocation,\n\t\t * set its first page's private to this order;\n\t\t * !PagePrivate(page) means it's just a normal page.\n\t\t */\n\t\tsplit_page(page, order);\n\t\tSetPagePrivate(page);\n\t\tset_page_private(page, order);\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max_order",
            "ilog2(nr_pages - rb->aux_nr_pages)"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "nr_pages - rb->aux_nr_pages"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc_node",
          "args": [
            "nr_pages",
            "sizeof(void *)",
            "GFP_KERNEL",
            "node"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "nr_pages"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "watermark"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_aux",
          "args": [
            "event"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "rb_has_aux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "88-91",
          "snippet": "static inline bool rb_has_aux(struct perf_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline bool rb_has_aux(struct perf_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "event->cpu"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nint rb_alloc_aux(struct perf_buffer *rb, struct perf_event *event,\n\t\t pgoff_t pgoff, int nr_pages, long watermark, int flags)\n{\n\tbool overwrite = !(flags & RING_BUFFER_WRITABLE);\n\tint node = (event->cpu == -1) ? -1 : cpu_to_node(event->cpu);\n\tint ret = -ENOMEM, max_order;\n\n\tif (!has_aux(event))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!overwrite) {\n\t\t/*\n\t\t * Watermark defaults to half the buffer, and so does the\n\t\t * max_order, to aid PMU drivers in double buffering.\n\t\t */\n\t\tif (!watermark)\n\t\t\twatermark = nr_pages << (PAGE_SHIFT - 1);\n\n\t\t/*\n\t\t * Use aux_watermark as the basis for chunking to\n\t\t * help PMU drivers honor the watermark.\n\t\t */\n\t\tmax_order = get_order(watermark);\n\t} else {\n\t\t/*\n\t\t * We need to start with the max_order that fits in nr_pages,\n\t\t * not the other way around, hence ilog2() and not get_order.\n\t\t */\n\t\tmax_order = ilog2(nr_pages);\n\t\twatermark = 0;\n\t}\n\n\trb->aux_pages = kcalloc_node(nr_pages, sizeof(void *), GFP_KERNEL,\n\t\t\t\t     node);\n\tif (!rb->aux_pages)\n\t\treturn -ENOMEM;\n\n\trb->free_aux = event->pmu->free_aux;\n\tfor (rb->aux_nr_pages = 0; rb->aux_nr_pages < nr_pages;) {\n\t\tstruct page *page;\n\t\tint last, order;\n\n\t\torder = min(max_order, ilog2(nr_pages - rb->aux_nr_pages));\n\t\tpage = rb_alloc_aux_page(node, order);\n\t\tif (!page)\n\t\t\tgoto out;\n\n\t\tfor (last = rb->aux_nr_pages + (1 << page_private(page));\n\t\t     last > rb->aux_nr_pages; rb->aux_nr_pages++)\n\t\t\trb->aux_pages[rb->aux_nr_pages] = page_address(page++);\n\t}\n\n\t/*\n\t * In overwrite mode, PMUs that don't support SG may not handle more\n\t * than one contiguous allocation, since they rely on PMI to do double\n\t * buffering. In this case, the entire buffer has to be one contiguous\n\t * chunk.\n\t */\n\tif ((event->pmu->capabilities & PERF_PMU_CAP_AUX_NO_SG) &&\n\t    overwrite) {\n\t\tstruct page *page = virt_to_page(rb->aux_pages[0]);\n\n\t\tif (page_private(page) != max_order)\n\t\t\tgoto out;\n\t}\n\n\trb->aux_priv = event->pmu->setup_aux(event, rb->aux_pages, nr_pages,\n\t\t\t\t\t     overwrite);\n\tif (!rb->aux_priv)\n\t\tgoto out;\n\n\tret = 0;\n\n\t/*\n\t * aux_pages (and pmu driver's private data, aux_priv) will be\n\t * referenced in both producer's and consumer's contexts, thus\n\t * we keep a refcount here to make sure either of the two can\n\t * reference them safely.\n\t */\n\trefcount_set(&rb->aux_refcount, 1);\n\n\trb->aux_overwrite = overwrite;\n\trb->aux_watermark = watermark;\n\nout:\n\tif (!ret)\n\t\trb->aux_pgoff = pgoff;\n\telse\n\t\t__rb_free_aux(rb);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__rb_free_aux",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "640-665",
    "snippet": "static void __rb_free_aux(struct perf_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rb->aux_pages"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_free_aux_page",
          "args": [
            "rb",
            "pg"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "rb_free_aux_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "631-638",
          "snippet": "static void rb_free_aux_page(struct perf_buffer *rb, int idx)\n{\n\tstruct page *page = virt_to_page(rb->aux_pages[idx]);\n\n\tClearPagePrivate(page);\n\tpage->mapping = NULL;\n\t__free_page(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void rb_free_aux_page(struct perf_buffer *rb, int idx)\n{\n\tstruct page *page = virt_to_page(rb->aux_pages[idx]);\n\n\tClearPagePrivate(page);\n\tpage->mapping = NULL;\n\t__free_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb->free_aux",
          "args": [
            "rb->aux_priv"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "in_atomic()"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_atomic",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void __rb_free_aux(struct perf_buffer *rb)\n{\n\tint pg;\n\n\t/*\n\t * Should never happen, the last reference should be dropped from\n\t * perf_mmap_close() path, which first stops aux transactions (which\n\t * in turn are the atomic holders of aux_refcount) and then does the\n\t * last rb_free_aux().\n\t */\n\tWARN_ON_ONCE(in_atomic());\n\n\tif (rb->aux_priv) {\n\t\trb->free_aux(rb->aux_priv);\n\t\trb->free_aux = NULL;\n\t\trb->aux_priv = NULL;\n\t}\n\n\tif (rb->aux_nr_pages) {\n\t\tfor (pg = 0; pg < rb->aux_nr_pages; pg++)\n\t\t\trb_free_aux_page(rb, pg);\n\n\t\tkfree(rb->aux_pages);\n\t\trb->aux_nr_pages = 0;\n\t}\n}"
  },
  {
    "function_name": "rb_free_aux_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "631-638",
    "snippet": "static void rb_free_aux_page(struct perf_buffer *rb, int idx)\n{\n\tstruct page *page = virt_to_page(rb->aux_pages[idx]);\n\n\tClearPagePrivate(page);\n\tpage->mapping = NULL;\n\t__free_page(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPagePrivate",
          "args": [
            "page"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "rb->aux_pages[idx]"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void rb_free_aux_page(struct perf_buffer *rb, int idx)\n{\n\tstruct page *page = virt_to_page(rb->aux_pages[idx]);\n\n\tClearPagePrivate(page);\n\tpage->mapping = NULL;\n\t__free_page(page);\n}"
  },
  {
    "function_name": "rb_alloc_aux_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "605-629",
    "snippet": "static struct page *rb_alloc_aux_page(int node, int order)\n{\n\tstruct page *page;\n\n\tif (order > MAX_ORDER)\n\t\torder = MAX_ORDER;\n\n\tdo {\n\t\tpage = alloc_pages_node(node, PERF_AUX_GFP, order);\n\t} while (!page && order--);\n\n\tif (page && order) {\n\t\t/*\n\t\t * Communicate the allocation size to the driver:\n\t\t * if we managed to secure a high-order allocation,\n\t\t * set its first page's private to this order;\n\t\t * !PagePrivate(page) means it's just a normal page.\n\t\t */\n\t\tsplit_page(page, order);\n\t\tSetPagePrivate(page);\n\t\tset_page_private(page, order);\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [
      "#define PERF_AUX_GFP\t(GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "page",
            "order"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPagePrivate",
          "args": [
            "page"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_page",
          "args": [
            "page",
            "order"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages_node",
          "args": [
            "node",
            "PERF_AUX_GFP",
            "order"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\n#define PERF_AUX_GFP\t(GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY)\n\nstatic struct page *rb_alloc_aux_page(int node, int order)\n{\n\tstruct page *page;\n\n\tif (order > MAX_ORDER)\n\t\torder = MAX_ORDER;\n\n\tdo {\n\t\tpage = alloc_pages_node(node, PERF_AUX_GFP, order);\n\t} while (!page && order--);\n\n\tif (page && order) {\n\t\t/*\n\t\t * Communicate the allocation size to the driver:\n\t\t * if we managed to secure a high-order allocation,\n\t\t * set its first page's private to this order;\n\t\t * !PagePrivate(page) means it's just a normal page.\n\t\t */\n\t\tsplit_page(page, order);\n\t\tSetPagePrivate(page);\n\t\tset_page_private(page, order);\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "perf_output_copy_aux",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "570-601",
    "snippet": "long perf_output_copy_aux(struct perf_output_handle *aux_handle,\n\t\t\t  struct perf_output_handle *handle,\n\t\t\t  unsigned long from, unsigned long to)\n{\n\tstruct perf_buffer *rb = aux_handle->rb;\n\tunsigned long tocopy, remainder, len = 0;\n\tvoid *addr;\n\n\tfrom &= (rb->aux_nr_pages << PAGE_SHIFT) - 1;\n\tto &= (rb->aux_nr_pages << PAGE_SHIFT) - 1;\n\n\tdo {\n\t\ttocopy = PAGE_SIZE - offset_in_page(from);\n\t\tif (to > from)\n\t\t\ttocopy = min(tocopy, to - from);\n\t\tif (!tocopy)\n\t\t\tbreak;\n\n\t\taddr = rb->aux_pages[from >> PAGE_SHIFT];\n\t\taddr += offset_in_page(from);\n\n\t\tremainder = perf_output_copy(handle, addr, tocopy);\n\t\tif (remainder)\n\t\t\treturn -EFAULT;\n\n\t\tlen += tocopy;\n\t\tfrom += tocopy;\n\t\tfrom &= (rb->aux_nr_pages << PAGE_SHIFT) - 1;\n\t} while (to != from);\n\n\treturn len;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_output_copy",
          "args": [
            "handle",
            "addr",
            "tocopy"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_copy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "287-291",
          "snippet": "unsigned int perf_output_copy(struct perf_output_handle *handle,\n\t\t      const void *buf, unsigned int len)\n{\n\treturn __output_copy(handle, buf, len);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nunsigned int perf_output_copy(struct perf_output_handle *handle,\n\t\t      const void *buf, unsigned int len)\n{\n\treturn __output_copy(handle, buf, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "from"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "tocopy",
            "to - from"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "from"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nlong perf_output_copy_aux(struct perf_output_handle *aux_handle,\n\t\t\t  struct perf_output_handle *handle,\n\t\t\t  unsigned long from, unsigned long to)\n{\n\tstruct perf_buffer *rb = aux_handle->rb;\n\tunsigned long tocopy, remainder, len = 0;\n\tvoid *addr;\n\n\tfrom &= (rb->aux_nr_pages << PAGE_SHIFT) - 1;\n\tto &= (rb->aux_nr_pages << PAGE_SHIFT) - 1;\n\n\tdo {\n\t\ttocopy = PAGE_SIZE - offset_in_page(from);\n\t\tif (to > from)\n\t\t\ttocopy = min(tocopy, to - from);\n\t\tif (!tocopy)\n\t\t\tbreak;\n\n\t\taddr = rb->aux_pages[from >> PAGE_SHIFT];\n\t\taddr += offset_in_page(from);\n\n\t\tremainder = perf_output_copy(handle, addr, tocopy);\n\t\tif (remainder)\n\t\t\treturn -EFAULT;\n\n\t\tlen += tocopy;\n\t\tfrom += tocopy;\n\t\tfrom &= (rb->aux_nr_pages << PAGE_SHIFT) - 1;\n\t} while (to != from);\n\n\treturn len;\n}"
  },
  {
    "function_name": "perf_get_aux",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "557-564",
    "snippet": "void *perf_get_aux(struct perf_output_handle *handle)\n{\n\t/* this is only valid between perf_aux_output_begin and *_end */\n\tif (!handle->event)\n\t\treturn NULL;\n\n\treturn handle->rb->aux_priv;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid *perf_get_aux(struct perf_output_handle *handle)\n{\n\t/* this is only valid between perf_aux_output_begin and *_end */\n\tif (!handle->event)\n\t\treturn NULL;\n\n\treturn handle->rb->aux_priv;\n}"
  },
  {
    "function_name": "perf_aux_output_skip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "535-554",
    "snippet": "int perf_aux_output_skip(struct perf_output_handle *handle, unsigned long size)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\n\tif (size > handle->size)\n\t\treturn -ENOSPC;\n\n\trb->aux_head += size;\n\n\tWRITE_ONCE(rb->user_page->aux_head, rb->aux_head);\n\tif (rb_need_aux_wakeup(rb)) {\n\t\tperf_output_wakeup(handle);\n\t\thandle->wakeup = rb->aux_wakeup + rb->aux_watermark;\n\t}\n\n\thandle->head = rb->aux_head;\n\thandle->size -= size;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_output_wakeup",
          "args": [
            "handle"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "20-26",
          "snippet": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_need_aux_wakeup",
          "args": [
            "rb"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "rb_need_aux_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "454-465",
          "snippet": "static __always_inline bool rb_need_aux_wakeup(struct perf_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline bool rb_need_aux_wakeup(struct perf_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rb->user_page->aux_head",
            "rb->aux_head"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nint perf_aux_output_skip(struct perf_output_handle *handle, unsigned long size)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\n\tif (size > handle->size)\n\t\treturn -ENOSPC;\n\n\trb->aux_head += size;\n\n\tWRITE_ONCE(rb->user_page->aux_head, rb->aux_head);\n\tif (rb_need_aux_wakeup(rb)) {\n\t\tperf_output_wakeup(handle);\n\t\thandle->wakeup = rb->aux_wakeup + rb->aux_watermark;\n\t}\n\n\thandle->head = rb->aux_head;\n\thandle->size -= size;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "perf_aux_output_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "477-528",
    "snippet": "void perf_aux_output_end(struct perf_output_handle *handle, unsigned long size)\n{\n\tbool wakeup = !!(handle->aux_flags & PERF_AUX_FLAG_TRUNCATED);\n\tstruct perf_buffer *rb = handle->rb;\n\tunsigned long aux_head;\n\n\t/* in overwrite mode, driver provides aux_head via handle */\n\tif (rb->aux_overwrite) {\n\t\thandle->aux_flags |= PERF_AUX_FLAG_OVERWRITE;\n\n\t\taux_head = handle->head;\n\t\trb->aux_head = aux_head;\n\t} else {\n\t\thandle->aux_flags &= ~PERF_AUX_FLAG_OVERWRITE;\n\n\t\taux_head = rb->aux_head;\n\t\trb->aux_head += size;\n\t}\n\n\t/*\n\t * Only send RECORD_AUX if we have something useful to communicate\n\t *\n\t * Note: the OVERWRITE records by themselves are not considered\n\t * useful, as they don't communicate any *new* information,\n\t * aside from the short-lived offset, that becomes history at\n\t * the next event sched-in and therefore isn't useful.\n\t * The userspace that needs to copy out AUX data in overwrite\n\t * mode should know to use user_page::aux_head for the actual\n\t * offset. So, from now on we don't output AUX records that\n\t * have *only* OVERWRITE flag set.\n\t */\n\tif (size || (handle->aux_flags & ~(u64)PERF_AUX_FLAG_OVERWRITE))\n\t\tperf_event_aux_event(handle->event, aux_head, size,\n\t\t\t\t     handle->aux_flags);\n\n\tWRITE_ONCE(rb->user_page->aux_head, rb->aux_head);\n\tif (rb_need_aux_wakeup(rb))\n\t\twakeup = true;\n\n\tif (wakeup) {\n\t\tif (handle->aux_flags & PERF_AUX_FLAG_TRUNCATED)\n\t\t\thandle->event->pending_disable = smp_processor_id();\n\t\tperf_output_wakeup(handle);\n\t}\n\n\thandle->event = NULL;\n\n\tWRITE_ONCE(rb->aux_nest, 0);\n\t/* can't be last */\n\trb_free_aux(rb);\n\tring_buffer_put(rb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_put",
          "args": [
            "rb"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "6022-6030",
          "snippet": "void ring_buffer_put(struct perf_buffer *rb)\n{\n\tif (!refcount_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&rb->event_list));\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct perf_buffer *rb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct perf_buffer *rb);\n\nvoid ring_buffer_put(struct perf_buffer *rb)\n{\n\tif (!refcount_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&rb->event_list));\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_free_aux",
          "args": [
            "rb"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "rb_free_aux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "760-764",
          "snippet": "void rb_free_aux(struct perf_buffer *rb)\n{\n\tif (refcount_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid rb_free_aux(struct perf_buffer *rb)\n{\n\tif (refcount_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rb->aux_nest",
            "0"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_output_wakeup",
          "args": [
            "handle"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "20-26",
          "snippet": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_need_aux_wakeup",
          "args": [
            "rb"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "rb_need_aux_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "454-465",
          "snippet": "static __always_inline bool rb_need_aux_wakeup(struct perf_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline bool rb_need_aux_wakeup(struct perf_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rb->user_page->aux_head",
            "rb->aux_head"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_aux_event",
          "args": [
            "handle->event",
            "aux_head",
            "size",
            "handle->aux_flags"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_aux_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "8602-8634",
          "snippet": "void perf_event_aux_event(struct perf_event *event, unsigned long head,\n\t\t\t  unsigned long size, u64 flags)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\toffset;\n\t\tu64\t\t\t\tsize;\n\t\tu64\t\t\t\tflags;\n\t} rec = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_AUX,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(rec),\n\t\t},\n\t\t.offset\t\t= head,\n\t\t.size\t\t= size,\n\t\t.flags\t\t= flags,\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, &sample, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t       struct list_head *head);",
            "static void perf_pmu_output_stop(struct perf_event *event);",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_addr_filters_splice(struct perf_event *event,\n\t\t\t\t       struct list_head *head);\nstatic void perf_pmu_output_stop(struct perf_event *event);\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_aux_event(struct perf_event *event, unsigned long head,\n\t\t\t  unsigned long size, u64 flags)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\toffset;\n\t\tu64\t\t\t\tsize;\n\t\tu64\t\t\t\tflags;\n\t} rec = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_AUX,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(rec),\n\t\t},\n\t\t.offset\t\t= head,\n\t\t.size\t\t= size,\n\t\t.flags\t\t= flags,\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, &sample, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid perf_aux_output_end(struct perf_output_handle *handle, unsigned long size)\n{\n\tbool wakeup = !!(handle->aux_flags & PERF_AUX_FLAG_TRUNCATED);\n\tstruct perf_buffer *rb = handle->rb;\n\tunsigned long aux_head;\n\n\t/* in overwrite mode, driver provides aux_head via handle */\n\tif (rb->aux_overwrite) {\n\t\thandle->aux_flags |= PERF_AUX_FLAG_OVERWRITE;\n\n\t\taux_head = handle->head;\n\t\trb->aux_head = aux_head;\n\t} else {\n\t\thandle->aux_flags &= ~PERF_AUX_FLAG_OVERWRITE;\n\n\t\taux_head = rb->aux_head;\n\t\trb->aux_head += size;\n\t}\n\n\t/*\n\t * Only send RECORD_AUX if we have something useful to communicate\n\t *\n\t * Note: the OVERWRITE records by themselves are not considered\n\t * useful, as they don't communicate any *new* information,\n\t * aside from the short-lived offset, that becomes history at\n\t * the next event sched-in and therefore isn't useful.\n\t * The userspace that needs to copy out AUX data in overwrite\n\t * mode should know to use user_page::aux_head for the actual\n\t * offset. So, from now on we don't output AUX records that\n\t * have *only* OVERWRITE flag set.\n\t */\n\tif (size || (handle->aux_flags & ~(u64)PERF_AUX_FLAG_OVERWRITE))\n\t\tperf_event_aux_event(handle->event, aux_head, size,\n\t\t\t\t     handle->aux_flags);\n\n\tWRITE_ONCE(rb->user_page->aux_head, rb->aux_head);\n\tif (rb_need_aux_wakeup(rb))\n\t\twakeup = true;\n\n\tif (wakeup) {\n\t\tif (handle->aux_flags & PERF_AUX_FLAG_TRUNCATED)\n\t\t\thandle->event->pending_disable = smp_processor_id();\n\t\tperf_output_wakeup(handle);\n\t}\n\n\thandle->event = NULL;\n\n\tWRITE_ONCE(rb->aux_nest, 0);\n\t/* can't be last */\n\trb_free_aux(rb);\n\tring_buffer_put(rb);\n}"
  },
  {
    "function_name": "rb_need_aux_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "454-465",
    "snippet": "static __always_inline bool rb_need_aux_wakeup(struct perf_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "rb->aux_head",
            "rb->aux_watermark"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline bool rb_need_aux_wakeup(struct perf_buffer *rb)\n{\n\tif (rb->aux_overwrite)\n\t\treturn false;\n\n\tif (rb->aux_head - rb->aux_wakeup >= rb->aux_watermark) {\n\t\trb->aux_wakeup = rounddown(rb->aux_head, rb->aux_watermark);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "perf_aux_output_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "361-451",
    "snippet": "void *perf_aux_output_begin(struct perf_output_handle *handle,\n\t\t\t    struct perf_event *event)\n{\n\tstruct perf_event *output_event = event;\n\tunsigned long aux_head, aux_tail;\n\tstruct perf_buffer *rb;\n\tunsigned int nest;\n\n\tif (output_event->parent)\n\t\toutput_event = output_event->parent;\n\n\t/*\n\t * Since this will typically be open across pmu::add/pmu::del, we\n\t * grab ring_buffer's refcount instead of holding rcu read lock\n\t * to make sure it doesn't disappear under us.\n\t */\n\trb = ring_buffer_get(output_event);\n\tif (!rb)\n\t\treturn NULL;\n\n\tif (!rb_has_aux(rb))\n\t\tgoto err;\n\n\t/*\n\t * If aux_mmap_count is zero, the aux buffer is in perf_mmap_close(),\n\t * about to get freed, so we leave immediately.\n\t *\n\t * Checking rb::aux_mmap_count and rb::refcount has to be done in\n\t * the same order, see perf_mmap_close. Otherwise we end up freeing\n\t * aux pages in this path, which is a bug, because in_atomic().\n\t */\n\tif (!atomic_read(&rb->aux_mmap_count))\n\t\tgoto err;\n\n\tif (!refcount_inc_not_zero(&rb->aux_refcount))\n\t\tgoto err;\n\n\tnest = READ_ONCE(rb->aux_nest);\n\t/*\n\t * Nesting is not supported for AUX area, make sure nested\n\t * writers are caught early\n\t */\n\tif (WARN_ON_ONCE(nest))\n\t\tgoto err_put;\n\n\tWRITE_ONCE(rb->aux_nest, nest + 1);\n\n\taux_head = rb->aux_head;\n\n\thandle->rb = rb;\n\thandle->event = event;\n\thandle->head = aux_head;\n\thandle->size = 0;\n\thandle->aux_flags = 0;\n\n\t/*\n\t * In overwrite mode, AUX data stores do not depend on aux_tail,\n\t * therefore (A) control dependency barrier does not exist. The\n\t * (B) <-> (C) ordering is still observed by the pmu driver.\n\t */\n\tif (!rb->aux_overwrite) {\n\t\taux_tail = READ_ONCE(rb->user_page->aux_tail);\n\t\thandle->wakeup = rb->aux_wakeup + rb->aux_watermark;\n\t\tif (aux_head - aux_tail < perf_aux_size(rb))\n\t\t\thandle->size = CIRC_SPACE(aux_head, aux_tail, perf_aux_size(rb));\n\n\t\t/*\n\t\t * handle->size computation depends on aux_tail load; this forms a\n\t\t * control dependency barrier separating aux_tail load from aux data\n\t\t * store that will be enabled on successful return\n\t\t */\n\t\tif (!handle->size) { /* A, matches D */\n\t\t\tevent->pending_disable = smp_processor_id();\n\t\t\tperf_output_wakeup(handle);\n\t\t\tWRITE_ONCE(rb->aux_nest, 0);\n\t\t\tgoto err_put;\n\t\t}\n\t}\n\n\treturn handle->rb->aux_priv;\n\nerr_put:\n\t/* can't be last */\n\trb_free_aux(rb);\n\nerr:\n\tring_buffer_put(rb);\n\thandle->event = NULL;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_put",
          "args": [
            "rb"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "6022-6030",
          "snippet": "void ring_buffer_put(struct perf_buffer *rb)\n{\n\tif (!refcount_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&rb->event_list));\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct perf_buffer *rb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct perf_buffer *rb);\n\nvoid ring_buffer_put(struct perf_buffer *rb)\n{\n\tif (!refcount_dec_and_test(&rb->refcount))\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&rb->event_list));\n\n\tcall_rcu(&rb->rcu_head, rb_free_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_free_aux",
          "args": [
            "rb"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "rb_free_aux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "760-764",
          "snippet": "void rb_free_aux(struct perf_buffer *rb)\n{\n\tif (refcount_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid rb_free_aux(struct perf_buffer *rb)\n{\n\tif (refcount_dec_and_test(&rb->aux_refcount))\n\t\t__rb_free_aux(rb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rb->aux_nest",
            "0"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_output_wakeup",
          "args": [
            "handle"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "20-26",
          "snippet": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIRC_SPACE",
          "args": [
            "aux_head",
            "aux_tail",
            "perf_aux_size(rb)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_aux_size",
          "args": [
            "rb"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "perf_aux_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "124-127",
          "snippet": "static inline unsigned long perf_aux_size(struct perf_buffer *rb)\n{\n\treturn rb->aux_nr_pages << PAGE_SHIFT;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long perf_aux_size(struct perf_buffer *rb)\n{\n\treturn rb->aux_nr_pages << PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rb->user_page->aux_tail"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rb->aux_nest",
            "nest + 1"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "nest"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rb->aux_nest"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_inc_not_zero",
          "args": [
            "&rb->aux_refcount"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rb->aux_mmap_count"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_has_aux",
          "args": [
            "rb"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "rb_has_aux",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "88-91",
          "snippet": "static inline bool rb_has_aux(struct perf_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline bool rb_has_aux(struct perf_buffer *rb)\n{\n\treturn !!rb->aux_nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_get",
          "args": [
            "output_event"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "6007-6020",
          "snippet": "struct perf_buffer *ring_buffer_get(struct perf_event *event)\n{\n\tstruct perf_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (rb) {\n\t\tif (!refcount_inc_not_zero(&rb->refcount))\n\t\t\trb = NULL;\n\t}\n\trcu_read_unlock();\n\n\treturn rb;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct perf_buffer *rb);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void ring_buffer_attach(struct perf_event *event,\n\t\t\t       struct perf_buffer *rb);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstruct perf_buffer *ring_buffer_get(struct perf_event *event)\n{\n\tstruct perf_buffer *rb;\n\n\trcu_read_lock();\n\trb = rcu_dereference(event->rb);\n\tif (rb) {\n\t\tif (!refcount_inc_not_zero(&rb->refcount))\n\t\t\trb = NULL;\n\t}\n\trcu_read_unlock();\n\n\treturn rb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid *perf_aux_output_begin(struct perf_output_handle *handle,\n\t\t\t    struct perf_event *event)\n{\n\tstruct perf_event *output_event = event;\n\tunsigned long aux_head, aux_tail;\n\tstruct perf_buffer *rb;\n\tunsigned int nest;\n\n\tif (output_event->parent)\n\t\toutput_event = output_event->parent;\n\n\t/*\n\t * Since this will typically be open across pmu::add/pmu::del, we\n\t * grab ring_buffer's refcount instead of holding rcu read lock\n\t * to make sure it doesn't disappear under us.\n\t */\n\trb = ring_buffer_get(output_event);\n\tif (!rb)\n\t\treturn NULL;\n\n\tif (!rb_has_aux(rb))\n\t\tgoto err;\n\n\t/*\n\t * If aux_mmap_count is zero, the aux buffer is in perf_mmap_close(),\n\t * about to get freed, so we leave immediately.\n\t *\n\t * Checking rb::aux_mmap_count and rb::refcount has to be done in\n\t * the same order, see perf_mmap_close. Otherwise we end up freeing\n\t * aux pages in this path, which is a bug, because in_atomic().\n\t */\n\tif (!atomic_read(&rb->aux_mmap_count))\n\t\tgoto err;\n\n\tif (!refcount_inc_not_zero(&rb->aux_refcount))\n\t\tgoto err;\n\n\tnest = READ_ONCE(rb->aux_nest);\n\t/*\n\t * Nesting is not supported for AUX area, make sure nested\n\t * writers are caught early\n\t */\n\tif (WARN_ON_ONCE(nest))\n\t\tgoto err_put;\n\n\tWRITE_ONCE(rb->aux_nest, nest + 1);\n\n\taux_head = rb->aux_head;\n\n\thandle->rb = rb;\n\thandle->event = event;\n\thandle->head = aux_head;\n\thandle->size = 0;\n\thandle->aux_flags = 0;\n\n\t/*\n\t * In overwrite mode, AUX data stores do not depend on aux_tail,\n\t * therefore (A) control dependency barrier does not exist. The\n\t * (B) <-> (C) ordering is still observed by the pmu driver.\n\t */\n\tif (!rb->aux_overwrite) {\n\t\taux_tail = READ_ONCE(rb->user_page->aux_tail);\n\t\thandle->wakeup = rb->aux_wakeup + rb->aux_watermark;\n\t\tif (aux_head - aux_tail < perf_aux_size(rb))\n\t\t\thandle->size = CIRC_SPACE(aux_head, aux_tail, perf_aux_size(rb));\n\n\t\t/*\n\t\t * handle->size computation depends on aux_tail load; this forms a\n\t\t * control dependency barrier separating aux_tail load from aux data\n\t\t * store that will be enabled on successful return\n\t\t */\n\t\tif (!handle->size) { /* A, matches D */\n\t\t\tevent->pending_disable = smp_processor_id();\n\t\t\tperf_output_wakeup(handle);\n\t\t\tWRITE_ONCE(rb->aux_nest, 0);\n\t\t\tgoto err_put;\n\t\t}\n\t}\n\n\treturn handle->rb->aux_priv;\n\nerr_put:\n\t/* can't be last */\n\trb_free_aux(rb);\n\nerr:\n\tring_buffer_put(rb);\n\thandle->event = NULL;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "perf_aux_output_flag",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "334-344",
    "snippet": "void perf_aux_output_flag(struct perf_output_handle *handle, u64 flags)\n{\n\t/*\n\t * OVERWRITE is determined by perf_aux_output_end() and can't\n\t * be passed in directly.\n\t */\n\tif (WARN_ON_ONCE(flags & PERF_AUX_FLAG_OVERWRITE))\n\t\treturn;\n\n\thandle->aux_flags |= flags;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "flags & PERF_AUX_FLAG_OVERWRITE"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid perf_aux_output_flag(struct perf_output_handle *handle, u64 flags)\n{\n\t/*\n\t * OVERWRITE is determined by perf_aux_output_end() and can't\n\t * be passed in directly.\n\t */\n\tif (WARN_ON_ONCE(flags & PERF_AUX_FLAG_OVERWRITE))\n\t\treturn;\n\n\thandle->aux_flags |= flags;\n}"
  },
  {
    "function_name": "ring_buffer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "305-332",
    "snippet": "static void\nring_buffer_init(struct perf_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\trefcount_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&rb->event_lock"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&rb->event_list"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&rb->refcount",
            "1"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max_size",
            "watermark"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "perf_data_size",
          "args": [
            "rb"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "perf_data_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "119-122",
          "snippet": "static inline unsigned long perf_data_size(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long perf_data_size(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void\nring_buffer_init(struct perf_buffer *rb, long watermark, int flags)\n{\n\tlong max_size = perf_data_size(rb);\n\n\tif (watermark)\n\t\trb->watermark = min(max_size, watermark);\n\n\tif (!rb->watermark)\n\t\trb->watermark = max_size / 2;\n\n\tif (flags & RING_BUFFER_WRITABLE)\n\t\trb->overwrite = 0;\n\telse\n\t\trb->overwrite = 1;\n\n\trefcount_set(&rb->refcount, 1);\n\n\tINIT_LIST_HEAD(&rb->event_list);\n\tspin_lock_init(&rb->event_lock);\n\n\t/*\n\t * perf_output_begin() only checks rb->paused, therefore\n\t * rb->paused must be true if we have no pages for output.\n\t */\n\tif (!rb->nr_pages)\n\t\trb->paused = 1;\n}"
  },
  {
    "function_name": "perf_output_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "299-303",
    "snippet": "void perf_output_end(struct perf_output_handle *handle)\n{\n\tperf_output_put_handle(handle);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_output_put_handle",
          "args": [
            "handle"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_put_handle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "50-135",
          "snippet": "static void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\tunsigned long head;\n\tunsigned int nest;\n\n\t/*\n\t * If this isn't the outermost nesting, we don't have to update\n\t * @rb->user_page->data_head.\n\t */\n\tnest = READ_ONCE(rb->nest);\n\tif (nest > 1) {\n\t\tWRITE_ONCE(rb->nest, nest - 1);\n\t\tgoto out;\n\t}\n\nagain:\n\t/*\n\t * In order to avoid publishing a head value that goes backwards,\n\t * we must ensure the load of @rb->head happens after we've\n\t * incremented @rb->nest.\n\t *\n\t * Otherwise we can observe a @rb->head value before one published\n\t * by an IRQ/NMI happening between the load and the increment.\n\t */\n\tbarrier();\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here and advance @rb->head, causing our\n\t * load above to be stale.\n\t */\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\tWRITE_ONCE(rb->user_page->data_head, head);\n\n\t/*\n\t * We must publish the head before decrementing the nest count,\n\t * otherwise an IRQ/NMI can publish a more recent head value and our\n\t * write will (temporarily) publish a stale value.\n\t */\n\tbarrier();\n\tWRITE_ONCE(rb->nest, 0);\n\n\t/*\n\t * Ensure we decrement @rb->nest before we validate the @rb->head.\n\t * Otherwise we cannot be sure we caught the 'last' nested update.\n\t */\n\tbarrier();\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tWRITE_ONCE(rb->nest, 1);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\tunsigned long head;\n\tunsigned int nest;\n\n\t/*\n\t * If this isn't the outermost nesting, we don't have to update\n\t * @rb->user_page->data_head.\n\t */\n\tnest = READ_ONCE(rb->nest);\n\tif (nest > 1) {\n\t\tWRITE_ONCE(rb->nest, nest - 1);\n\t\tgoto out;\n\t}\n\nagain:\n\t/*\n\t * In order to avoid publishing a head value that goes backwards,\n\t * we must ensure the load of @rb->head happens after we've\n\t * incremented @rb->nest.\n\t *\n\t * Otherwise we can observe a @rb->head value before one published\n\t * by an IRQ/NMI happening between the load and the increment.\n\t */\n\tbarrier();\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here and advance @rb->head, causing our\n\t * load above to be stale.\n\t */\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\tWRITE_ONCE(rb->user_page->data_head, head);\n\n\t/*\n\t * We must publish the head before decrementing the nest count,\n\t * otherwise an IRQ/NMI can publish a more recent head value and our\n\t * write will (temporarily) publish a stale value.\n\t */\n\tbarrier();\n\tWRITE_ONCE(rb->nest, 0);\n\n\t/*\n\t * Ensure we decrement @rb->nest before we validate the @rb->head.\n\t * Otherwise we cannot be sure we caught the 'last' nested update.\n\t */\n\tbarrier();\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tWRITE_ONCE(rb->nest, 1);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nvoid perf_output_end(struct perf_output_handle *handle)\n{\n\tperf_output_put_handle(handle);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "perf_output_skip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "293-297",
    "snippet": "unsigned int perf_output_skip(struct perf_output_handle *handle,\n\t\t\t      unsigned int len)\n{\n\treturn __output_skip(handle, NULL, len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__output_skip",
          "args": [
            "handle",
            "NULL",
            "len"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nunsigned int perf_output_skip(struct perf_output_handle *handle,\n\t\t\t      unsigned int len)\n{\n\treturn __output_skip(handle, NULL, len);\n}"
  },
  {
    "function_name": "perf_output_copy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "287-291",
    "snippet": "unsigned int perf_output_copy(struct perf_output_handle *handle,\n\t\t      const void *buf, unsigned int len)\n{\n\treturn __output_copy(handle, buf, len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__output_copy",
          "args": [
            "handle",
            "buf",
            "len"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nunsigned int perf_output_copy(struct perf_output_handle *handle,\n\t\t      const void *buf, unsigned int len)\n{\n\treturn __output_copy(handle, buf, len);\n}"
  },
  {
    "function_name": "perf_output_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "278-285",
    "snippet": "int perf_output_begin(struct perf_output_handle *handle,\n\t\t      struct perf_sample_data *data,\n\t\t      struct perf_event *event, unsigned int size)\n{\n\n\treturn __perf_output_begin(handle, data, event, size,\n\t\t\t\t   unlikely(is_write_backward(event)));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__perf_output_begin",
          "args": [
            "handle",
            "data",
            "event",
            "size",
            "unlikely(is_write_backward(event))"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__perf_output_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "148-262",
          "snippet": "static __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_sample_data *data,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\t/* XXX mostly redundant; @data is already fully initializes */\n\t\tperf_event_header__init_id(&lost_event.header, data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_sample_data *data,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\t/* XXX mostly redundant; @data is already fully initializes */\n\t\tperf_event_header__init_id(&lost_event.header, data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_write_backward(event)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_backward",
          "args": [
            "event"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nint perf_output_begin(struct perf_output_handle *handle,\n\t\t      struct perf_sample_data *data,\n\t\t      struct perf_event *event, unsigned int size)\n{\n\n\treturn __perf_output_begin(handle, data, event, size,\n\t\t\t\t   unlikely(is_write_backward(event)));\n}"
  },
  {
    "function_name": "perf_output_begin_backward",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "271-276",
    "snippet": "int perf_output_begin_backward(struct perf_output_handle *handle,\n\t\t\t       struct perf_sample_data *data,\n\t\t\t       struct perf_event *event, unsigned int size)\n{\n\treturn __perf_output_begin(handle, data, event, size, true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__perf_output_begin",
          "args": [
            "handle",
            "data",
            "event",
            "size",
            "true"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "__perf_output_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "148-262",
          "snippet": "static __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_sample_data *data,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\t/* XXX mostly redundant; @data is already fully initializes */\n\t\tperf_event_header__init_id(&lost_event.header, data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_sample_data *data,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\t/* XXX mostly redundant; @data is already fully initializes */\n\t\tperf_event_header__init_id(&lost_event.header, data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nint perf_output_begin_backward(struct perf_output_handle *handle,\n\t\t\t       struct perf_sample_data *data,\n\t\t\t       struct perf_event *event, unsigned int size)\n{\n\treturn __perf_output_begin(handle, data, event, size, true);\n}"
  },
  {
    "function_name": "perf_output_begin_forward",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "264-269",
    "snippet": "int perf_output_begin_forward(struct perf_output_handle *handle,\n\t\t\t      struct perf_sample_data *data,\n\t\t\t      struct perf_event *event, unsigned int size)\n{\n\treturn __perf_output_begin(handle, data, event, size, false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__perf_output_begin",
          "args": [
            "handle",
            "data",
            "event",
            "size",
            "false"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "__perf_output_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "148-262",
          "snippet": "static __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_sample_data *data,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\t/* XXX mostly redundant; @data is already fully initializes */\n\t\tperf_event_header__init_id(&lost_event.header, data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_sample_data *data,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\t/* XXX mostly redundant; @data is already fully initializes */\n\t\tperf_event_header__init_id(&lost_event.header, data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nint perf_output_begin_forward(struct perf_output_handle *handle,\n\t\t\t      struct perf_sample_data *data,\n\t\t\t      struct perf_event *event, unsigned int size)\n{\n\treturn __perf_output_begin(handle, data, event, size, false);\n}"
  },
  {
    "function_name": "__perf_output_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "148-262",
    "snippet": "static __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_sample_data *data,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\t/* XXX mostly redundant; @data is already fully initializes */\n\t\tperf_event_header__init_id(&lost_event.header, data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_output_put_handle",
          "args": [
            "handle"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_put_handle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "50-135",
          "snippet": "static void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\tunsigned long head;\n\tunsigned int nest;\n\n\t/*\n\t * If this isn't the outermost nesting, we don't have to update\n\t * @rb->user_page->data_head.\n\t */\n\tnest = READ_ONCE(rb->nest);\n\tif (nest > 1) {\n\t\tWRITE_ONCE(rb->nest, nest - 1);\n\t\tgoto out;\n\t}\n\nagain:\n\t/*\n\t * In order to avoid publishing a head value that goes backwards,\n\t * we must ensure the load of @rb->head happens after we've\n\t * incremented @rb->nest.\n\t *\n\t * Otherwise we can observe a @rb->head value before one published\n\t * by an IRQ/NMI happening between the load and the increment.\n\t */\n\tbarrier();\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here and advance @rb->head, causing our\n\t * load above to be stale.\n\t */\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\tWRITE_ONCE(rb->user_page->data_head, head);\n\n\t/*\n\t * We must publish the head before decrementing the nest count,\n\t * otherwise an IRQ/NMI can publish a more recent head value and our\n\t * write will (temporarily) publish a stale value.\n\t */\n\tbarrier();\n\tWRITE_ONCE(rb->nest, 0);\n\n\t/*\n\t * Ensure we decrement @rb->nest before we validate the @rb->head.\n\t * Otherwise we cannot be sure we caught the 'last' nested update.\n\t */\n\tbarrier();\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tWRITE_ONCE(rb->nest, 1);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\tunsigned long head;\n\tunsigned int nest;\n\n\t/*\n\t * If this isn't the outermost nesting, we don't have to update\n\t * @rb->user_page->data_head.\n\t */\n\tnest = READ_ONCE(rb->nest);\n\tif (nest > 1) {\n\t\tWRITE_ONCE(rb->nest, nest - 1);\n\t\tgoto out;\n\t}\n\nagain:\n\t/*\n\t * In order to avoid publishing a head value that goes backwards,\n\t * we must ensure the load of @rb->head happens after we've\n\t * incremented @rb->nest.\n\t *\n\t * Otherwise we can observe a @rb->head value before one published\n\t * by an IRQ/NMI happening between the load and the increment.\n\t */\n\tbarrier();\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here and advance @rb->head, causing our\n\t * load above to be stale.\n\t */\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\tWRITE_ONCE(rb->user_page->data_head, head);\n\n\t/*\n\t * We must publish the head before decrementing the nest count,\n\t * otherwise an IRQ/NMI can publish a more recent head value and our\n\t * write will (temporarily) publish a stale value.\n\t */\n\tbarrier();\n\tWRITE_ONCE(rb->nest, 0);\n\n\t/*\n\t * Ensure we decrement @rb->nest before we validate the @rb->head.\n\t * Otherwise we cannot be sure we caught the 'last' nested update.\n\t */\n\tbarrier();\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tWRITE_ONCE(rb->nest, 1);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_inc",
          "args": [
            "&rb->lost"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event__output_id_sample",
          "args": [
            "event",
            "handle",
            "data"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event__output_id_sample",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "6880-6886",
          "snippet": "void perf_event__output_id_sample(struct perf_event *event,\n\t\t\t\t  struct perf_output_handle *handle,\n\t\t\t\t  struct perf_sample_data *sample)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event__output_id_sample(handle, sample);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event__output_id_sample(struct perf_event *event,\n\t\t\t\t  struct perf_output_handle *handle,\n\t\t\t\t  struct perf_sample_data *sample)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event__output_id_sample(handle, sample);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_output_put",
          "args": [
            "handle",
            "lost_event"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_header__init_id",
          "args": [
            "&lost_event.header",
            "data",
            "event"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_header__init_id",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "6848-6854",
          "snippet": "void perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct perf_event *event)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event_header__init_id(header, data, event);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void put_event(struct perf_event *event);",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_remove_from_owner(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void put_event(struct perf_event *event);\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_remove_from_owner(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nvoid perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct perf_event *event)\n{\n\tif (event->attr.sample_id_all)\n\t\t__perf_event_header__init_id(header, data, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_xchg",
          "args": [
            "&rb->lost",
            "0"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "have_lost"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_order",
          "args": [
            "rb"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "page_order",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "113-116",
          "snippet": "static inline int page_order(struct perf_buffer *rb)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline int page_order(struct perf_buffer *rb)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_add",
          "args": [
            "rb->watermark",
            "&rb->wakeup"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "head - local_read(&rb->wakeup) > rb->watermark"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->wakeup"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-head"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_cmpxchg",
          "args": [
            "&rb->head",
            "offset",
            "head"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ring_buffer_has_space",
          "args": [
            "head",
            "tail",
            "perf_data_size(rb)",
            "size",
            "backward"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_has_space",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "137-146",
          "snippet": "static __always_inline bool\nring_buffer_has_space(unsigned long head, unsigned long tail,\n\t\t      unsigned long data_size, unsigned int size,\n\t\t      bool backward)\n{\n\tif (!backward)\n\t\treturn CIRC_SPACE(head, tail, data_size) >= size;\n\telse\n\t\treturn CIRC_SPACE(tail, head, data_size) >= size;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline bool\nring_buffer_has_space(unsigned long head, unsigned long tail,\n\t\t      unsigned long data_size, unsigned int size,\n\t\t      bool backward)\n{\n\tif (!backward)\n\t\treturn CIRC_SPACE(head, tail, data_size) >= size;\n\telse\n\t\treturn CIRC_SPACE(tail, head, data_size) >= size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_data_size",
          "args": [
            "rb"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "perf_data_size",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "119-122",
          "snippet": "static inline unsigned long perf_data_size(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long perf_data_size(struct perf_buffer *rb)\n{\n\treturn rb->nr_pages << (PAGE_SHIFT + page_order(rb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->head"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rb->user_page->data_tail"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_output_get_handle",
          "args": [
            "handle"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_get_handle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "36-48",
          "snippet": "static void perf_output_get_handle(struct perf_output_handle *handle)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\n\tpreempt_disable();\n\n\t/*\n\t * Avoid an explicit LOAD/STORE such that architectures with memops\n\t * can use them.\n\t */\n\t(*(volatile unsigned int *)&rb->nest)++;\n\thandle->wakeup = local_read(&rb->wakeup);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_get_handle(struct perf_output_handle *handle)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\n\tpreempt_disable();\n\n\t/*\n\t * Avoid an explicit LOAD/STORE such that architectures with memops\n\t * can use them.\n\t */\n\t(*(volatile unsigned int *)&rb->nest)++;\n\thandle->wakeup = local_read(&rb->wakeup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "have_lost"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->lost"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_inc",
          "args": [
            "&rb->lost"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rb->paused"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rb"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "event->rb"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline int\n__perf_output_begin(struct perf_output_handle *handle,\n\t\t    struct perf_sample_data *data,\n\t\t    struct perf_event *event, unsigned int size,\n\t\t    bool backward)\n{\n\tstruct perf_buffer *rb;\n\tunsigned long tail, offset, head;\n\tint have_lost, page_shift;\n\tstruct {\n\t\tstruct perf_event_header header;\n\t\tu64\t\t\t id;\n\t\tu64\t\t\t lost;\n\t} lost_event;\n\n\trcu_read_lock();\n\t/*\n\t * For inherited events we send all the output towards the parent.\n\t */\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\trb = rcu_dereference(event->rb);\n\tif (unlikely(!rb))\n\t\tgoto out;\n\n\tif (unlikely(rb->paused)) {\n\t\tif (rb->nr_pages)\n\t\t\tlocal_inc(&rb->lost);\n\t\tgoto out;\n\t}\n\n\thandle->rb    = rb;\n\thandle->event = event;\n\n\thave_lost = local_read(&rb->lost);\n\tif (unlikely(have_lost)) {\n\t\tsize += sizeof(lost_event);\n\t\tif (event->attr.sample_id_all)\n\t\t\tsize += event->id_header_size;\n\t}\n\n\tperf_output_get_handle(handle);\n\n\tdo {\n\t\ttail = READ_ONCE(rb->user_page->data_tail);\n\t\toffset = head = local_read(&rb->head);\n\t\tif (!rb->overwrite) {\n\t\t\tif (unlikely(!ring_buffer_has_space(head, tail,\n\t\t\t\t\t\t\t    perf_data_size(rb),\n\t\t\t\t\t\t\t    size, backward)))\n\t\t\t\tgoto fail;\n\t\t}\n\n\t\t/*\n\t\t * The above forms a control dependency barrier separating the\n\t\t * @tail load above from the data stores below. Since the @tail\n\t\t * load is required to compute the branch to fail below.\n\t\t *\n\t\t * A, matches D; the full memory barrier userspace SHOULD issue\n\t\t * after reading the data and before storing the new tail\n\t\t * position.\n\t\t *\n\t\t * See perf_output_put_handle().\n\t\t */\n\n\t\tif (!backward)\n\t\t\thead += size;\n\t\telse\n\t\t\thead -= size;\n\t} while (local_cmpxchg(&rb->head, offset, head) != offset);\n\n\tif (backward) {\n\t\toffset = head;\n\t\thead = (u64)(-head);\n\t}\n\n\t/*\n\t * We rely on the implied barrier() by local_cmpxchg() to ensure\n\t * none of the data stores below can be lifted up by the compiler.\n\t */\n\n\tif (unlikely(head - local_read(&rb->wakeup) > rb->watermark))\n\t\tlocal_add(rb->watermark, &rb->wakeup);\n\n\tpage_shift = PAGE_SHIFT + page_order(rb);\n\n\thandle->page = (offset >> page_shift) & (rb->nr_pages - 1);\n\toffset &= (1UL << page_shift) - 1;\n\thandle->addr = rb->data_pages[handle->page] + offset;\n\thandle->size = (1UL << page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = PERF_RECORD_LOST;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->id;\n\t\tlost_event.lost        = local_xchg(&rb->lost, 0);\n\n\t\t/* XXX mostly redundant; @data is already fully initializes */\n\t\tperf_event_header__init_id(&lost_event.header, data, event);\n\t\tperf_output_put(handle, lost_event);\n\t\tperf_event__output_id_sample(event, handle, data);\n\t}\n\n\treturn 0;\n\nfail:\n\tlocal_inc(&rb->lost);\n\tperf_output_put_handle(handle);\nout:\n\trcu_read_unlock();\n\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "ring_buffer_has_space",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "137-146",
    "snippet": "static __always_inline bool\nring_buffer_has_space(unsigned long head, unsigned long tail,\n\t\t      unsigned long data_size, unsigned int size,\n\t\t      bool backward)\n{\n\tif (!backward)\n\t\treturn CIRC_SPACE(head, tail, data_size) >= size;\n\telse\n\t\treturn CIRC_SPACE(tail, head, data_size) >= size;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CIRC_SPACE",
          "args": [
            "tail",
            "head",
            "data_size"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CIRC_SPACE",
          "args": [
            "head",
            "tail",
            "data_size"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic __always_inline bool\nring_buffer_has_space(unsigned long head, unsigned long tail,\n\t\t      unsigned long data_size, unsigned int size,\n\t\t      bool backward)\n{\n\tif (!backward)\n\t\treturn CIRC_SPACE(head, tail, data_size) >= size;\n\telse\n\t\treturn CIRC_SPACE(tail, head, data_size) >= size;\n}"
  },
  {
    "function_name": "perf_output_put_handle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "50-135",
    "snippet": "static void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\tunsigned long head;\n\tunsigned int nest;\n\n\t/*\n\t * If this isn't the outermost nesting, we don't have to update\n\t * @rb->user_page->data_head.\n\t */\n\tnest = READ_ONCE(rb->nest);\n\tif (nest > 1) {\n\t\tWRITE_ONCE(rb->nest, nest - 1);\n\t\tgoto out;\n\t}\n\nagain:\n\t/*\n\t * In order to avoid publishing a head value that goes backwards,\n\t * we must ensure the load of @rb->head happens after we've\n\t * incremented @rb->nest.\n\t *\n\t * Otherwise we can observe a @rb->head value before one published\n\t * by an IRQ/NMI happening between the load and the increment.\n\t */\n\tbarrier();\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here and advance @rb->head, causing our\n\t * load above to be stale.\n\t */\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\tWRITE_ONCE(rb->user_page->data_head, head);\n\n\t/*\n\t * We must publish the head before decrementing the nest count,\n\t * otherwise an IRQ/NMI can publish a more recent head value and our\n\t * write will (temporarily) publish a stale value.\n\t */\n\tbarrier();\n\tWRITE_ONCE(rb->nest, 0);\n\n\t/*\n\t * Ensure we decrement @rb->nest before we validate the @rb->head.\n\t * Otherwise we cannot be sure we caught the 'last' nested update.\n\t */\n\tbarrier();\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tWRITE_ONCE(rb->nest, 1);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_output_wakeup",
          "args": [
            "handle"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "perf_output_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
          "lines": "20-26",
          "snippet": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/poll.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/perf_event.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->wakeup"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rb->nest",
            "1"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "head != local_read(&rb->head)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->head"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rb->nest",
            "0"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rb->user_page->data_head",
            "head"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->head"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rb->nest",
            "nest - 1"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rb->nest"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_put_handle(struct perf_output_handle *handle)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\tunsigned long head;\n\tunsigned int nest;\n\n\t/*\n\t * If this isn't the outermost nesting, we don't have to update\n\t * @rb->user_page->data_head.\n\t */\n\tnest = READ_ONCE(rb->nest);\n\tif (nest > 1) {\n\t\tWRITE_ONCE(rb->nest, nest - 1);\n\t\tgoto out;\n\t}\n\nagain:\n\t/*\n\t * In order to avoid publishing a head value that goes backwards,\n\t * we must ensure the load of @rb->head happens after we've\n\t * incremented @rb->nest.\n\t *\n\t * Otherwise we can observe a @rb->head value before one published\n\t * by an IRQ/NMI happening between the load and the increment.\n\t */\n\tbarrier();\n\thead = local_read(&rb->head);\n\n\t/*\n\t * IRQ/NMI can happen here and advance @rb->head, causing our\n\t * load above to be stale.\n\t */\n\n\t/*\n\t * Since the mmap() consumer (userspace) can run on a different CPU:\n\t *\n\t *   kernel\t\t\t\tuser\n\t *\n\t *   if (LOAD ->data_tail) {\t\tLOAD ->data_head\n\t *\t\t\t(A)\t\tsmp_rmb()\t(C)\n\t *\tSTORE $data\t\t\tLOAD $data\n\t *\tsmp_wmb()\t(B)\t\tsmp_mb()\t(D)\n\t *\tSTORE ->data_head\t\tSTORE ->data_tail\n\t *   }\n\t *\n\t * Where A pairs with D, and B pairs with C.\n\t *\n\t * In our case (A) is a control dependency that separates the load of\n\t * the ->data_tail and the stores of $data. In case ->data_tail\n\t * indicates there is no room in the buffer to store $data we do not.\n\t *\n\t * D needs to be a full barrier since it separates the data READ\n\t * from the tail WRITE.\n\t *\n\t * For B a WMB is sufficient since it separates two WRITEs, and for C\n\t * an RMB is sufficient since it separates two READs.\n\t *\n\t * See perf_output_begin().\n\t */\n\tsmp_wmb(); /* B, matches C */\n\tWRITE_ONCE(rb->user_page->data_head, head);\n\n\t/*\n\t * We must publish the head before decrementing the nest count,\n\t * otherwise an IRQ/NMI can publish a more recent head value and our\n\t * write will (temporarily) publish a stale value.\n\t */\n\tbarrier();\n\tWRITE_ONCE(rb->nest, 0);\n\n\t/*\n\t * Ensure we decrement @rb->nest before we validate the @rb->head.\n\t * Otherwise we cannot be sure we caught the 'last' nested update.\n\t */\n\tbarrier();\n\tif (unlikely(head != local_read(&rb->head))) {\n\t\tWRITE_ONCE(rb->nest, 1);\n\t\tgoto again;\n\t}\n\n\tif (handle->wakeup != local_read(&rb->wakeup))\n\t\tperf_output_wakeup(handle);\n\nout:\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "perf_output_get_handle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "36-48",
    "snippet": "static void perf_output_get_handle(struct perf_output_handle *handle)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\n\tpreempt_disable();\n\n\t/*\n\t * Avoid an explicit LOAD/STORE such that architectures with memops\n\t * can use them.\n\t */\n\t(*(volatile unsigned int *)&rb->nest)++;\n\thandle->wakeup = local_read(&rb->wakeup);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_read",
          "args": [
            "&rb->wakeup"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_get_handle(struct perf_output_handle *handle)\n{\n\tstruct perf_buffer *rb = handle->rb;\n\n\tpreempt_disable();\n\n\t/*\n\t * Avoid an explicit LOAD/STORE such that architectures with memops\n\t * can use them.\n\t */\n\t(*(volatile unsigned int *)&rb->nest)++;\n\thandle->wakeup = local_read(&rb->wakeup);\n}"
  },
  {
    "function_name": "perf_output_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/ring_buffer.c",
    "lines": "20-26",
    "snippet": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nospec.h>",
      "#include <linux/poll.h>",
      "#include <linux/circ_buf.h>",
      "#include <linux/slab.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/perf_event.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&handle->event->pending"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq_work.c",
          "lines": "106-118",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kasan.h>",
            "#include <asm/processor.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kasan.h>\n#include <asm/processor.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\t__irq_work_queue_local(work);\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&handle->rb->poll",
            "EPOLLIN"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nospec.h>\n#include <linux/poll.h>\n#include <linux/circ_buf.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/perf_event.h>\n\nstatic void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, EPOLLIN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}"
  }
]