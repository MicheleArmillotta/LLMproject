[
  {
    "function_name": "unregister_die_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "540-543",
    "snippet": "int unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ATOMIC_NOTIFIER_HEAD(die_chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_notifier_chain_unregister",
          "args": [
            "&die_chain",
            "nb"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "162-173",
          "snippet": "int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(die_chain);\n\nint unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}"
  },
  {
    "function_name": "register_die_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "534-537",
    "snippet": "int register_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&die_chain, nb);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ATOMIC_NOTIFIER_HEAD(die_chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_notifier_chain_register",
          "args": [
            "&die_chain",
            "nb"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "140-150",
          "snippet": "int atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(die_chain);\n\nint register_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_register(&die_chain, nb);\n}"
  },
  {
    "function_name": "notify_die",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "517-531",
    "snippet": "int notrace notify_die(enum die_val val, const char *str,\n\t       struct pt_regs *regs, long err, int trap, int sig)\n{\n\tstruct die_args args = {\n\t\t.regs\t= regs,\n\t\t.str\t= str,\n\t\t.err\t= err,\n\t\t.trapnr\t= trap,\n\t\t.signr\t= sig,\n\n\t};\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t   \"notify_die called but RCU thinks we're quiescent\");\n\treturn atomic_notifier_call_chain(&die_chain, val, &args);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ATOMIC_NOTIFIER_HEAD(die_chain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_notifier_call_chain",
          "args": [
            "&die_chain",
            "val",
            "&args"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "193-203",
          "snippet": "int atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "!rcu_is_watching()",
            "\"notify_die called but RCU thinks we're quiescent\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_is_watching",
          "args": [],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_is_watching",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "1123-1131",
          "snippet": "notrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nnotrace bool rcu_is_watching(void)\n{\n\tbool ret;\n\n\tpreempt_disable_notrace();\n\tret = !rcu_dynticks_curr_cpu_in_eqs();\n\tpreempt_enable_notrace();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(die_chain);\n\nint notrace notify_die(enum die_val val, const char *str,\n\t       struct pt_regs *regs, long err, int trap, int sig)\n{\n\tstruct die_args args = {\n\t\t.regs\t= regs,\n\t\t.str\t= str,\n\t\t.err\t= err,\n\t\t.trapnr\t= trap,\n\t\t.signr\t= sig,\n\n\t};\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(),\n\t\t\t   \"notify_die called but RCU thinks we're quiescent\");\n\treturn atomic_notifier_call_chain(&die_chain, val, &args);\n}"
  },
  {
    "function_name": "srcu_init_notifier_head",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "504-510",
    "snippet": "void srcu_init_notifier_head(struct srcu_notifier_head *nh)\n{\n\tmutex_init(&nh->mutex);\n\tif (init_srcu_struct(&nh->srcu) < 0)\n\t\tBUG();\n\tnh->head = NULL;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_srcu_struct",
          "args": [
            "&nh->srcu"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "224-238",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&nh->mutex"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nvoid srcu_init_notifier_head(struct srcu_notifier_head *nh)\n{\n\tmutex_init(&nh->mutex);\n\tif (init_srcu_struct(&nh->srcu) < 0)\n\t\tBUG();\n\tnh->head = NULL;\n}"
  },
  {
    "function_name": "srcu_notifier_call_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "479-489",
    "snippet": "int srcu_notifier_call_chain(struct srcu_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret;\n\tint idx;\n\n\tidx = srcu_read_lock(&nh->srcu);\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\tsrcu_read_unlock(&nh->srcu, idx);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&nh->srcu",
            "idx"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "416-420",
          "snippet": "void __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notifier_call_chain",
          "args": [
            "&nh->head",
            "val",
            "v",
            "-1",
            "NULL"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "65-95",
          "snippet": "static int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&nh->srcu"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "400-408",
          "snippet": "int __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint srcu_notifier_call_chain(struct srcu_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret;\n\tint idx;\n\n\tidx = srcu_read_lock(&nh->srcu);\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\tsrcu_read_unlock(&nh->srcu, idx);\n\treturn ret;\n}"
  },
  {
    "function_name": "srcu_notifier_chain_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "442-460",
    "snippet": "int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\tsynchronize_srcu(&nh->srcu);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "&nh->srcu"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "start_poll_synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1044-1047",
          "snippet": "unsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nh->mutex"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notifier_chain_unregister",
          "args": [
            "&nh->head",
            "n"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_notifier_chain_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "442-460",
          "snippet": "int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\tsynchronize_srcu(&nh->srcu);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nh->mutex"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "system_state == SYSTEM_BOOTING"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\tsynchronize_srcu(&nh->srcu);\n\treturn ret;\n}"
  },
  {
    "function_name": "srcu_notifier_chain_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "412-429",
    "snippet": "int srcu_notifier_chain_register(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_register(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&nh->mutex"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notifier_chain_register",
          "args": [
            "&nh->head",
            "n"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "412-429",
          "snippet": "int srcu_notifier_chain_register(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_register(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&nh->mutex"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "system_state == SYSTEM_BOOTING"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint srcu_notifier_chain_register(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_register(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "raw_notifier_call_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "389-393",
    "snippet": "int raw_notifier_call_chain(struct raw_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn notifier_call_chain(&nh->head, val, v, -1, NULL);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_call_chain",
          "args": [
            "&nh->head",
            "val",
            "v",
            "-1",
            "NULL"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "65-95",
          "snippet": "static int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_call_chain(struct raw_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn notifier_call_chain(&nh->head, val, v, -1, NULL);\n}"
  },
  {
    "function_name": "raw_notifier_call_chain_robust",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "365-369",
    "snippet": "int raw_notifier_call_chain_robust(struct raw_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\treturn notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_call_chain_robust",
          "args": [
            "&nh->head",
            "val_up",
            "val_down",
            "v"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "raw_notifier_call_chain_robust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "365-369",
          "snippet": "int raw_notifier_call_chain_robust(struct raw_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\treturn notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_call_chain_robust(struct raw_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\treturn notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n}"
  },
  {
    "function_name": "raw_notifier_chain_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "358-362",
    "snippet": "int raw_notifier_chain_unregister(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_unregister(&nh->head, n);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_chain_unregister",
          "args": [
            "&nh->head",
            "n"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_notifier_chain_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "442-460",
          "snippet": "int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\tsynchronize_srcu(&nh->srcu);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\tsynchronize_srcu(&nh->srcu);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_chain_unregister(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_unregister(&nh->head, n);\n}"
  },
  {
    "function_name": "raw_notifier_chain_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "341-345",
    "snippet": "int raw_notifier_chain_register(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_register(&nh->head, n);\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_chain_register",
          "args": [
            "&nh->head",
            "n"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "412-429",
          "snippet": "int srcu_notifier_chain_register(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_register(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint srcu_notifier_chain_register(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_register(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_chain_register(struct raw_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\treturn notifier_chain_register(&nh->head, n);\n}"
  },
  {
    "function_name": "blocking_notifier_call_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "307-323",
    "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nh->rwsem"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notifier_call_chain",
          "args": [
            "&nh->head",
            "val",
            "v",
            "-1",
            "NULL"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "65-95",
          "snippet": "static int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nh->rwsem"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "nh->head"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "blocking_notifier_call_chain_robust",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "272-288",
    "snippet": "int blocking_notifier_call_chain_robust(struct blocking_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&nh->rwsem"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notifier_call_chain_robust",
          "args": [
            "&nh->head",
            "val_up",
            "val_down",
            "v"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "raw_notifier_call_chain_robust",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "365-369",
          "snippet": "int raw_notifier_call_chain_robust(struct raw_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\treturn notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint raw_notifier_call_chain_robust(struct raw_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\treturn notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&nh->rwsem"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "nh->head"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain_robust(struct blocking_notifier_head *nh,\n\t\tunsigned long val_up, unsigned long val_down, void *v)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain_robust(&nh->head, val_up, val_down, v);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "blocking_notifier_chain_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "252-269",
    "snippet": "int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nh->rwsem"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notifier_chain_unregister",
          "args": [
            "&nh->head",
            "n"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_notifier_chain_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "442-460",
          "snippet": "int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\tsynchronize_srcu(&nh->srcu);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\tsynchronize_srcu(&nh->srcu);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nh->rwsem"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "system_state == SYSTEM_BOOTING"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
  },
  {
    "function_name": "blocking_notifier_chain_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "222-239",
    "snippet": "int blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&nh->rwsem"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notifier_chain_register",
          "args": [
            "&nh->head",
            "n"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "412-429",
          "snippet": "int srcu_notifier_chain_register(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_register(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint srcu_notifier_chain_register(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_register(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&nh->rwsem"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "system_state == SYSTEM_BOOTING"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
  },
  {
    "function_name": "atomic_notifier_call_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "193-203",
    "snippet": "int atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notifier_call_chain",
          "args": [
            "&nh->head",
            "val",
            "v",
            "-1",
            "NULL"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "65-95",
          "snippet": "static int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_call_chain(struct atomic_notifier_head *nh,\n\t\t\t       unsigned long val, void *v)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = notifier_call_chain(&nh->head, val, v, -1, NULL);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "atomic_notifier_chain_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "162-173",
    "snippet": "int atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&nh->lock",
            "flags"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notifier_chain_unregister",
          "args": [
            "&nh->head",
            "n"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_notifier_chain_unregister",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "442-460",
          "snippet": "int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\tsynchronize_srcu(&nh->srcu);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\tsynchronize_srcu(&nh->srcu);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&nh->lock",
            "flags"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_unregister(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\tsynchronize_rcu();\n\treturn ret;\n}"
  },
  {
    "function_name": "atomic_notifier_chain_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "140-150",
    "snippet": "int atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&nh->lock",
            "flags"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "notifier_chain_register",
          "args": [
            "&nh->head",
            "n"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_notifier_chain_register",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "412-429",
          "snippet": "int srcu_notifier_chain_register(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_register(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint srcu_notifier_chain_register(struct srcu_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call mutex_lock().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tmutex_lock(&nh->mutex);\n\tret = notifier_chain_register(&nh->head, n);\n\tmutex_unlock(&nh->mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&nh->lock",
            "flags"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint atomic_notifier_chain_register(struct atomic_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&nh->lock, flags);\n\tret = notifier_chain_register(&nh->head, n);\n\tspin_unlock_irqrestore(&nh->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "notifier_call_chain_robust",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "113-124",
    "snippet": "static int notifier_call_chain_robust(struct notifier_block **nl,\n\t\t\t\t     unsigned long val_up, unsigned long val_down,\n\t\t\t\t     void *v)\n{\n\tint ret, nr = 0;\n\n\tret = notifier_call_chain(nl, val_up, v, -1, &nr);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\tnotifier_call_chain(nl, val_down, v, nr-1, NULL);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_call_chain",
          "args": [
            "nl",
            "val_down",
            "v",
            "nr-1",
            "NULL"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "notifier_call_chain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "65-95",
          "snippet": "static int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic int notifier_call_chain_robust(struct notifier_block **nl,\n\t\t\t\t     unsigned long val_up, unsigned long val_down,\n\t\t\t\t     void *v)\n{\n\tint ret, nr = 0;\n\n\tret = notifier_call_chain(nl, val_up, v, -1, &nr);\n\tif (ret & NOTIFY_STOP_MASK)\n\t\tnotifier_call_chain(nl, val_down, v, nr-1, NULL);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "notifier_call_chain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "65-95",
    "snippet": "static int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nb->notifier_call",
          "args": [
            "nb",
            "val",
            "v"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Invalid notifier called!\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!func_ptr_is_kernel_text(nb->notifier_call)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_ptr_is_kernel_text",
          "args": [
            "nb->notifier_call"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "func_ptr_is_kernel_text",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/extable.c",
          "lines": "141-148",
          "snippet": "int func_ptr_is_kernel_text(void *ptr)\n{\n\tunsigned long addr;\n\taddr = (unsigned long) dereference_function_descriptor(ptr);\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\treturn is_module_text_address(addr);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/sections.h>",
            "#include <linux/filter.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/extable.h>",
            "#include <linux/memory.h>",
            "#include <linux/ftrace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <linux/filter.h>\n#include <linux/kprobes.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/extable.h>\n#include <linux/memory.h>\n#include <linux/ftrace.h>\n\nint func_ptr_is_kernel_text(void *ptr)\n{\n\tunsigned long addr;\n\taddr = (unsigned long) dereference_function_descriptor(ptr);\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\treturn is_module_text_address(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "nb->next"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "*nl"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic int notifier_call_chain(struct notifier_block **nl,\n\t\t\t       unsigned long val, void *v,\n\t\t\t       int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\tstruct notifier_block *nb, *next_nb;\n\n\tnb = rcu_dereference_raw(*nl);\n\n\twhile (nb && nr_to_call) {\n\t\tnext_nb = rcu_dereference_raw(nb->next);\n\n#ifdef CONFIG_DEBUG_NOTIFIERS\n\t\tif (unlikely(!func_ptr_is_kernel_text(nb->notifier_call))) {\n\t\t\tWARN(1, \"Invalid notifier called!\");\n\t\t\tnb = next_nb;\n\t\t\tcontinue;\n\t\t}\n#endif\n\t\tret = nb->notifier_call(nb, val, v);\n\n\t\tif (nr_calls)\n\t\t\t(*nr_calls)++;\n\n\t\tif (ret & NOTIFY_STOP_MASK)\n\t\t\tbreak;\n\t\tnb = next_nb;\n\t\tnr_to_call--;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "notifier_chain_unregister",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "40-51",
    "snippet": "static int notifier_chain_unregister(struct notifier_block **nl,\n\t\tstruct notifier_block *n)\n{\n\twhile ((*nl) != NULL) {\n\t\tif ((*nl) == n) {\n\t\t\trcu_assign_pointer(*nl, n->next);\n\t\t\treturn 0;\n\t\t}\n\t\tnl = &((*nl)->next);\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*nl",
            "n->next"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic int notifier_chain_unregister(struct notifier_block **nl,\n\t\tstruct notifier_block *n)\n{\n\twhile ((*nl) != NULL) {\n\t\tif ((*nl) == n) {\n\t\t\trcu_assign_pointer(*nl, n->next);\n\t\t\treturn 0;\n\t\t}\n\t\tnl = &((*nl)->next);\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "notifier_chain_register",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
    "lines": "22-38",
    "snippet": "static int notifier_chain_register(struct notifier_block **nl,\n\t\t\t\t   struct notifier_block *n)\n{\n\twhile ((*nl) != NULL) {\n\t\tif (unlikely((*nl) == n)) {\n\t\t\tWARN(1, \"notifier callback %ps already registered\",\n\t\t\t     n->notifier_call);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (n->priority > (*nl)->priority)\n\t\t\tbreak;\n\t\tnl = &((*nl)->next);\n\t}\n\tn->next = *nl;\n\trcu_assign_pointer(*nl, n);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/reboot.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/notifier.h>",
      "#include <linux/export.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/kdebug.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*nl",
            "n"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"notifier callback %ps already registered\"",
            "n->notifier_call"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(*nl) == n"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic int notifier_chain_register(struct notifier_block **nl,\n\t\t\t\t   struct notifier_block *n)\n{\n\twhile ((*nl) != NULL) {\n\t\tif (unlikely((*nl) == n)) {\n\t\t\tWARN(1, \"notifier callback %ps already registered\",\n\t\t\t     n->notifier_call);\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (n->priority > (*nl)->priority)\n\t\t\tbreak;\n\t\tnl = &((*nl)->next);\n\t}\n\tn->next = *nl;\n\trcu_assign_pointer(*nl, n);\n\treturn 0;\n}"
  }
]