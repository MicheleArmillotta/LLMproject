[
  {
    "function_name": "scf_torture_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "535-656",
    "snippet": "static int __init scf_torture_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\tunsigned long weight_resched1 = weight_resched;\n\tunsigned long weight_single1 = weight_single;\n\tunsigned long weight_single_rpc1 = weight_single_rpc;\n\tunsigned long weight_single_wait1 = weight_single_wait;\n\tunsigned long weight_many1 = weight_many;\n\tunsigned long weight_many_wait1 = weight_many_wait;\n\tunsigned long weight_all1 = weight_all;\n\tunsigned long weight_all_wait1 = weight_all_wait;\n\n\tif (!torture_init_begin(SCFTORT_STRING, verbose))\n\t\treturn -EBUSY;\n\n\tscftorture_print_module_parms(\"Start of test\");\n\n\tif (weight_resched <= 0 &&\n\t    weight_single <= 0 && weight_single_rpc <= 0 && weight_single_wait <= 0 &&\n\t    weight_many <= 0 && weight_many_wait <= 0 &&\n\t    weight_all <= 0 && weight_all_wait <= 0) {\n\t\tweight_resched1 = weight_resched == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_single1 = weight_single == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_single_rpc1 = weight_single_rpc == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_single_wait1 = weight_single_wait == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_many1 = weight_many == 0 ? 0 : 2;\n\t\tweight_many_wait1 = weight_many_wait == 0 ? 0 : 2;\n\t\tweight_all1 = weight_all == 0 ? 0 : 1;\n\t\tweight_all_wait1 = weight_all_wait == 0 ? 0 : 1;\n\t} else {\n\t\tif (weight_resched == -1)\n\t\t\tweight_resched1 = 0;\n\t\tif (weight_single == -1)\n\t\t\tweight_single1 = 0;\n\t\tif (weight_single_rpc == -1)\n\t\t\tweight_single_rpc1 = 0;\n\t\tif (weight_single_wait == -1)\n\t\t\tweight_single_wait1 = 0;\n\t\tif (weight_many == -1)\n\t\t\tweight_many1 = 0;\n\t\tif (weight_many_wait == -1)\n\t\t\tweight_many_wait1 = 0;\n\t\tif (weight_all == -1)\n\t\t\tweight_all1 = 0;\n\t\tif (weight_all_wait == -1)\n\t\t\tweight_all_wait1 = 0;\n\t}\n\tif (weight_resched1 == 0 && weight_single1 == 0 && weight_single_rpc1 == 0 &&\n\t    weight_single_wait1 == 0 && weight_many1 == 0 && weight_many_wait1 == 0 &&\n\t    weight_all1 == 0 && weight_all_wait1 == 0) {\n\t\tSCFTORTOUT_ERRSTRING(\"all zero weights makes no sense\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\tif (IS_BUILTIN(CONFIG_SCF_TORTURE_TEST))\n\t\tscf_sel_add(weight_resched1, SCF_PRIM_RESCHED, false);\n\telse if (weight_resched1)\n\t\tSCFTORTOUT_ERRSTRING(\"built as module, weight_resched ignored\");\n\tscf_sel_add(weight_single1, SCF_PRIM_SINGLE, false);\n\tscf_sel_add(weight_single_rpc1, SCF_PRIM_SINGLE_RPC, true);\n\tscf_sel_add(weight_single_wait1, SCF_PRIM_SINGLE, true);\n\tscf_sel_add(weight_many1, SCF_PRIM_MANY, false);\n\tscf_sel_add(weight_many_wait1, SCF_PRIM_MANY, true);\n\tscf_sel_add(weight_all1, SCF_PRIM_ALL, false);\n\tscf_sel_add(weight_all_wait1, SCF_PRIM_ALL, true);\n\tscf_sel_dump();\n\n\tif (onoff_interval > 0) {\n\t\tfirsterr = torture_onoff_init(onoff_holdoff * HZ, onoff_interval, NULL);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (shutdown_secs > 0) {\n\t\tfirsterr = torture_shutdown_init(shutdown_secs, scf_torture_cleanup);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stutter > 0) {\n\t\tfirsterr = torture_stutter_init(stutter, stutter);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\t// Worker tasks invoking smp_call_function().\n\tif (nthreads < 0)\n\t\tnthreads = num_online_cpus();\n\tscf_stats_p = kcalloc(nthreads, sizeof(scf_stats_p[0]), GFP_KERNEL);\n\tif (!scf_stats_p) {\n\t\tSCFTORTOUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\n\tVERBOSE_SCFTORTOUT(\"Starting %d smp_call_function() threads\", nthreads);\n\n\tatomic_set(&n_started, nthreads);\n\tfor (i = 0; i < nthreads; i++) {\n\t\tscf_stats_p[i].cpu = i;\n\t\tfirsterr = torture_create_kthread(scftorture_invoker, (void *)&scf_stats_p[i],\n\t\t\t\t\t\t  scf_stats_p[i].task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(scf_torture_stats, NULL, scf_torture_stats_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tscf_torture_cleanup();\n\tif (shutdown_secs) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_SCF_TORTURE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define SCF_PRIM_ALL\t\t4",
      "#define SCF_PRIM_MANY\t\t3",
      "#define SCF_PRIM_SINGLE_RPC\t2",
      "#define SCF_PRIM_SINGLE\t\t1",
      "#define SCF_PRIM_RESCHED\t0",
      "#define SCFTORT_STRING \"scftorture\""
    ],
    "globals_used": [
      "static struct scf_statistics *scf_stats_p;",
      "static struct task_struct *scf_torture_stats_task;",
      "static atomic_t n_started;",
      "extern void resched_cpu(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_power_off",
          "args": [],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_power_off",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/reboot.c",
          "lines": "289-299",
          "snippet": "void kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void (*pm_power_off_prepare)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n#include <linux/atomic.h>\n\nvoid (*pm_power_off_prepare)(void);\n\nvoid kernel_power_off(void)\n{\n\tkernel_shutdown_prepare(SYSTEM_POWER_OFF);\n\tif (pm_power_off_prepare)\n\t\tpm_power_off_prepare();\n\tmigrate_to_reboot_cpu();\n\tsyscore_shutdown();\n\tpr_emerg(\"Power down\\n\");\n\tkmsg_dump(KMSG_DUMP_SHUTDOWN);\n\tmachine_power_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!IS_MODULE(CONFIG_SCF_TORTURE_TEST)"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MODULE",
          "args": [
            "CONFIG_SCF_TORTURE_TEST"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_torture_cleanup",
          "args": [],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "scf_torture_cleanup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
          "lines": "505-533",
          "snippet": "static void scf_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tWRITE_ONCE(scfdone, true);\n\tif (nthreads && scf_stats_p)\n\t\tfor (i = 0; i < nthreads; i++)\n\t\t\ttorture_stop_kthread(\"scftorture_invoker\", scf_stats_p[i].task);\n\telse\n\t\tgoto end;\n\tsmp_call_function(scf_cleanup_handler, NULL, 0);\n\ttorture_stop_kthread(scf_torture_stats, scf_torture_stats_task);\n\tscf_torture_stats_print();  // -After- the stats thread is stopped!\n\tkfree(scf_stats_p);  // -After- the last stats print has completed!\n\tscf_stats_p = NULL;\n\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) || atomic_read(&n_mb_out_errs))\n\t\tscftorture_print_module_parms(\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tscftorture_print_module_parms(\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tscftorture_print_module_parms(\"End of test: SUCCESS\");\n\nend:\n\ttorture_cleanup_end();\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct scf_statistics *scf_stats_p;",
            "static struct task_struct *scf_torture_stats_task;",
            "static atomic_t n_errs;",
            "static atomic_t n_mb_in_errs;",
            "static atomic_t n_mb_out_errs;",
            "static bool scfdone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct scf_statistics *scf_stats_p;\nstatic struct task_struct *scf_torture_stats_task;\nstatic atomic_t n_errs;\nstatic atomic_t n_mb_in_errs;\nstatic atomic_t n_mb_out_errs;\nstatic bool scfdone;\n\nstatic void scf_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tWRITE_ONCE(scfdone, true);\n\tif (nthreads && scf_stats_p)\n\t\tfor (i = 0; i < nthreads; i++)\n\t\t\ttorture_stop_kthread(\"scftorture_invoker\", scf_stats_p[i].task);\n\telse\n\t\tgoto end;\n\tsmp_call_function(scf_cleanup_handler, NULL, 0);\n\ttorture_stop_kthread(scf_torture_stats, scf_torture_stats_task);\n\tscf_torture_stats_print();  // -After- the stats thread is stopped!\n\tkfree(scf_stats_p);  // -After- the last stats print has completed!\n\tscf_stats_p = NULL;\n\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) || atomic_read(&n_mb_out_errs))\n\t\tscftorture_print_module_parms(\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tscftorture_print_module_parms(\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tscftorture_print_module_parms(\"End of test: SUCCESS\");\n\nend:\n\ttorture_cleanup_end();\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_end",
          "args": [],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "835-839",
          "snippet": "void torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(fullstop_mutex);",
            "static struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_MUTEX(fullstop_mutex);\nstatic struct notifier_block torture_shutdown_nb = {\n\t.notifier_call = torture_shutdown_notify,\n};\n\nvoid torture_init_end(void)\n{\n\tmutex_unlock(&fullstop_mutex);\n\tregister_reboot_notifier(&torture_shutdown_nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "scf_torture_stats",
            "NULL",
            "scf_torture_stats_task"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_create_kthread",
          "args": [
            "scftorture_invoker",
            "(void *)&scf_stats_p[i]",
            "scf_stats_p[i].task"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&n_started",
            "nthreads"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCFTORTOUT",
          "args": [
            "\"Starting %d smp_call_function() threads\"",
            "nthreads"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCFTORTOUT_ERRSTRING",
          "args": [
            "\"out of memory\""
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nthreads",
            "sizeof(scf_stats_p[0])",
            "GFP_KERNEL"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_stutter_init",
          "args": [
            "stutter",
            "stutter"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "torture_stutter_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "786-791",
          "snippet": "int torture_stutter_init(const int s, const int sgap)\n{\n\tstutter = s;\n\tstutter_gap = sgap;\n\treturn torture_create_kthread(torture_stutter, NULL, stutter_task);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *stutter_task;",
            "static int stutter;",
            "static int stutter_gap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *stutter_task;\nstatic int stutter;\nstatic int stutter_gap;\n\nint torture_stutter_init(const int s, const int sgap)\n{\n\tstutter = s;\n\tstutter_gap = sgap;\n\treturn torture_create_kthread(torture_stutter, NULL, stutter_task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_shutdown_init",
          "args": [
            "shutdown_secs",
            "scf_torture_cleanup"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "661-670",
          "snippet": "int torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\treturn torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *shutdown_task;",
            "static ktime_t shutdown_time;",
            "static void (*torture_shutdown_hook)(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic struct task_struct *shutdown_task;\nstatic ktime_t shutdown_time;\nstatic void (*torture_shutdown_hook)(void);\n\nint torture_shutdown_init(int ssecs, void (*cleanup)(void))\n{\n\ttorture_shutdown_hook = cleanup;\n\tif (ssecs > 0) {\n\t\tshutdown_time = ktime_add(ktime_get(), ktime_set(ssecs, 0));\n\t\treturn torture_create_kthread(torture_shutdown, NULL,\n\t\t\t\t\t     shutdown_task);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_error",
          "args": [
            "firsterr"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_onoff_init",
          "args": [
            "onoff_holdoff * HZ",
            "onoff_interval",
            "NULL"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "382-394",
          "snippet": "int torture_onoff_init(long ooholdoff, long oointerval, torture_ofl_func *f)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tonoff_f = f;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(torture_onoff, NULL, onoff_task);\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn 0;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_onoff_init(long ooholdoff, long oointerval, torture_ofl_func *f)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tonoff_f = f;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(torture_onoff, NULL, onoff_task);\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn 0;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "scf_sel_dump",
          "args": [],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "scf_sel_dump",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
          "lines": "223-238",
          "snippet": "static void scf_sel_dump(void)\n{\n\tint i;\n\tunsigned long oldw = 0;\n\tstruct scf_selector *scfsp;\n\tunsigned long w;\n\n\tfor (i = 0; i < scf_sel_array_len; i++) {\n\t\tscfsp = &scf_sel_array[i];\n\t\tw = (scfsp->scfs_weight - oldw) * 100000 / scf_sel_totweight;\n\t\tpr_info(\"%s: %3lu.%03lu %s(%s)\\n\", __func__, w / 1000, w % 1000,\n\t\t\tscf_prim_name[scfsp->scfs_prim],\n\t\t\tscfsp->scfs_wait ? \"wait\" : \"nowait\");\n\t\toldw = scfsp->scfs_weight;\n\t}\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *scf_prim_name[] = {\n\t\"resched_cpu\",\n\t\"smp_call_function_single\",\n\t\"smp_call_function_single_rpc\",\n\t\"smp_call_function_many\",\n\t\"smp_call_function\",\n};",
            "static struct scf_selector scf_sel_array[SCF_NPRIMS];",
            "static int scf_sel_array_len;",
            "static unsigned long scf_sel_totweight;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic char *scf_prim_name[] = {\n\t\"resched_cpu\",\n\t\"smp_call_function_single\",\n\t\"smp_call_function_single_rpc\",\n\t\"smp_call_function_many\",\n\t\"smp_call_function\",\n};\nstatic struct scf_selector scf_sel_array[SCF_NPRIMS];\nstatic int scf_sel_array_len;\nstatic unsigned long scf_sel_totweight;\n\nstatic void scf_sel_dump(void)\n{\n\tint i;\n\tunsigned long oldw = 0;\n\tstruct scf_selector *scfsp;\n\tunsigned long w;\n\n\tfor (i = 0; i < scf_sel_array_len; i++) {\n\t\tscfsp = &scf_sel_array[i];\n\t\tw = (scfsp->scfs_weight - oldw) * 100000 / scf_sel_totweight;\n\t\tpr_info(\"%s: %3lu.%03lu %s(%s)\\n\", __func__, w / 1000, w % 1000,\n\t\t\tscf_prim_name[scfsp->scfs_prim],\n\t\t\tscfsp->scfs_wait ? \"wait\" : \"nowait\");\n\t\toldw = scfsp->scfs_weight;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scf_sel_add",
          "args": [
            "weight_all_wait1",
            "SCF_PRIM_ALL",
            "true"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "scf_sel_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
          "lines": "203-220",
          "snippet": "static void scf_sel_add(unsigned long weight, int prim, bool wait)\n{\n\tstruct scf_selector *scfsp = &scf_sel_array[scf_sel_array_len];\n\n\t// If no weight, if array would overflow, if computing three-place\n\t// percentages would overflow, or if the scf_prim_name[] array would\n\t// overflow, don't bother.  In the last three two cases, complain.\n\tif (!weight ||\n\t    WARN_ON_ONCE(scf_sel_array_len >= ARRAY_SIZE(scf_sel_array)) ||\n\t    WARN_ON_ONCE(0 - 100000 * weight <= 100000 * scf_sel_totweight) ||\n\t    WARN_ON_ONCE(prim >= ARRAY_SIZE(scf_prim_name)))\n\t\treturn;\n\tscf_sel_totweight += weight;\n\tscfsp->scfs_weight = scf_sel_totweight;\n\tscfsp->scfs_prim = prim;\n\tscfsp->scfs_wait = wait;\n\tscf_sel_array_len++;\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *scf_prim_name[] = {\n\t\"resched_cpu\",\n\t\"smp_call_function_single\",\n\t\"smp_call_function_single_rpc\",\n\t\"smp_call_function_many\",\n\t\"smp_call_function\",\n};",
            "static struct scf_selector scf_sel_array[SCF_NPRIMS];",
            "static int scf_sel_array_len;",
            "static unsigned long scf_sel_totweight;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic char *scf_prim_name[] = {\n\t\"resched_cpu\",\n\t\"smp_call_function_single\",\n\t\"smp_call_function_single_rpc\",\n\t\"smp_call_function_many\",\n\t\"smp_call_function\",\n};\nstatic struct scf_selector scf_sel_array[SCF_NPRIMS];\nstatic int scf_sel_array_len;\nstatic unsigned long scf_sel_totweight;\n\nstatic void scf_sel_add(unsigned long weight, int prim, bool wait)\n{\n\tstruct scf_selector *scfsp = &scf_sel_array[scf_sel_array_len];\n\n\t// If no weight, if array would overflow, if computing three-place\n\t// percentages would overflow, or if the scf_prim_name[] array would\n\t// overflow, don't bother.  In the last three two cases, complain.\n\tif (!weight ||\n\t    WARN_ON_ONCE(scf_sel_array_len >= ARRAY_SIZE(scf_sel_array)) ||\n\t    WARN_ON_ONCE(0 - 100000 * weight <= 100000 * scf_sel_totweight) ||\n\t    WARN_ON_ONCE(prim >= ARRAY_SIZE(scf_prim_name)))\n\t\treturn;\n\tscf_sel_totweight += weight;\n\tscfsp->scfs_weight = scf_sel_totweight;\n\tscfsp->scfs_prim = prim;\n\tscfsp->scfs_wait = wait;\n\tscf_sel_array_len++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCFTORTOUT_ERRSTRING",
          "args": [
            "\"built as module, weight_resched ignored\""
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_BUILTIN",
          "args": [
            "CONFIG_SCF_TORTURE_TEST"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCFTORTOUT_ERRSTRING",
          "args": [
            "\"all zero weights makes no sense\""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scftorture_print_module_parms",
          "args": [
            "\"Start of test\""
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "scftorture_print_module_parms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
          "lines": "493-499",
          "snippet": "static void\nscftorture_print_module_parms(const char *tag)\n{\n\tpr_alert(SCFTORT_FLAG\n\t\t \"--- %s:  verbose=%d holdoff=%d longwait=%d nthreads=%d onoff_holdoff=%d onoff_interval=%d shutdown_secs=%d stat_interval=%d stutter=%d use_cpus_read_lock=%d, weight_resched=%d, weight_single=%d, weight_single_rpc=%d, weight_single_wait=%d, weight_many=%d, weight_many_wait=%d, weight_all=%d, weight_all_wait=%d\\n\", tag,\n\t\t verbose, holdoff, longwait, nthreads, onoff_holdoff, onoff_interval, shutdown, stat_interval, stutter, use_cpus_read_lock, weight_resched, weight_single, weight_single_rpc, weight_single_wait, weight_many, weight_many_wait, weight_all, weight_all_wait);\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define SCFTORT_FLAG SCFTORT_STRING \": \""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCFTORT_FLAG SCFTORT_STRING \": \"\n\nstatic void\nscftorture_print_module_parms(const char *tag)\n{\n\tpr_alert(SCFTORT_FLAG\n\t\t \"--- %s:  verbose=%d holdoff=%d longwait=%d nthreads=%d onoff_holdoff=%d onoff_interval=%d shutdown_secs=%d stat_interval=%d stutter=%d use_cpus_read_lock=%d, weight_resched=%d, weight_single=%d, weight_single_rpc=%d, weight_single_wait=%d, weight_many=%d, weight_many_wait=%d, weight_all=%d, weight_all_wait=%d\\n\", tag,\n\t\t verbose, holdoff, longwait, nthreads, onoff_holdoff, onoff_interval, shutdown, stat_interval, stutter, use_cpus_read_lock, weight_resched, weight_single, weight_single_rpc, weight_single_wait, weight_many, weight_many_wait, weight_all, weight_all_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_init_begin",
          "args": [
            "SCFTORT_STRING",
            "verbose"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "torture_init_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "815-829",
          "snippet": "bool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static char *torture_type;",
            "static int verbose;",
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic char *torture_type;\nstatic int verbose;\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_init_begin(char *ttype, int v)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (torture_type != NULL) {\n\t\tpr_alert(\"%s: Refusing %s init: %s running.\\n\",\n\t\t\t  __func__, ttype, torture_type);\n\t\tpr_alert(\"%s: One torture test at a time!\\n\", __func__);\n\t\tmutex_unlock(&fullstop_mutex);\n\t\treturn false;\n\t}\n\ttorture_type = ttype;\n\tverbose = v;\n\tfullstop = FULLSTOP_DONTSTOP;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCF_PRIM_ALL\t\t4\n#define SCF_PRIM_MANY\t\t3\n#define SCF_PRIM_SINGLE_RPC\t2\n#define SCF_PRIM_SINGLE\t\t1\n#define SCF_PRIM_RESCHED\t0\n#define SCFTORT_STRING \"scftorture\"\n\nstatic struct scf_statistics *scf_stats_p;\nstatic struct task_struct *scf_torture_stats_task;\nstatic atomic_t n_started;\nextern void resched_cpu(int cpu);\n\nstatic int __init scf_torture_init(void)\n{\n\tlong i;\n\tint firsterr = 0;\n\tunsigned long weight_resched1 = weight_resched;\n\tunsigned long weight_single1 = weight_single;\n\tunsigned long weight_single_rpc1 = weight_single_rpc;\n\tunsigned long weight_single_wait1 = weight_single_wait;\n\tunsigned long weight_many1 = weight_many;\n\tunsigned long weight_many_wait1 = weight_many_wait;\n\tunsigned long weight_all1 = weight_all;\n\tunsigned long weight_all_wait1 = weight_all_wait;\n\n\tif (!torture_init_begin(SCFTORT_STRING, verbose))\n\t\treturn -EBUSY;\n\n\tscftorture_print_module_parms(\"Start of test\");\n\n\tif (weight_resched <= 0 &&\n\t    weight_single <= 0 && weight_single_rpc <= 0 && weight_single_wait <= 0 &&\n\t    weight_many <= 0 && weight_many_wait <= 0 &&\n\t    weight_all <= 0 && weight_all_wait <= 0) {\n\t\tweight_resched1 = weight_resched == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_single1 = weight_single == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_single_rpc1 = weight_single_rpc == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_single_wait1 = weight_single_wait == 0 ? 0 : 2 * nr_cpu_ids;\n\t\tweight_many1 = weight_many == 0 ? 0 : 2;\n\t\tweight_many_wait1 = weight_many_wait == 0 ? 0 : 2;\n\t\tweight_all1 = weight_all == 0 ? 0 : 1;\n\t\tweight_all_wait1 = weight_all_wait == 0 ? 0 : 1;\n\t} else {\n\t\tif (weight_resched == -1)\n\t\t\tweight_resched1 = 0;\n\t\tif (weight_single == -1)\n\t\t\tweight_single1 = 0;\n\t\tif (weight_single_rpc == -1)\n\t\t\tweight_single_rpc1 = 0;\n\t\tif (weight_single_wait == -1)\n\t\t\tweight_single_wait1 = 0;\n\t\tif (weight_many == -1)\n\t\t\tweight_many1 = 0;\n\t\tif (weight_many_wait == -1)\n\t\t\tweight_many_wait1 = 0;\n\t\tif (weight_all == -1)\n\t\t\tweight_all1 = 0;\n\t\tif (weight_all_wait == -1)\n\t\t\tweight_all_wait1 = 0;\n\t}\n\tif (weight_resched1 == 0 && weight_single1 == 0 && weight_single_rpc1 == 0 &&\n\t    weight_single_wait1 == 0 && weight_many1 == 0 && weight_many_wait1 == 0 &&\n\t    weight_all1 == 0 && weight_all_wait1 == 0) {\n\t\tSCFTORTOUT_ERRSTRING(\"all zero weights makes no sense\");\n\t\tfirsterr = -EINVAL;\n\t\tgoto unwind;\n\t}\n\tif (IS_BUILTIN(CONFIG_SCF_TORTURE_TEST))\n\t\tscf_sel_add(weight_resched1, SCF_PRIM_RESCHED, false);\n\telse if (weight_resched1)\n\t\tSCFTORTOUT_ERRSTRING(\"built as module, weight_resched ignored\");\n\tscf_sel_add(weight_single1, SCF_PRIM_SINGLE, false);\n\tscf_sel_add(weight_single_rpc1, SCF_PRIM_SINGLE_RPC, true);\n\tscf_sel_add(weight_single_wait1, SCF_PRIM_SINGLE, true);\n\tscf_sel_add(weight_many1, SCF_PRIM_MANY, false);\n\tscf_sel_add(weight_many_wait1, SCF_PRIM_MANY, true);\n\tscf_sel_add(weight_all1, SCF_PRIM_ALL, false);\n\tscf_sel_add(weight_all_wait1, SCF_PRIM_ALL, true);\n\tscf_sel_dump();\n\n\tif (onoff_interval > 0) {\n\t\tfirsterr = torture_onoff_init(onoff_holdoff * HZ, onoff_interval, NULL);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (shutdown_secs > 0) {\n\t\tfirsterr = torture_shutdown_init(shutdown_secs, scf_torture_cleanup);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stutter > 0) {\n\t\tfirsterr = torture_stutter_init(stutter, stutter);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\t// Worker tasks invoking smp_call_function().\n\tif (nthreads < 0)\n\t\tnthreads = num_online_cpus();\n\tscf_stats_p = kcalloc(nthreads, sizeof(scf_stats_p[0]), GFP_KERNEL);\n\tif (!scf_stats_p) {\n\t\tSCFTORTOUT_ERRSTRING(\"out of memory\");\n\t\tfirsterr = -ENOMEM;\n\t\tgoto unwind;\n\t}\n\n\tVERBOSE_SCFTORTOUT(\"Starting %d smp_call_function() threads\", nthreads);\n\n\tatomic_set(&n_started, nthreads);\n\tfor (i = 0; i < nthreads; i++) {\n\t\tscf_stats_p[i].cpu = i;\n\t\tfirsterr = torture_create_kthread(scftorture_invoker, (void *)&scf_stats_p[i],\n\t\t\t\t\t\t  scf_stats_p[i].task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval > 0) {\n\t\tfirsterr = torture_create_kthread(scf_torture_stats, NULL, scf_torture_stats_task);\n\t\tif (torture_init_error(firsterr))\n\t\t\tgoto unwind;\n\t}\n\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\tscf_torture_cleanup();\n\tif (shutdown_secs) {\n\t\tWARN_ON(!IS_MODULE(CONFIG_SCF_TORTURE_TEST));\n\t\tkernel_power_off();\n\t}\n\treturn firsterr;\n}"
  },
  {
    "function_name": "scf_torture_cleanup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "505-533",
    "snippet": "static void scf_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tWRITE_ONCE(scfdone, true);\n\tif (nthreads && scf_stats_p)\n\t\tfor (i = 0; i < nthreads; i++)\n\t\t\ttorture_stop_kthread(\"scftorture_invoker\", scf_stats_p[i].task);\n\telse\n\t\tgoto end;\n\tsmp_call_function(scf_cleanup_handler, NULL, 0);\n\ttorture_stop_kthread(scf_torture_stats, scf_torture_stats_task);\n\tscf_torture_stats_print();  // -After- the stats thread is stopped!\n\tkfree(scf_stats_p);  // -After- the last stats print has completed!\n\tscf_stats_p = NULL;\n\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) || atomic_read(&n_mb_out_errs))\n\t\tscftorture_print_module_parms(\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tscftorture_print_module_parms(\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tscftorture_print_module_parms(\"End of test: SUCCESS\");\n\nend:\n\ttorture_cleanup_end();\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct scf_statistics *scf_stats_p;",
      "static struct task_struct *scf_torture_stats_task;",
      "static atomic_t n_errs;",
      "static atomic_t n_mb_in_errs;",
      "static atomic_t n_mb_out_errs;",
      "static bool scfdone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_cleanup_end",
          "args": [],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "876-881",
          "snippet": "void torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *torture_type;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic char *torture_type;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nvoid torture_cleanup_end(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\ttorture_type = NULL;\n\tmutex_unlock(&fullstop_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scftorture_print_module_parms",
          "args": [
            "\"End of test: SUCCESS\""
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "scftorture_print_module_parms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
          "lines": "493-499",
          "snippet": "static void\nscftorture_print_module_parms(const char *tag)\n{\n\tpr_alert(SCFTORT_FLAG\n\t\t \"--- %s:  verbose=%d holdoff=%d longwait=%d nthreads=%d onoff_holdoff=%d onoff_interval=%d shutdown_secs=%d stat_interval=%d stutter=%d use_cpus_read_lock=%d, weight_resched=%d, weight_single=%d, weight_single_rpc=%d, weight_single_wait=%d, weight_many=%d, weight_many_wait=%d, weight_all=%d, weight_all_wait=%d\\n\", tag,\n\t\t verbose, holdoff, longwait, nthreads, onoff_holdoff, onoff_interval, shutdown, stat_interval, stutter, use_cpus_read_lock, weight_resched, weight_single, weight_single_rpc, weight_single_wait, weight_many, weight_many_wait, weight_all, weight_all_wait);\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define SCFTORT_FLAG SCFTORT_STRING \": \""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCFTORT_FLAG SCFTORT_STRING \": \"\n\nstatic void\nscftorture_print_module_parms(const char *tag)\n{\n\tpr_alert(SCFTORT_FLAG\n\t\t \"--- %s:  verbose=%d holdoff=%d longwait=%d nthreads=%d onoff_holdoff=%d onoff_interval=%d shutdown_secs=%d stat_interval=%d stutter=%d use_cpus_read_lock=%d, weight_resched=%d, weight_single=%d, weight_single_rpc=%d, weight_single_wait=%d, weight_many=%d, weight_many_wait=%d, weight_all=%d, weight_all_wait=%d\\n\", tag,\n\t\t verbose, holdoff, longwait, nthreads, onoff_holdoff, onoff_interval, shutdown, stat_interval, stutter, use_cpus_read_lock, weight_resched, weight_single, weight_single_rpc, weight_single_wait, weight_many, weight_many_wait, weight_all, weight_all_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_onoff_failures",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_failures",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "430-438",
          "snippet": "bool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn false;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool torture_onoff_failures(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else /* #ifdef CONFIG_HOTPLUG_CPU */\n\treturn false;\n#endif /* #else #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_mb_out_errs"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_mb_in_errs"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_errs"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scf_stats_p"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scf_torture_stats_print",
          "args": [],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "scf_torture_stats_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
          "lines": "151-185",
          "snippet": "static void scf_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong long invoked_count = 0;\n\tbool isdone = READ_ONCE(scfdone);\n\tstruct scf_statistics scfs = {};\n\n\tfor_each_possible_cpu(cpu)\n\t\tinvoked_count += data_race(per_cpu(scf_invoked_count, cpu));\n\tfor (i = 0; i < nthreads; i++) {\n\t\tscfs.n_resched += scf_stats_p[i].n_resched;\n\t\tscfs.n_single += scf_stats_p[i].n_single;\n\t\tscfs.n_single_ofl += scf_stats_p[i].n_single_ofl;\n\t\tscfs.n_single_rpc += scf_stats_p[i].n_single_rpc;\n\t\tscfs.n_single_wait += scf_stats_p[i].n_single_wait;\n\t\tscfs.n_single_wait_ofl += scf_stats_p[i].n_single_wait_ofl;\n\t\tscfs.n_many += scf_stats_p[i].n_many;\n\t\tscfs.n_many_wait += scf_stats_p[i].n_many_wait;\n\t\tscfs.n_all += scf_stats_p[i].n_all;\n\t\tscfs.n_all_wait += scf_stats_p[i].n_all_wait;\n\t}\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) ||\n\t    atomic_read(&n_mb_out_errs) || atomic_read(&n_alloc_errs))\n\t\tbangstr = \"!!! \";\n\tpr_alert(\"%s %sscf_invoked_count %s: %lld resched: %lld single: %lld/%lld single_ofl: %lld/%lld single_rpc: %lld single_rpc_ofl: %lld many: %lld/%lld all: %lld/%lld \",\n\t\t SCFTORT_FLAG, bangstr, isdone ? \"VER\" : \"ver\", invoked_count, scfs.n_resched,\n\t\t scfs.n_single, scfs.n_single_wait, scfs.n_single_ofl, scfs.n_single_wait_ofl,\n\t\t scfs.n_single_rpc, scfs.n_single_rpc_ofl,\n\t\t scfs.n_many, scfs.n_many_wait, scfs.n_all, scfs.n_all_wait);\n\ttorture_onoff_stats();\n\tpr_cont(\"ste: %d stnmie: %d stnmoe: %d staf: %d\\n\", atomic_read(&n_errs),\n\t\tatomic_read(&n_mb_in_errs), atomic_read(&n_mb_out_errs),\n\t\tatomic_read(&n_alloc_errs));\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define SCFTORT_FLAG SCFTORT_STRING \": \""
          ],
          "globals_used": [
            "static struct scf_statistics *scf_stats_p;",
            "static DEFINE_PER_CPU(long long, scf_invoked_count);",
            "static atomic_t n_errs;",
            "static atomic_t n_mb_in_errs;",
            "static atomic_t n_mb_out_errs;",
            "static atomic_t n_alloc_errs;",
            "static bool scfdone;",
            "static char *bangstr = \"\";",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCFTORT_FLAG SCFTORT_STRING \": \"\n\nstatic struct scf_statistics *scf_stats_p;\nstatic DEFINE_PER_CPU(long long, scf_invoked_count);\nstatic atomic_t n_errs;\nstatic atomic_t n_mb_in_errs;\nstatic atomic_t n_mb_out_errs;\nstatic atomic_t n_alloc_errs;\nstatic bool scfdone;\nstatic char *bangstr = \"\";\nextern void resched_cpu(int cpu);\n\nstatic void scf_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong long invoked_count = 0;\n\tbool isdone = READ_ONCE(scfdone);\n\tstruct scf_statistics scfs = {};\n\n\tfor_each_possible_cpu(cpu)\n\t\tinvoked_count += data_race(per_cpu(scf_invoked_count, cpu));\n\tfor (i = 0; i < nthreads; i++) {\n\t\tscfs.n_resched += scf_stats_p[i].n_resched;\n\t\tscfs.n_single += scf_stats_p[i].n_single;\n\t\tscfs.n_single_ofl += scf_stats_p[i].n_single_ofl;\n\t\tscfs.n_single_rpc += scf_stats_p[i].n_single_rpc;\n\t\tscfs.n_single_wait += scf_stats_p[i].n_single_wait;\n\t\tscfs.n_single_wait_ofl += scf_stats_p[i].n_single_wait_ofl;\n\t\tscfs.n_many += scf_stats_p[i].n_many;\n\t\tscfs.n_many_wait += scf_stats_p[i].n_many_wait;\n\t\tscfs.n_all += scf_stats_p[i].n_all;\n\t\tscfs.n_all_wait += scf_stats_p[i].n_all_wait;\n\t}\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) ||\n\t    atomic_read(&n_mb_out_errs) || atomic_read(&n_alloc_errs))\n\t\tbangstr = \"!!! \";\n\tpr_alert(\"%s %sscf_invoked_count %s: %lld resched: %lld single: %lld/%lld single_ofl: %lld/%lld single_rpc: %lld single_rpc_ofl: %lld many: %lld/%lld all: %lld/%lld \",\n\t\t SCFTORT_FLAG, bangstr, isdone ? \"VER\" : \"ver\", invoked_count, scfs.n_resched,\n\t\t scfs.n_single, scfs.n_single_wait, scfs.n_single_ofl, scfs.n_single_wait_ofl,\n\t\t scfs.n_single_rpc, scfs.n_single_rpc_ofl,\n\t\t scfs.n_many, scfs.n_many_wait, scfs.n_all, scfs.n_all_wait);\n\ttorture_onoff_stats();\n\tpr_cont(\"ste: %d stnmie: %d stnmoe: %d staf: %d\\n\", atomic_read(&n_errs),\n\t\tatomic_read(&n_mb_in_errs), atomic_read(&n_mb_out_errs),\n\t\tatomic_read(&n_alloc_errs));\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_stop_kthread",
          "args": [
            "scf_torture_stats",
            "scf_torture_stats_task"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "_torture_stop_kthread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "948-955",
          "snippet": "void _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid _torture_stop_kthread(char *m, struct task_struct **tp)\n{\n\tif (*tp == NULL)\n\t\treturn;\n\tVERBOSE_TOROUT_STRING(m);\n\tkthread_stop(*tp);\n\t*tp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "scf_cleanup_handler",
            "NULL",
            "0"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "1012-1017",
          "snippet": "void smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "scfdone",
            "true"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_cleanup_begin",
          "args": [],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "torture_cleanup_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "857-873",
          "snippet": "bool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */",
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;",
            "static DEFINE_MUTEX(fullstop_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_RMMOD    2\t/* Normal rmmod of torture. */\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\nstatic DEFINE_MUTEX(fullstop_mutex);\n\nbool torture_cleanup_begin(void)\n{\n\tmutex_lock(&fullstop_mutex);\n\tif (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_warn(\"Concurrent rmmod and shutdown illegal!\\n\");\n\t\tmutex_unlock(&fullstop_mutex);\n\t\tschedule_timeout_uninterruptible(10);\n\t\treturn true;\n\t}\n\tWRITE_ONCE(fullstop, FULLSTOP_RMMOD);\n\tmutex_unlock(&fullstop_mutex);\n\ttorture_shutdown_cleanup();\n\ttorture_shuffle_cleanup();\n\ttorture_stutter_cleanup();\n\ttorture_onoff_cleanup();\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct scf_statistics *scf_stats_p;\nstatic struct task_struct *scf_torture_stats_task;\nstatic atomic_t n_errs;\nstatic atomic_t n_mb_in_errs;\nstatic atomic_t n_mb_out_errs;\nstatic bool scfdone;\n\nstatic void scf_torture_cleanup(void)\n{\n\tint i;\n\n\tif (torture_cleanup_begin())\n\t\treturn;\n\n\tWRITE_ONCE(scfdone, true);\n\tif (nthreads && scf_stats_p)\n\t\tfor (i = 0; i < nthreads; i++)\n\t\t\ttorture_stop_kthread(\"scftorture_invoker\", scf_stats_p[i].task);\n\telse\n\t\tgoto end;\n\tsmp_call_function(scf_cleanup_handler, NULL, 0);\n\ttorture_stop_kthread(scf_torture_stats, scf_torture_stats_task);\n\tscf_torture_stats_print();  // -After- the stats thread is stopped!\n\tkfree(scf_stats_p);  // -After- the last stats print has completed!\n\tscf_stats_p = NULL;\n\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) || atomic_read(&n_mb_out_errs))\n\t\tscftorture_print_module_parms(\"End of test: FAILURE\");\n\telse if (torture_onoff_failures())\n\t\tscftorture_print_module_parms(\"End of test: LOCK_HOTPLUG\");\n\telse\n\t\tscftorture_print_module_parms(\"End of test: SUCCESS\");\n\nend:\n\ttorture_cleanup_end();\n}"
  },
  {
    "function_name": "scf_cleanup_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "501-503",
    "snippet": "static void scf_cleanup_handler(void *unused)\n{\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic void scf_cleanup_handler(void *unused)\n{\n}"
  },
  {
    "function_name": "scftorture_print_module_parms",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "493-499",
    "snippet": "static void\nscftorture_print_module_parms(const char *tag)\n{\n\tpr_alert(SCFTORT_FLAG\n\t\t \"--- %s:  verbose=%d holdoff=%d longwait=%d nthreads=%d onoff_holdoff=%d onoff_interval=%d shutdown_secs=%d stat_interval=%d stutter=%d use_cpus_read_lock=%d, weight_resched=%d, weight_single=%d, weight_single_rpc=%d, weight_single_wait=%d, weight_many=%d, weight_many_wait=%d, weight_all=%d, weight_all_wait=%d\\n\", tag,\n\t\t verbose, holdoff, longwait, nthreads, onoff_holdoff, onoff_interval, shutdown, stat_interval, stutter, use_cpus_read_lock, weight_resched, weight_single, weight_single_rpc, weight_single_wait, weight_many, weight_many_wait, weight_all, weight_all_wait);\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define SCFTORT_FLAG SCFTORT_STRING \": \""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "SCFTORT_FLAG\n\t\t \"--- %s:  verbose=%d holdoff=%d longwait=%d nthreads=%d onoff_holdoff=%d onoff_interval=%d shutdown_secs=%d stat_interval=%d stutter=%d use_cpus_read_lock=%d, weight_resched=%d, weight_single=%d, weight_single_rpc=%d, weight_single_wait=%d, weight_many=%d, weight_many_wait=%d, weight_all=%d, weight_all_wait=%d\\n\"",
            "tag",
            "verbose",
            "holdoff",
            "longwait",
            "nthreads",
            "onoff_holdoff",
            "onoff_interval",
            "shutdown",
            "stat_interval",
            "stutter",
            "use_cpus_read_lock",
            "weight_resched",
            "weight_single",
            "weight_single_rpc",
            "weight_single_wait",
            "weight_many",
            "weight_many_wait",
            "weight_all",
            "weight_all_wait"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCFTORT_FLAG SCFTORT_STRING \": \"\n\nstatic void\nscftorture_print_module_parms(const char *tag)\n{\n\tpr_alert(SCFTORT_FLAG\n\t\t \"--- %s:  verbose=%d holdoff=%d longwait=%d nthreads=%d onoff_holdoff=%d onoff_interval=%d shutdown_secs=%d stat_interval=%d stutter=%d use_cpus_read_lock=%d, weight_resched=%d, weight_single=%d, weight_single_rpc=%d, weight_single_wait=%d, weight_many=%d, weight_many_wait=%d, weight_all=%d, weight_all_wait=%d\\n\", tag,\n\t\t verbose, holdoff, longwait, nthreads, onoff_holdoff, onoff_interval, shutdown, stat_interval, stutter, use_cpus_read_lock, weight_resched, weight_single, weight_single_rpc, weight_single_wait, weight_many, weight_many_wait, weight_all, weight_all_wait);\n}"
  },
  {
    "function_name": "scftorture_invoker",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "439-491",
    "snippet": "static int scftorture_invoker(void *arg)\n{\n\tint cpu;\n\tint curcpu;\n\tDEFINE_TORTURE_RANDOM(rand);\n\tstruct scf_statistics *scfp = (struct scf_statistics *)arg;\n\tbool was_offline = false;\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d: task started\", scfp->cpu);\n\tcpu = scfp->cpu % nr_cpu_ids;\n\tWARN_ON_ONCE(set_cpus_allowed_ptr(current, cpumask_of(cpu)));\n\tset_user_nice(current, MAX_NICE);\n\tif (holdoff)\n\t\tschedule_timeout_interruptible(holdoff * HZ);\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d: Waiting for all SCF torturers from cpu %d\", scfp->cpu, raw_smp_processor_id());\n\n\t// Make sure that the CPU is affinitized appropriately during testing.\n\tcurcpu = raw_smp_processor_id();\n\tWARN_ONCE(curcpu != scfp->cpu % nr_cpu_ids,\n\t\t  \"%s: Wanted CPU %d, running on %d, nr_cpu_ids = %d\\n\",\n\t\t  __func__, scfp->cpu, curcpu, nr_cpu_ids);\n\n\tif (!atomic_dec_return(&n_started))\n\t\twhile (atomic_read_acquire(&n_started)) {\n\t\t\tif (torture_must_stop()) {\n\t\t\t\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d ended before starting\", scfp->cpu);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d started\", scfp->cpu);\n\n\tdo {\n\t\tscftorture_invoke_one(scfp, &rand);\n\t\twhile (cpu_is_offline(cpu) && !torture_must_stop()) {\n\t\t\tschedule_timeout_interruptible(HZ / 5);\n\t\t\twas_offline = true;\n\t\t}\n\t\tif (was_offline) {\n\t\t\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n\t\t\twas_offline = false;\n\t\t}\n\t\tcond_resched();\n\t\tstutter_wait(\"scftorture_invoker\");\n\t} while (!torture_must_stop());\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d ended\", scfp->cpu);\nend:\n\ttorture_kthread_stopping(\"scftorture_invoker\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t n_started;",
      "extern void resched_cpu(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"scftorture_invoker\""
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCFTORTOUT",
          "args": [
            "\"scftorture_invoker %d ended\"",
            "scfp->cpu"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stutter_wait",
          "args": [
            "\"scftorture_invoker\""
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "stutter_wait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "722-749",
          "snippet": "bool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stutter_pause_test;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int stutter_pause_test;\n\nbool stutter_wait(const char *title)\n{\n\tunsigned int i = 0;\n\tbool ret = false;\n\tint spt;\n\n\tcond_resched_tasks_rcu_qs();\n\tspt = READ_ONCE(stutter_pause_test);\n\tfor (; spt; spt = READ_ONCE(stutter_pause_test)) {\n\t\tif (!ret) {\n\t\t\tsched_set_normal(current, MAX_NICE);\n\t\t\tret = true;\n\t\t}\n\t\tif (spt == 1) {\n\t\t\tschedule_timeout_interruptible(1);\n\t\t} else if (spt == 2) {\n\t\t\twhile (READ_ONCE(stutter_pause_test)) {\n\t\t\t\tif (!(i++ & 0xffff))\n\t\t\t\t\ttorture_hrtimeout_us(10, 0, NULL);\n\t\t\t\tcond_resched();\n\t\t\t}\n\t\t} else {\n\t\t\tschedule_timeout_interruptible(round_jiffies_relative(HZ));\n\t\t}\n\t\ttorture_shutdown_absorb(title);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "__cond_resched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "8172-8193",
          "snippet": "int __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched __cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\t/*\n\t * In preemptible kernels, ->rcu_read_lock_nesting tells the tick\n\t * whether the current CPU is in an RCU read-side critical section,\n\t * so the tick can report quiescent states even for CPUs looping\n\t * in kernel context.  In contrast, in non-preemptible kernels,\n\t * RCU readers leave no in-memory hints, which means that CPU-bound\n\t * processes executing in kernel context might never report an\n\t * RCU quiescent state.  Therefore, the following code causes\n\t * cond_resched() to report a quiescent state, but only when RCU\n\t * is in urgent need of one.\n\t */\n#ifndef CONFIG_PREEMPT_RCU\n\trcu_all_qs();\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cpus_allowed_ptr",
          "args": [
            "current",
            "cpumask_of(cpu)"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_ptr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2888-2891",
          "snippet": "int set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint set_cpus_allowed_ptr(struct task_struct *p, const struct cpumask *new_mask)\n{\n\treturn __set_cpus_allowed_ptr(p, new_mask, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "HZ / 5"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "cpu"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scftorture_invoke_one",
          "args": [
            "scfp",
            "&rand"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "scftorture_invoke_one",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
          "lines": "312-435",
          "snippet": "static void scftorture_invoke_one(struct scf_statistics *scfp, struct torture_random_state *trsp)\n{\n\tuintptr_t cpu;\n\tint ret = 0;\n\tstruct scf_check *scfcp = NULL;\n\tstruct scf_selector *scfsp = scf_sel_rand(trsp);\n\n\tif (use_cpus_read_lock)\n\t\tcpus_read_lock();\n\telse\n\t\tpreempt_disable();\n\tif (scfsp->scfs_prim == SCF_PRIM_SINGLE || scfsp->scfs_wait) {\n\t\tscfcp = kmalloc(sizeof(*scfcp), GFP_ATOMIC);\n\t\tif (WARN_ON_ONCE(!scfcp)) {\n\t\t\tatomic_inc(&n_alloc_errs);\n\t\t} else {\n\t\t\tscfcp->scfc_cpu = -1;\n\t\t\tscfcp->scfc_wait = scfsp->scfs_wait;\n\t\t\tscfcp->scfc_out = false;\n\t\t\tscfcp->scfc_rpc = false;\n\t\t}\n\t}\n\tswitch (scfsp->scfs_prim) {\n\tcase SCF_PRIM_RESCHED:\n\t\tif (IS_BUILTIN(CONFIG_SCF_TORTURE_TEST)) {\n\t\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\t\tscfp->n_resched++;\n\t\t\tresched_cpu(cpu);\n\t\t\tthis_cpu_inc(scf_invoked_count);\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_SINGLE:\n\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_single_wait++;\n\t\telse\n\t\t\tscfp->n_single++;\n\t\tif (scfcp) {\n\t\t\tscfcp->scfc_cpu = cpu;\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tret = smp_call_function_single(cpu, scf_handler_1, (void *)scfcp, scfsp->scfs_wait);\n\t\tif (ret) {\n\t\t\tif (scfsp->scfs_wait)\n\t\t\t\tscfp->n_single_wait_ofl++;\n\t\t\telse\n\t\t\t\tscfp->n_single_ofl++;\n\t\t\tkfree(scfcp);\n\t\t\tscfcp = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_SINGLE_RPC:\n\t\tif (!scfcp)\n\t\t\tbreak;\n\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\tscfp->n_single_rpc++;\n\t\tscfcp->scfc_cpu = cpu;\n\t\tscfcp->scfc_wait = true;\n\t\tinit_completion(&scfcp->scfc_completion);\n\t\tscfcp->scfc_rpc = true;\n\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\tscfcp->scfc_in = true;\n\t\tret = smp_call_function_single(cpu, scf_handler_1, (void *)scfcp, 0);\n\t\tif (!ret) {\n\t\t\tif (use_cpus_read_lock)\n\t\t\t\tcpus_read_unlock();\n\t\t\telse\n\t\t\t\tpreempt_enable();\n\t\t\twait_for_completion(&scfcp->scfc_completion);\n\t\t\tif (use_cpus_read_lock)\n\t\t\t\tcpus_read_lock();\n\t\t\telse\n\t\t\t\tpreempt_disable();\n\t\t} else {\n\t\t\tscfp->n_single_rpc_ofl++;\n\t\t\tkfree(scfcp);\n\t\t\tscfcp = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_MANY:\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_many_wait++;\n\t\telse\n\t\t\tscfp->n_many++;\n\t\tif (scfcp) {\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tsmp_call_function_many(cpu_online_mask, scf_handler, scfcp, scfsp->scfs_wait);\n\t\tbreak;\n\tcase SCF_PRIM_ALL:\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_all_wait++;\n\t\telse\n\t\t\tscfp->n_all++;\n\t\tif (scfcp) {\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tsmp_call_function(scf_handler, scfcp, scfsp->scfs_wait);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tif (scfcp)\n\t\t\tscfcp->scfc_out = true;\n\t}\n\tif (scfcp && scfsp->scfs_wait) {\n\t\tif (WARN_ON_ONCE((num_online_cpus() > 1 || scfsp->scfs_prim == SCF_PRIM_SINGLE) &&\n\t\t\t\t !scfcp->scfc_out)) {\n\t\t\tpr_warn(\"%s: Memory-ordering failure, scfs_prim: %d.\\n\", __func__, scfsp->scfs_prim);\n\t\t\tatomic_inc(&n_mb_out_errs); // Leak rather than trash!\n\t\t} else {\n\t\t\tkfree(scfcp);\n\t\t}\n\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t}\n\tif (use_cpus_read_lock)\n\t\tcpus_read_unlock();\n\telse\n\t\tpreempt_enable();\n\tif (!(torture_random(trsp) & 0xfff))\n\t\tschedule_timeout_uninterruptible(1);\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define SCF_PRIM_ALL\t\t4",
            "#define SCF_PRIM_MANY\t\t3",
            "#define SCF_PRIM_SINGLE_RPC\t2",
            "#define SCF_PRIM_SINGLE\t\t1",
            "#define SCF_PRIM_RESCHED\t0"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(long long, scf_invoked_count);",
            "static atomic_t n_mb_out_errs;",
            "static atomic_t n_alloc_errs;",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCF_PRIM_ALL\t\t4\n#define SCF_PRIM_MANY\t\t3\n#define SCF_PRIM_SINGLE_RPC\t2\n#define SCF_PRIM_SINGLE\t\t1\n#define SCF_PRIM_RESCHED\t0\n\nstatic DEFINE_PER_CPU(long long, scf_invoked_count);\nstatic atomic_t n_mb_out_errs;\nstatic atomic_t n_alloc_errs;\nextern void resched_cpu(int cpu);\n\nstatic void scftorture_invoke_one(struct scf_statistics *scfp, struct torture_random_state *trsp)\n{\n\tuintptr_t cpu;\n\tint ret = 0;\n\tstruct scf_check *scfcp = NULL;\n\tstruct scf_selector *scfsp = scf_sel_rand(trsp);\n\n\tif (use_cpus_read_lock)\n\t\tcpus_read_lock();\n\telse\n\t\tpreempt_disable();\n\tif (scfsp->scfs_prim == SCF_PRIM_SINGLE || scfsp->scfs_wait) {\n\t\tscfcp = kmalloc(sizeof(*scfcp), GFP_ATOMIC);\n\t\tif (WARN_ON_ONCE(!scfcp)) {\n\t\t\tatomic_inc(&n_alloc_errs);\n\t\t} else {\n\t\t\tscfcp->scfc_cpu = -1;\n\t\t\tscfcp->scfc_wait = scfsp->scfs_wait;\n\t\t\tscfcp->scfc_out = false;\n\t\t\tscfcp->scfc_rpc = false;\n\t\t}\n\t}\n\tswitch (scfsp->scfs_prim) {\n\tcase SCF_PRIM_RESCHED:\n\t\tif (IS_BUILTIN(CONFIG_SCF_TORTURE_TEST)) {\n\t\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\t\tscfp->n_resched++;\n\t\t\tresched_cpu(cpu);\n\t\t\tthis_cpu_inc(scf_invoked_count);\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_SINGLE:\n\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_single_wait++;\n\t\telse\n\t\t\tscfp->n_single++;\n\t\tif (scfcp) {\n\t\t\tscfcp->scfc_cpu = cpu;\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tret = smp_call_function_single(cpu, scf_handler_1, (void *)scfcp, scfsp->scfs_wait);\n\t\tif (ret) {\n\t\t\tif (scfsp->scfs_wait)\n\t\t\t\tscfp->n_single_wait_ofl++;\n\t\t\telse\n\t\t\t\tscfp->n_single_ofl++;\n\t\t\tkfree(scfcp);\n\t\t\tscfcp = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_SINGLE_RPC:\n\t\tif (!scfcp)\n\t\t\tbreak;\n\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\tscfp->n_single_rpc++;\n\t\tscfcp->scfc_cpu = cpu;\n\t\tscfcp->scfc_wait = true;\n\t\tinit_completion(&scfcp->scfc_completion);\n\t\tscfcp->scfc_rpc = true;\n\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\tscfcp->scfc_in = true;\n\t\tret = smp_call_function_single(cpu, scf_handler_1, (void *)scfcp, 0);\n\t\tif (!ret) {\n\t\t\tif (use_cpus_read_lock)\n\t\t\t\tcpus_read_unlock();\n\t\t\telse\n\t\t\t\tpreempt_enable();\n\t\t\twait_for_completion(&scfcp->scfc_completion);\n\t\t\tif (use_cpus_read_lock)\n\t\t\t\tcpus_read_lock();\n\t\t\telse\n\t\t\t\tpreempt_disable();\n\t\t} else {\n\t\t\tscfp->n_single_rpc_ofl++;\n\t\t\tkfree(scfcp);\n\t\t\tscfcp = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_MANY:\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_many_wait++;\n\t\telse\n\t\t\tscfp->n_many++;\n\t\tif (scfcp) {\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tsmp_call_function_many(cpu_online_mask, scf_handler, scfcp, scfsp->scfs_wait);\n\t\tbreak;\n\tcase SCF_PRIM_ALL:\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_all_wait++;\n\t\telse\n\t\t\tscfp->n_all++;\n\t\tif (scfcp) {\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tsmp_call_function(scf_handler, scfcp, scfsp->scfs_wait);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tif (scfcp)\n\t\t\tscfcp->scfc_out = true;\n\t}\n\tif (scfcp && scfsp->scfs_wait) {\n\t\tif (WARN_ON_ONCE((num_online_cpus() > 1 || scfsp->scfs_prim == SCF_PRIM_SINGLE) &&\n\t\t\t\t !scfcp->scfc_out)) {\n\t\t\tpr_warn(\"%s: Memory-ordering failure, scfs_prim: %d.\\n\", __func__, scfsp->scfs_prim);\n\t\t\tatomic_inc(&n_mb_out_errs); // Leak rather than trash!\n\t\t} else {\n\t\t\tkfree(scfcp);\n\t\t}\n\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t}\n\tif (use_cpus_read_lock)\n\t\tcpus_read_unlock();\n\telse\n\t\tpreempt_enable();\n\tif (!(torture_random(trsp) & 0xfff))\n\t\tschedule_timeout_uninterruptible(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCFTORTOUT",
          "args": [
            "\"scftorture_invoker %d started\"",
            "scfp->cpu"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCFTORTOUT",
          "args": [
            "\"scftorture_invoker %d ended before starting\"",
            "scfp->cpu"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read_acquire",
          "args": [
            "&n_started"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&n_started"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "curcpu != scfp->cpu % nr_cpu_ids",
            "\"%s: Wanted CPU %d, running on %d, nr_cpu_ids = %d\\n\"",
            "__func__",
            "scfp->cpu",
            "curcpu",
            "nr_cpu_ids"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCFTORTOUT",
          "args": [
            "\"scftorture_invoker %d: Waiting for all SCF torturers from cpu %d\"",
            "scfp->cpu",
            "raw_smp_processor_id()"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_nice",
          "args": [
            "current",
            "MAX_NICE"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_nice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6891-6942",
          "snippet": "void set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_user_nice(struct task_struct *p, long nice)\n{\n\tbool queued, running;\n\tint old_prio;\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\tif (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)\n\t\treturn;\n\t/*\n\t * We have to be careful, if called from sys_setpriority(),\n\t * the task might be in the middle of scheduling on another CPU.\n\t */\n\trq = task_rq_lock(p, &rf);\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * The RT priorities are set via sched_setscheduler(), but we still\n\t * allow the 'normal' nice value to be set - but as expected\n\t * it won't have any effect on scheduling until the task is\n\t * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:\n\t */\n\tif (task_has_dl_policy(p) || task_has_rt_policy(p)) {\n\t\tp->static_prio = NICE_TO_PRIO(nice);\n\t\tgoto out_unlock;\n\t}\n\tqueued = task_on_rq_queued(p);\n\trunning = task_current(rq, p);\n\tif (queued)\n\t\tdequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);\n\tif (running)\n\t\tput_prev_task(rq, p);\n\n\tp->static_prio = NICE_TO_PRIO(nice);\n\tset_load_weight(p, true);\n\told_prio = p->prio;\n\tp->prio = effective_prio(p);\n\n\tif (queued)\n\t\tenqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);\n\tif (running)\n\t\tset_next_task(rq, p);\n\n\t/*\n\t * If the task increased its priority or is running and\n\t * lowered its priority, then reschedule its CPU:\n\t */\n\tp->sched_class->prio_changed(rq, p, old_prio);\n\nout_unlock:\n\ttask_rq_unlock(rq, p, &rf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "set_cpus_allowed_ptr(current, cpumask_of(cpu))"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VERBOSE_SCFTORTOUT",
          "args": [
            "\"scftorture_invoker %d: task started\"",
            "scfp->cpu"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_TORTURE_RANDOM",
          "args": [
            "rand"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic atomic_t n_started;\nextern void resched_cpu(int cpu);\n\nstatic int scftorture_invoker(void *arg)\n{\n\tint cpu;\n\tint curcpu;\n\tDEFINE_TORTURE_RANDOM(rand);\n\tstruct scf_statistics *scfp = (struct scf_statistics *)arg;\n\tbool was_offline = false;\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d: task started\", scfp->cpu);\n\tcpu = scfp->cpu % nr_cpu_ids;\n\tWARN_ON_ONCE(set_cpus_allowed_ptr(current, cpumask_of(cpu)));\n\tset_user_nice(current, MAX_NICE);\n\tif (holdoff)\n\t\tschedule_timeout_interruptible(holdoff * HZ);\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d: Waiting for all SCF torturers from cpu %d\", scfp->cpu, raw_smp_processor_id());\n\n\t// Make sure that the CPU is affinitized appropriately during testing.\n\tcurcpu = raw_smp_processor_id();\n\tWARN_ONCE(curcpu != scfp->cpu % nr_cpu_ids,\n\t\t  \"%s: Wanted CPU %d, running on %d, nr_cpu_ids = %d\\n\",\n\t\t  __func__, scfp->cpu, curcpu, nr_cpu_ids);\n\n\tif (!atomic_dec_return(&n_started))\n\t\twhile (atomic_read_acquire(&n_started)) {\n\t\t\tif (torture_must_stop()) {\n\t\t\t\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d ended before starting\", scfp->cpu);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tschedule_timeout_uninterruptible(1);\n\t\t}\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d started\", scfp->cpu);\n\n\tdo {\n\t\tscftorture_invoke_one(scfp, &rand);\n\t\twhile (cpu_is_offline(cpu) && !torture_must_stop()) {\n\t\t\tschedule_timeout_interruptible(HZ / 5);\n\t\t\twas_offline = true;\n\t\t}\n\t\tif (was_offline) {\n\t\t\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n\t\t\twas_offline = false;\n\t\t}\n\t\tcond_resched();\n\t\tstutter_wait(\"scftorture_invoker\");\n\t} while (!torture_must_stop());\n\n\tVERBOSE_SCFTORTOUT(\"scftorture_invoker %d ended\", scfp->cpu);\nend:\n\ttorture_kthread_stopping(\"scftorture_invoker\");\n\treturn 0;\n}"
  },
  {
    "function_name": "scftorture_invoke_one",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "312-435",
    "snippet": "static void scftorture_invoke_one(struct scf_statistics *scfp, struct torture_random_state *trsp)\n{\n\tuintptr_t cpu;\n\tint ret = 0;\n\tstruct scf_check *scfcp = NULL;\n\tstruct scf_selector *scfsp = scf_sel_rand(trsp);\n\n\tif (use_cpus_read_lock)\n\t\tcpus_read_lock();\n\telse\n\t\tpreempt_disable();\n\tif (scfsp->scfs_prim == SCF_PRIM_SINGLE || scfsp->scfs_wait) {\n\t\tscfcp = kmalloc(sizeof(*scfcp), GFP_ATOMIC);\n\t\tif (WARN_ON_ONCE(!scfcp)) {\n\t\t\tatomic_inc(&n_alloc_errs);\n\t\t} else {\n\t\t\tscfcp->scfc_cpu = -1;\n\t\t\tscfcp->scfc_wait = scfsp->scfs_wait;\n\t\t\tscfcp->scfc_out = false;\n\t\t\tscfcp->scfc_rpc = false;\n\t\t}\n\t}\n\tswitch (scfsp->scfs_prim) {\n\tcase SCF_PRIM_RESCHED:\n\t\tif (IS_BUILTIN(CONFIG_SCF_TORTURE_TEST)) {\n\t\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\t\tscfp->n_resched++;\n\t\t\tresched_cpu(cpu);\n\t\t\tthis_cpu_inc(scf_invoked_count);\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_SINGLE:\n\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_single_wait++;\n\t\telse\n\t\t\tscfp->n_single++;\n\t\tif (scfcp) {\n\t\t\tscfcp->scfc_cpu = cpu;\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tret = smp_call_function_single(cpu, scf_handler_1, (void *)scfcp, scfsp->scfs_wait);\n\t\tif (ret) {\n\t\t\tif (scfsp->scfs_wait)\n\t\t\t\tscfp->n_single_wait_ofl++;\n\t\t\telse\n\t\t\t\tscfp->n_single_ofl++;\n\t\t\tkfree(scfcp);\n\t\t\tscfcp = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_SINGLE_RPC:\n\t\tif (!scfcp)\n\t\t\tbreak;\n\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\tscfp->n_single_rpc++;\n\t\tscfcp->scfc_cpu = cpu;\n\t\tscfcp->scfc_wait = true;\n\t\tinit_completion(&scfcp->scfc_completion);\n\t\tscfcp->scfc_rpc = true;\n\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\tscfcp->scfc_in = true;\n\t\tret = smp_call_function_single(cpu, scf_handler_1, (void *)scfcp, 0);\n\t\tif (!ret) {\n\t\t\tif (use_cpus_read_lock)\n\t\t\t\tcpus_read_unlock();\n\t\t\telse\n\t\t\t\tpreempt_enable();\n\t\t\twait_for_completion(&scfcp->scfc_completion);\n\t\t\tif (use_cpus_read_lock)\n\t\t\t\tcpus_read_lock();\n\t\t\telse\n\t\t\t\tpreempt_disable();\n\t\t} else {\n\t\t\tscfp->n_single_rpc_ofl++;\n\t\t\tkfree(scfcp);\n\t\t\tscfcp = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_MANY:\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_many_wait++;\n\t\telse\n\t\t\tscfp->n_many++;\n\t\tif (scfcp) {\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tsmp_call_function_many(cpu_online_mask, scf_handler, scfcp, scfsp->scfs_wait);\n\t\tbreak;\n\tcase SCF_PRIM_ALL:\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_all_wait++;\n\t\telse\n\t\t\tscfp->n_all++;\n\t\tif (scfcp) {\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tsmp_call_function(scf_handler, scfcp, scfsp->scfs_wait);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tif (scfcp)\n\t\t\tscfcp->scfc_out = true;\n\t}\n\tif (scfcp && scfsp->scfs_wait) {\n\t\tif (WARN_ON_ONCE((num_online_cpus() > 1 || scfsp->scfs_prim == SCF_PRIM_SINGLE) &&\n\t\t\t\t !scfcp->scfc_out)) {\n\t\t\tpr_warn(\"%s: Memory-ordering failure, scfs_prim: %d.\\n\", __func__, scfsp->scfs_prim);\n\t\t\tatomic_inc(&n_mb_out_errs); // Leak rather than trash!\n\t\t} else {\n\t\t\tkfree(scfcp);\n\t\t}\n\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t}\n\tif (use_cpus_read_lock)\n\t\tcpus_read_unlock();\n\telse\n\t\tpreempt_enable();\n\tif (!(torture_random(trsp) & 0xfff))\n\t\tschedule_timeout_uninterruptible(1);\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define SCF_PRIM_ALL\t\t4",
      "#define SCF_PRIM_MANY\t\t3",
      "#define SCF_PRIM_SINGLE_RPC\t2",
      "#define SCF_PRIM_SINGLE\t\t1",
      "#define SCF_PRIM_RESCHED\t0"
    ],
    "globals_used": [
      "static DEFINE_PER_CPU(long long, scf_invoked_count);",
      "static atomic_t n_mb_out_errs;",
      "static atomic_t n_alloc_errs;",
      "extern void resched_cpu(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "1"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1912-1916",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scfcp"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_mb_out_errs"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Memory-ordering failure, scfs_prim: %d.\\n\"",
            "__func__",
            "scfsp->scfs_prim"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(num_online_cpus() > 1 || scfsp->scfs_prim == SCF_PRIM_SINGLE) &&\n\t\t\t\t !scfcp->scfc_out"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "torture_num_online_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "185-188",
          "snippet": "int torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint torture_num_online_cpus(void)\n{\n\treturn READ_ONCE(torture_online_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function",
          "args": [
            "scf_handler",
            "scfcp",
            "scfsp->scfs_wait"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "1012-1017",
          "snippet": "void smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\nvoid smp_call_function(smp_call_func_t func, void *info, int wait)\n{\n\tpreempt_disable();\n\tsmp_call_function_many(cpu_online_mask, func, info, wait);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_call_function_many",
          "args": [
            "cpu_online_mask",
            "scf_handler",
            "scfcp",
            "scfsp->scfs_wait"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_many",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/smp.c",
          "lines": "990-994",
          "snippet": "void smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tsmp_call_function_many_cond(mask, func, info, wait * SCF_WAIT, NULL);\n}",
          "includes": [
            "#include \"sched/smp.h\"",
            "#include \"smpboot.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/hypervisor.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched.h>",
            "#include <linux/cpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/gfp.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/rculist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/irq_work.h>"
          ],
          "macros_used": [
            "#define SCF_WAIT\t(1U << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched/smp.h\"\n#include \"smpboot.h\"\n#include <linux/jump_label.h>\n#include <linux/sched/debug.h>\n#include <linux/nmi.h>\n#include <linux/sched/clock.h>\n#include <linux/hypervisor.h>\n#include <linux/sched/idle.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/gfp.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/rculist.h>\n#include <linux/rcupdate.h>\n#include <linux/irq_work.h>\n\n#define SCF_WAIT\t(1U << 0)\n\nvoid smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tsmp_call_function_many_cond(mask, func, info, wait * SCF_WAIT, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&scfcp->scfc_completion"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "scf_handler_1",
            "(void *)scfcp",
            "0"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "smp_call_function_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/up.c",
          "lines": "12-25",
          "snippet": "int smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hypervisor.h>",
            "#include <linux/smp.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hypervisor.h>\n#include <linux/smp.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n\nint smp_call_function_single(int cpu, void (*func) (void *info), void *info,\n\t\t\t\tint wait)\n{\n\tunsigned long flags;\n\n\tif (cpu != 0)\n\t\treturn -ENXIO;\n\n\tlocal_irq_save(flags);\n\tfunc(info);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&scfcp->scfc_completion"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "scf_invoked_count"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resched_cpu",
          "args": [
            "cpu"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "resched_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "1000-1009",
          "snippet": "void resched_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_rq_lock_irqsave(rq, flags);\n\tif (cpu_online(cpu) || cpu == smp_processor_id())\n\t\tresched_curr(rq);\n\traw_spin_rq_unlock_irqrestore(rq, flags);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_cpu(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tunsigned long flags;\n\n\traw_spin_rq_lock_irqsave(rq, flags);\n\tif (cpu_online(cpu) || cpu == smp_processor_id())\n\t\tresched_curr(rq);\n\traw_spin_rq_unlock_irqrestore(rq, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_BUILTIN",
          "args": [
            "CONFIG_SCF_TORTURE_TEST"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_alloc_errs"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!scfcp"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*scfcp)",
            "GFP_ATOMIC"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scf_sel_rand",
          "args": [
            "trsp"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "scf_sel_rand",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
          "lines": "241-251",
          "snippet": "static struct scf_selector *scf_sel_rand(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long w = torture_random(trsp) % (scf_sel_totweight + 1);\n\n\tfor (i = 0; i < scf_sel_array_len; i++)\n\t\tif (scf_sel_array[i].scfs_weight >= w)\n\t\t\treturn &scf_sel_array[i];\n\tWARN_ON_ONCE(1);\n\treturn &scf_sel_array[0];\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct scf_selector scf_sel_array[SCF_NPRIMS];",
            "static int scf_sel_array_len;",
            "static unsigned long scf_sel_totweight;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct scf_selector scf_sel_array[SCF_NPRIMS];\nstatic int scf_sel_array_len;\nstatic unsigned long scf_sel_totweight;\n\nstatic struct scf_selector *scf_sel_rand(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long w = torture_random(trsp) % (scf_sel_totweight + 1);\n\n\tfor (i = 0; i < scf_sel_array_len; i++)\n\t\tif (scf_sel_array[i].scfs_weight >= w)\n\t\t\treturn &scf_sel_array[i];\n\tWARN_ON_ONCE(1);\n\treturn &scf_sel_array[0];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCF_PRIM_ALL\t\t4\n#define SCF_PRIM_MANY\t\t3\n#define SCF_PRIM_SINGLE_RPC\t2\n#define SCF_PRIM_SINGLE\t\t1\n#define SCF_PRIM_RESCHED\t0\n\nstatic DEFINE_PER_CPU(long long, scf_invoked_count);\nstatic atomic_t n_mb_out_errs;\nstatic atomic_t n_alloc_errs;\nextern void resched_cpu(int cpu);\n\nstatic void scftorture_invoke_one(struct scf_statistics *scfp, struct torture_random_state *trsp)\n{\n\tuintptr_t cpu;\n\tint ret = 0;\n\tstruct scf_check *scfcp = NULL;\n\tstruct scf_selector *scfsp = scf_sel_rand(trsp);\n\n\tif (use_cpus_read_lock)\n\t\tcpus_read_lock();\n\telse\n\t\tpreempt_disable();\n\tif (scfsp->scfs_prim == SCF_PRIM_SINGLE || scfsp->scfs_wait) {\n\t\tscfcp = kmalloc(sizeof(*scfcp), GFP_ATOMIC);\n\t\tif (WARN_ON_ONCE(!scfcp)) {\n\t\t\tatomic_inc(&n_alloc_errs);\n\t\t} else {\n\t\t\tscfcp->scfc_cpu = -1;\n\t\t\tscfcp->scfc_wait = scfsp->scfs_wait;\n\t\t\tscfcp->scfc_out = false;\n\t\t\tscfcp->scfc_rpc = false;\n\t\t}\n\t}\n\tswitch (scfsp->scfs_prim) {\n\tcase SCF_PRIM_RESCHED:\n\t\tif (IS_BUILTIN(CONFIG_SCF_TORTURE_TEST)) {\n\t\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\t\tscfp->n_resched++;\n\t\t\tresched_cpu(cpu);\n\t\t\tthis_cpu_inc(scf_invoked_count);\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_SINGLE:\n\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_single_wait++;\n\t\telse\n\t\t\tscfp->n_single++;\n\t\tif (scfcp) {\n\t\t\tscfcp->scfc_cpu = cpu;\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tret = smp_call_function_single(cpu, scf_handler_1, (void *)scfcp, scfsp->scfs_wait);\n\t\tif (ret) {\n\t\t\tif (scfsp->scfs_wait)\n\t\t\t\tscfp->n_single_wait_ofl++;\n\t\t\telse\n\t\t\t\tscfp->n_single_ofl++;\n\t\t\tkfree(scfcp);\n\t\t\tscfcp = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_SINGLE_RPC:\n\t\tif (!scfcp)\n\t\t\tbreak;\n\t\tcpu = torture_random(trsp) % nr_cpu_ids;\n\t\tscfp->n_single_rpc++;\n\t\tscfcp->scfc_cpu = cpu;\n\t\tscfcp->scfc_wait = true;\n\t\tinit_completion(&scfcp->scfc_completion);\n\t\tscfcp->scfc_rpc = true;\n\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\tscfcp->scfc_in = true;\n\t\tret = smp_call_function_single(cpu, scf_handler_1, (void *)scfcp, 0);\n\t\tif (!ret) {\n\t\t\tif (use_cpus_read_lock)\n\t\t\t\tcpus_read_unlock();\n\t\t\telse\n\t\t\t\tpreempt_enable();\n\t\t\twait_for_completion(&scfcp->scfc_completion);\n\t\t\tif (use_cpus_read_lock)\n\t\t\t\tcpus_read_lock();\n\t\t\telse\n\t\t\t\tpreempt_disable();\n\t\t} else {\n\t\t\tscfp->n_single_rpc_ofl++;\n\t\t\tkfree(scfcp);\n\t\t\tscfcp = NULL;\n\t\t}\n\t\tbreak;\n\tcase SCF_PRIM_MANY:\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_many_wait++;\n\t\telse\n\t\t\tscfp->n_many++;\n\t\tif (scfcp) {\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tsmp_call_function_many(cpu_online_mask, scf_handler, scfcp, scfsp->scfs_wait);\n\t\tbreak;\n\tcase SCF_PRIM_ALL:\n\t\tif (scfsp->scfs_wait)\n\t\t\tscfp->n_all_wait++;\n\t\telse\n\t\t\tscfp->n_all++;\n\t\tif (scfcp) {\n\t\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t\t\tscfcp->scfc_in = true;\n\t\t}\n\t\tsmp_call_function(scf_handler, scfcp, scfsp->scfs_wait);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tif (scfcp)\n\t\t\tscfcp->scfc_out = true;\n\t}\n\tif (scfcp && scfsp->scfs_wait) {\n\t\tif (WARN_ON_ONCE((num_online_cpus() > 1 || scfsp->scfs_prim == SCF_PRIM_SINGLE) &&\n\t\t\t\t !scfcp->scfc_out)) {\n\t\t\tpr_warn(\"%s: Memory-ordering failure, scfs_prim: %d.\\n\", __func__, scfsp->scfs_prim);\n\t\t\tatomic_inc(&n_mb_out_errs); // Leak rather than trash!\n\t\t} else {\n\t\t\tkfree(scfcp);\n\t\t}\n\t\tbarrier(); // Prevent race-reduction compiler optimizations.\n\t}\n\tif (use_cpus_read_lock)\n\t\tcpus_read_unlock();\n\telse\n\t\tpreempt_enable();\n\tif (!(torture_random(trsp) & 0xfff))\n\t\tschedule_timeout_uninterruptible(1);\n}"
  },
  {
    "function_name": "scf_handler_1",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "301-309",
    "snippet": "static void scf_handler_1(void *scfc_in)\n{\n\tstruct scf_check *scfcp = scfc_in;\n\n\tif (likely(scfcp) && WARN_ONCE(smp_processor_id() != scfcp->scfc_cpu, \"%s: Wanted CPU %d got CPU %d\\n\", __func__, scfcp->scfc_cpu, smp_processor_id())) {\n\t\tatomic_inc(&n_errs);\n\t}\n\tscf_handler(scfcp);\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t n_errs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scf_handler",
          "args": [
            "scfcp"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "scf_handler_1",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
          "lines": "301-309",
          "snippet": "static void scf_handler_1(void *scfc_in)\n{\n\tstruct scf_check *scfcp = scfc_in;\n\n\tif (likely(scfcp) && WARN_ONCE(smp_processor_id() != scfcp->scfc_cpu, \"%s: Wanted CPU %d got CPU %d\\n\", __func__, scfcp->scfc_cpu, smp_processor_id())) {\n\t\tatomic_inc(&n_errs);\n\t}\n\tscf_handler(scfcp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_errs"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "smp_processor_id() != scfcp->scfc_cpu",
            "\"%s: Wanted CPU %d got CPU %d\\n\"",
            "__func__",
            "scfcp->scfc_cpu",
            "smp_processor_id()"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "scfcp"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic atomic_t n_errs;\n\nstatic void scf_handler_1(void *scfc_in)\n{\n\tstruct scf_check *scfcp = scfc_in;\n\n\tif (likely(scfcp) && WARN_ONCE(smp_processor_id() != scfcp->scfc_cpu, \"%s: Wanted CPU %d got CPU %d\\n\", __func__, scfcp->scfc_cpu, smp_processor_id())) {\n\t\tatomic_inc(&n_errs);\n\t}\n\tscf_handler(scfcp);\n}"
  },
  {
    "function_name": "scf_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "256-298",
    "snippet": "static void scf_handler(void *scfc_in)\n{\n\tint i;\n\tint j;\n\tunsigned long r = torture_random(this_cpu_ptr(&scf_torture_rand));\n\tstruct scf_check *scfcp = scfc_in;\n\n\tif (likely(scfcp)) {\n\t\tWRITE_ONCE(scfcp->scfc_out, false); // For multiple receivers.\n\t\tif (WARN_ON_ONCE(unlikely(!READ_ONCE(scfcp->scfc_in))))\n\t\t\tatomic_inc(&n_mb_in_errs);\n\t}\n\tthis_cpu_inc(scf_invoked_count);\n\tif (longwait <= 0) {\n\t\tif (!(r & 0xffc0))\n\t\t\tudelay(r & 0x3f);\n\t\tgoto out;\n\t}\n\tif (r & 0xfff)\n\t\tgoto out;\n\tr = (r >> 12);\n\tif (longwait <= 0) {\n\t\tudelay((r & 0xff) + 1);\n\t\tgoto out;\n\t}\n\tr = r % longwait + 1;\n\tfor (i = 0; i < r; i++) {\n\t\tfor (j = 0; j < 1000; j++) {\n\t\t\tudelay(1000);\n\t\t\tcpu_relax();\n\t\t}\n\t}\nout:\n\tif (unlikely(!scfcp))\n\t\treturn;\n\tif (scfcp->scfc_wait) {\n\t\tWRITE_ONCE(scfcp->scfc_out, true);\n\t\tif (scfcp->scfc_rpc)\n\t\t\tcomplete(&scfcp->scfc_completion);\n\t} else {\n\t\tkfree(scfcp);\n\t}\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(long long, scf_invoked_count);",
      "static atomic_t n_mb_in_errs;",
      "static DEFINE_TORTURE_RANDOM_PERCPU(scf_torture_rand);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "scfcp"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&scfcp->scfc_completion"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1334-1345",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "scfcp->scfc_out",
            "true"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!scfcp"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1000"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "(r & 0xff) + 1"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "r & 0x3f"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "scf_invoked_count"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&n_mb_in_errs"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "unlikely(!READ_ONCE(scfcp->scfc_in))"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!READ_ONCE(scfcp->scfc_in)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "scfcp->scfc_in"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "scfcp->scfc_out",
            "false"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "scfcp"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "this_cpu_ptr(&scf_torture_rand)"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&scf_torture_rand"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_PER_CPU(long long, scf_invoked_count);\nstatic atomic_t n_mb_in_errs;\nstatic DEFINE_TORTURE_RANDOM_PERCPU(scf_torture_rand);\n\nstatic void scf_handler(void *scfc_in)\n{\n\tint i;\n\tint j;\n\tunsigned long r = torture_random(this_cpu_ptr(&scf_torture_rand));\n\tstruct scf_check *scfcp = scfc_in;\n\n\tif (likely(scfcp)) {\n\t\tWRITE_ONCE(scfcp->scfc_out, false); // For multiple receivers.\n\t\tif (WARN_ON_ONCE(unlikely(!READ_ONCE(scfcp->scfc_in))))\n\t\t\tatomic_inc(&n_mb_in_errs);\n\t}\n\tthis_cpu_inc(scf_invoked_count);\n\tif (longwait <= 0) {\n\t\tif (!(r & 0xffc0))\n\t\t\tudelay(r & 0x3f);\n\t\tgoto out;\n\t}\n\tif (r & 0xfff)\n\t\tgoto out;\n\tr = (r >> 12);\n\tif (longwait <= 0) {\n\t\tudelay((r & 0xff) + 1);\n\t\tgoto out;\n\t}\n\tr = r % longwait + 1;\n\tfor (i = 0; i < r; i++) {\n\t\tfor (j = 0; j < 1000; j++) {\n\t\t\tudelay(1000);\n\t\t\tcpu_relax();\n\t\t}\n\t}\nout:\n\tif (unlikely(!scfcp))\n\t\treturn;\n\tif (scfcp->scfc_wait) {\n\t\tWRITE_ONCE(scfcp->scfc_out, true);\n\t\tif (scfcp->scfc_rpc)\n\t\t\tcomplete(&scfcp->scfc_completion);\n\t} else {\n\t\tkfree(scfcp);\n\t}\n}"
  },
  {
    "function_name": "scf_sel_rand",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "241-251",
    "snippet": "static struct scf_selector *scf_sel_rand(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long w = torture_random(trsp) % (scf_sel_totweight + 1);\n\n\tfor (i = 0; i < scf_sel_array_len; i++)\n\t\tif (scf_sel_array[i].scfs_weight >= w)\n\t\t\treturn &scf_sel_array[i];\n\tWARN_ON_ONCE(1);\n\treturn &scf_sel_array[0];\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct scf_selector scf_sel_array[SCF_NPRIMS];",
      "static int scf_sel_array_len;",
      "static unsigned long scf_sel_totweight;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_random",
          "args": [
            "trsp"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "torture_random",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "449-459",
          "snippet": "unsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define TORTURE_RANDOM_REFRESH\t10000",
            "#define TORTURE_RANDOM_ADD\t479001701 /* prime */",
            "#define TORTURE_RANDOM_MULT\t39916801  /* prime */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define TORTURE_RANDOM_REFRESH\t10000\n#define TORTURE_RANDOM_ADD\t479001701 /* prime */\n#define TORTURE_RANDOM_MULT\t39916801  /* prime */\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->trs_count < 0) {\n\t\ttrsp->trs_state += (unsigned long)local_clock();\n\t\ttrsp->trs_count = TORTURE_RANDOM_REFRESH;\n\t}\n\ttrsp->trs_state = trsp->trs_state * TORTURE_RANDOM_MULT +\n\t\tTORTURE_RANDOM_ADD;\n\treturn swahw32(trsp->trs_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic struct scf_selector scf_sel_array[SCF_NPRIMS];\nstatic int scf_sel_array_len;\nstatic unsigned long scf_sel_totweight;\n\nstatic struct scf_selector *scf_sel_rand(struct torture_random_state *trsp)\n{\n\tint i;\n\tunsigned long w = torture_random(trsp) % (scf_sel_totweight + 1);\n\n\tfor (i = 0; i < scf_sel_array_len; i++)\n\t\tif (scf_sel_array[i].scfs_weight >= w)\n\t\t\treturn &scf_sel_array[i];\n\tWARN_ON_ONCE(1);\n\treturn &scf_sel_array[0];\n}"
  },
  {
    "function_name": "scf_sel_dump",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "223-238",
    "snippet": "static void scf_sel_dump(void)\n{\n\tint i;\n\tunsigned long oldw = 0;\n\tstruct scf_selector *scfsp;\n\tunsigned long w;\n\n\tfor (i = 0; i < scf_sel_array_len; i++) {\n\t\tscfsp = &scf_sel_array[i];\n\t\tw = (scfsp->scfs_weight - oldw) * 100000 / scf_sel_totweight;\n\t\tpr_info(\"%s: %3lu.%03lu %s(%s)\\n\", __func__, w / 1000, w % 1000,\n\t\t\tscf_prim_name[scfsp->scfs_prim],\n\t\t\tscfsp->scfs_wait ? \"wait\" : \"nowait\");\n\t\toldw = scfsp->scfs_weight;\n\t}\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *scf_prim_name[] = {\n\t\"resched_cpu\",\n\t\"smp_call_function_single\",\n\t\"smp_call_function_single_rpc\",\n\t\"smp_call_function_many\",\n\t\"smp_call_function\",\n};",
      "static struct scf_selector scf_sel_array[SCF_NPRIMS];",
      "static int scf_sel_array_len;",
      "static unsigned long scf_sel_totweight;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: %3lu.%03lu %s(%s)\\n\"",
            "__func__",
            "w / 1000",
            "w % 1000",
            "scf_prim_name[scfsp->scfs_prim]",
            "scfsp->scfs_wait ? \"wait\" : \"nowait\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic char *scf_prim_name[] = {\n\t\"resched_cpu\",\n\t\"smp_call_function_single\",\n\t\"smp_call_function_single_rpc\",\n\t\"smp_call_function_many\",\n\t\"smp_call_function\",\n};\nstatic struct scf_selector scf_sel_array[SCF_NPRIMS];\nstatic int scf_sel_array_len;\nstatic unsigned long scf_sel_totweight;\n\nstatic void scf_sel_dump(void)\n{\n\tint i;\n\tunsigned long oldw = 0;\n\tstruct scf_selector *scfsp;\n\tunsigned long w;\n\n\tfor (i = 0; i < scf_sel_array_len; i++) {\n\t\tscfsp = &scf_sel_array[i];\n\t\tw = (scfsp->scfs_weight - oldw) * 100000 / scf_sel_totweight;\n\t\tpr_info(\"%s: %3lu.%03lu %s(%s)\\n\", __func__, w / 1000, w % 1000,\n\t\t\tscf_prim_name[scfsp->scfs_prim],\n\t\t\tscfsp->scfs_wait ? \"wait\" : \"nowait\");\n\t\toldw = scfsp->scfs_weight;\n\t}\n}"
  },
  {
    "function_name": "scf_sel_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "203-220",
    "snippet": "static void scf_sel_add(unsigned long weight, int prim, bool wait)\n{\n\tstruct scf_selector *scfsp = &scf_sel_array[scf_sel_array_len];\n\n\t// If no weight, if array would overflow, if computing three-place\n\t// percentages would overflow, or if the scf_prim_name[] array would\n\t// overflow, don't bother.  In the last three two cases, complain.\n\tif (!weight ||\n\t    WARN_ON_ONCE(scf_sel_array_len >= ARRAY_SIZE(scf_sel_array)) ||\n\t    WARN_ON_ONCE(0 - 100000 * weight <= 100000 * scf_sel_totweight) ||\n\t    WARN_ON_ONCE(prim >= ARRAY_SIZE(scf_prim_name)))\n\t\treturn;\n\tscf_sel_totweight += weight;\n\tscfsp->scfs_weight = scf_sel_totweight;\n\tscfsp->scfs_prim = prim;\n\tscfsp->scfs_wait = wait;\n\tscf_sel_array_len++;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *scf_prim_name[] = {\n\t\"resched_cpu\",\n\t\"smp_call_function_single\",\n\t\"smp_call_function_single_rpc\",\n\t\"smp_call_function_many\",\n\t\"smp_call_function\",\n};",
      "static struct scf_selector scf_sel_array[SCF_NPRIMS];",
      "static int scf_sel_array_len;",
      "static unsigned long scf_sel_totweight;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "prim >= ARRAY_SIZE(scf_prim_name)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "scf_prim_name"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "0 - 100000 * weight <= 100000 * scf_sel_totweight"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "scf_sel_array_len >= ARRAY_SIZE(scf_sel_array)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "scf_sel_array"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic char *scf_prim_name[] = {\n\t\"resched_cpu\",\n\t\"smp_call_function_single\",\n\t\"smp_call_function_single_rpc\",\n\t\"smp_call_function_many\",\n\t\"smp_call_function\",\n};\nstatic struct scf_selector scf_sel_array[SCF_NPRIMS];\nstatic int scf_sel_array_len;\nstatic unsigned long scf_sel_totweight;\n\nstatic void scf_sel_add(unsigned long weight, int prim, bool wait)\n{\n\tstruct scf_selector *scfsp = &scf_sel_array[scf_sel_array_len];\n\n\t// If no weight, if array would overflow, if computing three-place\n\t// percentages would overflow, or if the scf_prim_name[] array would\n\t// overflow, don't bother.  In the last three two cases, complain.\n\tif (!weight ||\n\t    WARN_ON_ONCE(scf_sel_array_len >= ARRAY_SIZE(scf_sel_array)) ||\n\t    WARN_ON_ONCE(0 - 100000 * weight <= 100000 * scf_sel_totweight) ||\n\t    WARN_ON_ONCE(prim >= ARRAY_SIZE(scf_prim_name)))\n\t\treturn;\n\tscf_sel_totweight += weight;\n\tscfsp->scfs_weight = scf_sel_totweight;\n\tscfsp->scfs_prim = prim;\n\tscfsp->scfs_wait = wait;\n\tscf_sel_array_len++;\n}"
  },
  {
    "function_name": "scf_torture_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "189-200",
    "snippet": "static int\nscf_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"scf_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\tscf_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"scf_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"scf_torture_stats\");\n\treturn 0;\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "torture_kthread_stopping",
          "args": [
            "\"scf_torture_stats\""
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "torture_kthread_stopping",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "910-920",
          "snippet": "void torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_kthread_stopping(char *title)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"Stopping %s\", title);\n\tVERBOSE_TOROUT_STRING(buf);\n\twhile (!kthread_should_stop()) {\n\t\ttorture_shutdown_absorb(title);\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_must_stop",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "torture_must_stop_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "897-900",
          "snippet": "bool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_DONTSTOP 0\t/* Normal operation. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nbool torture_must_stop_irq(void)\n{\n\treturn READ_ONCE(fullstop) != FULLSTOP_DONTSTOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "torture_shutdown_absorb",
          "args": [
            "\"scf_torture_stats\""
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "scf_torture_stats_print",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "scf_torture_stats_print",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
          "lines": "151-185",
          "snippet": "static void scf_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong long invoked_count = 0;\n\tbool isdone = READ_ONCE(scfdone);\n\tstruct scf_statistics scfs = {};\n\n\tfor_each_possible_cpu(cpu)\n\t\tinvoked_count += data_race(per_cpu(scf_invoked_count, cpu));\n\tfor (i = 0; i < nthreads; i++) {\n\t\tscfs.n_resched += scf_stats_p[i].n_resched;\n\t\tscfs.n_single += scf_stats_p[i].n_single;\n\t\tscfs.n_single_ofl += scf_stats_p[i].n_single_ofl;\n\t\tscfs.n_single_rpc += scf_stats_p[i].n_single_rpc;\n\t\tscfs.n_single_wait += scf_stats_p[i].n_single_wait;\n\t\tscfs.n_single_wait_ofl += scf_stats_p[i].n_single_wait_ofl;\n\t\tscfs.n_many += scf_stats_p[i].n_many;\n\t\tscfs.n_many_wait += scf_stats_p[i].n_many_wait;\n\t\tscfs.n_all += scf_stats_p[i].n_all;\n\t\tscfs.n_all_wait += scf_stats_p[i].n_all_wait;\n\t}\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) ||\n\t    atomic_read(&n_mb_out_errs) || atomic_read(&n_alloc_errs))\n\t\tbangstr = \"!!! \";\n\tpr_alert(\"%s %sscf_invoked_count %s: %lld resched: %lld single: %lld/%lld single_ofl: %lld/%lld single_rpc: %lld single_rpc_ofl: %lld many: %lld/%lld all: %lld/%lld \",\n\t\t SCFTORT_FLAG, bangstr, isdone ? \"VER\" : \"ver\", invoked_count, scfs.n_resched,\n\t\t scfs.n_single, scfs.n_single_wait, scfs.n_single_ofl, scfs.n_single_wait_ofl,\n\t\t scfs.n_single_rpc, scfs.n_single_rpc_ofl,\n\t\t scfs.n_many, scfs.n_many_wait, scfs.n_all, scfs.n_all_wait);\n\ttorture_onoff_stats();\n\tpr_cont(\"ste: %d stnmie: %d stnmoe: %d staf: %d\\n\", atomic_read(&n_errs),\n\t\tatomic_read(&n_mb_in_errs), atomic_read(&n_mb_out_errs),\n\t\tatomic_read(&n_alloc_errs));\n}",
          "includes": [
            "#include <linux/types.h>",
            "#include <linux/torture.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/init.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [
            "#define SCFTORT_FLAG SCFTORT_STRING \": \""
          ],
          "globals_used": [
            "static struct scf_statistics *scf_stats_p;",
            "static DEFINE_PER_CPU(long long, scf_invoked_count);",
            "static atomic_t n_errs;",
            "static atomic_t n_mb_in_errs;",
            "static atomic_t n_mb_out_errs;",
            "static atomic_t n_alloc_errs;",
            "static bool scfdone;",
            "static char *bangstr = \"\";",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCFTORT_FLAG SCFTORT_STRING \": \"\n\nstatic struct scf_statistics *scf_stats_p;\nstatic DEFINE_PER_CPU(long long, scf_invoked_count);\nstatic atomic_t n_errs;\nstatic atomic_t n_mb_in_errs;\nstatic atomic_t n_mb_out_errs;\nstatic atomic_t n_alloc_errs;\nstatic bool scfdone;\nstatic char *bangstr = \"\";\nextern void resched_cpu(int cpu);\n\nstatic void scf_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong long invoked_count = 0;\n\tbool isdone = READ_ONCE(scfdone);\n\tstruct scf_statistics scfs = {};\n\n\tfor_each_possible_cpu(cpu)\n\t\tinvoked_count += data_race(per_cpu(scf_invoked_count, cpu));\n\tfor (i = 0; i < nthreads; i++) {\n\t\tscfs.n_resched += scf_stats_p[i].n_resched;\n\t\tscfs.n_single += scf_stats_p[i].n_single;\n\t\tscfs.n_single_ofl += scf_stats_p[i].n_single_ofl;\n\t\tscfs.n_single_rpc += scf_stats_p[i].n_single_rpc;\n\t\tscfs.n_single_wait += scf_stats_p[i].n_single_wait;\n\t\tscfs.n_single_wait_ofl += scf_stats_p[i].n_single_wait_ofl;\n\t\tscfs.n_many += scf_stats_p[i].n_many;\n\t\tscfs.n_many_wait += scf_stats_p[i].n_many_wait;\n\t\tscfs.n_all += scf_stats_p[i].n_all;\n\t\tscfs.n_all_wait += scf_stats_p[i].n_all_wait;\n\t}\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) ||\n\t    atomic_read(&n_mb_out_errs) || atomic_read(&n_alloc_errs))\n\t\tbangstr = \"!!! \";\n\tpr_alert(\"%s %sscf_invoked_count %s: %lld resched: %lld single: %lld/%lld single_ofl: %lld/%lld single_rpc: %lld single_rpc_ofl: %lld many: %lld/%lld all: %lld/%lld \",\n\t\t SCFTORT_FLAG, bangstr, isdone ? \"VER\" : \"ver\", invoked_count, scfs.n_resched,\n\t\t scfs.n_single, scfs.n_single_wait, scfs.n_single_ofl, scfs.n_single_wait_ofl,\n\t\t scfs.n_single_rpc, scfs.n_single_rpc_ofl,\n\t\t scfs.n_many, scfs.n_many_wait, scfs.n_all, scfs.n_all_wait);\n\ttorture_onoff_stats();\n\tpr_cont(\"ste: %d stnmie: %d stnmoe: %d staf: %d\\n\", atomic_read(&n_errs),\n\t\tatomic_read(&n_mb_in_errs), atomic_read(&n_mb_out_errs),\n\t\tatomic_read(&n_alloc_errs));\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "stat_interval * HZ"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1898-1902",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VERBOSE_TOROUT_STRING",
          "args": [
            "\"scf_torture_stats task started\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic int\nscf_torture_stats(void *arg)\n{\n\tVERBOSE_TOROUT_STRING(\"scf_torture_stats task started\");\n\tdo {\n\t\tschedule_timeout_interruptible(stat_interval * HZ);\n\t\tscf_torture_stats_print();\n\t\ttorture_shutdown_absorb(\"scf_torture_stats\");\n\t} while (!torture_must_stop());\n\ttorture_kthread_stopping(\"scf_torture_stats\");\n\treturn 0;\n}"
  },
  {
    "function_name": "scf_torture_stats_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/scftorture.c",
    "lines": "151-185",
    "snippet": "static void scf_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong long invoked_count = 0;\n\tbool isdone = READ_ONCE(scfdone);\n\tstruct scf_statistics scfs = {};\n\n\tfor_each_possible_cpu(cpu)\n\t\tinvoked_count += data_race(per_cpu(scf_invoked_count, cpu));\n\tfor (i = 0; i < nthreads; i++) {\n\t\tscfs.n_resched += scf_stats_p[i].n_resched;\n\t\tscfs.n_single += scf_stats_p[i].n_single;\n\t\tscfs.n_single_ofl += scf_stats_p[i].n_single_ofl;\n\t\tscfs.n_single_rpc += scf_stats_p[i].n_single_rpc;\n\t\tscfs.n_single_wait += scf_stats_p[i].n_single_wait;\n\t\tscfs.n_single_wait_ofl += scf_stats_p[i].n_single_wait_ofl;\n\t\tscfs.n_many += scf_stats_p[i].n_many;\n\t\tscfs.n_many_wait += scf_stats_p[i].n_many_wait;\n\t\tscfs.n_all += scf_stats_p[i].n_all;\n\t\tscfs.n_all_wait += scf_stats_p[i].n_all_wait;\n\t}\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) ||\n\t    atomic_read(&n_mb_out_errs) || atomic_read(&n_alloc_errs))\n\t\tbangstr = \"!!! \";\n\tpr_alert(\"%s %sscf_invoked_count %s: %lld resched: %lld single: %lld/%lld single_ofl: %lld/%lld single_rpc: %lld single_rpc_ofl: %lld many: %lld/%lld all: %lld/%lld \",\n\t\t SCFTORT_FLAG, bangstr, isdone ? \"VER\" : \"ver\", invoked_count, scfs.n_resched,\n\t\t scfs.n_single, scfs.n_single_wait, scfs.n_single_ofl, scfs.n_single_wait_ofl,\n\t\t scfs.n_single_rpc, scfs.n_single_rpc_ofl,\n\t\t scfs.n_many, scfs.n_many_wait, scfs.n_all, scfs.n_all_wait);\n\ttorture_onoff_stats();\n\tpr_cont(\"ste: %d stnmie: %d stnmoe: %d staf: %d\\n\", atomic_read(&n_errs),\n\t\tatomic_read(&n_mb_in_errs), atomic_read(&n_mb_out_errs),\n\t\tatomic_read(&n_alloc_errs));\n}",
    "includes": [
      "#include <linux/types.h>",
      "#include <linux/torture.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/stat.h>",
      "#include <linux/smp.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/rcupdate_trace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/percpu.h>",
      "#include <linux/notifier.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kthread.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/init.h>",
      "#include <linux/err.h>",
      "#include <linux/delay.h>",
      "#include <linux/cpu.h>",
      "#include <linux/completion.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define SCFTORT_FLAG SCFTORT_STRING \": \""
    ],
    "globals_used": [
      "static struct scf_statistics *scf_stats_p;",
      "static DEFINE_PER_CPU(long long, scf_invoked_count);",
      "static atomic_t n_errs;",
      "static atomic_t n_mb_in_errs;",
      "static atomic_t n_mb_out_errs;",
      "static atomic_t n_alloc_errs;",
      "static bool scfdone;",
      "static char *bangstr = \"\";",
      "extern void resched_cpu(int cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"ste: %d stnmie: %d stnmoe: %d staf: %d\\n\"",
            "atomic_read(&n_errs)",
            "atomic_read(&n_mb_in_errs)",
            "atomic_read(&n_mb_out_errs)",
            "atomic_read(&n_alloc_errs)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_alloc_errs"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_mb_out_errs"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_mb_in_errs"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_errs"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "torture_onoff_stats",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "torture_onoff_stats",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "414-424",
          "snippet": "void torture_onoff_stats(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tpr_cont(\"onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (HZ=%d) \",\n\t\tn_online_successes, n_online_attempts,\n\t\tn_offline_successes, n_offline_attempts,\n\t\tmin_online, max_online,\n\t\tmin_offline, max_offline,\n\t\tsum_online, sum_offline, HZ);\n#endif /* #ifdef CONFIG_HOTPLUG_CPU */\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid torture_onoff_stats(void)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tpr_cont(\"onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (HZ=%d) \",\n\t\tn_online_successes, n_online_attempts,\n\t\tn_offline_successes, n_offline_attempts,\n\t\tmin_online, max_online,\n\t\tmin_offline, max_offline,\n\t\tsum_online, sum_offline, HZ);\n#endif /* #ifdef CONFIG_HOTPLUG_CPU */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s %sscf_invoked_count %s: %lld resched: %lld single: %lld/%lld single_ofl: %lld/%lld single_rpc: %lld single_rpc_ofl: %lld many: %lld/%lld all: %lld/%lld \"",
            "SCFTORT_FLAG",
            "bangstr",
            "isdone ? \"VER\" : \"ver\"",
            "invoked_count",
            "scfs.n_resched",
            "scfs.n_single",
            "scfs.n_single_wait",
            "scfs.n_single_ofl",
            "scfs.n_single_wait_ofl",
            "scfs.n_single_rpc",
            "scfs.n_single_rpc_ofl",
            "scfs.n_many",
            "scfs.n_many_wait",
            "scfs.n_all",
            "scfs.n_all_wait"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_alloc_errs"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_mb_out_errs"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_mb_in_errs"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&n_errs"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "scfdone"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/types.h>\n#include <linux/torture.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define SCFTORT_FLAG SCFTORT_STRING \": \"\n\nstatic struct scf_statistics *scf_stats_p;\nstatic DEFINE_PER_CPU(long long, scf_invoked_count);\nstatic atomic_t n_errs;\nstatic atomic_t n_mb_in_errs;\nstatic atomic_t n_mb_out_errs;\nstatic atomic_t n_alloc_errs;\nstatic bool scfdone;\nstatic char *bangstr = \"\";\nextern void resched_cpu(int cpu);\n\nstatic void scf_torture_stats_print(void)\n{\n\tint cpu;\n\tint i;\n\tlong long invoked_count = 0;\n\tbool isdone = READ_ONCE(scfdone);\n\tstruct scf_statistics scfs = {};\n\n\tfor_each_possible_cpu(cpu)\n\t\tinvoked_count += data_race(per_cpu(scf_invoked_count, cpu));\n\tfor (i = 0; i < nthreads; i++) {\n\t\tscfs.n_resched += scf_stats_p[i].n_resched;\n\t\tscfs.n_single += scf_stats_p[i].n_single;\n\t\tscfs.n_single_ofl += scf_stats_p[i].n_single_ofl;\n\t\tscfs.n_single_rpc += scf_stats_p[i].n_single_rpc;\n\t\tscfs.n_single_wait += scf_stats_p[i].n_single_wait;\n\t\tscfs.n_single_wait_ofl += scf_stats_p[i].n_single_wait_ofl;\n\t\tscfs.n_many += scf_stats_p[i].n_many;\n\t\tscfs.n_many_wait += scf_stats_p[i].n_many_wait;\n\t\tscfs.n_all += scf_stats_p[i].n_all;\n\t\tscfs.n_all_wait += scf_stats_p[i].n_all_wait;\n\t}\n\tif (atomic_read(&n_errs) || atomic_read(&n_mb_in_errs) ||\n\t    atomic_read(&n_mb_out_errs) || atomic_read(&n_alloc_errs))\n\t\tbangstr = \"!!! \";\n\tpr_alert(\"%s %sscf_invoked_count %s: %lld resched: %lld single: %lld/%lld single_ofl: %lld/%lld single_rpc: %lld single_rpc_ofl: %lld many: %lld/%lld all: %lld/%lld \",\n\t\t SCFTORT_FLAG, bangstr, isdone ? \"VER\" : \"ver\", invoked_count, scfs.n_resched,\n\t\t scfs.n_single, scfs.n_single_wait, scfs.n_single_ofl, scfs.n_single_wait_ofl,\n\t\t scfs.n_single_rpc, scfs.n_single_rpc_ofl,\n\t\t scfs.n_many, scfs.n_many_wait, scfs.n_all, scfs.n_all_wait);\n\ttorture_onoff_stats();\n\tpr_cont(\"ste: %d stnmie: %d stnmoe: %d staf: %d\\n\", atomic_read(&n_errs),\n\t\tatomic_read(&n_mb_in_errs), atomic_read(&n_mb_out_errs),\n\t\tatomic_read(&n_alloc_errs));\n}"
  }
]