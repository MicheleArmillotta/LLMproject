[
  {
    "function_name": "queue_stack_map_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "244-248",
    "snippet": "static int queue_stack_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t\tvoid *next_key)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_stack_map_get_next_key(struct bpf_map *map, void *key,\n\t\t\t\t\tvoid *next_key)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "queue_stack_map_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "238-241",
    "snippet": "static int queue_stack_map_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_stack_map_delete_elem(struct bpf_map *map, void *key)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "queue_stack_map_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "231-235",
    "snippet": "static int queue_stack_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 flags)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_stack_map_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 flags)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "queue_stack_map_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "225-228",
    "snippet": "static void *queue_stack_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic void *queue_stack_map_lookup_elem(struct bpf_map *map, void *key)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "queue_stack_map_push_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "184-222",
    "snippet": "static int queue_stack_map_push_elem(struct bpf_map *map, void *value,\n\t\t\t\t     u64 flags)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long irq_flags;\n\tint err = 0;\n\tvoid *dst;\n\n\t/* BPF_EXIST is used to force making room for a new element in case the\n\t * map is full\n\t */\n\tbool replace = (flags & BPF_EXIST);\n\n\t/* Check supported flags for queue and stack maps */\n\tif (flags & BPF_NOEXIST || flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&qs->lock, irq_flags);\n\n\tif (queue_stack_map_is_full(qs)) {\n\t\tif (!replace) {\n\t\t\terr = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t\t/* advance tail pointer to overwrite oldest element */\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\n\tdst = &qs->elements[qs->head * qs->map.value_size];\n\tmemcpy(dst, value, qs->map.value_size);\n\n\tif (unlikely(++qs->head >= qs->size))\n\t\tqs->head = 0;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, irq_flags);\n\treturn err;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&qs->lock",
            "irq_flags"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "++qs->head >= qs->size"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "value",
            "qs->map.value_size"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "++qs->tail >= qs->size"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_stack_map_is_full",
          "args": [
            "qs"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "queue_stack_map_is_full",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "35-43",
          "snippet": "static bool queue_stack_map_is_full(struct bpf_queue_stack *qs)\n{\n\tu32 head = qs->head + 1;\n\n\tif (unlikely(head >= qs->size))\n\t\thead = 0;\n\n\treturn head == qs->tail;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic bool queue_stack_map_is_full(struct bpf_queue_stack *qs)\n{\n\tu32 head = qs->head + 1;\n\n\tif (unlikely(head >= qs->size))\n\t\thead = 0;\n\n\treturn head == qs->tail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&qs->lock",
            "irq_flags"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_queue_stack",
          "args": [
            "map"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_queue_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "25-28",
          "snippet": "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_stack_map_push_elem(struct bpf_map *map, void *value,\n\t\t\t\t     u64 flags)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long irq_flags;\n\tint err = 0;\n\tvoid *dst;\n\n\t/* BPF_EXIST is used to force making room for a new element in case the\n\t * map is full\n\t */\n\tbool replace = (flags & BPF_EXIST);\n\n\t/* Check supported flags for queue and stack maps */\n\tif (flags & BPF_NOEXIST || flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\traw_spin_lock_irqsave(&qs->lock, irq_flags);\n\n\tif (queue_stack_map_is_full(qs)) {\n\t\tif (!replace) {\n\t\t\terr = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t\t/* advance tail pointer to overwrite oldest element */\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\n\tdst = &qs->elements[qs->head * qs->map.value_size];\n\tmemcpy(dst, value, qs->map.value_size);\n\n\tif (unlikely(++qs->head >= qs->size))\n\t\tqs->head = 0;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, irq_flags);\n\treturn err;\n}"
  },
  {
    "function_name": "stack_map_pop_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "178-181",
    "snippet": "static int stack_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn __stack_map_get(map, value, true);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__stack_map_get",
          "args": [
            "map",
            "value",
            "true"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__stack_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "128-157",
          "snippet": "static int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn __stack_map_get(map, value, true);\n}"
  },
  {
    "function_name": "queue_map_pop_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "172-175",
    "snippet": "static int queue_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn __queue_map_get(map, value, true);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__queue_map_get",
          "args": [
            "map",
            "value",
            "true"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "99-125",
          "snippet": "static int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_map_pop_elem(struct bpf_map *map, void *value)\n{\n\treturn __queue_map_get(map, value, true);\n}"
  },
  {
    "function_name": "stack_map_peek_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "166-169",
    "snippet": "static int stack_map_peek_elem(struct bpf_map *map, void *value)\n{\n\treturn __stack_map_get(map, value, false);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__stack_map_get",
          "args": [
            "map",
            "value",
            "false"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__stack_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "128-157",
          "snippet": "static int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int stack_map_peek_elem(struct bpf_map *map, void *value)\n{\n\treturn __stack_map_get(map, value, false);\n}"
  },
  {
    "function_name": "queue_map_peek_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "160-163",
    "snippet": "static int queue_map_peek_elem(struct bpf_map *map, void *value)\n{\n\treturn __queue_map_get(map, value, false);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__queue_map_get",
          "args": [
            "map",
            "value",
            "false"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "__queue_map_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "99-125",
          "snippet": "static int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int queue_map_peek_elem(struct bpf_map *map, void *value)\n{\n\treturn __queue_map_get(map, value, false);\n}"
  },
  {
    "function_name": "__stack_map_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "128-157",
    "snippet": "static int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&qs->lock",
            "flags"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "ptr",
            "qs->map.value_size"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index >= qs->size"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value",
            "0",
            "qs->map.value_size"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_stack_map_is_empty",
          "args": [
            "qs"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "queue_stack_map_is_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "30-33",
          "snippet": "static bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&qs->lock",
            "flags"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_queue_stack",
          "args": [
            "map"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_queue_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "25-28",
          "snippet": "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __stack_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\tu32 index;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tindex = qs->head - 1;\n\tif (unlikely(index >= qs->size))\n\t\tindex = qs->size - 1;\n\n\tptr = &qs->elements[index * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete)\n\t\tqs->head = index;\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
  },
  {
    "function_name": "__queue_map_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "99-125",
    "snippet": "static int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&qs->lock",
            "flags"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "++qs->tail >= qs->size"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "ptr",
            "qs->map.value_size"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value",
            "0",
            "qs->map.value_size"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue_stack_map_is_empty",
          "args": [
            "qs"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "queue_stack_map_is_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "30-33",
          "snippet": "static bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&qs->lock",
            "flags"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_queue_stack",
          "args": [
            "map"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_queue_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "25-28",
          "snippet": "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic int __queue_map_get(struct bpf_map *map, void *value, bool delete)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\tunsigned long flags;\n\tint err = 0;\n\tvoid *ptr;\n\n\traw_spin_lock_irqsave(&qs->lock, flags);\n\n\tif (queue_stack_map_is_empty(qs)) {\n\t\tmemset(value, 0, qs->map.value_size);\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tptr = &qs->elements[qs->tail * qs->map.value_size];\n\tmemcpy(value, ptr, qs->map.value_size);\n\n\tif (delete) {\n\t\tif (unlikely(++qs->tail >= qs->size))\n\t\t\tqs->tail = 0;\n\t}\n\nout:\n\traw_spin_unlock_irqrestore(&qs->lock, flags);\n\treturn err;\n}"
  },
  {
    "function_name": "queue_stack_map_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "92-97",
    "snippet": "static void queue_stack_map_free(struct bpf_map *map)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\n\tbpf_map_area_free(qs);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_area_free",
          "args": [
            "qs"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "344-347",
          "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_queue_stack",
          "args": [
            "map"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_queue_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
          "lines": "25-28",
          "snippet": "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}",
          "includes": [
            "#include \"percpu_freelist.h\"",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic void queue_stack_map_free(struct bpf_map *map)\n{\n\tstruct bpf_queue_stack *qs = bpf_queue_stack(map);\n\n\tbpf_map_area_free(qs);\n}"
  },
  {
    "function_name": "queue_stack_map_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "67-89",
    "snippet": "static struct bpf_map *queue_stack_map_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_queue_stack *qs;\n\tu64 size, queue_size;\n\n\tsize = (u64) attr->max_entries + 1;\n\tqueue_size = sizeof(*qs) + size * attr->value_size;\n\n\tqs = bpf_map_area_alloc(queue_size, numa_node);\n\tif (!qs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset(qs, 0, sizeof(*qs));\n\n\tbpf_map_init_from_attr(&qs->map, attr);\n\n\tqs->size = size;\n\n\traw_spin_lock_init(&qs->lock);\n\n\treturn &qs->map;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&qs->lock"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&qs->map",
            "attr"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "361-370",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "qs",
            "0",
            "sizeof(*qs)"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_area_alloc",
          "args": [
            "queue_size",
            "numa_node"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_area_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "334-337",
          "snippet": "void *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(u64 size, int numa_node)\n{\n\treturn __bpf_map_area_alloc(size, numa_node, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_map *queue_stack_map_alloc(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_queue_stack *qs;\n\tu64 size, queue_size;\n\n\tsize = (u64) attr->max_entries + 1;\n\tqueue_size = sizeof(*qs) + size * attr->value_size;\n\n\tqs = bpf_map_area_alloc(queue_size, numa_node);\n\tif (!qs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset(qs, 0, sizeof(*qs));\n\n\tbpf_map_init_from_attr(&qs->map, attr);\n\n\tqs->size = size;\n\n\traw_spin_lock_init(&qs->lock);\n\n\treturn &qs->map;\n}"
  },
  {
    "function_name": "queue_stack_map_alloc_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "46-65",
    "snippet": "static int queue_stack_map_alloc_check(union bpf_attr *attr)\n{\n\tif (!bpf_capable())\n\t\treturn -EPERM;\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size != 0 ||\n\t    attr->value_size == 0 ||\n\t    attr->map_flags & ~QUEUE_STACK_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags))\n\t\treturn -EINVAL;\n\n\tif (attr->value_size > KMALLOC_MAX_SIZE)\n\t\t/* if value_size is bigger, the user space won't be able to\n\t\t * access the elements.\n\t\t */\n\t\treturn -E2BIG;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define QUEUE_STACK_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_ACCESS_MASK)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_flags_access_ok",
          "args": [
            "attr->map_flags"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\n#define QUEUE_STACK_CREATE_FLAG_MASK \\\n\t(BPF_F_NUMA_NODE | BPF_F_ACCESS_MASK)\n\nstatic int queue_stack_map_alloc_check(union bpf_attr *attr)\n{\n\tif (!bpf_capable())\n\t\treturn -EPERM;\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 || attr->key_size != 0 ||\n\t    attr->value_size == 0 ||\n\t    attr->map_flags & ~QUEUE_STACK_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags))\n\t\treturn -EINVAL;\n\n\tif (attr->value_size > KMALLOC_MAX_SIZE)\n\t\t/* if value_size is bigger, the user space won't be able to\n\t\t * access the elements.\n\t\t */\n\t\treturn -E2BIG;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "queue_stack_map_is_full",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "35-43",
    "snippet": "static bool queue_stack_map_is_full(struct bpf_queue_stack *qs)\n{\n\tu32 head = qs->head + 1;\n\n\tif (unlikely(head >= qs->size))\n\t\thead = 0;\n\n\treturn head == qs->tail;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "head >= qs->size"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic bool queue_stack_map_is_full(struct bpf_queue_stack *qs)\n{\n\tu32 head = qs->head + 1;\n\n\tif (unlikely(head >= qs->size))\n\t\thead = 0;\n\n\treturn head == qs->tail;\n}"
  },
  {
    "function_name": "queue_stack_map_is_empty",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "30-33",
    "snippet": "static bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic bool queue_stack_map_is_empty(struct bpf_queue_stack *qs)\n{\n\treturn qs->head == qs->tail;\n}"
  },
  {
    "function_name": "bpf_queue_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/queue_stack_maps.c",
    "lines": "25-28",
    "snippet": "static struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}",
    "includes": [
      "#include \"percpu_freelist.h\"",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_queue_stack",
            "map"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"percpu_freelist.h\"\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_queue_stack *bpf_queue_stack(struct bpf_map *map)\n{\n\treturn container_of(map, struct bpf_queue_stack, map);\n}"
  }
]