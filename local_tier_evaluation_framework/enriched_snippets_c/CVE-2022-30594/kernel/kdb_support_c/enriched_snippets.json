[
  {
    "function_name": "kdb_restore_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "553-557",
    "snippet": "void kdb_restore_flags(void)\n{\n\tBUG_ON(kdb_flags_index <= 0);\n\tkdb_flags = kdb_flags_stack[--kdb_flags_index];\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_flags_stack[4], kdb_flags_index;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "kdb_flags_index <= 0"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic int kdb_flags_stack[4], kdb_flags_index;\n\nvoid kdb_restore_flags(void)\n{\n\tBUG_ON(kdb_flags_index <= 0);\n\tkdb_flags = kdb_flags_stack[--kdb_flags_index];\n}"
  },
  {
    "function_name": "kdb_save_flags",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "547-551",
    "snippet": "void kdb_save_flags(void)\n{\n\tBUG_ON(kdb_flags_index >= ARRAY_SIZE(kdb_flags_stack));\n\tkdb_flags_stack[kdb_flags_index++] = kdb_flags;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_flags_stack[4], kdb_flags_index;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "kdb_flags_index >= ARRAY_SIZE(kdb_flags_stack)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "kdb_flags_stack"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic int kdb_flags_stack[4], kdb_flags_index;\n\nvoid kdb_save_flags(void)\n{\n\tBUG_ON(kdb_flags_index >= ARRAY_SIZE(kdb_flags_stack));\n\tkdb_flags_stack[kdb_flags_index++] = kdb_flags;\n}"
  },
  {
    "function_name": "kdb_task_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "523-539",
    "snippet": "bool kdb_task_state(const struct task_struct *p, const char *mask)\n{\n\tchar state = kdb_task_state_char(p);\n\n\t/* If there is no mask, then we will filter code that runs when the\n\t * scheduler is idling and any system daemons that are currently\n\t * sleeping.\n\t */\n\tif (!mask || mask[0] == '\\0')\n\t\treturn !strchr(\"-ims\", state);\n\n\t/* A is a special case that matches all states */\n\tif (strchr(mask, 'A'))\n\t\treturn true;\n\n\treturn strchr(mask, state);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "mask",
            "state"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "mask",
            "'A'"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"-ims\"",
            "state"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_state_char",
          "args": [
            "p"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state_char",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "486-510",
          "snippet": "char kdb_task_state_char (const struct task_struct *p)\n{\n\tunsigned long tmp;\n\tchar state;\n\tint cpu;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tstate = task_state_to_char((struct task_struct *) p);\n\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tcpu = kdb_process_cpu(p);\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && strchr(\"IMS\", state)) {\n\t\tstate = tolower(state);\t\t/* sleeping system daemon */\n\t}\n\treturn state;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tunsigned long tmp;\n\tchar state;\n\tint cpu;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tstate = task_state_to_char((struct task_struct *) p);\n\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tcpu = kdb_process_cpu(p);\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && strchr(\"IMS\", state)) {\n\t\tstate = tolower(state);\t\t/* sleeping system daemon */\n\t}\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nbool kdb_task_state(const struct task_struct *p, const char *mask)\n{\n\tchar state = kdb_task_state_char(p);\n\n\t/* If there is no mask, then we will filter code that runs when the\n\t * scheduler is idling and any system daemons that are currently\n\t * sleeping.\n\t */\n\tif (!mask || mask[0] == '\\0')\n\t\treturn !strchr(\"-ims\", state);\n\n\t/* A is a special case that matches all states */\n\tif (strchr(mask, 'A'))\n\t\treturn true;\n\n\treturn strchr(mask, state);\n}"
  },
  {
    "function_name": "kdb_task_state_char",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "486-510",
    "snippet": "char kdb_task_state_char (const struct task_struct *p)\n{\n\tunsigned long tmp;\n\tchar state;\n\tint cpu;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tstate = task_state_to_char((struct task_struct *) p);\n\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tcpu = kdb_process_cpu(p);\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && strchr(\"IMS\", state)) {\n\t\tstate = tolower(state);\t\t/* sleeping system daemon */\n\t}\n\treturn state;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tolower",
          "args": [
            "state"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"IMS\"",
            "state"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_has_cpu",
          "args": [
            "p"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_process_cpu",
          "args": [
            "p"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_idle_task",
          "args": [
            "p"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_state_to_char",
          "args": [
            "(struct task_struct *) p"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "&tmp",
            "(char *)p",
            "sizeof(unsigned long)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tunsigned long tmp;\n\tchar state;\n\tint cpu;\n\n\tif (!p ||\n\t    copy_from_kernel_nofault(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tstate = task_state_to_char((struct task_struct *) p);\n\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tcpu = kdb_process_cpu(p);\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = '-';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && strchr(\"IMS\", state)) {\n\t\tstate = tolower(state);\t\t/* sleeping system daemon */\n\t}\n\treturn state;\n}"
  },
  {
    "function_name": "kdb_putword",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "443-475",
    "snippet": "int kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_func_printf",
          "args": [
            "\"bad width %zu\\n\"",
            "size"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_putarea",
          "args": [
            "addr",
            "w8"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_putarea",
          "args": [
            "addr",
            "w4"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_putarea",
          "args": [
            "addr",
            "w2"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_putarea",
          "args": [
            "addr",
            "w1"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}"
  },
  {
    "function_name": "kdb_getword",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "394-431",
    "snippet": "int kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_func_printf",
          "args": [
            "\"bad width %zu\\n\"",
            "size"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "w8",
            "addr"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "w4",
            "addr"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "w2",
            "addr"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "w1",
            "addr"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}"
  },
  {
    "function_name": "kdb_getphysword",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "344-382",
    "snippet": "int kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_func_printf",
          "args": [
            "\"bad width %zu\\n\"",
            "size"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getphys",
          "args": [
            "&w8",
            "addr",
            "sizeof(w8)"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getphysword",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "344-382",
          "snippet": "int kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_func_printf(\"bad width %zu\\n\", size);\n\t}\n\treturn diag;\n}"
  },
  {
    "function_name": "kdb_getphys",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "318-333",
    "snippet": "static int kdb_getphys(void *res, unsigned long addr, size_t size)\n{\n\tunsigned long pfn;\n\tvoid *vaddr;\n\tstruct page *page;\n\n\tpfn = (addr >> PAGE_SHIFT);\n\tif (!pfn_valid(pfn))\n\t\treturn 1;\n\tpage = pfn_to_page(pfn);\n\tvaddr = kmap_atomic(page);\n\tmemcpy(res, vaddr + (addr & (PAGE_SIZE - 1)), size);\n\tkunmap_atomic(vaddr);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "vaddr"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res",
            "vaddr + (addr & (PAGE_SIZE - 1))",
            "size"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic int kdb_getphys(void *res, unsigned long addr, size_t size)\n{\n\tunsigned long pfn;\n\tvoid *vaddr;\n\tstruct page *page;\n\n\tpfn = (addr >> PAGE_SHIFT);\n\tif (!pfn_valid(pfn))\n\t\treturn 1;\n\tpage = pfn_to_page(pfn);\n\tvaddr = kmap_atomic(page);\n\tmemcpy(res, vaddr + (addr & (PAGE_SIZE - 1)), size);\n\tkunmap_atomic(vaddr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_putarea_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "292-305",
    "snippet": "int kdb_putarea_size(unsigned long addr, void *res, size_t size)\n{\n\tint ret = copy_from_kernel_nofault((char *)addr, (char *)res, size);\n\tif (ret) {\n\t\tif (!KDB_STATE(SUPPRESS)) {\n\t\t\tkdb_func_printf(\"Bad address 0x%lx\\n\", addr);\n\t\t\tKDB_STATE_SET(SUPPRESS);\n\t\t}\n\t\tret = KDB_BADADDR;\n\t} else {\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SUPPRESS"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "SUPPRESS"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_func_printf",
          "args": [
            "\"Bad address 0x%lx\\n\"",
            "addr"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "SUPPRESS"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "(char *)addr",
            "(char *)res",
            "size"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_putarea_size(unsigned long addr, void *res, size_t size)\n{\n\tint ret = copy_from_kernel_nofault((char *)addr, (char *)res, size);\n\tif (ret) {\n\t\tif (!KDB_STATE(SUPPRESS)) {\n\t\t\tkdb_func_printf(\"Bad address 0x%lx\\n\", addr);\n\t\t\tKDB_STATE_SET(SUPPRESS);\n\t\t}\n\t\tret = KDB_BADADDR;\n\t} else {\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "kdb_getarea_size",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "267-280",
    "snippet": "int kdb_getarea_size(void *res, unsigned long addr, size_t size)\n{\n\tint ret = copy_from_kernel_nofault((char *)res, (char *)addr, size);\n\tif (ret) {\n\t\tif (!KDB_STATE(SUPPRESS)) {\n\t\t\tkdb_func_printf(\"Bad address 0x%lx\\n\", addr);\n\t\t\tKDB_STATE_SET(SUPPRESS);\n\t\t}\n\t\tret = KDB_BADADDR;\n\t} else {\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SUPPRESS"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "SUPPRESS"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_func_printf",
          "args": [
            "\"Bad address 0x%lx\\n\"",
            "addr"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "SUPPRESS"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_kernel_nofault",
          "args": [
            "(char *)res",
            "(char *)addr",
            "size"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdb_getarea_size(void *res, unsigned long addr, size_t size)\n{\n\tint ret = copy_from_kernel_nofault((char *)res, (char *)addr, size);\n\tif (ret) {\n\t\tif (!KDB_STATE(SUPPRESS)) {\n\t\t\tkdb_func_printf(\"Bad address 0x%lx\\n\", addr);\n\t\t\tKDB_STATE_SET(SUPPRESS);\n\t\t}\n\t\tret = KDB_BADADDR;\n\t} else {\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "kdb_strdup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "248-255",
    "snippet": "char *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "s",
            "str"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "n",
            "type"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nchar *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}"
  },
  {
    "function_name": "kdb_symbol_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "199-235",
    "snippet": "void kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "symtab_p2->mod_name",
            "\"kernel\""
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbnearsym",
          "args": [
            "addr",
            "symtab_p2"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "kdbnearsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "82-111",
          "snippet": "int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n\tstatic char namebuf[KSYM_NAME_LEN];\n\n\tkdb_dbg_printf(AR, \"addr=0x%lx, symtab=%px\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), namebuf);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tkdb_dbg_printf(AR, \"returns %d symtab->sym_start=0x%lx, symtab->mod_name=%px, symtab->sym_name=%px (%s)\\n\",\n\t\t       ret, symtab->sym_start, symtab->mod_name, symtab->sym_name, symtab->sym_name);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n\tstatic char namebuf[KSYM_NAME_LEN];\n\n\tkdb_dbg_printf(AR, \"addr=0x%lx, symtab=%px\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), namebuf);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tkdb_dbg_printf(AR, \"returns %d symtab->sym_start=0x%lx, symtab->mod_name=%px, symtab->sym_name=%px (%s)\\n\",\n\t\t       ret, symtab->sym_start, symtab->mod_name, symtab->sym_name, symtab->sym_name);\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nvoid kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}"
  },
  {
    "function_name": "kallsyms_symbol_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "171-185",
    "snippet": "int kallsyms_symbol_next(char *prefix_name, int flag, int buf_size)\n{\n\tint prefix_len = strlen(prefix_name);\n\tstatic loff_t pos;\n\tconst char *name;\n\n\tif (!flag)\n\t\tpos = 0;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (!strncmp(name, prefix_name, prefix_len))\n\t\t\treturn strscpy(prefix_name, name, buf_size);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "prefix_name",
            "name",
            "buf_size"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "prefix_name",
            "prefix_len"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_walk_kallsyms",
          "args": [
            "&pos"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_walk_kallsyms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "856-872",
          "snippet": "const char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix_name"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kallsyms_symbol_next(char *prefix_name, int flag, int buf_size)\n{\n\tint prefix_len = strlen(prefix_name);\n\tstatic loff_t pos;\n\tconst char *name;\n\n\tif (!flag)\n\t\tpos = 0;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (!strncmp(name, prefix_name, prefix_len))\n\t\t\treturn strscpy(prefix_name, name, buf_size);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kallsyms_symbol_complete",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "127-157",
    "snippet": "int kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrscpy(ks_namebuf, name, sizeof(ks_namebuf));\n\t\t\t/* Work out the longest name that matches the prefix */\n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len > prefix_len)\n\t\tmemcpy(prefix_name, ks_namebuf_prev, prev_len+1);\n\treturn number;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char ks_namebuf[KSYM_NAME_LEN+1], ks_namebuf_prev[KSYM_NAME_LEN+1];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "prefix_name",
            "ks_namebuf_prev",
            "prev_len+1"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "max_len-1",
            "strlen(ks_namebuf)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ks_namebuf"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "ks_namebuf",
            "name",
            "sizeof(ks_namebuf)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "prefix_name",
            "prefix_len"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_walk_kallsyms",
          "args": [
            "&pos"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_walk_kallsyms",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "856-872",
          "snippet": "const char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kdb_walk_kallsyms(loff_t *pos)\n{\n\tstatic struct kallsym_iter kdb_walk_kallsyms_iter;\n\tif (*pos == 0) {\n\t\tmemset(&kdb_walk_kallsyms_iter, 0,\n\t\t       sizeof(kdb_walk_kallsyms_iter));\n\t\treset_iter(&kdb_walk_kallsyms_iter, 0);\n\t}\n\twhile (1) {\n\t\tif (!update_iter(&kdb_walk_kallsyms_iter, *pos))\n\t\t\treturn NULL;\n\t\t++*pos;\n\t\t/* Some debugging symbols have no name.  Ignore them. */\n\t\tif (kdb_walk_kallsyms_iter.name[0])\n\t\t\treturn kdb_walk_kallsyms_iter.name;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nstatic char ks_namebuf[KSYM_NAME_LEN+1], ks_namebuf_prev[KSYM_NAME_LEN+1];\n\nint kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrscpy(ks_namebuf, name, sizeof(ks_namebuf));\n\t\t\t/* Work out the longest name that matches the prefix */\n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len > prefix_len)\n\t\tmemcpy(prefix_name, ks_namebuf_prev, prev_len+1);\n\treturn number;\n}"
  },
  {
    "function_name": "kdbnearsym",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "82-111",
    "snippet": "int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n\tstatic char namebuf[KSYM_NAME_LEN];\n\n\tkdb_dbg_printf(AR, \"addr=0x%lx, symtab=%px\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), namebuf);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tkdb_dbg_printf(AR, \"returns %d symtab->sym_start=0x%lx, symtab->mod_name=%px, symtab->sym_name=%px (%s)\\n\",\n\t\t       ret, symtab->sym_start, symtab->mod_name, symtab->sym_name, symtab->sym_name);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_dbg_printf",
          "args": [
            "AR",
            "\"returns %d symtab->sym_start=0x%lx, symtab->mod_name=%px, symtab->sym_name=%px (%s)\\n\"",
            "ret",
            "symtab->sym_start",
            "symtab->mod_name",
            "symtab->sym_name",
            "symtab->sym_name"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "addr",
            "&symbolsize",
            "&offset",
            "(char **)(&symtab->mod_name)",
            "namebuf"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "377-384",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "symtab",
            "0",
            "sizeof(*symtab)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_dbg_printf",
          "args": [
            "AR",
            "\"addr=0x%lx, symtab=%px\\n\"",
            "addr",
            "symtab"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n\tstatic char namebuf[KSYM_NAME_LEN];\n\n\tkdb_dbg_printf(AR, \"addr=0x%lx, symtab=%px\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), namebuf);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tkdb_dbg_printf(AR, \"returns %d symtab->sym_start=0x%lx, symtab->mod_name=%px, symtab->sym_name=%px (%s)\\n\",\n\t\t       ret, symtab->sym_start, symtab->mod_name, symtab->sym_name, symtab->sym_name);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "kdbgetsymval",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_support.c",
    "lines": "40-52",
    "snippet": "int kdbgetsymval(const char *symname, kdb_symtab_t *symtab)\n{\n\tkdb_dbg_printf(AR, \"symname=%s, symtab=%px\\n\", symname, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\tsymtab->sym_start = kallsyms_lookup_name(symname);\n\tif (symtab->sym_start) {\n\t\tkdb_dbg_printf(AR, \"returns 1, symtab->sym_start=0x%lx\\n\",\n\t\t\t       symtab->sym_start);\n\t\treturn 1;\n\t}\n\tkdb_dbg_printf(AR, \"returns 0\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/ctype.h>",
      "#include <linux/slab.h>",
      "#include <linux/kdb.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/delay.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/highmem.h>",
      "#include <linux/module.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/stddef.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_dbg_printf",
          "args": [
            "AR",
            "\"returns 0\\n\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_dbg_printf",
          "args": [
            "AR",
            "\"returns 1, symtab->sym_start=0x%lx\\n\"",
            "symtab->sym_start"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_name",
          "args": [
            "symname"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "module_kallsyms_lookup_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4466-4487",
          "snippet": "unsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(modules);",
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(modules);\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nunsigned long module_kallsyms_lookup_name(const char *name)\n{\n\tstruct module *mod;\n\tchar *colon;\n\tunsigned long ret = 0;\n\n\t/* Don't lock: we're in enough trouble already. */\n\tpreempt_disable();\n\tif ((colon = strnchr(name, MODULE_NAME_LEN, ':')) != NULL) {\n\t\tif ((mod = find_module_all(name, colon - name, false)) != NULL)\n\t\t\tret = find_kallsyms_symbol_value(mod, colon+1);\n\t} else {\n\t\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\t\tcontinue;\n\t\t\tif ((ret = find_kallsyms_symbol_value(mod, name)) != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tpreempt_enable();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "symtab",
            "0",
            "sizeof(*symtab)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_dbg_printf",
          "args": [
            "AR",
            "\"symname=%s, symtab=%px\\n\"",
            "symname",
            "symtab"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n\nint kdbgetsymval(const char *symname, kdb_symtab_t *symtab)\n{\n\tkdb_dbg_printf(AR, \"symname=%s, symtab=%px\\n\", symname, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\tsymtab->sym_start = kallsyms_lookup_name(symname);\n\tif (symtab->sym_start) {\n\t\tkdb_dbg_printf(AR, \"returns 1, symtab->sym_start=0x%lx\\n\",\n\t\t\t       symtab->sym_start);\n\t\treturn 1;\n\t}\n\tkdb_dbg_printf(AR, \"returns 0\\n\");\n\treturn 0;\n}"
  }
]