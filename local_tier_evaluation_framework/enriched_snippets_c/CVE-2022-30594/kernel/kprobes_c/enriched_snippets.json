[
  {
    "function_name": "debugfs_kprobe_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2888-2902",
    "snippet": "static int __init debugfs_kprobe_init(void)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(\"kprobes\", NULL);\n\n\tdebugfs_create_file(\"list\", 0400, dir, NULL, &kprobes_fops);\n\n\tdebugfs_create_file(\"enabled\", 0600, dir, NULL, &fops_kp);\n\n\tdebugfs_create_file(\"blacklist\", 0400, dir, NULL,\n\t\t\t    &kprobe_blacklist_fops);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"blacklist\"",
            "0400",
            "dir",
            "NULL",
            "&kprobe_blacklist_fops"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"enabled\"",
            "0600",
            "dir",
            "NULL",
            "&fops_kp"
          ],
          "line": 2896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"list\"",
            "0400",
            "dir",
            "NULL",
            "&kprobes_fops"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"kprobes\"",
            "NULL"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __init;\n\nstatic int __init debugfs_kprobe_init(void)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(\"kprobes\", NULL);\n\n\tdebugfs_create_file(\"list\", 0400, dir, NULL, &kprobes_fops);\n\n\tdebugfs_create_file(\"enabled\", 0600, dir, NULL, &fops_kp);\n\n\tdebugfs_create_file(\"blacklist\", 0400, dir, NULL,\n\t\t\t    &kprobe_blacklist_fops);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "write_enabled_file_bool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2865-2880",
    "snippet": "static ssize_t write_enabled_file_bool(struct file *file,\n\t       const char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tbool enable;\n\tint ret;\n\n\tret = kstrtobool_from_user(user_buf, count, &enable);\n\tif (ret)\n\t\treturn ret;\n\n\tret = enable ? arm_all_kprobes() : disarm_all_kprobes();\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "disarm_all_kprobes",
          "args": [],
          "line": 2875
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_all_kprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2800-2844",
          "snippet": "static int disarm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are already disarmed, just return */\n\tif (kprobes_all_disarmed) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn 0;\n\t}\n\n\tkprobes_all_disarmed = true;\n\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Disarm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!arch_trampoline_kprobe(p) && !kprobe_disabled(p)) {\n\t\t\t\terr = disarm_kprobe(p, false);\n\t\t\t\tif (err) {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally disabled, but failed to disable %d out of %d probes. Please check which kprobes are kept enabled via debugfs.\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally disabled\\n\");\n\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for disarming all kprobes by optimizer */\n\twait_for_kprobe_optimizer();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
            "static bool kprobes_all_disarmed;",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int disarm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are already disarmed, just return */\n\tif (kprobes_all_disarmed) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn 0;\n\t}\n\n\tkprobes_all_disarmed = true;\n\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Disarm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!arch_trampoline_kprobe(p) && !kprobe_disabled(p)) {\n\t\t\t\terr = disarm_kprobe(p, false);\n\t\t\t\tif (err) {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally disabled, but failed to disable %d out of %d probes. Please check which kprobes are kept enabled via debugfs.\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally disabled\\n\");\n\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for disarming all kprobes by optimizer */\n\twait_for_kprobe_optimizer();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtobool_from_user",
          "args": [
            "user_buf",
            "count",
            "&enable"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic ssize_t write_enabled_file_bool(struct file *file,\n\t       const char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tbool enable;\n\tint ret;\n\n\tret = kstrtobool_from_user(user_buf, count, &enable);\n\tif (ret)\n\t\treturn ret;\n\n\tret = enable ? arm_all_kprobes() : disarm_all_kprobes();\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}"
  },
  {
    "function_name": "read_enabled_file_bool",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2851-2863",
    "snippet": "static ssize_t read_enabled_file_bool(struct file *file,\n\t       char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[3];\n\n\tif (!kprobes_all_disarmed)\n\t\tbuf[0] = '1';\n\telse\n\t\tbuf[0] = '0';\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "user_buf",
            "count",
            "ppos",
            "buf",
            "2"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic ssize_t read_enabled_file_bool(struct file *file,\n\t       char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[3];\n\n\tif (!kprobes_all_disarmed)\n\t\tbuf[0] = '1';\n\telse\n\t\tbuf[0] = '0';\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}"
  },
  {
    "function_name": "disarm_all_kprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2800-2844",
    "snippet": "static int disarm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are already disarmed, just return */\n\tif (kprobes_all_disarmed) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn 0;\n\t}\n\n\tkprobes_all_disarmed = true;\n\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Disarm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!arch_trampoline_kprobe(p) && !kprobe_disabled(p)) {\n\t\t\t\terr = disarm_kprobe(p, false);\n\t\t\t\tif (err) {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally disabled, but failed to disable %d out of %d probes. Please check which kprobes are kept enabled via debugfs.\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally disabled\\n\");\n\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for disarming all kprobes by optimizer */\n\twait_for_kprobe_optimizer();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static bool kprobes_all_disarmed;",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_for_kprobe_optimizer",
          "args": [],
          "line": 2841
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_kprobe_optimizer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "647-663",
          "snippet": "void wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* This will also make 'optimizing_work' execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* 'optimizing_work' might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* This will also make 'optimizing_work' execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* 'optimizing_work' might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2838
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Kprobes globally disabled\\n\""
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Kprobes globally disabled, but failed to disable %d out of %d probes. Please check which kprobes are kept enabled via debugfs.\\n\"",
            "errors",
            "total"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disarm_kprobe",
          "args": [
            "p",
            "false"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1177-1189",
          "snippet": "static int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_trampoline_kprobe",
          "args": [
            "p"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int disarm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are already disarmed, just return */\n\tif (kprobes_all_disarmed) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn 0;\n\t}\n\n\tkprobes_all_disarmed = true;\n\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Disarm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!arch_trampoline_kprobe(p) && !kprobe_disabled(p)) {\n\t\t\t\terr = disarm_kprobe(p, false);\n\t\t\t\tif (err) {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally disabled, but failed to disable %d out of %d probes. Please check which kprobes are kept enabled via debugfs.\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally disabled\\n\");\n\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for disarming all kprobes by optimizer */\n\twait_for_kprobe_optimizer();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "arm_all_kprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2754-2798",
    "snippet": "static int arm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are armed, just return */\n\tif (!kprobes_all_disarmed)\n\t\tgoto already_enabled;\n\n\t/*\n\t * optimize_kprobe() called by arm_kprobe() checks\n\t * kprobes_all_disarmed, so set kprobes_all_disarmed before\n\t * arm_kprobe.\n\t */\n\tkprobes_all_disarmed = false;\n\t/* Arming kprobes doesn't optimize kprobe itself */\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Arm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p)) {\n\t\t\t\terr = arm_kprobe(p);\n\t\t\t\tif (err)  {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally enabled, but failed to enable %d out of %d probes. Please check which kprobes are kept disabled via debugfs.\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally enabled\\n\");\n\nalready_enabled:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static bool kprobes_all_disarmed;",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2796
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Kprobes globally enabled\\n\""
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Kprobes globally enabled, but failed to enable %d out of %d probes. Please check which kprobes are kept disabled via debugfs.\\n\"",
            "errors",
            "total"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arm_kprobe",
          "args": [
            "p"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "arm_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1163-1175",
          "snippet": "static int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int arm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i, total = 0, errors = 0;\n\tint err, ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* If kprobes are armed, just return */\n\tif (!kprobes_all_disarmed)\n\t\tgoto already_enabled;\n\n\t/*\n\t * optimize_kprobe() called by arm_kprobe() checks\n\t * kprobes_all_disarmed, so set kprobes_all_disarmed before\n\t * arm_kprobe.\n\t */\n\tkprobes_all_disarmed = false;\n\t/* Arming kprobes doesn't optimize kprobe itself */\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\t/* Arm all kprobes on a best-effort basis */\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p)) {\n\t\t\t\terr = arm_kprobe(p);\n\t\t\t\tif (err)  {\n\t\t\t\t\terrors++;\n\t\t\t\t\tret = err;\n\t\t\t\t}\n\t\t\t\ttotal++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (errors)\n\t\tpr_warn(\"Kprobes globally enabled, but failed to enable %d out of %d probes. Please check which kprobes are kept disabled via debugfs.\\n\",\n\t\t\terrors, total);\n\telse\n\t\tpr_info(\"Kprobes globally enabled\\n\");\n\nalready_enabled:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "kprobe_blacklist_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2741-2744",
    "snippet": "static void kprobe_blacklist_seq_stop(struct seq_file *f, void *v)\n{\n\tmutex_unlock(&kprobe_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void kprobe_blacklist_seq_stop(struct seq_file *f, void *v)\n{\n\tmutex_unlock(&kprobe_mutex);\n}"
  },
  {
    "function_name": "kprobe_blacklist_seq_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2723-2739",
    "snippet": "static int kprobe_blacklist_seq_show(struct seq_file *m, void *v)\n{\n\tstruct kprobe_blacklist_entry *ent =\n\t\tlist_entry(v, struct kprobe_blacklist_entry, list);\n\n\t/*\n\t * If '/proc/kallsyms' is not showing kernel address, we won't\n\t * show them here either.\n\t */\n\tif (!kallsyms_show_value(m->file->f_cred))\n\t\tseq_printf(m, \"0x%px-0x%px\\t%ps\\n\", NULL, NULL,\n\t\t\t   (void *)ent->start_addr);\n\telse\n\t\tseq_printf(m, \"0x%px-0x%px\\t%ps\\n\", (void *)ent->start_addr,\n\t\t\t   (void *)ent->end_addr, (void *)ent->start_addr);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"0x%px-0x%px\\t%ps\\n\"",
            "(void *)ent->start_addr",
            "(void *)ent->end_addr",
            "(void *)ent->start_addr"
          ],
          "line": 2736
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_show_value",
          "args": [
            "m->file->f_cred"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_show_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "817-832",
          "snippet": "bool kallsyms_show_value(const struct cred *cred)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (security_capable(cred, &init_user_ns, CAP_SYSLOG,\n\t\t\t\t     CAP_OPT_NOAUDIT) == 0)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nbool kallsyms_show_value(const struct cred *cred)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (security_capable(cred, &init_user_ns, CAP_SYSLOG,\n\t\t\t\t     CAP_OPT_NOAUDIT) == 0)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "v",
            "structkprobe_blacklist_entry",
            "list"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int kprobe_blacklist_seq_show(struct seq_file *m, void *v)\n{\n\tstruct kprobe_blacklist_entry *ent =\n\t\tlist_entry(v, struct kprobe_blacklist_entry, list);\n\n\t/*\n\t * If '/proc/kallsyms' is not showing kernel address, we won't\n\t * show them here either.\n\t */\n\tif (!kallsyms_show_value(m->file->f_cred))\n\t\tseq_printf(m, \"0x%px-0x%px\\t%ps\\n\", NULL, NULL,\n\t\t\t   (void *)ent->start_addr);\n\telse\n\t\tseq_printf(m, \"0x%px-0x%px\\t%ps\\n\", (void *)ent->start_addr,\n\t\t\t   (void *)ent->end_addr, (void *)ent->start_addr);\n\treturn 0;\n}"
  },
  {
    "function_name": "kprobe_blacklist_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2718-2721",
    "snippet": "static void *kprobe_blacklist_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &kprobe_blacklist, pos);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&kprobe_blacklist",
            "pos"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void *kprobe_blacklist_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &kprobe_blacklist, pos);\n}"
  },
  {
    "function_name": "kprobe_blacklist_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2712-2716",
    "snippet": "static void *kprobe_blacklist_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&kprobe_mutex);\n\treturn seq_list_start(&kprobe_blacklist, *pos);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);",
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&kprobe_blacklist",
            "*pos"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void *kprobe_blacklist_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&kprobe_mutex);\n\treturn seq_list_start(&kprobe_blacklist, *pos);\n}"
  },
  {
    "function_name": "show_kprobe_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2678-2700",
    "snippet": "static int show_kprobe_addr(struct seq_file *pi, void *v)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p, *kp;\n\tconst char *sym = NULL;\n\tunsigned int i = *(loff_t *) v;\n\tunsigned long offset = 0;\n\tchar *modname, namebuf[KSYM_NAME_LEN];\n\n\thead = &kprobe_table[i];\n\tpreempt_disable();\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tsym = kallsyms_lookup((unsigned long)p->addr, NULL,\n\t\t\t\t\t&offset, &modname, namebuf);\n\t\tif (kprobe_aggrprobe(p)) {\n\t\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\t\treport_probe(pi, kp, sym, offset, modname, p);\n\t\t} else\n\t\t\treport_probe(pi, p, sym, offset, modname, NULL);\n\t}\n\tpreempt_enable();\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_probe",
          "args": [
            "pi",
            "p",
            "sym",
            "offset",
            "modname",
            "NULL"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "report_probe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2629-2658",
          "snippet": "static void report_probe(struct seq_file *pi, struct kprobe *p,\n\t\tconst char *sym, int offset, char *modname, struct kprobe *pp)\n{\n\tchar *kprobe_type;\n\tvoid *addr = p->addr;\n\n\tif (p->pre_handler == pre_handler_kretprobe)\n\t\tkprobe_type = \"r\";\n\telse\n\t\tkprobe_type = \"k\";\n\n\tif (!kallsyms_show_value(pi->file->f_cred))\n\t\taddr = NULL;\n\n\tif (sym)\n\t\tseq_printf(pi, \"%px  %s  %s+0x%x  %s \",\n\t\t\taddr, kprobe_type, sym, offset,\n\t\t\t(modname ? modname : \" \"));\n\telse\t/* try to use %pS */\n\t\tseq_printf(pi, \"%px  %s  %pS \",\n\t\t\taddr, kprobe_type, p->addr);\n\n\tif (!pp)\n\t\tpp = p;\n\tseq_printf(pi, \"%s%s%s%s\\n\",\n\t\t(kprobe_gone(p) ? \"[GONE]\" : \"\"),\n\t\t((kprobe_disabled(p) && !kprobe_gone(p)) ?  \"[DISABLED]\" : \"\"),\n\t\t(kprobe_optimized(pp) ? \"[OPTIMIZED]\" : \"\"),\n\t\t(kprobe_ftrace(pp) ? \"[FTRACE]\" : \"\"));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void report_probe(struct seq_file *pi, struct kprobe *p,\n\t\tconst char *sym, int offset, char *modname, struct kprobe *pp)\n{\n\tchar *kprobe_type;\n\tvoid *addr = p->addr;\n\n\tif (p->pre_handler == pre_handler_kretprobe)\n\t\tkprobe_type = \"r\";\n\telse\n\t\tkprobe_type = \"k\";\n\n\tif (!kallsyms_show_value(pi->file->f_cred))\n\t\taddr = NULL;\n\n\tif (sym)\n\t\tseq_printf(pi, \"%px  %s  %s+0x%x  %s \",\n\t\t\taddr, kprobe_type, sym, offset,\n\t\t\t(modname ? modname : \" \"));\n\telse\t/* try to use %pS */\n\t\tseq_printf(pi, \"%px  %s  %pS \",\n\t\t\taddr, kprobe_type, p->addr);\n\n\tif (!pp)\n\t\tpp = p;\n\tseq_printf(pi, \"%s%s%s%s\\n\",\n\t\t(kprobe_gone(p) ? \"[GONE]\" : \"\"),\n\t\t((kprobe_disabled(p) && !kprobe_gone(p)) ?  \"[DISABLED]\" : \"\"),\n\t\t(kprobe_optimized(pp) ? \"[OPTIMIZED]\" : \"\"),\n\t\t(kprobe_ftrace(pp) ? \"[FTRACE]\" : \"\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "395-398",
          "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup",
          "args": [
            "(unsigned long)p->addr",
            "NULL",
            "&offset",
            "&modname",
            "namebuf"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "377-384",
          "snippet": "const char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nconst char *kallsyms_lookup(unsigned long addr,\n\t\t\t    unsigned long *symbolsize,\n\t\t\t    unsigned long *offset,\n\t\t\t    char **modname, char *namebuf)\n{\n\treturn kallsyms_lookup_buildid(addr, symbolsize, offset, modname,\n\t\t\t\t       NULL, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\n\nstatic int show_kprobe_addr(struct seq_file *pi, void *v)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p, *kp;\n\tconst char *sym = NULL;\n\tunsigned int i = *(loff_t *) v;\n\tunsigned long offset = 0;\n\tchar *modname, namebuf[KSYM_NAME_LEN];\n\n\thead = &kprobe_table[i];\n\tpreempt_disable();\n\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\tsym = kallsyms_lookup((unsigned long)p->addr, NULL,\n\t\t\t\t\t&offset, &modname, namebuf);\n\t\tif (kprobe_aggrprobe(p)) {\n\t\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\t\treport_probe(pi, kp, sym, offset, modname, p);\n\t\t} else\n\t\t\treport_probe(pi, p, sym, offset, modname, NULL);\n\t}\n\tpreempt_enable();\n\treturn 0;\n}"
  },
  {
    "function_name": "kprobe_seq_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2673-2676",
    "snippet": "static void kprobe_seq_stop(struct seq_file *f, void *v)\n{\n\t/* Nothing to do */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kprobe_seq_stop(struct seq_file *f, void *v)\n{\n\t/* Nothing to do */\n}"
  },
  {
    "function_name": "kprobe_seq_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2665-2671",
    "snippet": "static void *kprobe_seq_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >= KPROBE_TABLE_SIZE)\n\t\treturn NULL;\n\treturn pos;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic void *kprobe_seq_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >= KPROBE_TABLE_SIZE)\n\t\treturn NULL;\n\treturn pos;\n}"
  },
  {
    "function_name": "kprobe_seq_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2660-2663",
    "snippet": "static void *kprobe_seq_start(struct seq_file *f, loff_t *pos)\n{\n\treturn (*pos < KPROBE_TABLE_SIZE) ? pos : NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic void *kprobe_seq_start(struct seq_file *f, loff_t *pos)\n{\n\treturn (*pos < KPROBE_TABLE_SIZE) ? pos : NULL;\n}"
  },
  {
    "function_name": "report_probe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2629-2658",
    "snippet": "static void report_probe(struct seq_file *pi, struct kprobe *p,\n\t\tconst char *sym, int offset, char *modname, struct kprobe *pp)\n{\n\tchar *kprobe_type;\n\tvoid *addr = p->addr;\n\n\tif (p->pre_handler == pre_handler_kretprobe)\n\t\tkprobe_type = \"r\";\n\telse\n\t\tkprobe_type = \"k\";\n\n\tif (!kallsyms_show_value(pi->file->f_cred))\n\t\taddr = NULL;\n\n\tif (sym)\n\t\tseq_printf(pi, \"%px  %s  %s+0x%x  %s \",\n\t\t\taddr, kprobe_type, sym, offset,\n\t\t\t(modname ? modname : \" \"));\n\telse\t/* try to use %pS */\n\t\tseq_printf(pi, \"%px  %s  %pS \",\n\t\t\taddr, kprobe_type, p->addr);\n\n\tif (!pp)\n\t\tpp = p;\n\tseq_printf(pi, \"%s%s%s%s\\n\",\n\t\t(kprobe_gone(p) ? \"[GONE]\" : \"\"),\n\t\t((kprobe_disabled(p) && !kprobe_gone(p)) ?  \"[DISABLED]\" : \"\"),\n\t\t(kprobe_optimized(pp) ? \"[OPTIMIZED]\" : \"\"),\n\t\t(kprobe_ftrace(pp) ? \"[FTRACE]\" : \"\"));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "pi",
            "\"%s%s%s%s\\n\"",
            "(kprobe_gone(p) ? \"[GONE]\" : \"\")",
            "((kprobe_disabled(p) && !kprobe_gone(p)) ?  \"[DISABLED]\" : \"\")",
            "(kprobe_optimized(pp) ? \"[OPTIMIZED]\" : \"\")",
            "(kprobe_ftrace(pp) ? \"[FTRACE]\" : \"\")"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_ftrace",
          "args": [
            "pp"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1148-1151",
          "snippet": "static inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_optimized",
          "args": [
            "pp"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "p"
          ],
          "line": 2655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "p"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_show_value",
          "args": [
            "pi->file->f_cred"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_show_value",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "817-832",
          "snippet": "bool kallsyms_show_value(const struct cred *cred)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (security_capable(cred, &init_user_ns, CAP_SYSLOG,\n\t\t\t\t     CAP_OPT_NOAUDIT) == 0)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nbool kallsyms_show_value(const struct cred *cred)\n{\n\tswitch (kptr_restrict) {\n\tcase 0:\n\t\tif (kallsyms_for_perf())\n\t\t\treturn true;\n\t\tfallthrough;\n\tcase 1:\n\t\tif (security_capable(cred, &init_user_ns, CAP_SYSLOG,\n\t\t\t\t     CAP_OPT_NOAUDIT) == 0)\n\t\t\treturn true;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void report_probe(struct seq_file *pi, struct kprobe *p,\n\t\tconst char *sym, int offset, char *modname, struct kprobe *pp)\n{\n\tchar *kprobe_type;\n\tvoid *addr = p->addr;\n\n\tif (p->pre_handler == pre_handler_kretprobe)\n\t\tkprobe_type = \"r\";\n\telse\n\t\tkprobe_type = \"k\";\n\n\tif (!kallsyms_show_value(pi->file->f_cred))\n\t\taddr = NULL;\n\n\tif (sym)\n\t\tseq_printf(pi, \"%px  %s  %s+0x%x  %s \",\n\t\t\taddr, kprobe_type, sym, offset,\n\t\t\t(modname ? modname : \" \"));\n\telse\t/* try to use %pS */\n\t\tseq_printf(pi, \"%px  %s  %pS \",\n\t\t\taddr, kprobe_type, p->addr);\n\n\tif (!pp)\n\t\tpp = p;\n\tseq_printf(pi, \"%s%s%s%s\\n\",\n\t\t(kprobe_gone(p) ? \"[GONE]\" : \"\"),\n\t\t((kprobe_disabled(p) && !kprobe_gone(p)) ?  \"[DISABLED]\" : \"\"),\n\t\t(kprobe_optimized(pp) ? \"[OPTIMIZED]\" : \"\"),\n\t\t(kprobe_ftrace(pp) ? \"[FTRACE]\" : \"\"));\n}"
  },
  {
    "function_name": "init_optprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2614-2624",
    "snippet": "static int __init init_optprobes(void)\n{\n\t/*\n\t * Enable kprobe optimization - this kicks the optimizer which\n\t * depends on synchronize_rcu_tasks() and ksoftirqd, that is\n\t * not spawned in early initcall. So delay the optimization.\n\t */\n\toptimize_all_kprobes();\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "optimize_all_kprobes",
          "args": [],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_all_kprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "913-941",
          "snippet": "static void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already prohibited, just return. */\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for unoptimizing completion. */\n\twait_for_kprobe_optimizer();\n\tpr_info(\"kprobe jump-optimization is disabled. All kprobes are based on software breakpoint.\\n\");\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already prohibited, just return. */\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for unoptimizing completion. */\n\twait_for_kprobe_optimizer();\n\tpr_info(\"kprobe jump-optimization is disabled. All kprobes are based on software breakpoint.\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __init;\n\nstatic int __init init_optprobes(void)\n{\n\t/*\n\t * Enable kprobe optimization - this kicks the optimizer which\n\t * depends on synchronize_rcu_tasks() and ksoftirqd, that is\n\t * not spawned in early initcall. So delay the optimization.\n\t */\n\toptimize_all_kprobes();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "init_kprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2568-2610",
    "snippet": "static int __init init_kprobes(void)\n{\n\tint i, err = 0;\n\n\t/* FIXME allocate the probe table, currently defined statically */\n\t/* initialize all list heads */\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&kprobe_table[i]);\n\n\terr = populate_kprobe_blacklist(__start_kprobe_blacklist,\n\t\t\t\t\t__stop_kprobe_blacklist);\n\tif (err)\n\t\tpr_err(\"Failed to populate blacklist (error %d), kprobes not restricted, be careful using them!\\n\", err);\n\n\tif (kretprobe_blacklist_size) {\n\t\t/* lookup the function address from its name */\n\t\tfor (i = 0; kretprobe_blacklist[i].name != NULL; i++) {\n\t\t\tkretprobe_blacklist[i].addr =\n\t\t\t\tkprobe_lookup_name(kretprobe_blacklist[i].name, 0);\n\t\t\tif (!kretprobe_blacklist[i].addr)\n\t\t\t\tpr_err(\"Failed to lookup symbol '%s' for kretprobe blacklist. Maybe the target function is removed or renamed.\\n\",\n\t\t\t\t       kretprobe_blacklist[i].name);\n\t\t}\n\t}\n\n\t/* By default, kprobes are armed */\n\tkprobes_all_disarmed = false;\n\n#if defined(CONFIG_OPTPROBES) && defined(__ARCH_WANT_KPROBES_INSN_SLOT)\n\t/* Init 'kprobe_optinsn_slots' for allocation */\n\tkprobe_optinsn_slots.insn_size = MAX_OPTINSN_SIZE;\n#endif\n\n\terr = arch_init_kprobes();\n\tif (!err)\n\t\terr = register_die_notifier(&kprobe_exceptions_nb);\n\tif (!err)\n\t\terr = register_module_notifier(&kprobe_module_nb);\n\n\tkprobes_initialized = (err == 0);\n\tkprobe_sysctls_init();\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static int kprobes_initialized;",
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static bool kprobes_all_disarmed;",
      "static struct notifier_block kprobe_exceptions_nb = {\n\t.notifier_call = kprobe_exceptions_notify,\n\t.priority = 0x7fffffff /* we need to be notified first */\n};",
      "int __init",
      "static struct notifier_block kprobe_module_nb = {\n\t.notifier_call = kprobes_module_callback,\n\t.priority = 0\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_sysctls_init",
          "args": [],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_sysctls_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "977-980",
          "snippet": "static void __init kprobe_sysctls_init(void)\n{\n\tregister_sysctl_init(\"debug\", kprobe_sysctls);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __init;\n\nstatic void __init kprobe_sysctls_init(void)\n{\n\tregister_sysctl_init(\"debug\", kprobe_sysctls);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&kprobe_module_nb"
          ],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_die_notifier",
          "args": [
            "&kprobe_exceptions_nb"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_die_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/notifier.c",
          "lines": "540-543",
          "snippet": "int unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ATOMIC_NOTIFIER_HEAD(die_chain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nstatic ATOMIC_NOTIFIER_HEAD(die_chain);\n\nint unregister_die_notifier(struct notifier_block *nb)\n{\n\treturn atomic_notifier_chain_unregister(&die_chain, nb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_init_kprobes",
          "args": [],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to lookup symbol '%s' for kretprobe blacklist. Maybe the target function is removed or renamed.\\n\"",
            "kretprobe_blacklist[i].name"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_lookup_name",
          "args": [
            "kretprobe_blacklist[i].name",
            "0"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to populate blacklist (error %d), kprobes not restricted, be careful using them!\\n\"",
            "err"
          ],
          "line": 2580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "populate_kprobe_blacklist",
          "args": [
            "__start_kprobe_blacklist",
            "__stop_kprobe_blacklist"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "populate_kprobe_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2415-2442",
          "snippet": "static int __init populate_kprobe_blacklist(unsigned long *start,\n\t\t\t\t\t     unsigned long *end)\n{\n\tunsigned long entry;\n\tunsigned long *iter;\n\tint ret;\n\n\tfor (iter = start; iter < end; iter++) {\n\t\tentry = (unsigned long)dereference_symbol_descriptor((void *)*iter);\n\t\tret = kprobe_add_ksym_blacklist(entry);\n\t\tif (ret == -EINVAL)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Symbols in '__kprobes_text' are blacklisted */\n\tret = kprobe_add_area_blacklist((unsigned long)__kprobes_text_start,\n\t\t\t\t\t(unsigned long)__kprobes_text_end);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Symbols in 'noinstr' section are blacklisted */\n\tret = kprobe_add_area_blacklist((unsigned long)__noinstr_text_start,\n\t\t\t\t\t(unsigned long)__noinstr_text_end);\n\n\treturn ret ? : arch_populate_kprobe_blacklist();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int __init"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __init;\n\nstatic int __init populate_kprobe_blacklist(unsigned long *start,\n\t\t\t\t\t     unsigned long *end)\n{\n\tunsigned long entry;\n\tunsigned long *iter;\n\tint ret;\n\n\tfor (iter = start; iter < end; iter++) {\n\t\tentry = (unsigned long)dereference_symbol_descriptor((void *)*iter);\n\t\tret = kprobe_add_ksym_blacklist(entry);\n\t\tif (ret == -EINVAL)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Symbols in '__kprobes_text' are blacklisted */\n\tret = kprobe_add_area_blacklist((unsigned long)__kprobes_text_start,\n\t\t\t\t\t(unsigned long)__kprobes_text_end);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Symbols in 'noinstr' section are blacklisted */\n\tret = kprobe_add_area_blacklist((unsigned long)__noinstr_text_start,\n\t\t\t\t\t(unsigned long)__noinstr_text_end);\n\n\treturn ret ? : arch_populate_kprobe_blacklist();\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&kprobe_table[i]"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic int kprobes_initialized;\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic bool kprobes_all_disarmed;\nstatic struct notifier_block kprobe_exceptions_nb = {\n\t.notifier_call = kprobe_exceptions_notify,\n\t.priority = 0x7fffffff /* we need to be notified first */\n};\nint __init;\nstatic struct notifier_block kprobe_module_nb = {\n\t.notifier_call = kprobes_module_callback,\n\t.priority = 0\n};\n\nstatic int __init init_kprobes(void)\n{\n\tint i, err = 0;\n\n\t/* FIXME allocate the probe table, currently defined statically */\n\t/* initialize all list heads */\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&kprobe_table[i]);\n\n\terr = populate_kprobe_blacklist(__start_kprobe_blacklist,\n\t\t\t\t\t__stop_kprobe_blacklist);\n\tif (err)\n\t\tpr_err(\"Failed to populate blacklist (error %d), kprobes not restricted, be careful using them!\\n\", err);\n\n\tif (kretprobe_blacklist_size) {\n\t\t/* lookup the function address from its name */\n\t\tfor (i = 0; kretprobe_blacklist[i].name != NULL; i++) {\n\t\t\tkretprobe_blacklist[i].addr =\n\t\t\t\tkprobe_lookup_name(kretprobe_blacklist[i].name, 0);\n\t\t\tif (!kretprobe_blacklist[i].addr)\n\t\t\t\tpr_err(\"Failed to lookup symbol '%s' for kretprobe blacklist. Maybe the target function is removed or renamed.\\n\",\n\t\t\t\t       kretprobe_blacklist[i].name);\n\t\t}\n\t}\n\n\t/* By default, kprobes are armed */\n\tkprobes_all_disarmed = false;\n\n#if defined(CONFIG_OPTPROBES) && defined(__ARCH_WANT_KPROBES_INSN_SLOT)\n\t/* Init 'kprobe_optinsn_slots' for allocation */\n\tkprobe_optinsn_slots.insn_size = MAX_OPTINSN_SIZE;\n#endif\n\n\terr = arch_init_kprobes();\n\tif (!err)\n\t\terr = register_die_notifier(&kprobe_exceptions_nb);\n\tif (!err)\n\t\terr = register_module_notifier(&kprobe_module_nb);\n\n\tkprobes_initialized = (err == 0);\n\tkprobe_sysctls_init();\n\treturn err;\n}"
  },
  {
    "function_name": "kprobe_free_init_mem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2546-2566",
    "snippet": "void kprobe_free_init_mem(void)\n{\n\tvoid *start = (void *)(&__init_begin);\n\tvoid *end = (void *)(&__init_end);\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tint i;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Kill all kprobes on initmem because the target code has been freed. */\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (start <= (void *)p->addr && (void *)p->addr < end)\n\t\t\t\tkill_kprobe(p);\n\t\t}\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_kprobe",
          "args": [
            "p"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "kill_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2232-2262",
          "snippet": "static void kill_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tp->flags |= KPROBE_FLAG_GONE;\n\tif (kprobe_aggrprobe(p)) {\n\t\t/*\n\t\t * If this is an aggr_kprobe, we have to list all the\n\t\t * chained probes and mark them GONE.\n\t\t */\n\t\tlist_for_each_entry(kp, &p->list, list)\n\t\t\tkp->flags |= KPROBE_FLAG_GONE;\n\t\tp->post_handler = NULL;\n\t\tkill_optimized_kprobe(p);\n\t}\n\t/*\n\t * Here, we can remove insn_slot safely, because no thread calls\n\t * the original probed function (which will be freed soon) any more.\n\t */\n\tarch_remove_kprobe(p);\n\n\t/*\n\t * The module is going away. We should disarm the kprobe which\n\t * is using ftrace, because ftrace framework is still available at\n\t * 'MODULE_STATE_GOING' notification.\n\t */\n\tif (kprobe_ftrace(p) && !kprobe_disabled(p) && !kprobes_all_disarmed)\n\t\tdisarm_kprobe_ftrace(p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void kill_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tp->flags |= KPROBE_FLAG_GONE;\n\tif (kprobe_aggrprobe(p)) {\n\t\t/*\n\t\t * If this is an aggr_kprobe, we have to list all the\n\t\t * chained probes and mark them GONE.\n\t\t */\n\t\tlist_for_each_entry(kp, &p->list, list)\n\t\t\tkp->flags |= KPROBE_FLAG_GONE;\n\t\tp->post_handler = NULL;\n\t\tkill_optimized_kprobe(p);\n\t}\n\t/*\n\t * Here, we can remove insn_slot safely, because no thread calls\n\t * the original probed function (which will be freed soon) any more.\n\t */\n\tarch_remove_kprobe(p);\n\n\t/*\n\t * The module is going away. We should disarm the kprobe which\n\t * is using ftrace, because ftrace framework is still available at\n\t * 'MODULE_STATE_GOING' notification.\n\t */\n\tif (kprobe_ftrace(p) && !kprobe_disabled(p) && !kprobes_all_disarmed)\n\t\tdisarm_kprobe_ftrace(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid kprobe_free_init_mem(void)\n{\n\tvoid *start = (void *)(&__init_begin);\n\tvoid *end = (void *)(&__init_end);\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tint i;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Kill all kprobes on initmem because the target code has been freed. */\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (start <= (void *)p->addr && (void *)p->addr < end)\n\t\t\t\tkill_kprobe(p);\n\t\t}\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}"
  },
  {
    "function_name": "kprobes_module_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2491-2539",
    "snippet": "static int kprobes_module_callback(struct notifier_block *nb,\n\t\t\t\t   unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\tint checkcore = (val == MODULE_STATE_GOING);\n\n\tif (val == MODULE_STATE_COMING) {\n\t\tmutex_lock(&kprobe_mutex);\n\t\tadd_module_kprobe_blacklist(mod);\n\t\tmutex_unlock(&kprobe_mutex);\n\t}\n\tif (val != MODULE_STATE_GOING && val != MODULE_STATE_LIVE)\n\t\treturn NOTIFY_DONE;\n\n\t/*\n\t * When 'MODULE_STATE_GOING' was notified, both of module '.text' and\n\t * '.init.text' sections would be freed. When 'MODULE_STATE_LIVE' was\n\t * notified, only '.init.text' section would be freed. We need to\n\t * disable kprobes which have been inserted in the sections.\n\t */\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist)\n\t\t\tif (within_module_init((unsigned long)p->addr, mod) ||\n\t\t\t    (checkcore &&\n\t\t\t     within_module_core((unsigned long)p->addr, mod))) {\n\t\t\t\t/*\n\t\t\t\t * The vaddr this probe is installed will soon\n\t\t\t\t * be vfreed buy not synced to disk. Hence,\n\t\t\t\t * disarming the breakpoint isn't needed.\n\t\t\t\t *\n\t\t\t\t * Note, this will also move any optimized probes\n\t\t\t\t * that are pending to be removed from their\n\t\t\t\t * corresponding lists to the 'freeing_list' and\n\t\t\t\t * will not be touched by the delayed\n\t\t\t\t * kprobe_optimizer() work handler.\n\t\t\t\t */\n\t\t\t\tkill_kprobe(p);\n\t\t\t}\n\t}\n\tif (val == MODULE_STATE_GOING)\n\t\tremove_module_kprobe_blacklist(mod);\n\tmutex_unlock(&kprobe_mutex);\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_module_kprobe_blacklist",
          "args": [
            "mod"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "remove_module_kprobe_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2467-2488",
          "snippet": "static void remove_module_kprobe_blacklist(struct module *mod)\n{\n\tunsigned long start, end;\n\tint i;\n\n\tif (mod->kprobe_blacklist) {\n\t\tfor (i = 0; i < mod->num_kprobe_blacklist; i++)\n\t\t\tkprobe_remove_ksym_blacklist(mod->kprobe_blacklist[i]);\n\t}\n\n\tstart = (unsigned long)mod->kprobes_text_start;\n\tif (start) {\n\t\tend = start + mod->kprobes_text_size;\n\t\tkprobe_remove_area_blacklist(start, end);\n\t}\n\n\tstart = (unsigned long)mod->noinstr_text_start;\n\tif (start) {\n\t\tend = start + mod->noinstr_text_size;\n\t\tkprobe_remove_area_blacklist(start, end);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kprobe_blacklist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void remove_module_kprobe_blacklist(struct module *mod)\n{\n\tunsigned long start, end;\n\tint i;\n\n\tif (mod->kprobe_blacklist) {\n\t\tfor (i = 0; i < mod->num_kprobe_blacklist; i++)\n\t\t\tkprobe_remove_ksym_blacklist(mod->kprobe_blacklist[i]);\n\t}\n\n\tstart = (unsigned long)mod->kprobes_text_start;\n\tif (start) {\n\t\tend = start + mod->kprobes_text_size;\n\t\tkprobe_remove_area_blacklist(start, end);\n\t}\n\n\tstart = (unsigned long)mod->noinstr_text_start;\n\tif (start) {\n\t\tend = start + mod->noinstr_text_size;\n\t\tkprobe_remove_area_blacklist(start, end);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_kprobe",
          "args": [
            "p"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "kill_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2232-2262",
          "snippet": "static void kill_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tp->flags |= KPROBE_FLAG_GONE;\n\tif (kprobe_aggrprobe(p)) {\n\t\t/*\n\t\t * If this is an aggr_kprobe, we have to list all the\n\t\t * chained probes and mark them GONE.\n\t\t */\n\t\tlist_for_each_entry(kp, &p->list, list)\n\t\t\tkp->flags |= KPROBE_FLAG_GONE;\n\t\tp->post_handler = NULL;\n\t\tkill_optimized_kprobe(p);\n\t}\n\t/*\n\t * Here, we can remove insn_slot safely, because no thread calls\n\t * the original probed function (which will be freed soon) any more.\n\t */\n\tarch_remove_kprobe(p);\n\n\t/*\n\t * The module is going away. We should disarm the kprobe which\n\t * is using ftrace, because ftrace framework is still available at\n\t * 'MODULE_STATE_GOING' notification.\n\t */\n\tif (kprobe_ftrace(p) && !kprobe_disabled(p) && !kprobes_all_disarmed)\n\t\tdisarm_kprobe_ftrace(p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void kill_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tp->flags |= KPROBE_FLAG_GONE;\n\tif (kprobe_aggrprobe(p)) {\n\t\t/*\n\t\t * If this is an aggr_kprobe, we have to list all the\n\t\t * chained probes and mark them GONE.\n\t\t */\n\t\tlist_for_each_entry(kp, &p->list, list)\n\t\t\tkp->flags |= KPROBE_FLAG_GONE;\n\t\tp->post_handler = NULL;\n\t\tkill_optimized_kprobe(p);\n\t}\n\t/*\n\t * Here, we can remove insn_slot safely, because no thread calls\n\t * the original probed function (which will be freed soon) any more.\n\t */\n\tarch_remove_kprobe(p);\n\n\t/*\n\t * The module is going away. We should disarm the kprobe which\n\t * is using ftrace, because ftrace framework is still available at\n\t * 'MODULE_STATE_GOING' notification.\n\t */\n\tif (kprobe_ftrace(p) && !kprobe_disabled(p) && !kprobes_all_disarmed)\n\t\tdisarm_kprobe_ftrace(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_module_core",
          "args": [
            "(unsigned long)p->addr",
            "mod"
          ],
          "line": 2520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_init",
          "args": [
            "(unsigned long)p->addr",
            "mod"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_module_kprobe_blacklist",
          "args": [
            "mod"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "add_module_kprobe_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2444-2465",
          "snippet": "static void add_module_kprobe_blacklist(struct module *mod)\n{\n\tunsigned long start, end;\n\tint i;\n\n\tif (mod->kprobe_blacklist) {\n\t\tfor (i = 0; i < mod->num_kprobe_blacklist; i++)\n\t\t\tkprobe_add_ksym_blacklist(mod->kprobe_blacklist[i]);\n\t}\n\n\tstart = (unsigned long)mod->kprobes_text_start;\n\tif (start) {\n\t\tend = start + mod->kprobes_text_size;\n\t\tkprobe_add_area_blacklist(start, end);\n\t}\n\n\tstart = (unsigned long)mod->noinstr_text_start;\n\tif (start) {\n\t\tend = start + mod->noinstr_text_size;\n\t\tkprobe_add_area_blacklist(start, end);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kprobe_blacklist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void add_module_kprobe_blacklist(struct module *mod)\n{\n\tunsigned long start, end;\n\tint i;\n\n\tif (mod->kprobe_blacklist) {\n\t\tfor (i = 0; i < mod->num_kprobe_blacklist; i++)\n\t\t\tkprobe_add_ksym_blacklist(mod->kprobe_blacklist[i]);\n\t}\n\n\tstart = (unsigned long)mod->kprobes_text_start;\n\tif (start) {\n\t\tend = start + mod->kprobes_text_size;\n\t\tkprobe_add_area_blacklist(start, end);\n\t}\n\n\tstart = (unsigned long)mod->noinstr_text_start;\n\tif (start) {\n\t\tend = start + mod->noinstr_text_size;\n\t\tkprobe_add_area_blacklist(start, end);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int kprobes_module_callback(struct notifier_block *nb,\n\t\t\t\t   unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\tint checkcore = (val == MODULE_STATE_GOING);\n\n\tif (val == MODULE_STATE_COMING) {\n\t\tmutex_lock(&kprobe_mutex);\n\t\tadd_module_kprobe_blacklist(mod);\n\t\tmutex_unlock(&kprobe_mutex);\n\t}\n\tif (val != MODULE_STATE_GOING && val != MODULE_STATE_LIVE)\n\t\treturn NOTIFY_DONE;\n\n\t/*\n\t * When 'MODULE_STATE_GOING' was notified, both of module '.text' and\n\t * '.init.text' sections would be freed. When 'MODULE_STATE_LIVE' was\n\t * notified, only '.init.text' section would be freed. We need to\n\t * disable kprobes which have been inserted in the sections.\n\t */\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist)\n\t\t\tif (within_module_init((unsigned long)p->addr, mod) ||\n\t\t\t    (checkcore &&\n\t\t\t     within_module_core((unsigned long)p->addr, mod))) {\n\t\t\t\t/*\n\t\t\t\t * The vaddr this probe is installed will soon\n\t\t\t\t * be vfreed buy not synced to disk. Hence,\n\t\t\t\t * disarming the breakpoint isn't needed.\n\t\t\t\t *\n\t\t\t\t * Note, this will also move any optimized probes\n\t\t\t\t * that are pending to be removed from their\n\t\t\t\t * corresponding lists to the 'freeing_list' and\n\t\t\t\t * will not be touched by the delayed\n\t\t\t\t * kprobe_optimizer() work handler.\n\t\t\t\t */\n\t\t\t\tkill_kprobe(p);\n\t\t\t}\n\t}\n\tif (val == MODULE_STATE_GOING)\n\t\tremove_module_kprobe_blacklist(mod);\n\tmutex_unlock(&kprobe_mutex);\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "remove_module_kprobe_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2467-2488",
    "snippet": "static void remove_module_kprobe_blacklist(struct module *mod)\n{\n\tunsigned long start, end;\n\tint i;\n\n\tif (mod->kprobe_blacklist) {\n\t\tfor (i = 0; i < mod->num_kprobe_blacklist; i++)\n\t\t\tkprobe_remove_ksym_blacklist(mod->kprobe_blacklist[i]);\n\t}\n\n\tstart = (unsigned long)mod->kprobes_text_start;\n\tif (start) {\n\t\tend = start + mod->kprobes_text_size;\n\t\tkprobe_remove_area_blacklist(start, end);\n\t}\n\n\tstart = (unsigned long)mod->noinstr_text_start;\n\tif (start) {\n\t\tend = start + mod->noinstr_text_size;\n\t\tkprobe_remove_area_blacklist(start, end);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_remove_area_blacklist",
          "args": [
            "start",
            "end"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_remove_area_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2363-2373",
          "snippet": "static void kprobe_remove_area_blacklist(unsigned long start, unsigned long end)\n{\n\tstruct kprobe_blacklist_entry *ent, *n;\n\n\tlist_for_each_entry_safe(ent, n, &kprobe_blacklist, list) {\n\t\tif (ent->start_addr < start || ent->start_addr >= end)\n\t\t\tcontinue;\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kprobe_blacklist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void kprobe_remove_area_blacklist(unsigned long start, unsigned long end)\n{\n\tstruct kprobe_blacklist_entry *ent, *n;\n\n\tlist_for_each_entry_safe(ent, n, &kprobe_blacklist, list) {\n\t\tif (ent->start_addr < start || ent->start_addr >= end)\n\t\t\tcontinue;\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_remove_ksym_blacklist",
          "args": [
            "mod->kprobe_blacklist[i]"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_remove_ksym_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2375-2378",
          "snippet": "static void kprobe_remove_ksym_blacklist(unsigned long entry)\n{\n\tkprobe_remove_area_blacklist(entry, entry + 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kprobe_remove_ksym_blacklist(unsigned long entry)\n{\n\tkprobe_remove_area_blacklist(entry, entry + 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void remove_module_kprobe_blacklist(struct module *mod)\n{\n\tunsigned long start, end;\n\tint i;\n\n\tif (mod->kprobe_blacklist) {\n\t\tfor (i = 0; i < mod->num_kprobe_blacklist; i++)\n\t\t\tkprobe_remove_ksym_blacklist(mod->kprobe_blacklist[i]);\n\t}\n\n\tstart = (unsigned long)mod->kprobes_text_start;\n\tif (start) {\n\t\tend = start + mod->kprobes_text_size;\n\t\tkprobe_remove_area_blacklist(start, end);\n\t}\n\n\tstart = (unsigned long)mod->noinstr_text_start;\n\tif (start) {\n\t\tend = start + mod->noinstr_text_size;\n\t\tkprobe_remove_area_blacklist(start, end);\n\t}\n}"
  },
  {
    "function_name": "add_module_kprobe_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2444-2465",
    "snippet": "static void add_module_kprobe_blacklist(struct module *mod)\n{\n\tunsigned long start, end;\n\tint i;\n\n\tif (mod->kprobe_blacklist) {\n\t\tfor (i = 0; i < mod->num_kprobe_blacklist; i++)\n\t\t\tkprobe_add_ksym_blacklist(mod->kprobe_blacklist[i]);\n\t}\n\n\tstart = (unsigned long)mod->kprobes_text_start;\n\tif (start) {\n\t\tend = start + mod->kprobes_text_size;\n\t\tkprobe_add_area_blacklist(start, end);\n\t}\n\n\tstart = (unsigned long)mod->noinstr_text_start;\n\tif (start) {\n\t\tend = start + mod->noinstr_text_size;\n\t\tkprobe_add_area_blacklist(start, end);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_add_area_blacklist",
          "args": [
            "start",
            "end"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_add_area_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2347-2360",
          "snippet": "int kprobe_add_area_blacklist(unsigned long start, unsigned long end)\n{\n\tunsigned long entry;\n\tint ret = 0;\n\n\tfor (entry = start; entry < end; entry += ret) {\n\t\tret = kprobe_add_ksym_blacklist(entry);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\t/* In case of alias symbol */\n\t\t\tret = 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_add_area_blacklist(unsigned long start, unsigned long end)\n{\n\tunsigned long entry;\n\tint ret = 0;\n\n\tfor (entry = start; entry < end; entry += ret) {\n\t\tret = kprobe_add_ksym_blacklist(entry);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\t/* In case of alias symbol */\n\t\t\tret = 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_add_ksym_blacklist",
          "args": [
            "mod->kprobe_blacklist[i]"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_add_ksym_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2326-2344",
          "snippet": "int kprobe_add_ksym_blacklist(unsigned long entry)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long offset = 0, size = 0;\n\n\tif (!kernel_text_address(entry) ||\n\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\treturn -EINVAL;\n\n\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn -ENOMEM;\n\tent->start_addr = entry;\n\tent->end_addr = entry + size;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\n\treturn (int)size;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kprobe_blacklist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nint kprobe_add_ksym_blacklist(unsigned long entry)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long offset = 0, size = 0;\n\n\tif (!kernel_text_address(entry) ||\n\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\treturn -EINVAL;\n\n\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn -ENOMEM;\n\tent->start_addr = entry;\n\tent->end_addr = entry + size;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\n\treturn (int)size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void add_module_kprobe_blacklist(struct module *mod)\n{\n\tunsigned long start, end;\n\tint i;\n\n\tif (mod->kprobe_blacklist) {\n\t\tfor (i = 0; i < mod->num_kprobe_blacklist; i++)\n\t\t\tkprobe_add_ksym_blacklist(mod->kprobe_blacklist[i]);\n\t}\n\n\tstart = (unsigned long)mod->kprobes_text_start;\n\tif (start) {\n\t\tend = start + mod->kprobes_text_size;\n\t\tkprobe_add_area_blacklist(start, end);\n\t}\n\n\tstart = (unsigned long)mod->noinstr_text_start;\n\tif (start) {\n\t\tend = start + mod->noinstr_text_size;\n\t\tkprobe_add_area_blacklist(start, end);\n\t}\n}"
  },
  {
    "function_name": "populate_kprobe_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2415-2442",
    "snippet": "static int __init populate_kprobe_blacklist(unsigned long *start,\n\t\t\t\t\t     unsigned long *end)\n{\n\tunsigned long entry;\n\tunsigned long *iter;\n\tint ret;\n\n\tfor (iter = start; iter < end; iter++) {\n\t\tentry = (unsigned long)dereference_symbol_descriptor((void *)*iter);\n\t\tret = kprobe_add_ksym_blacklist(entry);\n\t\tif (ret == -EINVAL)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Symbols in '__kprobes_text' are blacklisted */\n\tret = kprobe_add_area_blacklist((unsigned long)__kprobes_text_start,\n\t\t\t\t\t(unsigned long)__kprobes_text_end);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Symbols in 'noinstr' section are blacklisted */\n\tret = kprobe_add_area_blacklist((unsigned long)__noinstr_text_start,\n\t\t\t\t\t(unsigned long)__noinstr_text_end);\n\n\treturn ret ? : arch_populate_kprobe_blacklist();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_populate_kprobe_blacklist",
          "args": [],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "arch_populate_kprobe_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2402-2405",
          "snippet": "__weak arch_populate_kprobe_blacklist(void)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n__weak arch_populate_kprobe_blacklist(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_add_area_blacklist",
          "args": [
            "(unsigned long)__noinstr_text_start",
            "(unsigned long)__noinstr_text_end"
          ],
          "line": 2438
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_add_area_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2347-2360",
          "snippet": "int kprobe_add_area_blacklist(unsigned long start, unsigned long end)\n{\n\tunsigned long entry;\n\tint ret = 0;\n\n\tfor (entry = start; entry < end; entry += ret) {\n\t\tret = kprobe_add_ksym_blacklist(entry);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\t/* In case of alias symbol */\n\t\t\tret = 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_add_area_blacklist(unsigned long start, unsigned long end)\n{\n\tunsigned long entry;\n\tint ret = 0;\n\n\tfor (entry = start; entry < end; entry += ret) {\n\t\tret = kprobe_add_ksym_blacklist(entry);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\t/* In case of alias symbol */\n\t\t\tret = 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_add_ksym_blacklist",
          "args": [
            "entry"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_add_ksym_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2326-2344",
          "snippet": "int kprobe_add_ksym_blacklist(unsigned long entry)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long offset = 0, size = 0;\n\n\tif (!kernel_text_address(entry) ||\n\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\treturn -EINVAL;\n\n\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn -ENOMEM;\n\tent->start_addr = entry;\n\tent->end_addr = entry + size;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\n\treturn (int)size;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kprobe_blacklist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nint kprobe_add_ksym_blacklist(unsigned long entry)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long offset = 0, size = 0;\n\n\tif (!kernel_text_address(entry) ||\n\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\treturn -EINVAL;\n\n\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn -ENOMEM;\n\tent->start_addr = entry;\n\tent->end_addr = entry + size;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\n\treturn (int)size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dereference_symbol_descriptor",
          "args": [
            "(void *)*iter"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __init;\n\nstatic int __init populate_kprobe_blacklist(unsigned long *start,\n\t\t\t\t\t     unsigned long *end)\n{\n\tunsigned long entry;\n\tunsigned long *iter;\n\tint ret;\n\n\tfor (iter = start; iter < end; iter++) {\n\t\tentry = (unsigned long)dereference_symbol_descriptor((void *)*iter);\n\t\tret = kprobe_add_ksym_blacklist(entry);\n\t\tif (ret == -EINVAL)\n\t\t\tcontinue;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t/* Symbols in '__kprobes_text' are blacklisted */\n\tret = kprobe_add_area_blacklist((unsigned long)__kprobes_text_start,\n\t\t\t\t\t(unsigned long)__kprobes_text_end);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Symbols in 'noinstr' section are blacklisted */\n\tret = kprobe_add_area_blacklist((unsigned long)__noinstr_text_start,\n\t\t\t\t\t(unsigned long)__noinstr_text_end);\n\n\treturn ret ? : arch_populate_kprobe_blacklist();\n}"
  },
  {
    "function_name": "arch_populate_kprobe_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2402-2405",
    "snippet": "__weak arch_populate_kprobe_blacklist(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n__weak arch_populate_kprobe_blacklist(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "kprobe_get_kallsym",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2386-2400",
    "snippet": "int kprobe_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t       char *sym)\n{\n#ifdef __ARCH_WANT_KPROBES_INSN_SLOT\n\tif (!kprobe_cache_get_kallsym(&kprobe_insn_slots, &symnum, value, type, sym))\n\t\treturn 0;\n#ifdef CONFIG_OPTPROBES\n\tif (!kprobe_cache_get_kallsym(&kprobe_optinsn_slots, &symnum, value, type, sym))\n\t\treturn 0;\n#endif\n#endif\n\tif (!arch_kprobe_get_kallsym(&symnum, value, type, sym))\n\t\treturn 0;\n\treturn -ERANGE;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kprobe_get_kallsym",
          "args": [
            "&symnum",
            "value",
            "type",
            "sym"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kprobe_get_kallsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2380-2384",
          "snippet": "int __weak arch_kprobe_get_kallsym(unsigned int *symnum, unsigned long *value,\n\t\t\t\t   char *type, char *sym)\n{\n\treturn -ERANGE;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __weak arch_kprobe_get_kallsym(unsigned int *symnum, unsigned long *value,\n\t\t\t\t   char *type, char *sym)\n{\n\treturn -ERANGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_cache_get_kallsym",
          "args": [
            "&kprobe_optinsn_slots",
            "&symnum",
            "value",
            "type",
            "sym"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_cache_get_kallsym",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "314-333",
          "snippet": "int kprobe_cache_get_kallsym(struct kprobe_insn_cache *c, unsigned int *symnum,\n\t\t\t     unsigned long *value, char *type, char *sym)\n{\n\tstruct kprobe_insn_page *kip;\n\tint ret = -ERANGE;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif ((*symnum)--)\n\t\t\tcontinue;\n\t\tstrscpy(sym, c->sym, KSYM_NAME_LEN);\n\t\t*type = 't';\n\t\t*value = (unsigned long)kip->insns;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_cache_get_kallsym(struct kprobe_insn_cache *c, unsigned int *symnum,\n\t\t\t     unsigned long *value, char *type, char *sym)\n{\n\tstruct kprobe_insn_page *kip;\n\tint ret = -ERANGE;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif ((*symnum)--)\n\t\t\tcontinue;\n\t\tstrscpy(sym, c->sym, KSYM_NAME_LEN);\n\t\t*type = 't';\n\t\t*value = (unsigned long)kip->insns;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_get_kallsym(unsigned int symnum, unsigned long *value, char *type,\n\t\t       char *sym)\n{\n#ifdef __ARCH_WANT_KPROBES_INSN_SLOT\n\tif (!kprobe_cache_get_kallsym(&kprobe_insn_slots, &symnum, value, type, sym))\n\t\treturn 0;\n#ifdef CONFIG_OPTPROBES\n\tif (!kprobe_cache_get_kallsym(&kprobe_optinsn_slots, &symnum, value, type, sym))\n\t\treturn 0;\n#endif\n#endif\n\tif (!arch_kprobe_get_kallsym(&symnum, value, type, sym))\n\t\treturn 0;\n\treturn -ERANGE;\n}"
  },
  {
    "function_name": "arch_kprobe_get_kallsym",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2380-2384",
    "snippet": "int __weak arch_kprobe_get_kallsym(unsigned int *symnum, unsigned long *value,\n\t\t\t\t   char *type, char *sym)\n{\n\treturn -ERANGE;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __weak arch_kprobe_get_kallsym(unsigned int *symnum, unsigned long *value,\n\t\t\t\t   char *type, char *sym)\n{\n\treturn -ERANGE;\n}"
  },
  {
    "function_name": "kprobe_remove_ksym_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2375-2378",
    "snippet": "static void kprobe_remove_ksym_blacklist(unsigned long entry)\n{\n\tkprobe_remove_area_blacklist(entry, entry + 1);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_remove_area_blacklist",
          "args": [
            "entry",
            "entry + 1"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_remove_area_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2363-2373",
          "snippet": "static void kprobe_remove_area_blacklist(unsigned long start, unsigned long end)\n{\n\tstruct kprobe_blacklist_entry *ent, *n;\n\n\tlist_for_each_entry_safe(ent, n, &kprobe_blacklist, list) {\n\t\tif (ent->start_addr < start || ent->start_addr >= end)\n\t\t\tcontinue;\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kprobe_blacklist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void kprobe_remove_area_blacklist(unsigned long start, unsigned long end)\n{\n\tstruct kprobe_blacklist_entry *ent, *n;\n\n\tlist_for_each_entry_safe(ent, n, &kprobe_blacklist, list) {\n\t\tif (ent->start_addr < start || ent->start_addr >= end)\n\t\t\tcontinue;\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kprobe_remove_ksym_blacklist(unsigned long entry)\n{\n\tkprobe_remove_area_blacklist(entry, entry + 1);\n}"
  },
  {
    "function_name": "kprobe_remove_area_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2363-2373",
    "snippet": "static void kprobe_remove_area_blacklist(unsigned long start, unsigned long end)\n{\n\tstruct kprobe_blacklist_entry *ent, *n;\n\n\tlist_for_each_entry_safe(ent, n, &kprobe_blacklist, list) {\n\t\tif (ent->start_addr < start || ent->start_addr >= end)\n\t\t\tcontinue;\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ent"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ent->list"
          ],
          "line": 2370
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ent",
            "n",
            "&kprobe_blacklist",
            "list"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic void kprobe_remove_area_blacklist(unsigned long start, unsigned long end)\n{\n\tstruct kprobe_blacklist_entry *ent, *n;\n\n\tlist_for_each_entry_safe(ent, n, &kprobe_blacklist, list) {\n\t\tif (ent->start_addr < start || ent->start_addr >= end)\n\t\t\tcontinue;\n\t\tlist_del(&ent->list);\n\t\tkfree(ent);\n\t}\n}"
  },
  {
    "function_name": "kprobe_add_area_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2347-2360",
    "snippet": "int kprobe_add_area_blacklist(unsigned long start, unsigned long end)\n{\n\tunsigned long entry;\n\tint ret = 0;\n\n\tfor (entry = start; entry < end; entry += ret) {\n\t\tret = kprobe_add_ksym_blacklist(entry);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\t/* In case of alias symbol */\n\t\t\tret = 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_add_ksym_blacklist",
          "args": [
            "entry"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_add_ksym_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2326-2344",
          "snippet": "int kprobe_add_ksym_blacklist(unsigned long entry)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long offset = 0, size = 0;\n\n\tif (!kernel_text_address(entry) ||\n\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\treturn -EINVAL;\n\n\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn -ENOMEM;\n\tent->start_addr = entry;\n\tent->end_addr = entry + size;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\n\treturn (int)size;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kprobe_blacklist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nint kprobe_add_ksym_blacklist(unsigned long entry)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long offset = 0, size = 0;\n\n\tif (!kernel_text_address(entry) ||\n\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\treturn -EINVAL;\n\n\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn -ENOMEM;\n\tent->start_addr = entry;\n\tent->end_addr = entry + size;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\n\treturn (int)size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_add_area_blacklist(unsigned long start, unsigned long end)\n{\n\tunsigned long entry;\n\tint ret = 0;\n\n\tfor (entry = start; entry < end; entry += ret) {\n\t\tret = kprobe_add_ksym_blacklist(entry);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 0)\t/* In case of alias symbol */\n\t\t\tret = 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kprobe_add_ksym_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2326-2344",
    "snippet": "int kprobe_add_ksym_blacklist(unsigned long entry)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long offset = 0, size = 0;\n\n\tif (!kernel_text_address(entry) ||\n\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\treturn -EINVAL;\n\n\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn -ENOMEM;\n\tent->start_addr = entry;\n\tent->end_addr = entry + size;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\n\treturn (int)size;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ent->list",
            "&kprobe_blacklist"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ent->list"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ent)",
            "GFP_KERNEL"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_size_offset",
          "args": [
            "entry",
            "&size",
            "&offset"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_size_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "315-326",
          "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_text_address",
          "args": [
            "entry"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_text_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/extable.c",
          "lines": "93-132",
          "snippet": "int kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots,\n\t * is_bpf_text_address() and is_bpf_image_address require\n\t * RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/sections.h>",
            "#include <linux/filter.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/extable.h>",
            "#include <linux/memory.h>",
            "#include <linux/ftrace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <linux/filter.h>\n#include <linux/kprobes.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/extable.h>\n#include <linux/memory.h>\n#include <linux/ftrace.h>\n\nint kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots,\n\t * is_bpf_text_address() and is_bpf_image_address require\n\t * RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nint kprobe_add_ksym_blacklist(unsigned long entry)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\tunsigned long offset = 0, size = 0;\n\n\tif (!kernel_text_address(entry) ||\n\t    !kallsyms_lookup_size_offset(entry, &size, &offset))\n\t\treturn -EINVAL;\n\n\tent = kmalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn -ENOMEM;\n\tent->start_addr = entry;\n\tent->end_addr = entry + size;\n\tINIT_LIST_HEAD(&ent->list);\n\tlist_add_tail(&ent->list, &kprobe_blacklist);\n\n\treturn (int)size;\n}"
  },
  {
    "function_name": "dump_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2319-2323",
    "snippet": "void dump_kprobe(struct kprobe *kp)\n{\n\tpr_err(\"Dump kprobe:\\n.symbol_name = %s, .offset = %x, .addr = %pS\\n\",\n\t       kp->symbol_name, kp->offset, kp->addr);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Dump kprobe:\\n.symbol_name = %s, .offset = %x, .addr = %pS\\n\"",
            "kp->symbol_name",
            "kp->offset",
            "kp->addr"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid dump_kprobe(struct kprobe *kp)\n{\n\tpr_err(\"Dump kprobe:\\n.symbol_name = %s, .offset = %x, .addr = %pS\\n\",\n\t       kp->symbol_name, kp->offset, kp->addr);\n}"
  },
  {
    "function_name": "enable_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2283-2315",
    "snippet": "int enable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Check whether specified probe is valid. */\n\tp = __get_valid_kprobe(kp);\n\tif (unlikely(p == NULL)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(kp)) {\n\t\t/* This kprobe has gone, we couldn't enable it. */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (p != kp)\n\t\tkp->flags &= ~KPROBE_FLAG_DISABLED;\n\n\tif (!kprobes_all_disarmed && kprobe_disabled(p)) {\n\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tret = arm_kprobe(p);\n\t\tif (ret)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\t}\nout:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arm_kprobe",
          "args": [
            "p"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "arm_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1163-1175",
          "snippet": "static int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "kp"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 2292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_valid_kprobe",
          "args": [
            "kp"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "__get_valid_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1526-1545",
          "snippet": "static struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nint enable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Check whether specified probe is valid. */\n\tp = __get_valid_kprobe(kp);\n\tif (unlikely(p == NULL)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(kp)) {\n\t\t/* This kprobe has gone, we couldn't enable it. */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (p != kp)\n\t\tkp->flags &= ~KPROBE_FLAG_DISABLED;\n\n\tif (!kprobes_all_disarmed && kprobe_disabled(p)) {\n\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tret = arm_kprobe(p);\n\t\tif (ret)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\t}\nout:\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "disable_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2265-2279",
    "snippet": "int disable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Disable this kprobe */\n\tp = __disable_kprobe(kp);\n\tif (IS_ERR(p))\n\t\tret = PTR_ERR(p);\n\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__disable_kprobe",
          "args": [
            "kp"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1719-1755",
          "snippet": "static struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If 'kprobes_all_disarmed' is set, 'orig_p'\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If 'kprobes_all_disarmed' is set, 'orig_p'\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nint disable_kprobe(struct kprobe *kp)\n{\n\tint ret = 0;\n\tstruct kprobe *p;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t/* Disable this kprobe */\n\tp = __disable_kprobe(kp);\n\tif (IS_ERR(p))\n\t\tret = PTR_ERR(p);\n\n\tmutex_unlock(&kprobe_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "kill_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2232-2262",
    "snippet": "static void kill_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tp->flags |= KPROBE_FLAG_GONE;\n\tif (kprobe_aggrprobe(p)) {\n\t\t/*\n\t\t * If this is an aggr_kprobe, we have to list all the\n\t\t * chained probes and mark them GONE.\n\t\t */\n\t\tlist_for_each_entry(kp, &p->list, list)\n\t\t\tkp->flags |= KPROBE_FLAG_GONE;\n\t\tp->post_handler = NULL;\n\t\tkill_optimized_kprobe(p);\n\t}\n\t/*\n\t * Here, we can remove insn_slot safely, because no thread calls\n\t * the original probed function (which will be freed soon) any more.\n\t */\n\tarch_remove_kprobe(p);\n\n\t/*\n\t * The module is going away. We should disarm the kprobe which\n\t * is using ftrace, because ftrace framework is still available at\n\t * 'MODULE_STATE_GOING' notification.\n\t */\n\tif (kprobe_ftrace(p) && !kprobe_disabled(p) && !kprobes_all_disarmed)\n\t\tdisarm_kprobe_ftrace(p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "disarm_kprobe_ftrace",
          "args": [
            "p"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1148-1151",
          "snippet": "static inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remove_kprobe",
          "args": [
            "p"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_optimized_kprobe",
          "args": [
            "p"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "kill_optimized_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "789-812",
          "snippet": "static void kill_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!list_empty(&op->list))\n\t\t/* Dequeue from the (un)optimization queue */\n\t\tlist_del_init(&op->list);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\n\tif (kprobe_unused(p)) {\n\t\t/* Enqueue if it is unused */\n\t\tlist_add(&op->list, &freeing_list);\n\t\t/*\n\t\t * Remove unused probes from the hash list. After waiting\n\t\t * for synchronization, this probe is reclaimed.\n\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t */\n\t\thlist_del_rcu(&op->kp.hlist);\n\t}\n\n\t/* Don't touch the code, because it is already freed. */\n\tarch_remove_optimized_kprobe(op);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kill_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!list_empty(&op->list))\n\t\t/* Dequeue from the (un)optimization queue */\n\t\tlist_del_init(&op->list);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\n\tif (kprobe_unused(p)) {\n\t\t/* Enqueue if it is unused */\n\t\tlist_add(&op->list, &freeing_list);\n\t\t/*\n\t\t * Remove unused probes from the hash list. After waiting\n\t\t * for synchronization, this probe is reclaimed.\n\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t */\n\t\thlist_del_rcu(&op->kp.hlist);\n\t}\n\n\t/* Don't touch the code, because it is already freed. */\n\tarch_remove_optimized_kprobe(op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 2244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "395-398",
          "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void kill_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tp->flags |= KPROBE_FLAG_GONE;\n\tif (kprobe_aggrprobe(p)) {\n\t\t/*\n\t\t * If this is an aggr_kprobe, we have to list all the\n\t\t * chained probes and mark them GONE.\n\t\t */\n\t\tlist_for_each_entry(kp, &p->list, list)\n\t\t\tkp->flags |= KPROBE_FLAG_GONE;\n\t\tp->post_handler = NULL;\n\t\tkill_optimized_kprobe(p);\n\t}\n\t/*\n\t * Here, we can remove insn_slot safely, because no thread calls\n\t * the original probed function (which will be freed soon) any more.\n\t */\n\tarch_remove_kprobe(p);\n\n\t/*\n\t * The module is going away. We should disarm the kprobe which\n\t * is using ftrace, because ftrace framework is still available at\n\t * 'MODULE_STATE_GOING' notification.\n\t */\n\tif (kprobe_ftrace(p) && !kprobe_disabled(p) && !kprobes_all_disarmed)\n\t\tdisarm_kprobe_ftrace(p);\n}"
  },
  {
    "function_name": "pre_handler_kretprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2223-2226",
    "snippet": "static int pre_handler_kretprobe(struct kprobe *p, struct pt_regs *regs)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nstatic int pre_handler_kretprobe(struct kprobe *p, struct pt_regs *regs)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "unregister_kretprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2218-2220",
    "snippet": "void unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}"
  },
  {
    "function_name": "unregister_kretprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2213-2215",
    "snippet": "void unregister_kretprobe(struct kretprobe *rp)\n{\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobe(struct kretprobe *rp)\n{\n}"
  },
  {
    "function_name": "register_kretprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2207-2210",
    "snippet": "int register_kretprobes(struct kretprobe **rps, int num)\n{\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint register_kretprobes(struct kretprobe **rps, int num)\n{\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "register_kretprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2201-2204",
    "snippet": "int register_kretprobe(struct kretprobe *rp)\n{\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint register_kretprobe(struct kretprobe *rp)\n{\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "unregister_kretprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2176-2197",
    "snippet": "void unregister_kretprobes(struct kretprobe **rps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++) {\n\t\tif (__unregister_kprobe_top(&rps[i]->kp) < 0)\n\t\t\trps[i]->kp.addr = NULL;\n\t\trps[i]->rph->rp = NULL;\n\t}\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_rcu();\n\tfor (i = 0; i < num; i++) {\n\t\tif (rps[i]->kp.addr) {\n\t\t\t__unregister_kprobe_bottom(&rps[i]->kp);\n\t\t\tfree_rp_inst(rps[i]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rp_inst",
          "args": [
            "rps[i]"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "free_rp_inst",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1310-1329",
          "snippet": "static inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct freelist_node *node;\n\tint count = 0;\n\n\tnode = rp->freelist.head;\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, freelist);\n\t\tnode = node->next;\n\n\t\tkfree(ri);\n\t\tcount++;\n\t}\n\n\tif (refcount_sub_and_test(count, &rp->rph->ref)) {\n\t\tkfree(rp->rph);\n\t\trp->rph = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct freelist_node *node;\n\tint count = 0;\n\n\tnode = rp->freelist.head;\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, freelist);\n\t\tnode = node->next;\n\n\t\tkfree(ri);\n\t\tcount++;\n\t}\n\n\tif (refcount_sub_and_test(count, &rp->rph->ref)) {\n\t\tkfree(rp->rph);\n\t\trp->rph = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_kprobe_bottom",
          "args": [
            "&rps[i]->kp"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_kprobe_bottom",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1814-1828",
          "snippet": "static void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_kprobe_top",
          "args": [
            "&rps[i]->kp"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_kprobe_top",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1760-1812",
          "snippet": "static int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid unregister_kretprobes(struct kretprobe **rps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++) {\n\t\tif (__unregister_kprobe_top(&rps[i]->kp) < 0)\n\t\t\trps[i]->kp.addr = NULL;\n\t\trps[i]->rph->rp = NULL;\n\t}\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_rcu();\n\tfor (i = 0; i < num; i++) {\n\t\tif (rps[i]->kp.addr) {\n\t\t\t__unregister_kprobe_bottom(&rps[i]->kp);\n\t\t\tfree_rp_inst(rps[i]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "unregister_kretprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2170-2173",
    "snippet": "void unregister_kretprobe(struct kretprobe *rp)\n{\n\tunregister_kretprobes(&rp, 1);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_kretprobes",
          "args": [
            "&rp",
            "1"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kretprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2218-2220",
          "snippet": "void unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobe(struct kretprobe *rp)\n{\n\tunregister_kretprobes(&rp, 1);\n}"
  },
  {
    "function_name": "register_kretprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2152-2167",
    "snippet": "int register_kretprobes(struct kretprobe **rps, int num)\n{\n\tint ret = 0, i;\n\n\tif (num <= 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kretprobe(rps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i > 0)\n\t\t\t\tunregister_kretprobes(rps, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_kretprobes",
          "args": [
            "rps",
            "i"
          ],
          "line": 2162
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kretprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2218-2220",
          "snippet": "void unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobes(struct kretprobe **rps, int num)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_kretprobe",
          "args": [
            "rps[i]"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kretprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2213-2215",
          "snippet": "void unregister_kretprobe(struct kretprobe *rp)\n{\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kretprobe(struct kretprobe *rp)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint register_kretprobes(struct kretprobe **rps, int num)\n{\n\tint ret = 0, i;\n\n\tif (num <= 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kretprobe(rps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i > 0)\n\t\t\t\tunregister_kretprobes(rps, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "register_kretprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2084-2149",
    "snippet": "int register_kretprobe(struct kretprobe *rp)\n{\n\tint ret;\n\tstruct kretprobe_instance *inst;\n\tint i;\n\tvoid *addr;\n\n\tret = kprobe_on_func_entry(rp->kp.addr, rp->kp.symbol_name, rp->kp.offset);\n\tif (ret)\n\t\treturn ret;\n\n\t/* If only 'rp->kp.addr' is specified, check reregistering kprobes */\n\tif (rp->kp.addr && warn_kprobe_rereg(&rp->kp))\n\t\treturn -EINVAL;\n\n\tif (kretprobe_blacklist_size) {\n\t\taddr = kprobe_addr(&rp->kp);\n\t\tif (IS_ERR(addr))\n\t\t\treturn PTR_ERR(addr);\n\n\t\tfor (i = 0; kretprobe_blacklist[i].name != NULL; i++) {\n\t\t\tif (kretprobe_blacklist[i].addr == addr)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (rp->data_size > KRETPROBE_MAX_DATA_SIZE)\n\t\treturn -E2BIG;\n\n\trp->kp.pre_handler = pre_handler_kretprobe;\n\trp->kp.post_handler = NULL;\n\n\t/* Pre-allocate memory for max kretprobe instances */\n\tif (rp->maxactive <= 0) {\n#ifdef CONFIG_PREEMPTION\n\t\trp->maxactive = max_t(unsigned int, 10, 2*num_possible_cpus());\n#else\n\t\trp->maxactive = num_possible_cpus();\n#endif\n\t}\n\trp->freelist.head = NULL;\n\trp->rph = kzalloc(sizeof(struct kretprobe_holder), GFP_KERNEL);\n\tif (!rp->rph)\n\t\treturn -ENOMEM;\n\n\trp->rph->rp = rp;\n\tfor (i = 0; i < rp->maxactive; i++) {\n\t\tinst = kzalloc(sizeof(struct kretprobe_instance) +\n\t\t\t       rp->data_size, GFP_KERNEL);\n\t\tif (inst == NULL) {\n\t\t\trefcount_set(&rp->rph->ref, i);\n\t\t\tfree_rp_inst(rp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tinst->rph = rp->rph;\n\t\tfreelist_add(&inst->freelist, &rp->freelist);\n\t}\n\trefcount_set(&rp->rph->ref, i);\n\n\trp->nmissed = 0;\n\t/* Establish function entry probe point */\n\tret = register_kprobe(&rp->kp);\n\tif (ret != 0)\n\t\tfree_rp_inst(rp);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_rp_inst",
          "args": [
            "rp"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "free_rp_inst",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1310-1329",
          "snippet": "static inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct freelist_node *node;\n\tint count = 0;\n\n\tnode = rp->freelist.head;\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, freelist);\n\t\tnode = node->next;\n\n\t\tkfree(ri);\n\t\tcount++;\n\t}\n\n\tif (refcount_sub_and_test(count, &rp->rph->ref)) {\n\t\tkfree(rp->rph);\n\t\trp->rph = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct freelist_node *node;\n\tint count = 0;\n\n\tnode = rp->freelist.head;\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, freelist);\n\t\tnode = node->next;\n\n\t\tkfree(ri);\n\t\tcount++;\n\t}\n\n\tif (refcount_sub_and_test(count, &rp->rph->ref)) {\n\t\tkfree(rp->rph);\n\t\trp->rph = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_kprobe",
          "args": [
            "&rp->kp"
          ],
          "line": 2145
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1848-1851",
          "snippet": "void unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&rp->rph->ref",
            "i"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freelist_add",
          "args": [
            "&inst->freelist",
            "&rp->freelist"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_set",
          "args": [
            "&rp->rph->ref",
            "i"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kretprobe_instance) +\n\t\t\t       rp->data_size",
            "GFP_KERNEL"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kretprobe_holder)",
            "GFP_KERNEL"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedint",
            "10",
            "2*num_possible_cpus()"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_tr_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1831-1865",
          "snippet": "void\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic void\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nvoid\nupdate_max_tr_single(struct trace_array *tr, struct task_struct *tsk, int cpu)\n{\n\tint ret;\n\n\tif (tr->stop_count)\n\t\treturn;\n\n\tWARN_ON_ONCE(!irqs_disabled());\n\tif (!tr->allocated_snapshot) {\n\t\t/* Only the nop tracer should hit this when disabling */\n\t\tWARN_ON_ONCE(tr->current_trace != &nop_trace);\n\t\treturn;\n\t}\n\n\tarch_spin_lock(&tr->max_lock);\n\n\tret = ring_buffer_swap_cpu(tr->max_buffer.buffer, tr->array_buffer.buffer, cpu);\n\n\tif (ret == -EBUSY) {\n\t\t/*\n\t\t * We failed to swap the buffer due to a commit taking\n\t\t * place on this CPU. We fail to record, but we reset\n\t\t * the max trace buffer (no one writes directly to it)\n\t\t * and flag that it failed.\n\t\t */\n\t\ttrace_array_printk_buf(tr->max_buffer.buffer, _THIS_IP_,\n\t\t\t\"Failed to swap buffers due to commit in progress\\n\");\n\t}\n\n\tWARN_ON_ONCE(ret && ret != -EAGAIN && ret != -EBUSY);\n\n\t__update_max_tr(tr, tsk, cpu);\n\tarch_spin_unlock(&tr->max_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "addr"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "addr"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_addr",
          "args": [
            "&rp->kp"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1517-1520",
          "snippet": "static kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "warn_kprobe_rereg",
          "args": [
            "&rp->kp"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "warn_kprobe_rereg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1551-1561",
          "snippet": "static inline int warn_kprobe_rereg(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\tif (WARN_ON_ONCE(__get_valid_kprobe(p)))\n\t\tret = -EINVAL;\n\tmutex_unlock(&kprobe_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic inline int warn_kprobe_rereg(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\tif (WARN_ON_ONCE(__get_valid_kprobe(p)))\n\t\tret = -EINVAL;\n\tmutex_unlock(&kprobe_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_on_func_entry",
          "args": [
            "rp->kp.addr",
            "rp->kp.symbol_name",
            "rp->kp.offset"
          ],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_on_func_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2068-2082",
          "snippet": "int kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn PTR_ERR(kp_addr);\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset))\n\t\treturn -ENOENT;\n\n\tif (!arch_kprobe_on_func_entry(offset))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn PTR_ERR(kp_addr);\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset))\n\t\treturn -ENOENT;\n\n\tif (!arch_kprobe_on_func_entry(offset))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint register_kretprobe(struct kretprobe *rp)\n{\n\tint ret;\n\tstruct kretprobe_instance *inst;\n\tint i;\n\tvoid *addr;\n\n\tret = kprobe_on_func_entry(rp->kp.addr, rp->kp.symbol_name, rp->kp.offset);\n\tif (ret)\n\t\treturn ret;\n\n\t/* If only 'rp->kp.addr' is specified, check reregistering kprobes */\n\tif (rp->kp.addr && warn_kprobe_rereg(&rp->kp))\n\t\treturn -EINVAL;\n\n\tif (kretprobe_blacklist_size) {\n\t\taddr = kprobe_addr(&rp->kp);\n\t\tif (IS_ERR(addr))\n\t\t\treturn PTR_ERR(addr);\n\n\t\tfor (i = 0; kretprobe_blacklist[i].name != NULL; i++) {\n\t\t\tif (kretprobe_blacklist[i].addr == addr)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (rp->data_size > KRETPROBE_MAX_DATA_SIZE)\n\t\treturn -E2BIG;\n\n\trp->kp.pre_handler = pre_handler_kretprobe;\n\trp->kp.post_handler = NULL;\n\n\t/* Pre-allocate memory for max kretprobe instances */\n\tif (rp->maxactive <= 0) {\n#ifdef CONFIG_PREEMPTION\n\t\trp->maxactive = max_t(unsigned int, 10, 2*num_possible_cpus());\n#else\n\t\trp->maxactive = num_possible_cpus();\n#endif\n\t}\n\trp->freelist.head = NULL;\n\trp->rph = kzalloc(sizeof(struct kretprobe_holder), GFP_KERNEL);\n\tif (!rp->rph)\n\t\treturn -ENOMEM;\n\n\trp->rph->rp = rp;\n\tfor (i = 0; i < rp->maxactive; i++) {\n\t\tinst = kzalloc(sizeof(struct kretprobe_instance) +\n\t\t\t       rp->data_size, GFP_KERNEL);\n\t\tif (inst == NULL) {\n\t\t\trefcount_set(&rp->rph->ref, i);\n\t\t\tfree_rp_inst(rp);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tinst->rph = rp->rph;\n\t\tfreelist_add(&inst->freelist, &rp->freelist);\n\t}\n\trefcount_set(&rp->rph->ref, i);\n\n\trp->nmissed = 0;\n\t/* Establish function entry probe point */\n\tret = register_kprobe(&rp->kp);\n\tif (ret != 0)\n\t\tfree_rp_inst(rp);\n\treturn ret;\n}"
  },
  {
    "function_name": "kprobe_on_func_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2068-2082",
    "snippet": "int kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn PTR_ERR(kp_addr);\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset))\n\t\treturn -ENOENT;\n\n\tif (!arch_kprobe_on_func_entry(offset))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kprobe_on_func_entry",
          "args": [
            "offset"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kprobe_on_func_entry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "2050-2053",
          "snippet": "bool __weak arch_kprobe_on_func_entry(unsigned long offset)\n{\n\treturn !offset;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __weak arch_kprobe_on_func_entry(unsigned long offset)\n{\n\treturn !offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kallsyms_lookup_size_offset",
          "args": [
            "(unsigned long)kp_addr",
            "NULL",
            "&offset"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "kallsyms_lookup_size_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "315-326",
          "snippet": "int kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint kallsyms_lookup_size_offset(unsigned long addr, unsigned long *symbolsize,\n\t\t\t\tunsigned long *offset)\n{\n\tchar namebuf[KSYM_NAME_LEN];\n\n\tif (is_ksym_addr(addr)) {\n\t\tget_symbol_pos(addr, symbolsize, offset);\n\t\treturn 1;\n\t}\n\treturn !!module_address_lookup(addr, symbolsize, offset, NULL, NULL, namebuf) ||\n\t       !!__bpf_address_lookup(addr, symbolsize, offset, namebuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "kp_addr"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kp_addr"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_kprobe_addr",
          "args": [
            "addr",
            "sym",
            "offset"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "_kprobe_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1497-1515",
          "snippet": "static kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_on_func_entry(kprobe_opcode_t *addr, const char *sym, unsigned long offset)\n{\n\tkprobe_opcode_t *kp_addr = _kprobe_addr(addr, sym, offset);\n\n\tif (IS_ERR(kp_addr))\n\t\treturn PTR_ERR(kp_addr);\n\n\tif (!kallsyms_lookup_size_offset((unsigned long)kp_addr, NULL, &offset))\n\t\treturn -ENOENT;\n\n\tif (!arch_kprobe_on_func_entry(offset))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_kprobe_on_func_entry",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2050-2053",
    "snippet": "bool __weak arch_kprobe_on_func_entry(unsigned long offset)\n{\n\treturn !offset;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __weak arch_kprobe_on_func_entry(unsigned long offset)\n{\n\treturn !offset;\n}"
  },
  {
    "function_name": "pre_handler_kretprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "2017-2047",
    "snippet": "NOKPROBE_SYMBOL(__kretprobe_trampoline_handler)\n\n/*\n * This kprobe pre_handler is registered with every kretprobe. When probe\n * hits it will set up the return probe.\n */\nstatic int pre_handler_kretprobe(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kretprobe *rp = container_of(p, struct kretprobe, kp);\n\tstruct kretprobe_instance *ri;\n\tstruct freelist_node *fn;\n\n\tfn = freelist_try_get(&rp->freelist);\n\tif (!fn) {\n\t\trp->nmissed++;\n\t\treturn 0;\n\t}\n\n\tri = container_of(fn, struct kretprobe_instance, freelist);\n\n\tif (rp->entry_handler && rp->entry_handler(ri, regs)) {\n\t\tfreelist_add(&ri->freelist, &rp->freelist);\n\t\treturn 0;\n\t}\n\n\tarch_prepare_kretprobe(ri, regs);\n\n\t__llist_add(&ri->llist, &current->kretprobe_instances);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__llist_add",
          "args": [
            "&ri->llist",
            "&current->kretprobe_instances"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_prepare_kretprobe",
          "args": [
            "ri",
            "regs"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freelist_add",
          "args": [
            "&ri->freelist",
            "&rp->freelist"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rp->entry_handler",
          "args": [
            "ri",
            "regs"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fn",
            "structkretprobe_instance",
            "freelist"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freelist_try_get",
          "args": [
            "&rp->freelist"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structkretprobe",
            "kp"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nNOKPROBE_SYMBOL(__kretprobe_trampoline_handler)\n\n/*\n * This kprobe pre_handler is registered with every kretprobe. When probe\n * hits it will set up the return probe.\n */\nstatic int pre_handler_kretprobe(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kretprobe *rp = container_of(p, struct kretprobe, kp);\n\tstruct kretprobe_instance *ri;\n\tstruct freelist_node *fn;\n\n\tfn = freelist_try_get(&rp->freelist);\n\tif (!fn) {\n\t\trp->nmissed++;\n\t\treturn 0;\n\t}\n\n\tri = container_of(fn, struct kretprobe_instance, freelist);\n\n\tif (rp->entry_handler && rp->entry_handler(ri, regs)) {\n\t\tfreelist_add(&ri->freelist, &rp->freelist);\n\t\treturn 0;\n\t}\n\n\tarch_prepare_kretprobe(ri, regs);\n\n\t__llist_add(&ri->llist, &current->kretprobe_instances);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__kretprobe_trampoline_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1955-2016",
    "snippet": "unsigned long __kretprobe_trampoline_handler(struct pt_regs *regs,\n\t\t\t\t\t     void *frame_pointer)\n{\n\tkprobe_opcode_t *correct_ret_addr = NULL;\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct llist_node *first, *node = NULL;\n\tstruct kretprobe *rp;\n\n\t/* Find correct address and all nodes for this frame. */\n\tcorrect_ret_addr = __kretprobe_find_ret_addr(current, &node);\n\tif (!correct_ret_addr) {\n\t\tpr_err(\"kretprobe: Return address not found, not execute handler. Maybe there is a bug in the kernel.\\n\");\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * Set the return address as the instruction pointer, because if the\n\t * user handler calls stack_trace_save_regs() with this 'regs',\n\t * the stack trace will start from the instruction pointer.\n\t */\n\tinstruction_pointer_set(regs, (unsigned long)correct_ret_addr);\n\n\t/* Run the user handler of the nodes. */\n\tfirst = current->kretprobe_instances.first;\n\twhile (first) {\n\t\tri = container_of(first, struct kretprobe_instance, llist);\n\n\t\tif (WARN_ON_ONCE(ri->fp != frame_pointer))\n\t\t\tbreak;\n\n\t\trp = get_kretprobe(ri);\n\t\tif (rp && rp->handler) {\n\t\t\tstruct kprobe *prev = kprobe_running();\n\n\t\t\t__this_cpu_write(current_kprobe, &rp->kp);\n\t\t\tri->ret_addr = correct_ret_addr;\n\t\t\trp->handler(ri, regs);\n\t\t\t__this_cpu_write(current_kprobe, prev);\n\t\t}\n\t\tif (first == node)\n\t\t\tbreak;\n\n\t\tfirst = first->next;\n\t}\n\n\tarch_kretprobe_fixup_return(regs, correct_ret_addr);\n\n\t/* Unlink all nodes for this frame. */\n\tfirst = current->kretprobe_instances.first;\n\tcurrent->kretprobe_instances.first = node->next;\n\tnode->next = NULL;\n\n\t/* Recycle free instances. */\n\twhile (first) {\n\t\tri = container_of(first, struct kretprobe_instance, llist);\n\t\tfirst = first->next;\n\n\t\trecycle_rp_inst(ri);\n\t}\n\n\treturn (unsigned long)correct_ret_addr;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recycle_rp_inst",
          "args": [
            "ri"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "recycle_rp_inst",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1250-1258",
          "snippet": "static void recycle_rp_inst(struct kretprobe_instance *ri)\n{\n\tstruct kretprobe *rp = get_kretprobe(ri);\n\n\tif (likely(rp))\n\t\tfreelist_add(&ri->freelist, &rp->freelist);\n\telse\n\t\tcall_rcu(&ri->rcu, free_rp_inst_rcu);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void recycle_rp_inst(struct kretprobe_instance *ri)\n{\n\tstruct kretprobe *rp = get_kretprobe(ri);\n\n\tif (likely(rp))\n\t\tfreelist_add(&ri->freelist, &rp->freelist);\n\telse\n\t\tcall_rcu(&ri->rcu, free_rp_inst_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "first",
            "structkretprobe_instance",
            "llist"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_kretprobe_fixup_return",
          "args": [
            "regs",
            "correct_ret_addr"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "arch_kretprobe_fixup_return",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1946-1953",
          "snippet": "void __weak arch_kretprobe_fixup_return(struct pt_regs *regs,\n\t\t\t\t\tkprobe_opcode_t *correct_ret_addr)\n{\n\t/*\n\t * Do nothing by default. Please fill this to update the fake return\n\t * address on the stack with the correct one on each arch if possible.\n\t */\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nvoid __weak arch_kretprobe_fixup_return(struct pt_regs *regs,\n\t\t\t\t\tkprobe_opcode_t *correct_ret_addr)\n{\n\t/*\n\t * Do nothing by default. Please fill this to update the fake return\n\t * address on the stack with the correct one on each arch if possible.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_kprobe",
            "prev"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rp->handler",
          "args": [
            "ri",
            "regs"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_kprobe",
            "&rp->kp"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_running",
          "args": [],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kretprobe",
          "args": [
            "ri"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ri->fp != frame_pointer"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "first",
            "structkretprobe_instance",
            "llist"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer_set",
          "args": [
            "regs",
            "(unsigned long)correct_ret_addr"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"kretprobe: Return address not found, not execute handler. Maybe there is a bug in the kernel.\\n\""
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kretprobe_find_ret_addr",
          "args": [
            "current",
            "&node"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "__kretprobe_find_ret_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1888-1908",
          "snippet": "static kprobe_opcode_t *__kretprobe_find_ret_addr(struct task_struct *tsk,\n\t\t\t\t\t\t  struct llist_node **cur)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct llist_node *node = *cur;\n\n\tif (!node)\n\t\tnode = tsk->kretprobe_instances.first;\n\telse\n\t\tnode = node->next;\n\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, llist);\n\t\tif (ri->ret_addr != kretprobe_trampoline_addr()) {\n\t\t\t*cur = node;\n\t\t\treturn ri->ret_addr;\n\t\t}\n\t\tnode = node->next;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *__kretprobe_find_ret_addr(struct task_struct *tsk,\n\t\t\t\t\t\t  struct llist_node **cur)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct llist_node *node = *cur;\n\n\tif (!node)\n\t\tnode = tsk->kretprobe_instances.first;\n\telse\n\t\tnode = node->next;\n\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, llist);\n\t\tif (ri->ret_addr != kretprobe_trampoline_addr()) {\n\t\t\t*cur = node;\n\t\t\treturn ri->ret_addr;\n\t\t}\n\t\tnode = node->next;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nunsigned long __kretprobe_trampoline_handler(struct pt_regs *regs,\n\t\t\t\t\t     void *frame_pointer)\n{\n\tkprobe_opcode_t *correct_ret_addr = NULL;\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct llist_node *first, *node = NULL;\n\tstruct kretprobe *rp;\n\n\t/* Find correct address and all nodes for this frame. */\n\tcorrect_ret_addr = __kretprobe_find_ret_addr(current, &node);\n\tif (!correct_ret_addr) {\n\t\tpr_err(\"kretprobe: Return address not found, not execute handler. Maybe there is a bug in the kernel.\\n\");\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * Set the return address as the instruction pointer, because if the\n\t * user handler calls stack_trace_save_regs() with this 'regs',\n\t * the stack trace will start from the instruction pointer.\n\t */\n\tinstruction_pointer_set(regs, (unsigned long)correct_ret_addr);\n\n\t/* Run the user handler of the nodes. */\n\tfirst = current->kretprobe_instances.first;\n\twhile (first) {\n\t\tri = container_of(first, struct kretprobe_instance, llist);\n\n\t\tif (WARN_ON_ONCE(ri->fp != frame_pointer))\n\t\t\tbreak;\n\n\t\trp = get_kretprobe(ri);\n\t\tif (rp && rp->handler) {\n\t\t\tstruct kprobe *prev = kprobe_running();\n\n\t\t\t__this_cpu_write(current_kprobe, &rp->kp);\n\t\t\tri->ret_addr = correct_ret_addr;\n\t\t\trp->handler(ri, regs);\n\t\t\t__this_cpu_write(current_kprobe, prev);\n\t\t}\n\t\tif (first == node)\n\t\t\tbreak;\n\n\t\tfirst = first->next;\n\t}\n\n\tarch_kretprobe_fixup_return(regs, correct_ret_addr);\n\n\t/* Unlink all nodes for this frame. */\n\tfirst = current->kretprobe_instances.first;\n\tcurrent->kretprobe_instances.first = node->next;\n\tnode->next = NULL;\n\n\t/* Recycle free instances. */\n\twhile (first) {\n\t\tri = container_of(first, struct kretprobe_instance, llist);\n\t\tfirst = first->next;\n\n\t\trecycle_rp_inst(ri);\n\t}\n\n\treturn (unsigned long)correct_ret_addr;\n}"
  },
  {
    "function_name": "arch_kretprobe_fixup_return",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1946-1953",
    "snippet": "void __weak arch_kretprobe_fixup_return(struct pt_regs *regs,\n\t\t\t\t\tkprobe_opcode_t *correct_ret_addr)\n{\n\t/*\n\t * Do nothing by default. Please fill this to update the fake return\n\t * address on the stack with the correct one on each arch if possible.\n\t */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nvoid __weak arch_kretprobe_fixup_return(struct pt_regs *regs,\n\t\t\t\t\tkprobe_opcode_t *correct_ret_addr)\n{\n\t/*\n\t * Do nothing by default. Please fill this to update the fake return\n\t * address on the stack with the correct one on each arch if possible.\n\t */\n}"
  },
  {
    "function_name": "kretprobe_find_ret_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1926-1943",
    "snippet": "unsigned long kretprobe_find_ret_addr(struct task_struct *tsk, void *fp,\n\t\t\t\t      struct llist_node **cur)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tkprobe_opcode_t *ret;\n\n\tif (WARN_ON_ONCE(!cur))\n\t\treturn 0;\n\n\tdo {\n\t\tret = __kretprobe_find_ret_addr(tsk, cur);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tri = container_of(*cur, struct kretprobe_instance, llist);\n\t} while (ri->fp != fp);\n\n\treturn (unsigned long)ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "*cur",
            "structkretprobe_instance",
            "llist"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kretprobe_find_ret_addr",
          "args": [
            "tsk",
            "cur"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "__kretprobe_find_ret_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1888-1908",
          "snippet": "static kprobe_opcode_t *__kretprobe_find_ret_addr(struct task_struct *tsk,\n\t\t\t\t\t\t  struct llist_node **cur)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct llist_node *node = *cur;\n\n\tif (!node)\n\t\tnode = tsk->kretprobe_instances.first;\n\telse\n\t\tnode = node->next;\n\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, llist);\n\t\tif (ri->ret_addr != kretprobe_trampoline_addr()) {\n\t\t\t*cur = node;\n\t\t\treturn ri->ret_addr;\n\t\t}\n\t\tnode = node->next;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *__kretprobe_find_ret_addr(struct task_struct *tsk,\n\t\t\t\t\t\t  struct llist_node **cur)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct llist_node *node = *cur;\n\n\tif (!node)\n\t\tnode = tsk->kretprobe_instances.first;\n\telse\n\t\tnode = node->next;\n\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, llist);\n\t\tif (ri->ret_addr != kretprobe_trampoline_addr()) {\n\t\t\t*cur = node;\n\t\t\treturn ri->ret_addr;\n\t\t}\n\t\tnode = node->next;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cur"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nunsigned long kretprobe_find_ret_addr(struct task_struct *tsk, void *fp,\n\t\t\t\t      struct llist_node **cur)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tkprobe_opcode_t *ret;\n\n\tif (WARN_ON_ONCE(!cur))\n\t\treturn 0;\n\n\tdo {\n\t\tret = __kretprobe_find_ret_addr(tsk, cur);\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tri = container_of(*cur, struct kretprobe_instance, llist);\n\t} while (ri->fp != fp);\n\n\treturn (unsigned long)ret;\n}"
  },
  {
    "function_name": "__kretprobe_find_ret_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1888-1908",
    "snippet": "static kprobe_opcode_t *__kretprobe_find_ret_addr(struct task_struct *tsk,\n\t\t\t\t\t\t  struct llist_node **cur)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct llist_node *node = *cur;\n\n\tif (!node)\n\t\tnode = tsk->kretprobe_instances.first;\n\telse\n\t\tnode = node->next;\n\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, llist);\n\t\tif (ri->ret_addr != kretprobe_trampoline_addr()) {\n\t\t\t*cur = node;\n\t\t\treturn ri->ret_addr;\n\t\t}\n\t\tnode = node->next;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kretprobe_trampoline_addr",
          "args": [],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structkretprobe_instance",
            "llist"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *__kretprobe_find_ret_addr(struct task_struct *tsk,\n\t\t\t\t\t\t  struct llist_node **cur)\n{\n\tstruct kretprobe_instance *ri = NULL;\n\tstruct llist_node *node = *cur;\n\n\tif (!node)\n\t\tnode = tsk->kretprobe_instances.first;\n\telse\n\t\tnode = node->next;\n\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, llist);\n\t\tif (ri->ret_addr != kretprobe_trampoline_addr()) {\n\t\t\t*cur = node;\n\t\t\treturn ri->ret_addr;\n\t\t}\n\t\tnode = node->next;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "kprobe_exceptions_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1873-1877",
    "snippet": "int __weak kprobe_exceptions_notify(struct notifier_block *self,\n\t\t\t\t\tunsigned long val, void *data)\n{\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __weak kprobe_exceptions_notify(struct notifier_block *self,\n\t\t\t\t\tunsigned long val, void *data)\n{\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "unregister_kprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1854-1870",
    "snippet": "void unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_rcu();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__unregister_kprobe_bottom",
          "args": [
            "kps[i]"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_kprobe_bottom",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1814-1828",
          "snippet": "static void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__unregister_kprobe_top",
          "args": [
            "kps[i]"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_kprobe_top",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1760-1812",
          "snippet": "static int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_rcu();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}"
  },
  {
    "function_name": "unregister_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1848-1851",
    "snippet": "void unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_kprobes",
          "args": [
            "&p",
            "1"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1854-1870",
          "snippet": "void unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_rcu();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_rcu();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}"
  },
  {
    "function_name": "register_kprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1830-1845",
    "snippet": "int register_kprobes(struct kprobe **kps, int num)\n{\n\tint i, ret = 0;\n\n\tif (num <= 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kprobe(kps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i > 0)\n\t\t\t\tunregister_kprobes(kps, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_kprobes",
          "args": [
            "kps",
            "i"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1854-1870",
          "snippet": "void unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_rcu();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid unregister_kprobes(struct kprobe **kps, int num)\n{\n\tint i;\n\n\tif (num <= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->addr = NULL;\n\tmutex_unlock(&kprobe_mutex);\n\n\tsynchronize_rcu();\n\tfor (i = 0; i < num; i++)\n\t\tif (kps[i]->addr)\n\t\t\t__unregister_kprobe_bottom(kps[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_kprobe",
          "args": [
            "kps[i]"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1848-1851",
          "snippet": "void unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid unregister_kprobe(struct kprobe *p)\n{\n\tunregister_kprobes(&p, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint register_kprobes(struct kprobe **kps, int num)\n{\n\tint i, ret = 0;\n\n\tif (num <= 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kprobe(kps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i > 0)\n\t\t\t\tunregister_kprobes(kps, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__unregister_kprobe_bottom",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1814-1828",
    "snippet": "static void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_aggr_kprobe",
          "args": [
            "ap"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "free_aggr_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1049-1053",
          "snippet": "static void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&p->list"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/fair.c",
          "lines": "475-477",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);",
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool sched_idle_cfs_rq(struct cfs_rq *cfs_rq);\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p->list.next",
            "structkprobe",
            "list"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&p->list"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_remove_kprobe",
          "args": [
            "p"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&p->list"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void __unregister_kprobe_bottom(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\n\tif (list_empty(&p->list))\n\t\t/* This is an independent kprobe */\n\t\tarch_remove_kprobe(p);\n\telse if (list_is_singular(&p->list)) {\n\t\t/* This is the last child of an aggrprobe */\n\t\tap = list_entry(p->list.next, struct kprobe, list);\n\t\tlist_del(&p->list);\n\t\tfree_aggr_kprobe(ap);\n\t}\n\t/* Otherwise, do nothing. */\n}"
  },
  {
    "function_name": "__unregister_kprobe_top",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1760-1812",
    "snippet": "static int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&ap->hlist"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "ap"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "852-885",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "ap"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&p->list"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "list_p",
            "&ap->list",
            "list"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "p"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disarmed",
          "args": [
            "ap"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_disarmed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "461-472",
          "snippet": "static inline bool kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&ap->list"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!kprobe_aggrprobe(ap)"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "ap"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "395-398",
          "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ap"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ap"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__disable_kprobe",
          "args": [
            "p"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "__disable_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1719-1755",
          "snippet": "static struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If 'kprobes_all_disarmed' is set, 'orig_p'\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If 'kprobes_all_disarmed' is set, 'orig_p'\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic int __unregister_kprobe_top(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\t/* Disable kprobe. This will disarm it if needed. */\n\tap = __disable_kprobe(p);\n\tif (IS_ERR(ap))\n\t\treturn PTR_ERR(ap);\n\n\tif (ap == p)\n\t\t/*\n\t\t * This probe is an independent(and non-optimized) kprobe\n\t\t * (not an aggrprobe). Remove from the hash list.\n\t\t */\n\t\tgoto disarmed;\n\n\t/* Following process expects this probe is an aggrprobe */\n\tWARN_ON(!kprobe_aggrprobe(ap));\n\n\tif (list_is_singular(&ap->list) && kprobe_disarmed(ap))\n\t\t/*\n\t\t * !disarmed could be happen if the probe is under delayed\n\t\t * unoptimizing.\n\t\t */\n\t\tgoto disarmed;\n\telse {\n\t\t/* If disabling probe has special handlers, update aggrprobe */\n\t\tif (p->post_handler && !kprobe_gone(p)) {\n\t\t\tlist_for_each_entry(list_p, &ap->list, list) {\n\t\t\t\tif ((list_p != p) && (list_p->post_handler))\n\t\t\t\t\tgoto noclean;\n\t\t\t}\n\t\t\tap->post_handler = NULL;\n\t\t}\nnoclean:\n\t\t/*\n\t\t * Remove from the aggrprobe: this path will do nothing in\n\t\t * __unregister_kprobe_bottom().\n\t\t */\n\t\tlist_del_rcu(&p->list);\n\t\tif (!kprobe_disabled(ap) && !kprobes_all_disarmed)\n\t\t\t/*\n\t\t\t * Try to optimize this probe again, because post\n\t\t\t * handler may have been changed.\n\t\t\t */\n\t\t\toptimize_kprobe(ap);\n\t}\n\treturn 0;\n\ndisarmed:\n\thlist_del_rcu(&ap->hlist);\n\treturn 0;\n}"
  },
  {
    "function_name": "__disable_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1719-1755",
    "snippet": "static struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If 'kprobes_all_disarmed' is set, 'orig_p'\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disarm_kprobe",
          "args": [
            "orig_p",
            "true"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1177-1189",
          "snippet": "static int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aggr_kprobe_disabled",
          "args": [
            "orig_p"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "orig_p == NULL"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_valid_kprobe",
          "args": [
            "p"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "__get_valid_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1526-1545",
          "snippet": "static struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic struct kprobe *__disable_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *orig_p;\n\tint ret;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\t/* Get an original kprobe for return */\n\torig_p = __get_valid_kprobe(p);\n\tif (unlikely(orig_p == NULL))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!kprobe_disabled(p)) {\n\t\t/* Disable probe if it is a child probe */\n\t\tif (p != orig_p)\n\t\t\tp->flags |= KPROBE_FLAG_DISABLED;\n\n\t\t/* Try to disarm and disable this/parent probe */\n\t\tif (p == orig_p || aggr_kprobe_disabled(orig_p)) {\n\t\t\t/*\n\t\t\t * If 'kprobes_all_disarmed' is set, 'orig_p'\n\t\t\t * should have already been disarmed, so\n\t\t\t * skip unneed disarming process.\n\t\t\t */\n\t\t\tif (!kprobes_all_disarmed) {\n\t\t\t\tret = disarm_kprobe(orig_p, true);\n\t\t\t\tif (ret) {\n\t\t\t\t\tp->flags &= ~KPROBE_FLAG_DISABLED;\n\t\t\t\t\treturn ERR_PTR(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\torig_p->flags |= KPROBE_FLAG_DISABLED;\n\t\t}\n\t}\n\n\treturn orig_p;\n}"
  },
  {
    "function_name": "aggr_kprobe_disabled",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1702-1717",
    "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "kp"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kp",
            "&ap->list",
            "list"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "register_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1632-1698",
    "snippet": "int register_kprobe(struct kprobe *p)\n{\n\tint ret;\n\tstruct kprobe *old_p;\n\tstruct module *probed_mod;\n\tkprobe_opcode_t *addr;\n\n\t/* Adjust probe address from symbol */\n\taddr = kprobe_addr(p);\n\tif (IS_ERR(addr))\n\t\treturn PTR_ERR(addr);\n\tp->addr = addr;\n\n\tret = warn_kprobe_rereg(p);\n\tif (ret)\n\t\treturn ret;\n\n\t/* User can pass only KPROBE_FLAG_DISABLED to register_kprobe */\n\tp->flags &= KPROBE_FLAG_DISABLED;\n\tp->nmissed = 0;\n\tINIT_LIST_HEAD(&p->list);\n\n\tret = check_kprobe_address_safe(p, &probed_mod);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&kprobe_mutex);\n\n\told_p = get_kprobe(p->addr);\n\tif (old_p) {\n\t\t/* Since this may unoptimize 'old_p', locking 'text_mutex'. */\n\t\tret = register_aggr_kprobe(old_p, p);\n\t\tgoto out;\n\t}\n\n\tcpus_read_lock();\n\t/* Prevent text modification */\n\tmutex_lock(&text_mutex);\n\tret = prepare_kprobe(p);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\tif (ret)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&p->hlist);\n\thlist_add_head_rcu(&p->hlist,\n\t\t       &kprobe_table[hash_ptr(p->addr, KPROBE_HASH_BITS)]);\n\n\tif (!kprobes_all_disarmed && !kprobe_disabled(p)) {\n\t\tret = arm_kprobe(p);\n\t\tif (ret) {\n\t\t\thlist_del_rcu(&p->hlist);\n\t\t\tsynchronize_rcu();\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Try to optimize kprobe */\n\ttry_to_optimize_kprobe(p);\nout:\n\tmutex_unlock(&kprobe_mutex);\n\n\tif (probed_mod)\n\t\tmodule_put(probed_mod);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_HASH_BITS 6"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static bool kprobes_all_disarmed;",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "probed_mod"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1087-1098",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_optimize_kprobe",
          "args": [
            "p"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "852-885",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&p->hlist"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arm_kprobe",
          "args": [
            "p"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "arm_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1163-1175",
          "snippet": "static int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&p->hlist",
            "&kprobe_table[hash_ptr(p->addr, KPROBE_HASH_BITS)]"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "p->addr",
            "KPROBE_HASH_BITS"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&p->hlist"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_kprobe",
          "args": [
            "p"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1154-1161",
          "snippet": "static int prepare_kprobe(struct kprobe *p)\n{\n\t/* Must ensure p->addr is really on ftrace */\n\tif (kprobe_ftrace(p))\n\t\treturn arch_prepare_kprobe_ftrace(p);\n\n\treturn arch_prepare_kprobe(p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int prepare_kprobe(struct kprobe *p)\n{\n\t/* Must ensure p->addr is really on ftrace */\n\tif (kprobe_ftrace(p))\n\t\treturn arch_prepare_kprobe_ftrace(p);\n\n\treturn arch_prepare_kprobe(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_aggr_kprobe",
          "args": [
            "old_p",
            "p"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "register_aggr_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1370-1445",
          "snippet": "static int register_aggr_kprobe(struct kprobe *orig_p, struct kprobe *p)\n{\n\tint ret = 0;\n\tstruct kprobe *ap = orig_p;\n\n\tcpus_read_lock();\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tif (!kprobe_aggrprobe(orig_p)) {\n\t\t/* If 'orig_p' is not an 'aggr_kprobe', create new one. */\n\t\tap = alloc_aggr_kprobe(orig_p);\n\t\tif (!ap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_aggr_kprobe(ap, orig_p);\n\t} else if (kprobe_unused(ap)) {\n\t\t/* This probe is going to die. Rescue it */\n\t\tret = reuse_unused_kprobe(ap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(ap)) {\n\t\t/*\n\t\t * Attempting to insert new probe at the same location that\n\t\t * had a probe in the module vaddr area which already\n\t\t * freed. So, the instruction slot has already been\n\t\t * released. We need a new slot for the new probe.\n\t\t */\n\t\tret = arch_prepare_kprobe(ap);\n\t\tif (ret)\n\t\t\t/*\n\t\t\t * Even if fail to allocate new slot, don't need to\n\t\t\t * free the 'ap'. It will be used next time, or\n\t\t\t * freed by unregister_kprobe().\n\t\t\t */\n\t\t\tgoto out;\n\n\t\t/* Prepare optimized instructions if possible. */\n\t\tprepare_optimized_kprobe(ap);\n\n\t\t/*\n\t\t * Clear gone flag to prevent allocating new slot again, and\n\t\t * set disabled flag because it is not armed yet.\n\t\t */\n\t\tap->flags = (ap->flags & ~KPROBE_FLAG_GONE)\n\t\t\t    | KPROBE_FLAG_DISABLED;\n\t}\n\n\t/* Copy the insn slot of 'p' to 'ap'. */\n\tcopy_kprobe(ap, p);\n\tret = add_new_kprobe(ap, p);\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n\n\tif (ret == 0 && kprobe_disabled(ap) && !kprobe_disabled(p)) {\n\t\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tif (!kprobes_all_disarmed) {\n\t\t\t/* Arm the breakpoint again. */\n\t\t\tret = arm_kprobe(ap);\n\t\t\tif (ret) {\n\t\t\t\tap->flags |= KPROBE_FLAG_DISABLED;\n\t\t\t\tlist_del_rcu(&p->list);\n\t\t\t\tsynchronize_rcu();\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic int register_aggr_kprobe(struct kprobe *orig_p, struct kprobe *p)\n{\n\tint ret = 0;\n\tstruct kprobe *ap = orig_p;\n\n\tcpus_read_lock();\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tif (!kprobe_aggrprobe(orig_p)) {\n\t\t/* If 'orig_p' is not an 'aggr_kprobe', create new one. */\n\t\tap = alloc_aggr_kprobe(orig_p);\n\t\tif (!ap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_aggr_kprobe(ap, orig_p);\n\t} else if (kprobe_unused(ap)) {\n\t\t/* This probe is going to die. Rescue it */\n\t\tret = reuse_unused_kprobe(ap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(ap)) {\n\t\t/*\n\t\t * Attempting to insert new probe at the same location that\n\t\t * had a probe in the module vaddr area which already\n\t\t * freed. So, the instruction slot has already been\n\t\t * released. We need a new slot for the new probe.\n\t\t */\n\t\tret = arch_prepare_kprobe(ap);\n\t\tif (ret)\n\t\t\t/*\n\t\t\t * Even if fail to allocate new slot, don't need to\n\t\t\t * free the 'ap'. It will be used next time, or\n\t\t\t * freed by unregister_kprobe().\n\t\t\t */\n\t\t\tgoto out;\n\n\t\t/* Prepare optimized instructions if possible. */\n\t\tprepare_optimized_kprobe(ap);\n\n\t\t/*\n\t\t * Clear gone flag to prevent allocating new slot again, and\n\t\t * set disabled flag because it is not armed yet.\n\t\t */\n\t\tap->flags = (ap->flags & ~KPROBE_FLAG_GONE)\n\t\t\t    | KPROBE_FLAG_DISABLED;\n\t}\n\n\t/* Copy the insn slot of 'p' to 'ap'. */\n\tcopy_kprobe(ap, p);\n\tret = add_new_kprobe(ap, p);\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n\n\tif (ret == 0 && kprobe_disabled(ap) && !kprobe_disabled(p)) {\n\t\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tif (!kprobes_all_disarmed) {\n\t\t\t/* Arm the breakpoint again. */\n\t\t\tret = arm_kprobe(ap);\n\t\t\tif (ret) {\n\t\t\t\tap->flags |= KPROBE_FLAG_DISABLED;\n\t\t\t\tlist_del_rcu(&p->list);\n\t\t\t\tsynchronize_rcu();\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kprobe",
          "args": [
            "p->addr"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "get_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "376-389",
          "snippet": "struct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist,\n\t\t\t\t lockdep_is_held(&kprobe_mutex)) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_HASH_BITS 6"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstruct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist,\n\t\t\t\t lockdep_is_held(&kprobe_mutex)) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_kprobe_address_safe",
          "args": [
            "p",
            "&probed_mod"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "check_kprobe_address_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1581-1630",
          "snippet": "static int check_kprobe_address_safe(struct kprobe *p,\n\t\t\t\t     struct module **probed_mod)\n{\n\tint ret;\n\n\tret = check_ftrace_location(p);\n\tif (ret)\n\t\treturn ret;\n\tjump_label_lock();\n\tpreempt_disable();\n\n\t/* Ensure it is not in reserved area nor out of text */\n\tif (!kernel_text_address((unsigned long) p->addr) ||\n\t    within_kprobe_blacklist((unsigned long) p->addr) ||\n\t    jump_label_text_reserved(p->addr, p->addr) ||\n\t    static_call_text_reserved(p->addr, p->addr) ||\n\t    find_bug((unsigned long)p->addr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if 'p' is probing a module. */\n\t*probed_mod = __module_text_address((unsigned long) p->addr);\n\tif (*probed_mod) {\n\t\t/*\n\t\t * We must hold a refcount of the probed module while updating\n\t\t * its code to prohibit unexpected unloading.\n\t\t */\n\t\tif (unlikely(!try_module_get(*probed_mod))) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * If the module freed '.init.text', we couldn't insert\n\t\t * kprobes in there.\n\t\t */\n\t\tif (within_module_init((unsigned long)p->addr, *probed_mod) &&\n\t\t    (*probed_mod)->state != MODULE_STATE_COMING) {\n\t\t\tmodule_put(*probed_mod);\n\t\t\t*probed_mod = NULL;\n\t\t\tret = -ENOENT;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\tjump_label_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int check_kprobe_address_safe(struct kprobe *p,\n\t\t\t\t     struct module **probed_mod)\n{\n\tint ret;\n\n\tret = check_ftrace_location(p);\n\tif (ret)\n\t\treturn ret;\n\tjump_label_lock();\n\tpreempt_disable();\n\n\t/* Ensure it is not in reserved area nor out of text */\n\tif (!kernel_text_address((unsigned long) p->addr) ||\n\t    within_kprobe_blacklist((unsigned long) p->addr) ||\n\t    jump_label_text_reserved(p->addr, p->addr) ||\n\t    static_call_text_reserved(p->addr, p->addr) ||\n\t    find_bug((unsigned long)p->addr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if 'p' is probing a module. */\n\t*probed_mod = __module_text_address((unsigned long) p->addr);\n\tif (*probed_mod) {\n\t\t/*\n\t\t * We must hold a refcount of the probed module while updating\n\t\t * its code to prohibit unexpected unloading.\n\t\t */\n\t\tif (unlikely(!try_module_get(*probed_mod))) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * If the module freed '.init.text', we couldn't insert\n\t\t * kprobes in there.\n\t\t */\n\t\tif (within_module_init((unsigned long)p->addr, *probed_mod) &&\n\t\t    (*probed_mod)->state != MODULE_STATE_COMING) {\n\t\t\tmodule_put(*probed_mod);\n\t\t\t*probed_mod = NULL;\n\t\t\tret = -ENOENT;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\tjump_label_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&p->list"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "warn_kprobe_rereg",
          "args": [
            "p"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "warn_kprobe_rereg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1551-1561",
          "snippet": "static inline int warn_kprobe_rereg(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\tif (WARN_ON_ONCE(__get_valid_kprobe(p)))\n\t\tret = -EINVAL;\n\tmutex_unlock(&kprobe_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic inline int warn_kprobe_rereg(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\tif (WARN_ON_ONCE(__get_valid_kprobe(p)))\n\t\tret = -EINVAL;\n\tmutex_unlock(&kprobe_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "addr"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "addr"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_addr",
          "args": [
            "p"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1517-1520",
          "snippet": "static kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic bool kprobes_all_disarmed;\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nint register_kprobe(struct kprobe *p)\n{\n\tint ret;\n\tstruct kprobe *old_p;\n\tstruct module *probed_mod;\n\tkprobe_opcode_t *addr;\n\n\t/* Adjust probe address from symbol */\n\taddr = kprobe_addr(p);\n\tif (IS_ERR(addr))\n\t\treturn PTR_ERR(addr);\n\tp->addr = addr;\n\n\tret = warn_kprobe_rereg(p);\n\tif (ret)\n\t\treturn ret;\n\n\t/* User can pass only KPROBE_FLAG_DISABLED to register_kprobe */\n\tp->flags &= KPROBE_FLAG_DISABLED;\n\tp->nmissed = 0;\n\tINIT_LIST_HEAD(&p->list);\n\n\tret = check_kprobe_address_safe(p, &probed_mod);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&kprobe_mutex);\n\n\told_p = get_kprobe(p->addr);\n\tif (old_p) {\n\t\t/* Since this may unoptimize 'old_p', locking 'text_mutex'. */\n\t\tret = register_aggr_kprobe(old_p, p);\n\t\tgoto out;\n\t}\n\n\tcpus_read_lock();\n\t/* Prevent text modification */\n\tmutex_lock(&text_mutex);\n\tret = prepare_kprobe(p);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\tif (ret)\n\t\tgoto out;\n\n\tINIT_HLIST_NODE(&p->hlist);\n\thlist_add_head_rcu(&p->hlist,\n\t\t       &kprobe_table[hash_ptr(p->addr, KPROBE_HASH_BITS)]);\n\n\tif (!kprobes_all_disarmed && !kprobe_disabled(p)) {\n\t\tret = arm_kprobe(p);\n\t\tif (ret) {\n\t\t\thlist_del_rcu(&p->hlist);\n\t\t\tsynchronize_rcu();\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Try to optimize kprobe */\n\ttry_to_optimize_kprobe(p);\nout:\n\tmutex_unlock(&kprobe_mutex);\n\n\tif (probed_mod)\n\t\tmodule_put(probed_mod);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "check_kprobe_address_safe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1581-1630",
    "snippet": "static int check_kprobe_address_safe(struct kprobe *p,\n\t\t\t\t     struct module **probed_mod)\n{\n\tint ret;\n\n\tret = check_ftrace_location(p);\n\tif (ret)\n\t\treturn ret;\n\tjump_label_lock();\n\tpreempt_disable();\n\n\t/* Ensure it is not in reserved area nor out of text */\n\tif (!kernel_text_address((unsigned long) p->addr) ||\n\t    within_kprobe_blacklist((unsigned long) p->addr) ||\n\t    jump_label_text_reserved(p->addr, p->addr) ||\n\t    static_call_text_reserved(p->addr, p->addr) ||\n\t    find_bug((unsigned long)p->addr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if 'p' is probing a module. */\n\t*probed_mod = __module_text_address((unsigned long) p->addr);\n\tif (*probed_mod) {\n\t\t/*\n\t\t * We must hold a refcount of the probed module while updating\n\t\t * its code to prohibit unexpected unloading.\n\t\t */\n\t\tif (unlikely(!try_module_get(*probed_mod))) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * If the module freed '.init.text', we couldn't insert\n\t\t * kprobes in there.\n\t\t */\n\t\tif (within_module_init((unsigned long)p->addr, *probed_mod) &&\n\t\t    (*probed_mod)->state != MODULE_STATE_COMING) {\n\t\t\tmodule_put(*probed_mod);\n\t\t\t*probed_mod = NULL;\n\t\t\tret = -ENOENT;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\tjump_label_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "30-33",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(jump_label_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic DEFINE_MUTEX(jump_label_mutex);\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "*probed_mod"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1087-1098",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_module_init",
          "args": [
            "(unsigned long)p->addr",
            "*probed_mod"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!try_module_get(*probed_mod)"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "*probed_mod"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__module_text_address",
          "args": [
            "(unsigned long) p->addr"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "__module_text_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "4780-4790",
          "snippet": "struct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t/* Make sure it's within the text section. */\n\t\tif (!within(addr, mod->init_layout.base, mod->init_layout.text_size)\n\t\t    && !within(addr, mod->core_layout.base, mod->core_layout.text_size))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cfi_cleanup(struct module *mod);",
            "static void cfi_init(struct module *mod);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic void cfi_cleanup(struct module *mod);\nstatic void cfi_init(struct module *mod);\n\nstruct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t/* Make sure it's within the text section. */\n\t\tif (!within(addr, mod->init_layout.base, mod->init_layout.text_size)\n\t\t    && !within(addr, mod->core_layout.base, mod->core_layout.text_size))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_bug",
          "args": [
            "(unsigned long)p->addr"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_call_text_reserved",
          "args": [
            "p->addr",
            "p->addr"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "static_call_text_reserved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/static_call.c",
          "lines": "462-472",
          "snippet": "int static_call_text_reserved(void *start, void *end)\n{\n\tbool init = system_state < SYSTEM_RUNNING;\n\tint ret = __static_call_text_reserved(__start_static_call_sites,\n\t\t\t__stop_static_call_sites, start, end, init);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn __static_call_mod_text_reserved(start, end);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/processor.h>",
            "#include <linux/cpu.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/smp.h>",
            "#include <linux/bug.h>",
            "#include <linux/static_call.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct static_call_site __start_static_call_sites[],\n\t\t\t       __stop_static_call_sites[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/processor.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/smp.h>\n#include <linux/bug.h>\n#include <linux/static_call.h>\n#include <linux/init.h>\n\nextern struct static_call_site __start_static_call_sites[],\n\t\t\t       __stop_static_call_sites[];\n\nint static_call_text_reserved(void *start, void *end)\n{\n\tbool init = system_state < SYSTEM_RUNNING;\n\tint ret = __static_call_text_reserved(__start_static_call_sites,\n\t\t\t__stop_static_call_sites, start, end, init);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn __static_call_mod_text_reserved(start, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_text_reserved",
          "args": [
            "p->addr",
            "p->addr"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_text_reserved",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "791-804",
          "snippet": "int jump_label_text_reserved(void *start, void *end)\n{\n\tbool init = system_state < SYSTEM_RUNNING;\n\tint ret = __jump_label_text_reserved(__start___jump_table,\n\t\t\t__stop___jump_table, start, end, init);\n\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = __jump_label_mod_text_reserved(start, end);\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nint jump_label_text_reserved(void *start, void *end)\n{\n\tbool init = system_state < SYSTEM_RUNNING;\n\tint ret = __jump_label_text_reserved(__start___jump_table,\n\t\t\t__stop___jump_table, start, end, init);\n\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = __jump_label_mod_text_reserved(start, end);\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_kprobe_blacklist",
          "args": [
            "(unsigned long) p->addr"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "within_kprobe_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1471-1489",
          "snippet": "bool within_kprobe_blacklist(unsigned long addr)\n{\n\tchar symname[KSYM_NAME_LEN], *p;\n\n\tif (__within_kprobe_blacklist(addr))\n\t\treturn true;\n\n\t/* Check if the address is on a suffixed-symbol */\n\tif (!lookup_symbol_name(addr, symname)) {\n\t\tp = strchr(symname, '.');\n\t\tif (!p)\n\t\t\treturn false;\n\t\t*p = '\\0';\n\t\taddr = (unsigned long)kprobe_lookup_name(symname, 0);\n\t\tif (addr)\n\t\t\treturn __within_kprobe_blacklist(addr);\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool within_kprobe_blacklist(unsigned long addr)\n{\n\tchar symname[KSYM_NAME_LEN], *p;\n\n\tif (__within_kprobe_blacklist(addr))\n\t\treturn true;\n\n\t/* Check if the address is on a suffixed-symbol */\n\tif (!lookup_symbol_name(addr, symname)) {\n\t\tp = strchr(symname, '.');\n\t\tif (!p)\n\t\t\treturn false;\n\t\t*p = '\\0';\n\t\taddr = (unsigned long)kprobe_lookup_name(symname, 0);\n\t\tif (addr)\n\t\t\treturn __within_kprobe_blacklist(addr);\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_text_address",
          "args": [
            "(unsigned long) p->addr"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_text_address",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/extable.c",
          "lines": "93-132",
          "snippet": "int kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots,\n\t * is_bpf_text_address() and is_bpf_image_address require\n\t * RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/sections.h>",
            "#include <linux/filter.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/extable.h>",
            "#include <linux/memory.h>",
            "#include <linux/ftrace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <linux/filter.h>\n#include <linux/kprobes.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/extable.h>\n#include <linux/memory.h>\n#include <linux/ftrace.h>\n\nint kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots,\n\t * is_bpf_text_address() and is_bpf_image_address require\n\t * RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "25-28",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(jump_label_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic DEFINE_MUTEX(jump_label_mutex);\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_ftrace_location",
          "args": [
            "p"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "check_ftrace_location",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1563-1579",
          "snippet": "static int check_ftrace_location(struct kprobe *p)\n{\n\tunsigned long ftrace_addr;\n\n\tftrace_addr = ftrace_location((unsigned long)p->addr);\n\tif (ftrace_addr) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\t/* Given address is not on the instruction boundary */\n\t\tif ((unsigned long)p->addr != ftrace_addr)\n\t\t\treturn -EILSEQ;\n\t\tp->flags |= KPROBE_FLAG_FTRACE;\n#else\t/* !CONFIG_KPROBES_ON_FTRACE */\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int check_ftrace_location(struct kprobe *p)\n{\n\tunsigned long ftrace_addr;\n\n\tftrace_addr = ftrace_location((unsigned long)p->addr);\n\tif (ftrace_addr) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\t/* Given address is not on the instruction boundary */\n\t\tif ((unsigned long)p->addr != ftrace_addr)\n\t\t\treturn -EILSEQ;\n\t\tp->flags |= KPROBE_FLAG_FTRACE;\n#else\t/* !CONFIG_KPROBES_ON_FTRACE */\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int check_kprobe_address_safe(struct kprobe *p,\n\t\t\t\t     struct module **probed_mod)\n{\n\tint ret;\n\n\tret = check_ftrace_location(p);\n\tif (ret)\n\t\treturn ret;\n\tjump_label_lock();\n\tpreempt_disable();\n\n\t/* Ensure it is not in reserved area nor out of text */\n\tif (!kernel_text_address((unsigned long) p->addr) ||\n\t    within_kprobe_blacklist((unsigned long) p->addr) ||\n\t    jump_label_text_reserved(p->addr, p->addr) ||\n\t    static_call_text_reserved(p->addr, p->addr) ||\n\t    find_bug((unsigned long)p->addr)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t/* Check if 'p' is probing a module. */\n\t*probed_mod = __module_text_address((unsigned long) p->addr);\n\tif (*probed_mod) {\n\t\t/*\n\t\t * We must hold a refcount of the probed module while updating\n\t\t * its code to prohibit unexpected unloading.\n\t\t */\n\t\tif (unlikely(!try_module_get(*probed_mod))) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * If the module freed '.init.text', we couldn't insert\n\t\t * kprobes in there.\n\t\t */\n\t\tif (within_module_init((unsigned long)p->addr, *probed_mod) &&\n\t\t    (*probed_mod)->state != MODULE_STATE_COMING) {\n\t\t\tmodule_put(*probed_mod);\n\t\t\t*probed_mod = NULL;\n\t\t\tret = -ENOENT;\n\t\t}\n\t}\nout:\n\tpreempt_enable();\n\tjump_label_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "check_ftrace_location",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1563-1579",
    "snippet": "static int check_ftrace_location(struct kprobe *p)\n{\n\tunsigned long ftrace_addr;\n\n\tftrace_addr = ftrace_location((unsigned long)p->addr);\n\tif (ftrace_addr) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\t/* Given address is not on the instruction boundary */\n\t\tif ((unsigned long)p->addr != ftrace_addr)\n\t\t\treturn -EILSEQ;\n\t\tp->flags |= KPROBE_FLAG_FTRACE;\n#else\t/* !CONFIG_KPROBES_ON_FTRACE */\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_location",
          "args": [
            "(unsigned long)p->addr"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "check_ftrace_location",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1563-1579",
          "snippet": "static int check_ftrace_location(struct kprobe *p)\n{\n\tunsigned long ftrace_addr;\n\n\tftrace_addr = ftrace_location((unsigned long)p->addr);\n\tif (ftrace_addr) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\t/* Given address is not on the instruction boundary */\n\t\tif ((unsigned long)p->addr != ftrace_addr)\n\t\t\treturn -EILSEQ;\n\t\tp->flags |= KPROBE_FLAG_FTRACE;\n#else\t/* !CONFIG_KPROBES_ON_FTRACE */\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int check_ftrace_location(struct kprobe *p)\n{\n\tunsigned long ftrace_addr;\n\n\tftrace_addr = ftrace_location((unsigned long)p->addr);\n\tif (ftrace_addr) {\n#ifdef CONFIG_KPROBES_ON_FTRACE\n\t\t/* Given address is not on the instruction boundary */\n\t\tif ((unsigned long)p->addr != ftrace_addr)\n\t\t\treturn -EILSEQ;\n\t\tp->flags |= KPROBE_FLAG_FTRACE;\n#else\t/* !CONFIG_KPROBES_ON_FTRACE */\n\t\treturn -EINVAL;\n#endif\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "warn_kprobe_rereg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1551-1561",
    "snippet": "static inline int warn_kprobe_rereg(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\tif (WARN_ON_ONCE(__get_valid_kprobe(p)))\n\t\tret = -EINVAL;\n\tmutex_unlock(&kprobe_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "__get_valid_kprobe(p)"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_valid_kprobe",
          "args": [
            "p"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "__get_valid_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1526-1545",
          "snippet": "static struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic inline int warn_kprobe_rereg(struct kprobe *p)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kprobe_mutex);\n\tif (WARN_ON_ONCE(__get_valid_kprobe(p)))\n\t\tret = -EINVAL;\n\tmutex_unlock(&kprobe_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__get_valid_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1526-1545",
    "snippet": "static struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "list_p",
            "&ap->list",
            "list"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ap"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kprobe",
          "args": [
            "p->addr"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "get_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "376-389",
          "snippet": "struct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist,\n\t\t\t\t lockdep_is_held(&kprobe_mutex)) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_HASH_BITS 6"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstruct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist,\n\t\t\t\t lockdep_is_held(&kprobe_mutex)) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic struct kprobe *__get_valid_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap, *list_p;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tap = get_kprobe(p->addr);\n\tif (unlikely(!ap))\n\t\treturn NULL;\n\n\tif (p != ap) {\n\t\tlist_for_each_entry(list_p, &ap->list, list)\n\t\t\tif (list_p == p)\n\t\t\t/* kprobe p is a valid probe */\n\t\t\t\tgoto valid;\n\t\treturn NULL;\n\t}\nvalid:\n\treturn ap;\n}"
  },
  {
    "function_name": "kprobe_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1517-1520",
    "snippet": "static kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_kprobe_addr",
          "args": [
            "p->addr",
            "p->symbol_name",
            "p->offset"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "_kprobe_addr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1497-1515",
          "snippet": "static kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *kprobe_addr(struct kprobe *p)\n{\n\treturn _kprobe_addr(p->addr, p->symbol_name, p->offset);\n}"
  },
  {
    "function_name": "_kprobe_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1497-1515",
    "snippet": "static kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_lookup_name",
          "args": [
            "symbol_name",
            "offset"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic kprobe_opcode_t *_kprobe_addr(kprobe_opcode_t *addr,\n\t\t\tconst char *symbol_name, unsigned int offset)\n{\n\tif ((symbol_name && addr) || (!symbol_name && !addr))\n\t\tgoto invalid;\n\n\tif (symbol_name) {\n\t\taddr = kprobe_lookup_name(symbol_name, offset);\n\t\tif (!addr)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\taddr = (kprobe_opcode_t *)(((char *)addr) + offset);\n\tif (addr)\n\t\treturn addr;\n\ninvalid:\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "within_kprobe_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1471-1489",
    "snippet": "bool within_kprobe_blacklist(unsigned long addr)\n{\n\tchar symname[KSYM_NAME_LEN], *p;\n\n\tif (__within_kprobe_blacklist(addr))\n\t\treturn true;\n\n\t/* Check if the address is on a suffixed-symbol */\n\tif (!lookup_symbol_name(addr, symname)) {\n\t\tp = strchr(symname, '.');\n\t\tif (!p)\n\t\t\treturn false;\n\t\t*p = '\\0';\n\t\taddr = (unsigned long)kprobe_lookup_name(symname, 0);\n\t\tif (addr)\n\t\t\treturn __within_kprobe_blacklist(addr);\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__within_kprobe_blacklist",
          "args": [
            "addr"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "__within_kprobe_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1454-1469",
          "snippet": "static bool __within_kprobe_blacklist(unsigned long addr)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\n\tif (arch_within_kprobe_blacklist(addr))\n\t\treturn true;\n\t/*\n\t * If 'kprobe_blacklist' is defined, check the address and\n\t * reject any probe registration in the prohibited area.\n\t */\n\tlist_for_each_entry(ent, &kprobe_blacklist, list) {\n\t\tif (addr >= ent->start_addr && addr < ent->end_addr)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kprobe_blacklist);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic bool __within_kprobe_blacklist(unsigned long addr)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\n\tif (arch_within_kprobe_blacklist(addr))\n\t\treturn true;\n\t/*\n\t * If 'kprobe_blacklist' is defined, check the address and\n\t * reject any probe registration in the prohibited area.\n\t */\n\tlist_for_each_entry(ent, &kprobe_blacklist, list) {\n\t\tif (addr >= ent->start_addr && addr < ent->end_addr)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_lookup_name",
          "args": [
            "symname",
            "0"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "symname",
            "'.'"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_symbol_name",
          "args": [
            "addr",
            "symname"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_symbol_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kallsyms.c",
          "lines": "386-410",
          "snippet": "int lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tint res;\n\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\tgoto found;\n\t}\n\t/* See if it's in a module. */\n\tres = lookup_module_symbol_name(addr, symname);\n\tif (res)\n\t\treturn res;\n\nfound:\n\tcleanup_symbol_name(symname);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/compiler.h>",
            "#include <linux/build_bug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/compiler.h>\n#include <linux/build_bug.h>\n#include <linux/kprobes.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint lookup_symbol_name(unsigned long addr, char *symname)\n{\n\tint res;\n\n\tsymname[0] = '\\0';\n\tsymname[KSYM_NAME_LEN - 1] = '\\0';\n\n\tif (is_ksym_addr(addr)) {\n\t\tunsigned long pos;\n\n\t\tpos = get_symbol_pos(addr, NULL, NULL);\n\t\t/* Grab name */\n\t\tkallsyms_expand_symbol(get_symbol_offset(pos),\n\t\t\t\t       symname, KSYM_NAME_LEN);\n\t\tgoto found;\n\t}\n\t/* See if it's in a module. */\n\tres = lookup_module_symbol_name(addr, symname);\n\tif (res)\n\t\treturn res;\n\nfound:\n\tcleanup_symbol_name(symname);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool within_kprobe_blacklist(unsigned long addr)\n{\n\tchar symname[KSYM_NAME_LEN], *p;\n\n\tif (__within_kprobe_blacklist(addr))\n\t\treturn true;\n\n\t/* Check if the address is on a suffixed-symbol */\n\tif (!lookup_symbol_name(addr, symname)) {\n\t\tp = strchr(symname, '.');\n\t\tif (!p)\n\t\t\treturn false;\n\t\t*p = '\\0';\n\t\taddr = (unsigned long)kprobe_lookup_name(symname, 0);\n\t\tif (addr)\n\t\t\treturn __within_kprobe_blacklist(addr);\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "__within_kprobe_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1454-1469",
    "snippet": "static bool __within_kprobe_blacklist(unsigned long addr)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\n\tif (arch_within_kprobe_blacklist(addr))\n\t\treturn true;\n\t/*\n\t * If 'kprobe_blacklist' is defined, check the address and\n\t * reject any probe registration in the prohibited area.\n\t */\n\tlist_for_each_entry(ent, &kprobe_blacklist, list) {\n\t\tif (addr >= ent->start_addr && addr < ent->end_addr)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(kprobe_blacklist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ent",
            "&kprobe_blacklist",
            "list"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_within_kprobe_blacklist",
          "args": [
            "addr"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "arch_within_kprobe_blacklist",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1447-1452",
          "snippet": "bool __weak arch_within_kprobe_blacklist(unsigned long addr)\n{\n\t/* The '__kprobes' functions and entry code must not be probed. */\n\treturn addr >= (unsigned long)__kprobes_text_start &&\n\t       addr < (unsigned long)__kprobes_text_end;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __weak arch_within_kprobe_blacklist(unsigned long addr)\n{\n\t/* The '__kprobes' functions and entry code must not be probed. */\n\treturn addr >= (unsigned long)__kprobes_text_start &&\n\t       addr < (unsigned long)__kprobes_text_end;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic LIST_HEAD(kprobe_blacklist);\n\nstatic bool __within_kprobe_blacklist(unsigned long addr)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\n\tif (arch_within_kprobe_blacklist(addr))\n\t\treturn true;\n\t/*\n\t * If 'kprobe_blacklist' is defined, check the address and\n\t * reject any probe registration in the prohibited area.\n\t */\n\tlist_for_each_entry(ent, &kprobe_blacklist, list) {\n\t\tif (addr >= ent->start_addr && addr < ent->end_addr)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "arch_within_kprobe_blacklist",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1447-1452",
    "snippet": "bool __weak arch_within_kprobe_blacklist(unsigned long addr)\n{\n\t/* The '__kprobes' functions and entry code must not be probed. */\n\treturn addr >= (unsigned long)__kprobes_text_start &&\n\t       addr < (unsigned long)__kprobes_text_end;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __weak arch_within_kprobe_blacklist(unsigned long addr)\n{\n\t/* The '__kprobes' functions and entry code must not be probed. */\n\treturn addr >= (unsigned long)__kprobes_text_start &&\n\t       addr < (unsigned long)__kprobes_text_end;\n}"
  },
  {
    "function_name": "register_aggr_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1370-1445",
    "snippet": "static int register_aggr_kprobe(struct kprobe *orig_p, struct kprobe *p)\n{\n\tint ret = 0;\n\tstruct kprobe *ap = orig_p;\n\n\tcpus_read_lock();\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tif (!kprobe_aggrprobe(orig_p)) {\n\t\t/* If 'orig_p' is not an 'aggr_kprobe', create new one. */\n\t\tap = alloc_aggr_kprobe(orig_p);\n\t\tif (!ap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_aggr_kprobe(ap, orig_p);\n\t} else if (kprobe_unused(ap)) {\n\t\t/* This probe is going to die. Rescue it */\n\t\tret = reuse_unused_kprobe(ap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(ap)) {\n\t\t/*\n\t\t * Attempting to insert new probe at the same location that\n\t\t * had a probe in the module vaddr area which already\n\t\t * freed. So, the instruction slot has already been\n\t\t * released. We need a new slot for the new probe.\n\t\t */\n\t\tret = arch_prepare_kprobe(ap);\n\t\tif (ret)\n\t\t\t/*\n\t\t\t * Even if fail to allocate new slot, don't need to\n\t\t\t * free the 'ap'. It will be used next time, or\n\t\t\t * freed by unregister_kprobe().\n\t\t\t */\n\t\t\tgoto out;\n\n\t\t/* Prepare optimized instructions if possible. */\n\t\tprepare_optimized_kprobe(ap);\n\n\t\t/*\n\t\t * Clear gone flag to prevent allocating new slot again, and\n\t\t * set disabled flag because it is not armed yet.\n\t\t */\n\t\tap->flags = (ap->flags & ~KPROBE_FLAG_GONE)\n\t\t\t    | KPROBE_FLAG_DISABLED;\n\t}\n\n\t/* Copy the insn slot of 'p' to 'ap'. */\n\tcopy_kprobe(ap, p);\n\tret = add_new_kprobe(ap, p);\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n\n\tif (ret == 0 && kprobe_disabled(ap) && !kprobe_disabled(p)) {\n\t\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tif (!kprobes_all_disarmed) {\n\t\t\t/* Arm the breakpoint again. */\n\t\t\tret = arm_kprobe(ap);\n\t\t\tif (ret) {\n\t\t\t\tap->flags |= KPROBE_FLAG_DISABLED;\n\t\t\t\tlist_del_rcu(&p->list);\n\t\t\t\tsynchronize_rcu();\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&p->list"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arm_kprobe",
          "args": [
            "ap"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "arm_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1163-1175",
          "snippet": "static int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "30-33",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(jump_label_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic DEFINE_MUTEX(jump_label_mutex);\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&text_mutex"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_new_kprobe",
          "args": [
            "ap",
            "p"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "add_new_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1332-1342",
          "snippet": "static int add_new_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tif (p->post_handler)\n\t\tunoptimize_kprobe(ap, true);\t/* Fall back to normal kprobe */\n\n\tlist_add_rcu(&p->list, &ap->list);\n\tif (p->post_handler && !ap->post_handler)\n\t\tap->post_handler = aggr_post_handler;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int add_new_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tif (p->post_handler)\n\t\tunoptimize_kprobe(ap, true);\t/* Fall back to normal kprobe */\n\n\tlist_add_rcu(&p->list, &ap->list);\n\tif (p->post_handler && !ap->post_handler)\n\t\tap->post_handler = aggr_post_handler;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_kprobe",
          "args": [
            "ap",
            "p"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "copy_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "408-412",
          "snippet": "static inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_optimized_kprobe",
          "args": [
            "ap"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_optimized_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "822-828",
          "snippet": "static void prepare_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\t__prepare_optimized_kprobe(op, p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void prepare_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\t__prepare_optimized_kprobe(op, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_prepare_kprobe",
          "args": [
            "ap"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "ap"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reuse_unused_kprobe",
          "args": [
            "ap"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "reuse_unused_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1037-1047",
          "snippet": "static int reuse_unused_kprobe(struct kprobe *ap)\n{\n\t/*\n\t * If the optimized kprobe is NOT supported, the aggr kprobe is\n\t * released at the same time that the last aggregated kprobe is\n\t * unregistered.\n\t * Thus there should be no chance to reuse unused kprobe.\n\t */\n\tWARN_ON_ONCE(1);\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int reuse_unused_kprobe(struct kprobe *ap)\n{\n\t/*\n\t * If the optimized kprobe is NOT supported, the aggr kprobe is\n\t * released at the same time that the last aggregated kprobe is\n\t * unregistered.\n\t * Thus there should be no chance to reuse unused kprobe.\n\t */\n\tWARN_ON_ONCE(1);\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_unused",
          "args": [
            "ap"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_unused",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "401-405",
          "snippet": "static inline bool kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_aggr_kprobe",
          "args": [
            "ap",
            "orig_p"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "init_aggr_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1348-1365",
          "snippet": "static void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy the insn slot of 'p' to 'ap'. */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy the insn slot of 'p' to 'ap'. */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_aggr_kprobe",
          "args": [
            "orig_p"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_aggr_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1055-1058",
          "snippet": "static struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "orig_p"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "395-398",
          "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "25-28",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(jump_label_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic DEFINE_MUTEX(jump_label_mutex);\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic int register_aggr_kprobe(struct kprobe *orig_p, struct kprobe *p)\n{\n\tint ret = 0;\n\tstruct kprobe *ap = orig_p;\n\n\tcpus_read_lock();\n\n\t/* For preparing optimization, jump_label_text_reserved() is called */\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tif (!kprobe_aggrprobe(orig_p)) {\n\t\t/* If 'orig_p' is not an 'aggr_kprobe', create new one. */\n\t\tap = alloc_aggr_kprobe(orig_p);\n\t\tif (!ap) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tinit_aggr_kprobe(ap, orig_p);\n\t} else if (kprobe_unused(ap)) {\n\t\t/* This probe is going to die. Rescue it */\n\t\tret = reuse_unused_kprobe(ap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (kprobe_gone(ap)) {\n\t\t/*\n\t\t * Attempting to insert new probe at the same location that\n\t\t * had a probe in the module vaddr area which already\n\t\t * freed. So, the instruction slot has already been\n\t\t * released. We need a new slot for the new probe.\n\t\t */\n\t\tret = arch_prepare_kprobe(ap);\n\t\tif (ret)\n\t\t\t/*\n\t\t\t * Even if fail to allocate new slot, don't need to\n\t\t\t * free the 'ap'. It will be used next time, or\n\t\t\t * freed by unregister_kprobe().\n\t\t\t */\n\t\t\tgoto out;\n\n\t\t/* Prepare optimized instructions if possible. */\n\t\tprepare_optimized_kprobe(ap);\n\n\t\t/*\n\t\t * Clear gone flag to prevent allocating new slot again, and\n\t\t * set disabled flag because it is not armed yet.\n\t\t */\n\t\tap->flags = (ap->flags & ~KPROBE_FLAG_GONE)\n\t\t\t    | KPROBE_FLAG_DISABLED;\n\t}\n\n\t/* Copy the insn slot of 'p' to 'ap'. */\n\tcopy_kprobe(ap, p);\n\tret = add_new_kprobe(ap, p);\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n\n\tif (ret == 0 && kprobe_disabled(ap) && !kprobe_disabled(p)) {\n\t\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t\tif (!kprobes_all_disarmed) {\n\t\t\t/* Arm the breakpoint again. */\n\t\t\tret = arm_kprobe(ap);\n\t\t\tif (ret) {\n\t\t\t\tap->flags |= KPROBE_FLAG_DISABLED;\n\t\t\t\tlist_del_rcu(&p->list);\n\t\t\t\tsynchronize_rcu();\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "init_aggr_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1348-1365",
    "snippet": "static void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy the insn slot of 'p' to 'ap'. */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_replace_rcu",
          "args": [
            "&p->hlist",
            "&ap->hlist"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&p->list",
            "&ap->list"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&ap->hlist"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ap->list"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_gone",
          "args": [
            "p"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_insn_slot",
          "args": [
            "ap"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_kprobe",
          "args": [
            "p",
            "ap"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "copy_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "408-412",
          "snippet": "static inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy the insn slot of 'p' to 'ap'. */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}"
  },
  {
    "function_name": "add_new_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1332-1342",
    "snippet": "static int add_new_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tif (p->post_handler)\n\t\tunoptimize_kprobe(ap, true);\t/* Fall back to normal kprobe */\n\n\tlist_add_rcu(&p->list, &ap->list);\n\tif (p->post_handler && !ap->post_handler)\n\t\tap->post_handler = aggr_post_handler;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&p->list",
            "&ap->list"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unoptimize_kprobe",
          "args": [
            "ap",
            "true"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "727-765",
          "snippet": "static void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p))\n\t\treturn;\n\n\tif (!list_empty(&op->list)) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* Queued in unoptimizing queue */\n\t\t\tif (force) {\n\t\t\t\t/*\n\t\t\t\t * Forcibly unoptimize the kprobe here, and queue it\n\t\t\t\t * in the freeing list for release afterwards.\n\t\t\t\t */\n\t\t\t\tforce_unoptimize_kprobe(op);\n\t\t\t\tlist_move(&op->list, &freeing_list);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Dequeue from the optimizing queue */\n\t\t\tlist_del_init(&op->list);\n\t\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Optimized kprobe case */\n\tif (force) {\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\t} else {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p))\n\t\treturn;\n\n\tif (!list_empty(&op->list)) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* Queued in unoptimizing queue */\n\t\t\tif (force) {\n\t\t\t\t/*\n\t\t\t\t * Forcibly unoptimize the kprobe here, and queue it\n\t\t\t\t * in the freeing list for release afterwards.\n\t\t\t\t */\n\t\t\t\tforce_unoptimize_kprobe(op);\n\t\t\t\tlist_move(&op->list, &freeing_list);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Dequeue from the optimizing queue */\n\t\t\tlist_del_init(&op->list);\n\t\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Optimized kprobe case */\n\tif (force) {\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\t} else {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int add_new_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tif (p->post_handler)\n\t\tunoptimize_kprobe(ap, true);\t/* Fall back to normal kprobe */\n\n\tlist_add_rcu(&p->list, &ap->list);\n\tif (p->post_handler && !ap->post_handler)\n\t\tap->post_handler = aggr_post_handler;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_rp_inst",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1310-1329",
    "snippet": "static inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct freelist_node *node;\n\tint count = 0;\n\n\tnode = rp->freelist.head;\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, freelist);\n\t\tnode = node->next;\n\n\t\tkfree(ri);\n\t\tcount++;\n\t}\n\n\tif (refcount_sub_and_test(count, &rp->rph->ref)) {\n\t\tkfree(rp->rph);\n\t\trp->rph = NULL;\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rp->rph"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_sub_and_test",
          "args": [
            "count",
            "&rp->rph->ref"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structkretprobe_instance",
            "freelist"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void free_rp_inst(struct kretprobe *rp)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct freelist_node *node;\n\tint count = 0;\n\n\tnode = rp->freelist.head;\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, freelist);\n\t\tnode = node->next;\n\n\t\tkfree(ri);\n\t\tcount++;\n\t}\n\n\tif (refcount_sub_and_test(count, &rp->rph->ref)) {\n\t\tkfree(rp->rph);\n\t\trp->rph = NULL;\n\t}\n}"
  },
  {
    "function_name": "kprobe_flush_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1287-1307",
    "snippet": "void kprobe_flush_task(struct task_struct *tk)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct llist_node *node;\n\n\t/* Early boot, not yet initialized. */\n\tif (unlikely(!kprobes_initialized))\n\t\treturn;\n\n\tkprobe_busy_begin();\n\n\tnode = __llist_del_all(&tk->kretprobe_instances);\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, llist);\n\t\tnode = node->next;\n\n\t\trecycle_rp_inst(ri);\n\t}\n\n\tkprobe_busy_end();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kprobes_initialized;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kprobe_busy_end",
          "args": [],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_busy_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1275-1279",
          "snippet": "void kprobe_busy_end(void)\n{\n\t__this_cpu_write(current_kprobe, NULL);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid kprobe_busy_end(void)\n{\n\t__this_cpu_write(current_kprobe, NULL);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "recycle_rp_inst",
          "args": [
            "ri"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "recycle_rp_inst",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1250-1258",
          "snippet": "static void recycle_rp_inst(struct kretprobe_instance *ri)\n{\n\tstruct kretprobe *rp = get_kretprobe(ri);\n\n\tif (likely(rp))\n\t\tfreelist_add(&ri->freelist, &rp->freelist);\n\telse\n\t\tcall_rcu(&ri->rcu, free_rp_inst_rcu);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void recycle_rp_inst(struct kretprobe_instance *ri)\n{\n\tstruct kretprobe *rp = get_kretprobe(ri);\n\n\tif (likely(rp))\n\t\tfreelist_add(&ri->freelist, &rp->freelist);\n\telse\n\t\tcall_rcu(&ri->rcu, free_rp_inst_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structkretprobe_instance",
            "llist"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__llist_del_all",
          "args": [
            "&tk->kretprobe_instances"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_busy_begin",
          "args": [],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_busy_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1265-1273",
          "snippet": "void kprobe_busy_begin(void)\n{\n\tstruct kprobe_ctlblk *kcb;\n\n\tpreempt_disable();\n\t__this_cpu_write(current_kprobe, &kprobe_busy);\n\tkcb = get_kprobe_ctlblk();\n\tkcb->kprobe_status = KPROBE_HIT_ACTIVE;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kprobe kprobe_busy = {\n\t.addr = (void *) get_kprobe,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe kprobe_busy = {\n\t.addr = (void *) get_kprobe,\n};\n\nvoid kprobe_busy_begin(void)\n{\n\tstruct kprobe_ctlblk *kcb;\n\n\tpreempt_disable();\n\t__this_cpu_write(current_kprobe, &kprobe_busy);\n\tkcb = get_kprobe_ctlblk();\n\tkcb->kprobe_status = KPROBE_HIT_ACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!kprobes_initialized"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int kprobes_initialized;\n\nvoid kprobe_flush_task(struct task_struct *tk)\n{\n\tstruct kretprobe_instance *ri;\n\tstruct llist_node *node;\n\n\t/* Early boot, not yet initialized. */\n\tif (unlikely(!kprobes_initialized))\n\t\treturn;\n\n\tkprobe_busy_begin();\n\n\tnode = __llist_del_all(&tk->kretprobe_instances);\n\twhile (node) {\n\t\tri = container_of(node, struct kretprobe_instance, llist);\n\t\tnode = node->next;\n\n\t\trecycle_rp_inst(ri);\n\t}\n\n\tkprobe_busy_end();\n}"
  },
  {
    "function_name": "kprobe_busy_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1275-1279",
    "snippet": "void kprobe_busy_end(void)\n{\n\t__this_cpu_write(current_kprobe, NULL);\n\tpreempt_enable();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_kprobe",
            "NULL"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid kprobe_busy_end(void)\n{\n\t__this_cpu_write(current_kprobe, NULL);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "kprobe_busy_begin",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1265-1273",
    "snippet": "void kprobe_busy_begin(void)\n{\n\tstruct kprobe_ctlblk *kcb;\n\n\tpreempt_disable();\n\t__this_cpu_write(current_kprobe, &kprobe_busy);\n\tkcb = get_kprobe_ctlblk();\n\tkcb->kprobe_status = KPROBE_HIT_ACTIVE;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kprobe kprobe_busy = {\n\t.addr = (void *) get_kprobe,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_kprobe_ctlblk",
          "args": [],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_kprobe",
            "&kprobe_busy"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "6425-6430",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe kprobe_busy = {\n\t.addr = (void *) get_kprobe,\n};\n\nvoid kprobe_busy_begin(void)\n{\n\tstruct kprobe_ctlblk *kcb;\n\n\tpreempt_disable();\n\t__this_cpu_write(current_kprobe, &kprobe_busy);\n\tkcb = get_kprobe_ctlblk();\n\tkcb->kprobe_status = KPROBE_HIT_ACTIVE;\n}"
  },
  {
    "function_name": "recycle_rp_inst",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1250-1258",
    "snippet": "static void recycle_rp_inst(struct kretprobe_instance *ri)\n{\n\tstruct kretprobe *rp = get_kretprobe(ri);\n\n\tif (likely(rp))\n\t\tfreelist_add(&ri->freelist, &rp->freelist);\n\telse\n\t\tcall_rcu(&ri->rcu, free_rp_inst_rcu);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&ri->rcu",
            "free_rp_inst_rcu"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1533-1536",
          "snippet": "void call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid call_rcu_tasks_trace(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tcall_rcu_tasks_generic(rhp, func, &rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freelist_add",
          "args": [
            "&ri->freelist",
            "&rp->freelist"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rp"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kretprobe",
          "args": [
            "ri"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void recycle_rp_inst(struct kretprobe_instance *ri)\n{\n\tstruct kretprobe *rp = get_kretprobe(ri);\n\n\tif (likely(rp))\n\t\tfreelist_add(&ri->freelist, &rp->freelist);\n\telse\n\t\tcall_rcu(&ri->rcu, free_rp_inst_rcu);\n}"
  },
  {
    "function_name": "free_rp_inst_rcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1240-1247",
    "snippet": "static void free_rp_inst_rcu(struct rcu_head *head)\n{\n\tstruct kretprobe_instance *ri = container_of(head, struct kretprobe_instance, rcu);\n\n\tif (refcount_dec_and_test(&ri->rph->ref))\n\t\tkfree(ri->rph);\n\tkfree(ri);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ri"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "refcount_dec_and_test",
          "args": [
            "&ri->rph->ref"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structkretprobe_instance",
            "rcu"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_rp_inst_rcu(struct rcu_head *head)\n{\n\tstruct kretprobe_instance *ri = container_of(head, struct kretprobe_instance, rcu);\n\n\tif (refcount_dec_and_test(&ri->rph->ref))\n\t\tkfree(ri->rph);\n\tkfree(ri);\n}"
  },
  {
    "function_name": "kprobes_inc_nmissed_count",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1227-1237",
    "snippet": "void kprobes_inc_nmissed_count(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tif (!kprobe_aggrprobe(p)) {\n\t\tp->nmissed++;\n\t} else {\n\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\tkp->nmissed++;\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "395-398",
          "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid kprobes_inc_nmissed_count(struct kprobe *p)\n{\n\tstruct kprobe *kp;\n\n\tif (!kprobe_aggrprobe(p)) {\n\t\tp->nmissed++;\n\t} else {\n\t\tlist_for_each_entry_rcu(kp, &p->list, list)\n\t\t\tkp->nmissed++;\n\t}\n}"
  },
  {
    "function_name": "aggr_post_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1211-1223",
    "snippet": "static void aggr_post_handler(struct kprobe *p, struct pt_regs *regs,\n\t\t\t      unsigned long flags)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->post_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tkp->post_handler(kp, regs, flags);\n\t\t\treset_kprobe_instance();\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_kprobe_instance",
          "args": [],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "reset_kprobe_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "365-368",
          "snippet": "static inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance);\n\nstatic inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kp->post_handler",
          "args": [
            "kp",
            "regs",
            "flags"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_kprobe_instance",
          "args": [
            "kp"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "set_kprobe_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "360-363",
          "snippet": "static inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance);\n\nstatic inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!kprobe_disabled(kp)"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "kp"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nstatic void aggr_post_handler(struct kprobe *p, struct pt_regs *regs,\n\t\t\t      unsigned long flags)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->post_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tkp->post_handler(kp, regs, flags);\n\t\t\treset_kprobe_instance();\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "aggr_pre_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1195-1208",
    "snippet": "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->pre_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tif (kp->pre_handler(kp, regs))\n\t\t\t\treturn 1;\n\t\t}\n\t\treset_kprobe_instance();\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_kprobe_instance",
          "args": [],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "reset_kprobe_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "365-368",
          "snippet": "static inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance);\n\nstatic inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kp->pre_handler",
          "args": [
            "kp",
            "regs"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_kprobe_instance",
          "args": [
            "kp"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "set_kprobe_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "360-363",
          "snippet": "static inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance);\n\nstatic inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!kprobe_disabled(kp)"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "kp"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->pre_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tif (kp->pre_handler(kp, regs))\n\t\t\t\treturn 1;\n\t\t}\n\t\treset_kprobe_instance();\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "disarm_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1177-1189",
    "snippet": "static int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&text_mutex"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__disarm_kprobe",
          "args": [
            "kp",
            "reopt"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "__disarm_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1001-1023",
          "snippet": "static void __disarm_kprobe(struct kprobe *p, bool reopt)\n{\n\tstruct kprobe *_p;\n\n\tlockdep_assert_held(&text_mutex);\n\n\t/* Try to unoptimize */\n\tunoptimize_kprobe(p, kprobes_all_disarmed);\n\n\tif (!kprobe_queued(p)) {\n\t\tarch_disarm_kprobe(p);\n\t\t/* If another kprobe was blocked, re-optimize it. */\n\t\t_p = get_optimized_kprobe(p->addr);\n\t\tif (unlikely(_p) && reopt)\n\t\t\toptimize_kprobe(_p);\n\t}\n\t/*\n\t * TODO: Since unoptimization and real disarming will be done by\n\t * the worker thread, we can not check whether another probe are\n\t * unoptimized because of this probe here. It should be re-optimized\n\t * by the worker thread.\n\t */\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic void __disarm_kprobe(struct kprobe *p, bool reopt)\n{\n\tstruct kprobe *_p;\n\n\tlockdep_assert_held(&text_mutex);\n\n\t/* Try to unoptimize */\n\tunoptimize_kprobe(p, kprobes_all_disarmed);\n\n\tif (!kprobe_queued(p)) {\n\t\tarch_disarm_kprobe(p);\n\t\t/* If another kprobe was blocked, re-optimize it. */\n\t\t_p = get_optimized_kprobe(p->addr);\n\t\tif (unlikely(_p) && reopt)\n\t\t\toptimize_kprobe(_p);\n\t}\n\t/*\n\t * TODO: Since unoptimization and real disarming will be done by\n\t * the worker thread, we can not check whether another probe are\n\t * unoptimized because of this probe here. It should be re-optimized\n\t * by the worker thread.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disarm_kprobe_ftrace",
          "args": [
            "kp"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1148-1151",
          "snippet": "static inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kprobe_ftrace(kp)"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe(struct kprobe *kp, bool reopt)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn disarm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__disarm_kprobe(kp, reopt);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arm_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1163-1175",
    "snippet": "static int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&text_mutex"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__arm_kprobe",
          "args": [
            "kp"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "__arm_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "984-998",
          "snippet": "static void __arm_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *_p;\n\n\tlockdep_assert_held(&text_mutex);\n\n\t/* Find the overlapping optimized kprobes. */\n\t_p = get_optimized_kprobe(p->addr);\n\tif (unlikely(_p))\n\t\t/* Fallback to unoptimized kprobe */\n\t\tunoptimize_kprobe(_p, true);\n\n\tarch_arm_kprobe(p);\n\toptimize_kprobe(p);\t/* Try to optimize (add kprobe to a list) */\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void __arm_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *_p;\n\n\tlockdep_assert_held(&text_mutex);\n\n\t/* Find the overlapping optimized kprobes. */\n\t_p = get_optimized_kprobe(p->addr);\n\tif (unlikely(_p))\n\t\t/* Fallback to unoptimized kprobe */\n\t\tunoptimize_kprobe(_p, true);\n\n\tarch_arm_kprobe(p);\n\toptimize_kprobe(p);\t/* Try to optimize (add kprobe to a list) */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arm_kprobe_ftrace",
          "args": [
            "kp"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1148-1151",
          "snippet": "static inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kprobe_ftrace(kp)"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe(struct kprobe *kp)\n{\n\tif (unlikely(kprobe_ftrace(kp)))\n\t\treturn arm_kprobe_ftrace(kp);\n\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\t__arm_kprobe(kp);\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "prepare_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1154-1161",
    "snippet": "static int prepare_kprobe(struct kprobe *p)\n{\n\t/* Must ensure p->addr is really on ftrace */\n\tif (kprobe_ftrace(p))\n\t\treturn arch_prepare_kprobe_ftrace(p);\n\n\treturn arch_prepare_kprobe(p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_prepare_kprobe",
          "args": [
            "p"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_prepare_kprobe_ftrace",
          "args": [
            "p"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_ftrace",
          "args": [
            "p"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1148-1151",
          "snippet": "static inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int prepare_kprobe(struct kprobe *p)\n{\n\t/* Must ensure p->addr is really on ftrace */\n\tif (kprobe_ftrace(p))\n\t\treturn arch_prepare_kprobe_ftrace(p);\n\n\treturn arch_prepare_kprobe(p);\n}"
  },
  {
    "function_name": "disarm_kprobe_ftrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1148-1151",
    "snippet": "static inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "arm_kprobe_ftrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1143-1146",
    "snippet": "static inline int arm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int arm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "disarm_kprobe_ftrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1134-1141",
    "snippet": "static int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tbool ipmodify = (p->post_handler != NULL);\n\n\treturn __disarm_kprobe_ftrace(p,\n\t\tipmodify ? &kprobe_ipmodify_ops : &kprobe_ftrace_ops,\n\t\tipmodify ? &kprobe_ipmodify_enabled : &kprobe_ftrace_enabled);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__disarm_kprobe_ftrace",
          "args": [
            "p",
            "ipmodify ? &kprobe_ipmodify_ops : &kprobe_ftrace_ops",
            "ipmodify ? &kprobe_ipmodify_enabled : &kprobe_ftrace_enabled"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "__disarm_kprobe_ftrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1113-1132",
          "snippet": "static int __disarm_kprobe_ftrace(struct kprobe *p, struct ftrace_ops *ops,\n\t\t\t\t  int *cnt)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tif (*cnt == 1) {\n\t\tret = unregister_ftrace_function(ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (error %d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\t(*cnt)--;\n\n\tret = ftrace_set_filter_ip(ops, (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (error %d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int __disarm_kprobe_ftrace(struct kprobe *p, struct ftrace_ops *ops,\n\t\t\t\t  int *cnt)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tif (*cnt == 1) {\n\t\tret = unregister_ftrace_function(ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (error %d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\t(*cnt)--;\n\n\tret = ftrace_set_filter_ip(ops, (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (error %d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tbool ipmodify = (p->post_handler != NULL);\n\n\treturn __disarm_kprobe_ftrace(p,\n\t\tipmodify ? &kprobe_ipmodify_ops : &kprobe_ftrace_ops,\n\t\tipmodify ? &kprobe_ipmodify_enabled : &kprobe_ftrace_enabled);\n}"
  },
  {
    "function_name": "__disarm_kprobe_ftrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1113-1132",
    "snippet": "static int __disarm_kprobe_ftrace(struct kprobe *p, struct ftrace_ops *ops,\n\t\t\t\t  int *cnt)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tif (*cnt == 1) {\n\t\tret = unregister_ftrace_function(ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (error %d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\t(*cnt)--;\n\n\tret = ftrace_set_filter_ip(ops, (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (error %d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "ret < 0",
            "\"Failed to disarm kprobe-ftrace at %pS (error %d)\\n\"",
            "p->addr",
            "ret"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "ops",
            "(unsigned long)p->addr",
            "1",
            "0"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5633-5638",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "ret < 0",
            "\"Failed to unregister kprobe-ftrace (error %d)\\n\"",
            "ret"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int __disarm_kprobe_ftrace(struct kprobe *p, struct ftrace_ops *ops,\n\t\t\t\t  int *cnt)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tif (*cnt == 1) {\n\t\tret = unregister_ftrace_function(ops);\n\t\tif (WARN(ret < 0, \"Failed to unregister kprobe-ftrace (error %d)\\n\", ret))\n\t\t\treturn ret;\n\t}\n\n\t(*cnt)--;\n\n\tret = ftrace_set_filter_ip(ops, (unsigned long)p->addr, 1, 0);\n\tWARN_ONCE(ret < 0, \"Failed to disarm kprobe-ftrace at %pS (error %d)\\n\",\n\t\t  p->addr, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "arm_kprobe_ftrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1104-1111",
    "snippet": "static int arm_kprobe_ftrace(struct kprobe *p)\n{\n\tbool ipmodify = (p->post_handler != NULL);\n\n\treturn __arm_kprobe_ftrace(p,\n\t\tipmodify ? &kprobe_ipmodify_ops : &kprobe_ftrace_ops,\n\t\tipmodify ? &kprobe_ipmodify_enabled : &kprobe_ftrace_enabled);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__arm_kprobe_ftrace",
          "args": [
            "p",
            "ipmodify ? &kprobe_ipmodify_ops : &kprobe_ftrace_ops",
            "ipmodify ? &kprobe_ipmodify_enabled : &kprobe_ftrace_enabled"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "__arm_kprobe_ftrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1075-1102",
          "snippet": "static int __arm_kprobe_ftrace(struct kprobe *p, struct ftrace_ops *ops,\n\t\t\t       int *cnt)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tret = ftrace_set_filter_ip(ops, (unsigned long)p->addr, 0, 0);\n\tif (WARN_ONCE(ret < 0, \"Failed to arm kprobe-ftrace at %pS (error %d)\\n\", p->addr, ret))\n\t\treturn ret;\n\n\tif (*cnt == 0) {\n\t\tret = register_ftrace_function(ops);\n\t\tif (WARN(ret < 0, \"Failed to register kprobe-ftrace (error %d)\\n\", ret))\n\t\t\tgoto err_ftrace;\n\t}\n\n\t(*cnt)++;\n\treturn ret;\n\nerr_ftrace:\n\t/*\n\t * At this point, sinec ops is not registered, we should be sefe from\n\t * registering empty filter.\n\t */\n\tftrace_set_filter_ip(ops, (unsigned long)p->addr, 1, 0);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int __arm_kprobe_ftrace(struct kprobe *p, struct ftrace_ops *ops,\n\t\t\t       int *cnt)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tret = ftrace_set_filter_ip(ops, (unsigned long)p->addr, 0, 0);\n\tif (WARN_ONCE(ret < 0, \"Failed to arm kprobe-ftrace at %pS (error %d)\\n\", p->addr, ret))\n\t\treturn ret;\n\n\tif (*cnt == 0) {\n\t\tret = register_ftrace_function(ops);\n\t\tif (WARN(ret < 0, \"Failed to register kprobe-ftrace (error %d)\\n\", ret))\n\t\t\tgoto err_ftrace;\n\t}\n\n\t(*cnt)++;\n\treturn ret;\n\nerr_ftrace:\n\t/*\n\t * At this point, sinec ops is not registered, we should be sefe from\n\t * registering empty filter.\n\t */\n\tftrace_set_filter_ip(ops, (unsigned long)p->addr, 1, 0);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int arm_kprobe_ftrace(struct kprobe *p)\n{\n\tbool ipmodify = (p->post_handler != NULL);\n\n\treturn __arm_kprobe_ftrace(p,\n\t\tipmodify ? &kprobe_ipmodify_ops : &kprobe_ftrace_ops,\n\t\tipmodify ? &kprobe_ipmodify_enabled : &kprobe_ftrace_enabled);\n}"
  },
  {
    "function_name": "__arm_kprobe_ftrace",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1075-1102",
    "snippet": "static int __arm_kprobe_ftrace(struct kprobe *p, struct ftrace_ops *ops,\n\t\t\t       int *cnt)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tret = ftrace_set_filter_ip(ops, (unsigned long)p->addr, 0, 0);\n\tif (WARN_ONCE(ret < 0, \"Failed to arm kprobe-ftrace at %pS (error %d)\\n\", p->addr, ret))\n\t\treturn ret;\n\n\tif (*cnt == 0) {\n\t\tret = register_ftrace_function(ops);\n\t\tif (WARN(ret < 0, \"Failed to register kprobe-ftrace (error %d)\\n\", ret))\n\t\t\tgoto err_ftrace;\n\t}\n\n\t(*cnt)++;\n\treturn ret;\n\nerr_ftrace:\n\t/*\n\t * At this point, sinec ops is not registered, we should be sefe from\n\t * registering empty filter.\n\t */\n\tftrace_set_filter_ip(ops, (unsigned long)p->addr, 1, 0);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_set_filter_ip",
          "args": [
            "ops",
            "(unsigned long)p->addr",
            "1",
            "0"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_set_filter_ip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "5633-5638",
          "snippet": "int ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "ret < 0",
            "\"Failed to register kprobe-ftrace (error %d)\\n\"",
            "ret"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7825-7834",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "ret < 0",
            "\"Failed to arm kprobe-ftrace at %pS (error %d)\\n\"",
            "p->addr",
            "ret"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic int __arm_kprobe_ftrace(struct kprobe *p, struct ftrace_ops *ops,\n\t\t\t       int *cnt)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tret = ftrace_set_filter_ip(ops, (unsigned long)p->addr, 0, 0);\n\tif (WARN_ONCE(ret < 0, \"Failed to arm kprobe-ftrace at %pS (error %d)\\n\", p->addr, ret))\n\t\treturn ret;\n\n\tif (*cnt == 0) {\n\t\tret = register_ftrace_function(ops);\n\t\tif (WARN(ret < 0, \"Failed to register kprobe-ftrace (error %d)\\n\", ret))\n\t\t\tgoto err_ftrace;\n\t}\n\n\t(*cnt)++;\n\treturn ret;\n\nerr_ftrace:\n\t/*\n\t * At this point, sinec ops is not registered, we should be sefe from\n\t * registering empty filter.\n\t */\n\tftrace_set_filter_ip(ops, (unsigned long)p->addr, 1, 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "alloc_aggr_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1055-1058",
    "snippet": "static struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kprobe)",
            "GFP_KERNEL"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}"
  },
  {
    "function_name": "free_aggr_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1049-1053",
    "snippet": "static void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remove_kprobe",
          "args": [
            "p"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}"
  },
  {
    "function_name": "reuse_unused_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1037-1047",
    "snippet": "static int reuse_unused_kprobe(struct kprobe *ap)\n{\n\t/*\n\t * If the optimized kprobe is NOT supported, the aggr kprobe is\n\t * released at the same time that the last aggregated kprobe is\n\t * unregistered.\n\t * Thus there should be no chance to reuse unused kprobe.\n\t */\n\tWARN_ON_ONCE(1);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int reuse_unused_kprobe(struct kprobe *ap)\n{\n\t/*\n\t * If the optimized kprobe is NOT supported, the aggr kprobe is\n\t * released at the same time that the last aggregated kprobe is\n\t * unregistered.\n\t * Thus there should be no chance to reuse unused kprobe.\n\t */\n\tWARN_ON_ONCE(1);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "__disarm_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "1001-1023",
    "snippet": "static void __disarm_kprobe(struct kprobe *p, bool reopt)\n{\n\tstruct kprobe *_p;\n\n\tlockdep_assert_held(&text_mutex);\n\n\t/* Try to unoptimize */\n\tunoptimize_kprobe(p, kprobes_all_disarmed);\n\n\tif (!kprobe_queued(p)) {\n\t\tarch_disarm_kprobe(p);\n\t\t/* If another kprobe was blocked, re-optimize it. */\n\t\t_p = get_optimized_kprobe(p->addr);\n\t\tif (unlikely(_p) && reopt)\n\t\t\toptimize_kprobe(_p);\n\t}\n\t/*\n\t * TODO: Since unoptimization and real disarming will be done by\n\t * the worker thread, we can not check whether another probe are\n\t * unoptimized because of this probe here. It should be re-optimized\n\t * by the worker thread.\n\t */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "_p"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "852-885",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "_p"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_optimized_kprobe",
          "args": [
            "p->addr"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "get_optimized_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "491-508",
          "snippet": "static struct kprobe *get_optimized_kprobe(kprobe_opcode_t *addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH / sizeof(kprobe_opcode_t); i++)\n\t\tp = get_kprobe(addr - i);\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *get_optimized_kprobe(kprobe_opcode_t *addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH / sizeof(kprobe_opcode_t); i++)\n\t\tp = get_kprobe(addr - i);\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_disarm_kprobe",
          "args": [
            "p"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_queued",
          "args": [
            "p"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_queued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "475-485",
          "snippet": "static bool kprobe_queued(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (!list_empty(&op->list))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobe_queued(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (!list_empty(&op->list))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unoptimize_kprobe",
          "args": [
            "p",
            "kprobes_all_disarmed"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "727-765",
          "snippet": "static void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p))\n\t\treturn;\n\n\tif (!list_empty(&op->list)) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* Queued in unoptimizing queue */\n\t\t\tif (force) {\n\t\t\t\t/*\n\t\t\t\t * Forcibly unoptimize the kprobe here, and queue it\n\t\t\t\t * in the freeing list for release afterwards.\n\t\t\t\t */\n\t\t\t\tforce_unoptimize_kprobe(op);\n\t\t\t\tlist_move(&op->list, &freeing_list);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Dequeue from the optimizing queue */\n\t\t\tlist_del_init(&op->list);\n\t\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Optimized kprobe case */\n\tif (force) {\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\t} else {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p))\n\t\treturn;\n\n\tif (!list_empty(&op->list)) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* Queued in unoptimizing queue */\n\t\t\tif (force) {\n\t\t\t\t/*\n\t\t\t\t * Forcibly unoptimize the kprobe here, and queue it\n\t\t\t\t * in the freeing list for release afterwards.\n\t\t\t\t */\n\t\t\t\tforce_unoptimize_kprobe(op);\n\t\t\t\tlist_move(&op->list, &freeing_list);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Dequeue from the optimizing queue */\n\t\t\tlist_del_init(&op->list);\n\t\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Optimized kprobe case */\n\tif (force) {\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\t} else {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&text_mutex"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic void __disarm_kprobe(struct kprobe *p, bool reopt)\n{\n\tstruct kprobe *_p;\n\n\tlockdep_assert_held(&text_mutex);\n\n\t/* Try to unoptimize */\n\tunoptimize_kprobe(p, kprobes_all_disarmed);\n\n\tif (!kprobe_queued(p)) {\n\t\tarch_disarm_kprobe(p);\n\t\t/* If another kprobe was blocked, re-optimize it. */\n\t\t_p = get_optimized_kprobe(p->addr);\n\t\tif (unlikely(_p) && reopt)\n\t\t\toptimize_kprobe(_p);\n\t}\n\t/*\n\t * TODO: Since unoptimization and real disarming will be done by\n\t * the worker thread, we can not check whether another probe are\n\t * unoptimized because of this probe here. It should be re-optimized\n\t * by the worker thread.\n\t */\n}"
  },
  {
    "function_name": "__arm_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "984-998",
    "snippet": "static void __arm_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *_p;\n\n\tlockdep_assert_held(&text_mutex);\n\n\t/* Find the overlapping optimized kprobes. */\n\t_p = get_optimized_kprobe(p->addr);\n\tif (unlikely(_p))\n\t\t/* Fallback to unoptimized kprobe */\n\t\tunoptimize_kprobe(_p, true);\n\n\tarch_arm_kprobe(p);\n\toptimize_kprobe(p);\t/* Try to optimize (add kprobe to a list) */\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "p"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "852-885",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_arm_kprobe",
          "args": [
            "p"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unoptimize_kprobe",
          "args": [
            "_p",
            "true"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "727-765",
          "snippet": "static void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p))\n\t\treturn;\n\n\tif (!list_empty(&op->list)) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* Queued in unoptimizing queue */\n\t\t\tif (force) {\n\t\t\t\t/*\n\t\t\t\t * Forcibly unoptimize the kprobe here, and queue it\n\t\t\t\t * in the freeing list for release afterwards.\n\t\t\t\t */\n\t\t\t\tforce_unoptimize_kprobe(op);\n\t\t\t\tlist_move(&op->list, &freeing_list);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Dequeue from the optimizing queue */\n\t\t\tlist_del_init(&op->list);\n\t\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Optimized kprobe case */\n\tif (force) {\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\t} else {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p))\n\t\treturn;\n\n\tif (!list_empty(&op->list)) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* Queued in unoptimizing queue */\n\t\t\tif (force) {\n\t\t\t\t/*\n\t\t\t\t * Forcibly unoptimize the kprobe here, and queue it\n\t\t\t\t * in the freeing list for release afterwards.\n\t\t\t\t */\n\t\t\t\tforce_unoptimize_kprobe(op);\n\t\t\t\tlist_move(&op->list, &freeing_list);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Dequeue from the optimizing queue */\n\t\t\tlist_del_init(&op->list);\n\t\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Optimized kprobe case */\n\tif (force) {\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\t} else {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "_p"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_optimized_kprobe",
          "args": [
            "p->addr"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "get_optimized_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "491-508",
          "snippet": "static struct kprobe *get_optimized_kprobe(kprobe_opcode_t *addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH / sizeof(kprobe_opcode_t); i++)\n\t\tp = get_kprobe(addr - i);\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *get_optimized_kprobe(kprobe_opcode_t *addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH / sizeof(kprobe_opcode_t); i++)\n\t\tp = get_kprobe(addr - i);\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&text_mutex"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void __arm_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *_p;\n\n\tlockdep_assert_held(&text_mutex);\n\n\t/* Find the overlapping optimized kprobes. */\n\t_p = get_optimized_kprobe(p->addr);\n\tif (unlikely(_p))\n\t\t/* Fallback to unoptimized kprobe */\n\t\tunoptimize_kprobe(_p, true);\n\n\tarch_arm_kprobe(p);\n\toptimize_kprobe(p);\t/* Try to optimize (add kprobe to a list) */\n}"
  },
  {
    "function_name": "kprobe_sysctls_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "977-980",
    "snippet": "static void __init kprobe_sysctls_init(void)\n{\n\tregister_sysctl_init(\"debug\", kprobe_sysctls);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int __init"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_init",
          "args": [
            "\"debug\"",
            "kprobe_sysctls"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint __init;\n\nstatic void __init kprobe_sysctls_init(void)\n{\n\tregister_sysctl_init(\"debug\", kprobe_sysctls);\n}"
  },
  {
    "function_name": "proc_kprobes_optimization_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "945-962",
    "snippet": "static int proc_kprobes_optimization_handler(struct ctl_table *table,\n\t\t\t\t\t     int write, void *buffer,\n\t\t\t\t\t     size_t *length, loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&kprobe_sysctl_mutex);\n\tsysctl_kprobes_optimization = kprobes_allow_optimization ? 1 : 0;\n\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\n\tif (sysctl_kprobes_optimization)\n\t\toptimize_all_kprobes();\n\telse\n\t\tunoptimize_all_kprobes();\n\tmutex_unlock(&kprobe_sysctl_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_sysctl_mutex"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unoptimize_all_kprobes",
          "args": [],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_all_kprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "913-941",
          "snippet": "static void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already prohibited, just return. */\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for unoptimizing completion. */\n\twait_for_kprobe_optimizer();\n\tpr_info(\"kprobe jump-optimization is disabled. All kprobes are based on software breakpoint.\\n\");\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already prohibited, just return. */\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for unoptimizing completion. */\n\twait_for_kprobe_optimizer();\n\tpr_info(\"kprobe jump-optimization is disabled. All kprobes are based on software breakpoint.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "length",
            "ppos"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1567-1571",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_sysctl_mutex"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int proc_kprobes_optimization_handler(struct ctl_table *table,\n\t\t\t\t\t     int write, void *buffer,\n\t\t\t\t\t     size_t *length, loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&kprobe_sysctl_mutex);\n\tsysctl_kprobes_optimization = kprobes_allow_optimization ? 1 : 0;\n\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\n\tif (sysctl_kprobes_optimization)\n\t\toptimize_all_kprobes();\n\telse\n\t\tunoptimize_all_kprobes();\n\tmutex_unlock(&kprobe_sysctl_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unoptimize_all_kprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "913-941",
    "snippet": "static void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already prohibited, just return. */\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for unoptimizing completion. */\n\twait_for_kprobe_optimizer();\n\tpr_info(\"kprobe jump-optimization is disabled. All kprobes are based on software breakpoint.\\n\");\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kprobe jump-optimization is disabled. All kprobes are based on software breakpoint.\\n\""
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_kprobe_optimizer",
          "args": [],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_kprobe_optimizer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "647-663",
          "snippet": "void wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* This will also make 'optimizing_work' execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* 'optimizing_work' might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* This will also make 'optimizing_work' execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* 'optimizing_work' might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unoptimize_kprobe",
          "args": [
            "p",
            "false"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "unoptimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "727-765",
          "snippet": "static void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p))\n\t\treturn;\n\n\tif (!list_empty(&op->list)) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* Queued in unoptimizing queue */\n\t\t\tif (force) {\n\t\t\t\t/*\n\t\t\t\t * Forcibly unoptimize the kprobe here, and queue it\n\t\t\t\t * in the freeing list for release afterwards.\n\t\t\t\t */\n\t\t\t\tforce_unoptimize_kprobe(op);\n\t\t\t\tlist_move(&op->list, &freeing_list);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Dequeue from the optimizing queue */\n\t\t\tlist_del_init(&op->list);\n\t\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Optimized kprobe case */\n\tif (force) {\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\t} else {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p))\n\t\treturn;\n\n\tif (!list_empty(&op->list)) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* Queued in unoptimizing queue */\n\t\t\tif (force) {\n\t\t\t\t/*\n\t\t\t\t * Forcibly unoptimize the kprobe here, and queue it\n\t\t\t\t * in the freeing list for release afterwards.\n\t\t\t\t */\n\t\t\t\tforce_unoptimize_kprobe(op);\n\t\t\t\tlist_move(&op->list, &freeing_list);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Dequeue from the optimizing queue */\n\t\t\tlist_del_init(&op->list);\n\t\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Optimized kprobe case */\n\tif (force) {\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\t} else {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already prohibited, just return. */\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\tmutex_unlock(&kprobe_mutex);\n\n\t/* Wait for unoptimizing completion. */\n\twait_for_kprobe_optimizer();\n\tpr_info(\"kprobe jump-optimization is disabled. All kprobes are based on software breakpoint.\\n\");\n}"
  },
  {
    "function_name": "optimize_all_kprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "887-910",
    "snippet": "static void optimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already allowed, just return. */\n\tif (kprobes_allow_optimization)\n\t\tgoto out;\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = true;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist)\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\toptimize_kprobe(p);\n\t}\n\tcpus_read_unlock();\n\tpr_info(\"kprobe jump-optimization is enabled. All kprobes are optimized if possible.\\n\");\nout:\n\tmutex_unlock(&kprobe_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kprobe jump-optimization is enabled. All kprobes are optimized if possible.\\n\""
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "p"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "852-885",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "p",
            "head",
            "hlist"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_TABLE_SIZE (1 << KPROBE_HASH_BITS)\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void optimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t/* If optimization is already allowed, just return. */\n\tif (kprobes_allow_optimization)\n\t\tgoto out;\n\n\tcpus_read_lock();\n\tkprobes_allow_optimization = true;\n\tfor (i = 0; i < KPROBE_TABLE_SIZE; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry(p, head, hlist)\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\toptimize_kprobe(p);\n\t}\n\tcpus_read_unlock();\n\tpr_info(\"kprobe jump-optimization is enabled. All kprobes are optimized if possible.\\n\");\nout:\n\tmutex_unlock(&kprobe_mutex);\n}"
  },
  {
    "function_name": "try_to_optimize_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "852-885",
    "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "30-33",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(jump_label_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic DEFINE_MUTEX(jump_label_mutex);\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&text_mutex"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "ap"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "852-885",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "init_aggr_kprobe",
          "args": [
            "ap",
            "p"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "init_aggr_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1348-1365",
          "snippet": "static void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy the insn slot of 'p' to 'ap'. */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void init_aggr_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\t/* Copy the insn slot of 'p' to 'ap'. */\n\tcopy_kprobe(p, ap);\n\tflush_insn_slot(ap);\n\tap->addr = p->addr;\n\tap->flags = p->flags & ~KPROBE_FLAG_OPTIMIZED;\n\tap->pre_handler = aggr_pre_handler;\n\t/* We don't care the kprobe which has gone. */\n\tif (p->post_handler && !kprobe_gone(p))\n\t\tap->post_handler = aggr_post_handler;\n\n\tINIT_LIST_HEAD(&ap->list);\n\tINIT_HLIST_NODE(&ap->hlist);\n\n\tlist_add_rcu(&p->list, &ap->list);\n\thlist_replace_rcu(&p->hlist, &ap->hlist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remove_optimized_kprobe",
          "args": [
            "op"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_prepared_optinsn",
          "args": [
            "&op->optinsn"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ap",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_aggr_kprobe",
          "args": [
            "p"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_aggr_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1055-1058",
          "snippet": "static struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\treturn kzalloc(sizeof(struct kprobe), GFP_KERNEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/jump_label.c",
          "lines": "25-28",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(jump_label_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic DEFINE_MUTEX(jump_label_mutex);\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_ftrace",
          "args": [
            "p"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1148-1151",
          "snippet": "static inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "alloc_aggr_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "831-844",
    "snippet": "static struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = kzalloc(sizeof(struct optimized_kprobe), GFP_KERNEL);\n\tif (!op)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&op->list);\n\top->kp.addr = p->addr;\n\t__prepare_optimized_kprobe(op, p);\n\n\treturn &op->kp;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__prepare_optimized_kprobe",
          "args": [
            "op",
            "p"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "__prepare_optimized_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "814-819",
          "snippet": "static inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&op->list"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct optimized_kprobe)",
            "GFP_KERNEL"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *alloc_aggr_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = kzalloc(sizeof(struct optimized_kprobe), GFP_KERNEL);\n\tif (!op)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&op->list);\n\top->kp.addr = p->addr;\n\t__prepare_optimized_kprobe(op, p);\n\n\treturn &op->kp;\n}"
  },
  {
    "function_name": "prepare_optimized_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "822-828",
    "snippet": "static void prepare_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\t__prepare_optimized_kprobe(op, p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__prepare_optimized_kprobe",
          "args": [
            "op",
            "p"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "__prepare_optimized_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "814-819",
          "snippet": "static inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void prepare_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\t__prepare_optimized_kprobe(op, p);\n}"
  },
  {
    "function_name": "__prepare_optimized_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "814-819",
    "snippet": "static inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_prepare_optimized_kprobe",
          "args": [
            "op",
            "p"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_ftrace",
          "args": [
            "p"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "disarm_kprobe_ftrace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1148-1151",
          "snippet": "static inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int disarm_kprobe_ftrace(struct kprobe *p)\n{\n\treturn -ENODEV;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline\nvoid __prepare_optimized_kprobe(struct optimized_kprobe *op, struct kprobe *p)\n{\n\tif (!kprobe_ftrace(p))\n\t\tarch_prepare_optimized_kprobe(op, p);\n}"
  },
  {
    "function_name": "kill_optimized_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "789-812",
    "snippet": "static void kill_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!list_empty(&op->list))\n\t\t/* Dequeue from the (un)optimization queue */\n\t\tlist_del_init(&op->list);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\n\tif (kprobe_unused(p)) {\n\t\t/* Enqueue if it is unused */\n\t\tlist_add(&op->list, &freeing_list);\n\t\t/*\n\t\t * Remove unused probes from the hash list. After waiting\n\t\t * for synchronization, this probe is reclaimed.\n\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t */\n\t\thlist_del_rcu(&op->kp.hlist);\n\t}\n\n\t/* Don't touch the code, because it is already freed. */\n\tarch_remove_optimized_kprobe(op);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_remove_optimized_kprobe",
          "args": [
            "op"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&op->kp.hlist"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&op->list",
            "&freeing_list"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_unused",
          "args": [
            "p"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_unused",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "401-405",
          "snippet": "static inline bool kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void kill_optimized_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!list_empty(&op->list))\n\t\t/* Dequeue from the (un)optimization queue */\n\t\tlist_del_init(&op->list);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\n\tif (kprobe_unused(p)) {\n\t\t/* Enqueue if it is unused */\n\t\tlist_add(&op->list, &freeing_list);\n\t\t/*\n\t\t * Remove unused probes from the hash list. After waiting\n\t\t * for synchronization, this probe is reclaimed.\n\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t */\n\t\thlist_del_rcu(&op->kp.hlist);\n\t}\n\n\t/* Don't touch the code, because it is already freed. */\n\tarch_remove_optimized_kprobe(op);\n}"
  },
  {
    "function_name": "reuse_unused_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "768-786",
    "snippet": "static int reuse_unused_kprobe(struct kprobe *ap)\n{\n\tstruct optimized_kprobe *op;\n\n\t/*\n\t * Unused kprobe MUST be on the way of delayed unoptimizing (means\n\t * there is still a relative jump) and disabled.\n\t */\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tWARN_ON_ONCE(list_empty(&op->list));\n\t/* Enable the probe again */\n\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t/* Optimize it again. (remove from 'op->list') */\n\tif (!kprobe_optready(ap))\n\t\treturn -EINVAL;\n\n\toptimize_kprobe(ap);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "optimize_kprobe",
          "args": [
            "ap"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_optimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "852-885",
          "snippet": "static void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void try_to_optimize_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *ap;\n\tstruct optimized_kprobe *op;\n\n\t/* Impossible to optimize ftrace-based kprobe. */\n\tif (kprobe_ftrace(p))\n\t\treturn;\n\n\t/* For preparing optimization, jump_label_text_reserved() is called. */\n\tcpus_read_lock();\n\tjump_label_lock();\n\tmutex_lock(&text_mutex);\n\n\tap = alloc_aggr_kprobe(p);\n\tif (!ap)\n\t\tgoto out;\n\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tif (!arch_prepared_optinsn(&op->optinsn)) {\n\t\t/* If failed to setup optimizing, fallback to kprobe. */\n\t\tarch_remove_optimized_kprobe(op);\n\t\tkfree(op);\n\t\tgoto out;\n\t}\n\n\tinit_aggr_kprobe(ap, p);\n\toptimize_kprobe(ap);\t/* This just kicks optimizer thread. */\n\nout:\n\tmutex_unlock(&text_mutex);\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_optready",
          "args": [
            "ap"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_optready",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "448-458",
          "snippet": "static inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "list_empty(&op->list)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ap",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int reuse_unused_kprobe(struct kprobe *ap)\n{\n\tstruct optimized_kprobe *op;\n\n\t/*\n\t * Unused kprobe MUST be on the way of delayed unoptimizing (means\n\t * there is still a relative jump) and disabled.\n\t */\n\top = container_of(ap, struct optimized_kprobe, kp);\n\tWARN_ON_ONCE(list_empty(&op->list));\n\t/* Enable the probe again */\n\tap->flags &= ~KPROBE_FLAG_DISABLED;\n\t/* Optimize it again. (remove from 'op->list') */\n\tif (!kprobe_optready(ap))\n\t\treturn -EINVAL;\n\n\toptimize_kprobe(ap);\n\treturn 0;\n}"
  },
  {
    "function_name": "unoptimize_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "727-765",
    "snippet": "static void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p))\n\t\treturn;\n\n\tif (!list_empty(&op->list)) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* Queued in unoptimizing queue */\n\t\t\tif (force) {\n\t\t\t\t/*\n\t\t\t\t * Forcibly unoptimize the kprobe here, and queue it\n\t\t\t\t * in the freeing list for release afterwards.\n\t\t\t\t */\n\t\t\t\tforce_unoptimize_kprobe(op);\n\t\t\t\tlist_move(&op->list, &freeing_list);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Dequeue from the optimizing queue */\n\t\t\tlist_del_init(&op->list);\n\t\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Optimized kprobe case */\n\tif (force) {\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\t} else {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kick_kprobe_optimizer",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "kick_kprobe_optimizer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "601-604",
          "snippet": "static void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define OPTIMIZE_DELAY 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define OPTIMIZE_DELAY 5\n\nstatic void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&op->list",
            "&unoptimizing_list"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_unoptimize_kprobe",
          "args": [
            "op"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "force_unoptimize_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "719-724",
          "snippet": "static void force_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tlockdep_assert_cpus_held();\n\tarch_unoptimize_kprobe(op);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void force_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tlockdep_assert_cpus_held();\n\tarch_unoptimize_kprobe(op);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&op->list",
            "&freeing_list"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "optprobe_queued_unopt",
          "args": [
            "op"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "optprobe_queued_unopt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "665-675",
          "snippet": "static bool optprobe_queued_unopt(struct optimized_kprobe *op)\n{\n\tstruct optimized_kprobe *_op;\n\n\tlist_for_each_entry(_op, &unoptimizing_list, list) {\n\t\tif (op == _op)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool optprobe_queued_unopt(struct optimized_kprobe *op)\n{\n\tstruct optimized_kprobe *_op;\n\n\tlist_for_each_entry(_op, &unoptimizing_list, list) {\n\t\tif (op == _op)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_optimized",
          "args": [
            "p"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disarmed",
          "args": [
            "p"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_disarmed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "461-472",
          "snippet": "static inline bool kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "395-398",
          "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void unoptimize_kprobe(struct kprobe *p, bool force)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (!kprobe_aggrprobe(p) || kprobe_disarmed(p))\n\t\treturn; /* This is not an optprobe nor optimized */\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tif (!kprobe_optimized(p))\n\t\treturn;\n\n\tif (!list_empty(&op->list)) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* Queued in unoptimizing queue */\n\t\t\tif (force) {\n\t\t\t\t/*\n\t\t\t\t * Forcibly unoptimize the kprobe here, and queue it\n\t\t\t\t * in the freeing list for release afterwards.\n\t\t\t\t */\n\t\t\t\tforce_unoptimize_kprobe(op);\n\t\t\t\tlist_move(&op->list, &freeing_list);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Dequeue from the optimizing queue */\n\t\t\tlist_del_init(&op->list);\n\t\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t}\n\t\treturn;\n\t}\n\n\t/* Optimized kprobe case */\n\tif (force) {\n\t\t/* Forcibly update the code: this is a special case */\n\t\tforce_unoptimize_kprobe(op);\n\t} else {\n\t\tlist_add(&op->list, &unoptimizing_list);\n\t\tkick_kprobe_optimizer();\n\t}\n}"
  },
  {
    "function_name": "force_unoptimize_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "719-724",
    "snippet": "static void force_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tlockdep_assert_cpus_held();\n\tarch_unoptimize_kprobe(op);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_unoptimize_kprobe",
          "args": [
            "op"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "335-347",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void force_unoptimize_kprobe(struct optimized_kprobe *op)\n{\n\tlockdep_assert_cpus_held();\n\tarch_unoptimize_kprobe(op);\n\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n}"
  },
  {
    "function_name": "optimize_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "678-716",
    "snippet": "static void optimize_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* Check if the kprobe is disabled or not ready for optimization. */\n\tif (!kprobe_optready(p) || !kprobes_allow_optimization ||\n\t    (kprobe_disabled(p) || kprobes_all_disarmed))\n\t\treturn;\n\n\t/* kprobes with 'post_handler' can not be optimized */\n\tif (p->post_handler)\n\t\treturn;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\t/* Check there is no other kprobes at the optimized instructions */\n\tif (arch_check_optimized_kprobe(op) < 0)\n\t\treturn;\n\n\t/* Check if it is already optimized. */\n\tif (op->kp.flags & KPROBE_FLAG_OPTIMIZED) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* This is under unoptimizing. Just dequeue the probe */\n\t\t\tlist_del_init(&op->list);\n\t\t}\n\t\treturn;\n\t}\n\top->kp.flags |= KPROBE_FLAG_OPTIMIZED;\n\n\t/*\n\t * On the 'unoptimizing_list' and 'optimizing_list',\n\t * 'op' must have OPTIMIZED flag\n\t */\n\tif (WARN_ON_ONCE(!list_empty(&op->list)))\n\t\treturn;\n\n\tlist_add(&op->list, &optimizing_list);\n\tkick_kprobe_optimizer();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kick_kprobe_optimizer",
          "args": [],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "kick_kprobe_optimizer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "601-604",
          "snippet": "static void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define OPTIMIZE_DELAY 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define OPTIMIZE_DELAY 5\n\nstatic void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&op->list",
            "&optimizing_list"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_filterlist_addrs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/debugfs.c",
          "lines": "95-101",
          "snippet": "static int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/bug.h>\n#include <linux/bsearch.h>\n#include <linux/atomic.h>\n\nstatic int cmp_filterlist_addrs(const void *rhs, const void *lhs)\n{\n\tconst unsigned long a = *(const unsigned long *)rhs;\n\tconst unsigned long b = *(const unsigned long *)lhs;\n\n\treturn a < b ? -1 : a == b ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_empty(&op->list)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "optprobe_queued_unopt",
          "args": [
            "op"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "optprobe_queued_unopt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "665-675",
          "snippet": "static bool optprobe_queued_unopt(struct optimized_kprobe *op)\n{\n\tstruct optimized_kprobe *_op;\n\n\tlist_for_each_entry(_op, &unoptimizing_list, list) {\n\t\tif (op == _op)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool optprobe_queued_unopt(struct optimized_kprobe *op)\n{\n\tstruct optimized_kprobe *_op;\n\n\tlist_for_each_entry(_op, &unoptimizing_list, list) {\n\t\tif (op == _op)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_check_optimized_kprobe",
          "args": [
            "op"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_optready",
          "args": [
            "p"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_optready",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "448-458",
          "snippet": "static inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic void optimize_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* Check if the kprobe is disabled or not ready for optimization. */\n\tif (!kprobe_optready(p) || !kprobes_allow_optimization ||\n\t    (kprobe_disabled(p) || kprobes_all_disarmed))\n\t\treturn;\n\n\t/* kprobes with 'post_handler' can not be optimized */\n\tif (p->post_handler)\n\t\treturn;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\t/* Check there is no other kprobes at the optimized instructions */\n\tif (arch_check_optimized_kprobe(op) < 0)\n\t\treturn;\n\n\t/* Check if it is already optimized. */\n\tif (op->kp.flags & KPROBE_FLAG_OPTIMIZED) {\n\t\tif (optprobe_queued_unopt(op)) {\n\t\t\t/* This is under unoptimizing. Just dequeue the probe */\n\t\t\tlist_del_init(&op->list);\n\t\t}\n\t\treturn;\n\t}\n\top->kp.flags |= KPROBE_FLAG_OPTIMIZED;\n\n\t/*\n\t * On the 'unoptimizing_list' and 'optimizing_list',\n\t * 'op' must have OPTIMIZED flag\n\t */\n\tif (WARN_ON_ONCE(!list_empty(&op->list)))\n\t\treturn;\n\n\tlist_add(&op->list, &optimizing_list);\n\tkick_kprobe_optimizer();\n}"
  },
  {
    "function_name": "optprobe_queued_unopt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "665-675",
    "snippet": "static bool optprobe_queued_unopt(struct optimized_kprobe *op)\n{\n\tstruct optimized_kprobe *_op;\n\n\tlist_for_each_entry(_op, &unoptimizing_list, list) {\n\t\tif (op == _op)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "_op",
            "&unoptimizing_list",
            "list"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool optprobe_queued_unopt(struct optimized_kprobe *op)\n{\n\tstruct optimized_kprobe *_op;\n\n\tlist_for_each_entry(_op, &unoptimizing_list, list) {\n\t\tif (op == _op)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "wait_for_kprobe_optimizer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "647-663",
    "snippet": "void wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* This will also make 'optimizing_work' execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* 'optimizing_work' might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_delayed_work",
          "args": [
            "&optimizing_work"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "flush_delayed_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3232-3239",
          "snippet": "bool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&unoptimizing_list"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nvoid wait_for_kprobe_optimizer(void)\n{\n\tmutex_lock(&kprobe_mutex);\n\n\twhile (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list)) {\n\t\tmutex_unlock(&kprobe_mutex);\n\n\t\t/* This will also make 'optimizing_work' execute immmediately */\n\t\tflush_delayed_work(&optimizing_work);\n\t\t/* 'optimizing_work' might not have been queued yet, relax */\n\t\tcpu_relax();\n\n\t\tmutex_lock(&kprobe_mutex);\n\t}\n\n\tmutex_unlock(&kprobe_mutex);\n}"
  },
  {
    "function_name": "kprobe_optimizer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "607-644",
    "snippet": "static void kprobe_optimizer(struct work_struct *work)\n{\n\tmutex_lock(&kprobe_mutex);\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\n\t/*\n\t * Step 1: Unoptimize kprobes and collect cleaned (unused and disarmed)\n\t * kprobes before waiting for quiesence period.\n\t */\n\tdo_unoptimize_kprobes();\n\n\t/*\n\t * Step 2: Wait for quiesence period to ensure all potentially\n\t * preempted tasks to have normally scheduled. Because optprobe\n\t * may modify multiple instructions, there is a chance that Nth\n\t * instruction is preempted. In that case, such tasks can return\n\t * to 2nd-Nth byte of jump instruction. This wait is for avoiding it.\n\t * Note that on non-preemptive kernel, this is transparently converted\n\t * to synchronoze_sched() to wait for all interrupts to have completed.\n\t */\n\tsynchronize_rcu_tasks();\n\n\t/* Step 3: Optimize kprobes after quiesence period */\n\tdo_optimize_kprobes();\n\n\t/* Step 4: Free cleaned kprobes after quiesence period */\n\tdo_free_cleaned_kprobes();\n\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\t/* Step 5: Kick optimizer again if needed */\n\tif (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list))\n\t\tkick_kprobe_optimizer();\n\n\tmutex_unlock(&kprobe_mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kick_kprobe_optimizer",
          "args": [],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "kick_kprobe_optimizer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "601-604",
          "snippet": "static void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define OPTIMIZE_DELAY 5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define OPTIMIZE_DELAY 5\n\nstatic void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&unoptimizing_list"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_free_cleaned_kprobes",
          "args": [],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "do_free_cleaned_kprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "583-598",
          "snippet": "static void do_free_cleaned_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\tlist_del_init(&op->list);\n\t\tif (WARN_ON_ONCE(!kprobe_unused(&op->kp))) {\n\t\t\t/*\n\t\t\t * This must not happen, but if there is a kprobe\n\t\t\t * still in use, keep it on kprobes hash list.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tfree_aggr_kprobe(&op->kp);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void do_free_cleaned_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\tlist_del_init(&op->list);\n\t\tif (WARN_ON_ONCE(!kprobe_unused(&op->kp))) {\n\t\t\t/*\n\t\t\t * This must not happen, but if there is a kprobe\n\t\t\t * still in use, keep it on kprobes hash list.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tfree_aggr_kprobe(&op->kp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_optimize_kprobes",
          "args": [],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "do_optimize_kprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "523-544",
          "snippet": "static void do_optimize_kprobes(void)\n{\n\tlockdep_assert_held(&text_mutex);\n\t/*\n\t * The optimization/unoptimization refers 'online_cpus' via\n\t * stop_machine() and cpu-hotplug modifies the 'online_cpus'.\n\t * And same time, 'text_mutex' will be held in cpu-hotplug and here.\n\t * This combination can cause a deadlock (cpu-hotplug tries to lock\n\t * 'text_mutex' but stop_machine() can not be done because\n\t * the 'online_cpus' has been changed)\n\t * To avoid this deadlock, caller must have locked cpu-hotplug\n\t * for preventing cpu-hotplug outside of 'text_mutex' locking.\n\t */\n\tlockdep_assert_cpus_held();\n\n\t/* Optimization never be done when disarmed */\n\tif (kprobes_all_disarmed || !kprobes_allow_optimization ||\n\t    list_empty(&optimizing_list))\n\t\treturn;\n\n\tarch_optimize_kprobes(&optimizing_list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kprobes_all_disarmed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic void do_optimize_kprobes(void)\n{\n\tlockdep_assert_held(&text_mutex);\n\t/*\n\t * The optimization/unoptimization refers 'online_cpus' via\n\t * stop_machine() and cpu-hotplug modifies the 'online_cpus'.\n\t * And same time, 'text_mutex' will be held in cpu-hotplug and here.\n\t * This combination can cause a deadlock (cpu-hotplug tries to lock\n\t * 'text_mutex' but stop_machine() can not be done because\n\t * the 'online_cpus' has been changed)\n\t * To avoid this deadlock, caller must have locked cpu-hotplug\n\t * for preventing cpu-hotplug outside of 'text_mutex' locking.\n\t */\n\tlockdep_assert_cpus_held();\n\n\t/* Optimization never be done when disarmed */\n\tif (kprobes_all_disarmed || !kprobes_allow_optimization ||\n\t    list_empty(&optimizing_list))\n\t\treturn;\n\n\tarch_optimize_kprobes(&optimizing_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_rcu_tasks",
          "args": [],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks_trace",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tasks.h",
          "lines": "1556-1560",
          "snippet": "void synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n\nvoid synchronize_rcu_tasks_trace(void)\n{\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_trace_lock_map), \"Illegal synchronize_rcu_tasks_trace() in RCU Tasks Trace read-side critical section\");\n\tsynchronize_rcu_tasks_generic(&rcu_tasks_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_unoptimize_kprobes",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "do_unoptimize_kprobes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "550-580",
          "snippet": "static void do_unoptimize_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlockdep_assert_held(&text_mutex);\n\t/* See comment in do_optimize_kprobes() */\n\tlockdep_assert_cpus_held();\n\n\t/* Unoptimization must be done anytime */\n\tif (list_empty(&unoptimizing_list))\n\t\treturn;\n\n\tarch_unoptimize_kprobes(&unoptimizing_list, &freeing_list);\n\t/* Loop on 'freeing_list' for disarming */\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\t/* Switching from detour code to origin */\n\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t/* Disarm probes if marked disabled */\n\t\tif (kprobe_disabled(&op->kp))\n\t\t\tarch_disarm_kprobe(&op->kp);\n\t\tif (kprobe_unused(&op->kp)) {\n\t\t\t/*\n\t\t\t * Remove unused probes from hash list. After waiting\n\t\t\t * for synchronization, these probes are reclaimed.\n\t\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t\t */\n\t\t\thlist_del_rcu(&op->kp.hlist);\n\t\t} else\n\t\t\tlist_del_init(&op->list);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void do_unoptimize_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlockdep_assert_held(&text_mutex);\n\t/* See comment in do_optimize_kprobes() */\n\tlockdep_assert_cpus_held();\n\n\t/* Unoptimization must be done anytime */\n\tif (list_empty(&unoptimizing_list))\n\t\treturn;\n\n\tarch_unoptimize_kprobes(&unoptimizing_list, &freeing_list);\n\t/* Loop on 'freeing_list' for disarming */\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\t/* Switching from detour code to origin */\n\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t/* Disarm probes if marked disabled */\n\t\tif (kprobe_disabled(&op->kp))\n\t\t\tarch_disarm_kprobe(&op->kp);\n\t\tif (kprobe_unused(&op->kp)) {\n\t\t\t/*\n\t\t\t * Remove unused probes from hash list. After waiting\n\t\t\t * for synchronization, these probes are reclaimed.\n\t\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t\t */\n\t\t\thlist_del_rcu(&op->kp.hlist);\n\t\t} else\n\t\t\tlist_del_init(&op->list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&text_mutex"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic void kprobe_optimizer(struct work_struct *work)\n{\n\tmutex_lock(&kprobe_mutex);\n\tcpus_read_lock();\n\tmutex_lock(&text_mutex);\n\n\t/*\n\t * Step 1: Unoptimize kprobes and collect cleaned (unused and disarmed)\n\t * kprobes before waiting for quiesence period.\n\t */\n\tdo_unoptimize_kprobes();\n\n\t/*\n\t * Step 2: Wait for quiesence period to ensure all potentially\n\t * preempted tasks to have normally scheduled. Because optprobe\n\t * may modify multiple instructions, there is a chance that Nth\n\t * instruction is preempted. In that case, such tasks can return\n\t * to 2nd-Nth byte of jump instruction. This wait is for avoiding it.\n\t * Note that on non-preemptive kernel, this is transparently converted\n\t * to synchronoze_sched() to wait for all interrupts to have completed.\n\t */\n\tsynchronize_rcu_tasks();\n\n\t/* Step 3: Optimize kprobes after quiesence period */\n\tdo_optimize_kprobes();\n\n\t/* Step 4: Free cleaned kprobes after quiesence period */\n\tdo_free_cleaned_kprobes();\n\n\tmutex_unlock(&text_mutex);\n\tcpus_read_unlock();\n\n\t/* Step 5: Kick optimizer again if needed */\n\tif (!list_empty(&optimizing_list) || !list_empty(&unoptimizing_list))\n\t\tkick_kprobe_optimizer();\n\n\tmutex_unlock(&kprobe_mutex);\n}"
  },
  {
    "function_name": "kick_kprobe_optimizer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "601-604",
    "snippet": "static void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define OPTIMIZE_DELAY 5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&optimizing_work",
            "OPTIMIZE_DELAY"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define OPTIMIZE_DELAY 5\n\nstatic void kick_kprobe_optimizer(void)\n{\n\tschedule_delayed_work(&optimizing_work, OPTIMIZE_DELAY);\n}"
  },
  {
    "function_name": "do_free_cleaned_kprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "583-598",
    "snippet": "static void do_free_cleaned_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\tlist_del_init(&op->list);\n\t\tif (WARN_ON_ONCE(!kprobe_unused(&op->kp))) {\n\t\t\t/*\n\t\t\t * This must not happen, but if there is a kprobe\n\t\t\t * still in use, keep it on kprobes hash list.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tfree_aggr_kprobe(&op->kp);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_aggr_kprobe",
          "args": [
            "&op->kp"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "free_aggr_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1049-1053",
          "snippet": "static void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_aggr_kprobe(struct kprobe *p)\n{\n\tarch_remove_kprobe(p);\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!kprobe_unused(&op->kp)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_unused",
          "args": [
            "&op->kp"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_unused",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "401-405",
          "snippet": "static inline bool kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "op",
            "tmp",
            "&freeing_list",
            "list"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void do_free_cleaned_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\tlist_del_init(&op->list);\n\t\tif (WARN_ON_ONCE(!kprobe_unused(&op->kp))) {\n\t\t\t/*\n\t\t\t * This must not happen, but if there is a kprobe\n\t\t\t * still in use, keep it on kprobes hash list.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tfree_aggr_kprobe(&op->kp);\n\t}\n}"
  },
  {
    "function_name": "do_unoptimize_kprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "550-580",
    "snippet": "static void do_unoptimize_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlockdep_assert_held(&text_mutex);\n\t/* See comment in do_optimize_kprobes() */\n\tlockdep_assert_cpus_held();\n\n\t/* Unoptimization must be done anytime */\n\tif (list_empty(&unoptimizing_list))\n\t\treturn;\n\n\tarch_unoptimize_kprobes(&unoptimizing_list, &freeing_list);\n\t/* Loop on 'freeing_list' for disarming */\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\t/* Switching from detour code to origin */\n\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t/* Disarm probes if marked disabled */\n\t\tif (kprobe_disabled(&op->kp))\n\t\t\tarch_disarm_kprobe(&op->kp);\n\t\tif (kprobe_unused(&op->kp)) {\n\t\t\t/*\n\t\t\t * Remove unused probes from hash list. After waiting\n\t\t\t * for synchronization, these probes are reclaimed.\n\t\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t\t */\n\t\t\thlist_del_rcu(&op->kp.hlist);\n\t\t} else\n\t\t\tlist_del_init(&op->list);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&op->list"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&op->kp.hlist"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_unused",
          "args": [
            "&op->kp"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_unused",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "401-405",
          "snippet": "static inline bool kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_disarm_kprobe",
          "args": [
            "&op->kp"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "&op->kp"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "op",
            "tmp",
            "&freeing_list",
            "list"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_unoptimize_kprobes",
          "args": [
            "&unoptimizing_list",
            "&freeing_list"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&unoptimizing_list"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "335-347",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&text_mutex"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void do_unoptimize_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\tlockdep_assert_held(&text_mutex);\n\t/* See comment in do_optimize_kprobes() */\n\tlockdep_assert_cpus_held();\n\n\t/* Unoptimization must be done anytime */\n\tif (list_empty(&unoptimizing_list))\n\t\treturn;\n\n\tarch_unoptimize_kprobes(&unoptimizing_list, &freeing_list);\n\t/* Loop on 'freeing_list' for disarming */\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\t/* Switching from detour code to origin */\n\t\top->kp.flags &= ~KPROBE_FLAG_OPTIMIZED;\n\t\t/* Disarm probes if marked disabled */\n\t\tif (kprobe_disabled(&op->kp))\n\t\t\tarch_disarm_kprobe(&op->kp);\n\t\tif (kprobe_unused(&op->kp)) {\n\t\t\t/*\n\t\t\t * Remove unused probes from hash list. After waiting\n\t\t\t * for synchronization, these probes are reclaimed.\n\t\t\t * (reclaiming is done by do_free_cleaned_kprobes().)\n\t\t\t */\n\t\t\thlist_del_rcu(&op->kp.hlist);\n\t\t} else\n\t\t\tlist_del_init(&op->list);\n\t}\n}"
  },
  {
    "function_name": "do_optimize_kprobes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "523-544",
    "snippet": "static void do_optimize_kprobes(void)\n{\n\tlockdep_assert_held(&text_mutex);\n\t/*\n\t * The optimization/unoptimization refers 'online_cpus' via\n\t * stop_machine() and cpu-hotplug modifies the 'online_cpus'.\n\t * And same time, 'text_mutex' will be held in cpu-hotplug and here.\n\t * This combination can cause a deadlock (cpu-hotplug tries to lock\n\t * 'text_mutex' but stop_machine() can not be done because\n\t * the 'online_cpus' has been changed)\n\t * To avoid this deadlock, caller must have locked cpu-hotplug\n\t * for preventing cpu-hotplug outside of 'text_mutex' locking.\n\t */\n\tlockdep_assert_cpus_held();\n\n\t/* Optimization never be done when disarmed */\n\tif (kprobes_all_disarmed || !kprobes_allow_optimization ||\n\t    list_empty(&optimizing_list))\n\t\treturn;\n\n\tarch_optimize_kprobes(&optimizing_list);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kprobes_all_disarmed;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_optimize_kprobes",
          "args": [
            "&optimizing_list"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&optimizing_list"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "335-347",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\t/*\n\t * We can't have hotplug operations before userspace starts running,\n\t * and some init codepaths will knowingly not take the hotplug lock.\n\t * This is all valid, so mute lockdep until it makes sense to report\n\t * unheld locks.\n\t */\n\tif (system_state < SYSTEM_RUNNING)\n\t\treturn;\n\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&text_mutex"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobes_all_disarmed;\n\nstatic void do_optimize_kprobes(void)\n{\n\tlockdep_assert_held(&text_mutex);\n\t/*\n\t * The optimization/unoptimization refers 'online_cpus' via\n\t * stop_machine() and cpu-hotplug modifies the 'online_cpus'.\n\t * And same time, 'text_mutex' will be held in cpu-hotplug and here.\n\t * This combination can cause a deadlock (cpu-hotplug tries to lock\n\t * 'text_mutex' but stop_machine() can not be done because\n\t * the 'online_cpus' has been changed)\n\t * To avoid this deadlock, caller must have locked cpu-hotplug\n\t * for preventing cpu-hotplug outside of 'text_mutex' locking.\n\t */\n\tlockdep_assert_cpus_held();\n\n\t/* Optimization never be done when disarmed */\n\tif (kprobes_all_disarmed || !kprobes_allow_optimization ||\n\t    list_empty(&optimizing_list))\n\t\treturn;\n\n\tarch_optimize_kprobes(&optimizing_list);\n}"
  },
  {
    "function_name": "get_optimized_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "491-508",
    "snippet": "static struct kprobe *get_optimized_kprobe(kprobe_opcode_t *addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH / sizeof(kprobe_opcode_t); i++)\n\t\tp = get_kprobe(addr - i);\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_within_optimized_kprobe",
          "args": [
            "op",
            "addr"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_optready",
          "args": [
            "p"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_optready",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "448-458",
          "snippet": "static inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_kprobe",
          "args": [
            "addr - i"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "get_kprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "376-389",
          "snippet": "struct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist,\n\t\t\t\t lockdep_is_held(&kprobe_mutex)) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [
            "#define KPROBE_HASH_BITS 6"
          ],
          "globals_used": [
            "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstruct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist,\n\t\t\t\t lockdep_is_held(&kprobe_mutex)) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic struct kprobe *get_optimized_kprobe(kprobe_opcode_t *addr)\n{\n\tint i;\n\tstruct kprobe *p = NULL;\n\tstruct optimized_kprobe *op;\n\n\t/* Don't check i == 0, since that is a breakpoint case. */\n\tfor (i = 1; !p && i < MAX_OPTIMIZED_LENGTH / sizeof(kprobe_opcode_t); i++)\n\t\tp = get_kprobe(addr - i);\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "kprobe_queued",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "475-485",
    "snippet": "static bool kprobe_queued(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (!list_empty(&op->list))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "395-398",
          "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool kprobe_queued(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (!list_empty(&op->list))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "kprobe_disarmed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "461-472",
    "snippet": "static inline bool kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&op->list"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "395-398",
          "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_disarmed(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\t/* If kprobe is not aggr/opt probe, just return kprobe is disabled */\n\tif (!kprobe_aggrprobe(p))\n\t\treturn kprobe_disabled(p);\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\n\treturn kprobe_disabled(p) && list_empty(&op->list);\n}"
  },
  {
    "function_name": "kprobe_optready",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "448-458",
    "snippet": "static inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_prepared_optinsn",
          "args": [
            "&op->optinsn"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "395-398",
          "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline int kprobe_optready(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\tif (kprobe_aggrprobe(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\treturn arch_prepared_optinsn(&op->optinsn);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_aggr_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "437-445",
    "snippet": "static void free_aggr_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tarch_remove_optimized_kprobe(op);\n\tarch_remove_kprobe(p);\n\tkfree(op);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "op"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_remove_kprobe",
          "args": [
            "p"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_remove_optimized_kprobe",
          "args": [
            "op"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structoptimized_kprobe",
            "kp"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_aggr_kprobe(struct kprobe *p)\n{\n\tstruct optimized_kprobe *op;\n\n\top = container_of(p, struct optimized_kprobe, kp);\n\tarch_remove_optimized_kprobe(op);\n\tarch_remove_kprobe(p);\n\tkfree(op);\n}"
  },
  {
    "function_name": "opt_pre_handler",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "422-433",
    "snippet": "void opt_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->pre_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tkp->pre_handler(kp, regs);\n\t\t}\n\t\treset_kprobe_instance();\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_kprobe_instance",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "reset_kprobe_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "365-368",
          "snippet": "static inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance);\n\nstatic inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kp->pre_handler",
          "args": [
            "kp",
            "regs"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_kprobe_instance",
          "args": [
            "kp"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "set_kprobe_instance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "360-363",
          "snippet": "static inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance);\n\nstatic inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!kprobe_disabled(kp)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "kp"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kp",
            "&p->list",
            "list"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int aggr_pre_handler(struct kprobe *p, struct pt_regs *regs);\n\nvoid opt_pre_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe *kp;\n\n\tlist_for_each_entry_rcu(kp, &p->list, list) {\n\t\tif (kp->pre_handler && likely(!kprobe_disabled(kp))) {\n\t\t\tset_kprobe_instance(kp);\n\t\t\tkp->pre_handler(kp, regs);\n\t\t}\n\t\treset_kprobe_instance();\n\t}\n}"
  },
  {
    "function_name": "copy_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "408-412",
    "snippet": "static inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&p->ainsn",
            "&ap->ainsn",
            "sizeof(struct arch_specific_insn)"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline void copy_kprobe(struct kprobe *ap, struct kprobe *p)\n{\n\tmemcpy(&p->opcode, &ap->opcode, sizeof(kprobe_opcode_t));\n\tmemcpy(&p->ainsn, &ap->ainsn, sizeof(struct arch_specific_insn));\n}"
  },
  {
    "function_name": "kprobe_unused",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "401-405",
    "snippet": "static inline bool kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&p->list"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_disabled",
          "args": [
            "p"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "aggr_kprobe_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "1702-1717",
          "snippet": "static bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(kprobe_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstatic bool aggr_kprobe_disabled(struct kprobe *ap)\n{\n\tstruct kprobe *kp;\n\n\tlockdep_assert_held(&kprobe_mutex);\n\n\tlist_for_each_entry(kp, &ap->list, list)\n\t\tif (!kprobe_disabled(kp))\n\t\t\t/*\n\t\t\t * Since there is an active probe on the list,\n\t\t\t * we can't disable this 'ap'.\n\t\t\t */\n\t\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kprobe_aggrprobe",
          "args": [
            "p"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "kprobe_aggrprobe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "395-398",
          "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_unused(struct kprobe *p)\n{\n\treturn kprobe_aggrprobe(p) && kprobe_disabled(p) &&\n\t       list_empty(&p->list);\n}"
  },
  {
    "function_name": "kprobe_aggrprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "395-398",
    "snippet": "static inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic inline bool kprobe_aggrprobe(struct kprobe *p)\n{\n\treturn p->pre_handler == aggr_pre_handler;\n}"
  },
  {
    "function_name": "get_kprobe",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "376-389",
    "snippet": "struct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist,\n\t\t\t\t lockdep_is_held(&kprobe_mutex)) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [
      "#define KPROBE_HASH_BITS 6"
    ],
    "globals_used": [
      "static struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];",
      "static DEFINE_MUTEX(kprobe_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "p",
            "head",
            "hlist",
            "lockdep_is_held(&kprobe_mutex)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&kprobe_mutex"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash_ptr",
          "args": [
            "addr",
            "KPROBE_HASH_BITS"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\n#define KPROBE_HASH_BITS 6\n\nstatic struct hlist_head kprobe_table[KPROBE_TABLE_SIZE];\nstatic DEFINE_MUTEX(kprobe_mutex);\n\nstruct kprobe *get_kprobe(void *addr)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\n\thead = &kprobe_table[hash_ptr(addr, KPROBE_HASH_BITS)];\n\thlist_for_each_entry_rcu(p, head, hlist,\n\t\t\t\t lockdep_is_held(&kprobe_mutex)) {\n\t\tif (p->addr == addr)\n\t\t\treturn p;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "reset_kprobe_instance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "365-368",
    "snippet": "static inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "kprobe_instance",
            "NULL"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance);\n\nstatic inline void reset_kprobe_instance(void)\n{\n\t__this_cpu_write(kprobe_instance, NULL);\n}"
  },
  {
    "function_name": "set_kprobe_instance",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "360-363",
    "snippet": "static inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct kprobe *, kprobe_instance);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "kprobe_instance",
            "kp"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic DEFINE_PER_CPU(struct kprobe *, kprobe_instance);\n\nstatic inline void set_kprobe_instance(struct kprobe *kp)\n{\n\t__this_cpu_write(kprobe_instance, kp);\n}"
  },
  {
    "function_name": "free_optinsn_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "341-344",
    "snippet": "void __weak free_optinsn_page(void *page)\n{\n\tfree_insn_page(page);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_insn_page",
          "args": [
            "page"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "free_insn_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "124-127",
          "snippet": "static void free_insn_page(void *page)\n{\n\tmodule_memfree(page);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_insn_page(void *page)\n{\n\tmodule_memfree(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid __weak free_optinsn_page(void *page)\n{\n\tfree_insn_page(page);\n}"
  },
  {
    "function_name": "alloc_optinsn_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "336-339",
    "snippet": "void __weak *alloc_optinsn_page(void)\n{\n\treturn alloc_insn_page();\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_insn_page",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_insn_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "113-122",
          "snippet": "void __weak *alloc_insn_page(void)\n{\n\t/*\n\t * Use module_alloc() so this page is within +/- 2GB of where the\n\t * kernel image and loaded module images reside. This is required\n\t * for most of the architectures.\n\t * (e.g. x86-64 needs this to handle the %rip-relative fixups.)\n\t */\n\treturn module_alloc(PAGE_SIZE);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid __weak *alloc_insn_page(void)\n{\n\t/*\n\t * Use module_alloc() so this page is within +/- 2GB of where the\n\t * kernel image and loaded module images reside. This is required\n\t * for most of the architectures.\n\t * (e.g. x86-64 needs this to handle the %rip-relative fixups.)\n\t */\n\treturn module_alloc(PAGE_SIZE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid __weak *alloc_optinsn_page(void)\n{\n\treturn alloc_insn_page();\n}"
  },
  {
    "function_name": "kprobe_cache_get_kallsym",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "314-333",
    "snippet": "int kprobe_cache_get_kallsym(struct kprobe_insn_cache *c, unsigned int *symnum,\n\t\t\t     unsigned long *value, char *type, char *sym)\n{\n\tstruct kprobe_insn_page *kip;\n\tint ret = -ERANGE;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif ((*symnum)--)\n\t\t\tcontinue;\n\t\tstrscpy(sym, c->sym, KSYM_NAME_LEN);\n\t\t*type = 't';\n\t\t*value = (unsigned long)kip->insns;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "sym",
            "c->sym",
            "KSYM_NAME_LEN"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kip",
            "&c->pages",
            "list"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nint kprobe_cache_get_kallsym(struct kprobe_insn_cache *c, unsigned int *symnum,\n\t\t\t     unsigned long *value, char *type, char *sym)\n{\n\tstruct kprobe_insn_page *kip;\n\tint ret = -ERANGE;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif ((*symnum)--)\n\t\t\tcontinue;\n\t\tstrscpy(sym, c->sym, KSYM_NAME_LEN);\n\t\t*type = 't';\n\t\t*value = (unsigned long)kip->insns;\n\t\tret = 0;\n\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__is_insn_slot_addr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "296-312",
    "snippet": "bool __is_insn_slot_addr(struct kprobe_insn_cache *c, unsigned long addr)\n{\n\tstruct kprobe_insn_page *kip;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (addr >= (unsigned long)kip->insns &&\n\t\t    addr < (unsigned long)kip->insns + PAGE_SIZE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kip",
            "&c->pages",
            "list"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nbool __is_insn_slot_addr(struct kprobe_insn_cache *c, unsigned long addr)\n{\n\tstruct kprobe_insn_page *kip;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (addr >= (unsigned long)kip->insns &&\n\t\t    addr < (unsigned long)kip->insns + PAGE_SIZE) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__free_insn_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "256-289",
    "snippet": "void __free_insn_slot(struct kprobe_insn_cache *c,\n\t\t      kprobe_opcode_t *slot, int dirty)\n{\n\tstruct kprobe_insn_page *kip;\n\tlong idx;\n\n\tmutex_lock(&c->mutex);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tidx = ((long)slot - (long)kip->insns) /\n\t\t\t(c->insn_size * sizeof(kprobe_opcode_t));\n\t\tif (idx >= 0 && idx < slots_per_page(c))\n\t\t\tgoto out;\n\t}\n\t/* Could not find this slot. */\n\tWARN_ON(1);\n\tkip = NULL;\nout:\n\trcu_read_unlock();\n\t/* Mark and sweep: this may sleep */\n\tif (kip) {\n\t\t/* Check double free */\n\t\tWARN_ON(kip->slot_used[idx] != SLOT_USED);\n\t\tif (dirty) {\n\t\t\tkip->slot_used[idx] = SLOT_DIRTY;\n\t\t\tkip->ngarbage++;\n\t\t\tif (++c->nr_garbage > slots_per_page(c))\n\t\t\t\tcollect_garbage_slots(c);\n\t\t} else {\n\t\t\tcollect_one_slot(kip, idx);\n\t\t}\n\t}\n\tmutex_unlock(&c->mutex);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&c->mutex"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_one_slot",
          "args": [
            "kip",
            "idx"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "collect_one_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "205-232",
          "snippet": "static bool collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\t/*\n\t\t\t * Record perf ksymbol unregister event before removing\n\t\t\t * the page.\n\t\t\t */\n\t\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t\t   (unsigned long)kip->insns, PAGE_SIZE, true,\n\t\t\t\t\t   kip->cache->sym);\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\t/*\n\t\t\t * Record perf ksymbol unregister event before removing\n\t\t\t * the page.\n\t\t\t */\n\t\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t\t   (unsigned long)kip->insns, PAGE_SIZE, true,\n\t\t\t\t\t   kip->cache->sym);\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_garbage_slots",
          "args": [
            "c"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "collect_garbage_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "234-254",
          "snippet": "static int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slots_per_page",
          "args": [
            "c"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "slots_per_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "102-105",
          "snippet": "static int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kip->slot_used[idx] != SLOT_USED"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kip",
            "&c->pages",
            "list"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&c->mutex"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid __free_insn_slot(struct kprobe_insn_cache *c,\n\t\t      kprobe_opcode_t *slot, int dirty)\n{\n\tstruct kprobe_insn_page *kip;\n\tlong idx;\n\n\tmutex_lock(&c->mutex);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tidx = ((long)slot - (long)kip->insns) /\n\t\t\t(c->insn_size * sizeof(kprobe_opcode_t));\n\t\tif (idx >= 0 && idx < slots_per_page(c))\n\t\t\tgoto out;\n\t}\n\t/* Could not find this slot. */\n\tWARN_ON(1);\n\tkip = NULL;\nout:\n\trcu_read_unlock();\n\t/* Mark and sweep: this may sleep */\n\tif (kip) {\n\t\t/* Check double free */\n\t\tWARN_ON(kip->slot_used[idx] != SLOT_USED);\n\t\tif (dirty) {\n\t\t\tkip->slot_used[idx] = SLOT_DIRTY;\n\t\t\tkip->ngarbage++;\n\t\t\tif (++c->nr_garbage > slots_per_page(c))\n\t\t\t\tcollect_garbage_slots(c);\n\t\t} else {\n\t\t\tcollect_one_slot(kip, idx);\n\t\t}\n\t}\n\tmutex_unlock(&c->mutex);\n}"
  },
  {
    "function_name": "collect_garbage_slots",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "234-254",
    "snippet": "static int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "collect_one_slot",
          "args": [
            "kip",
            "i"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "collect_one_slot",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "205-232",
          "snippet": "static bool collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\t/*\n\t\t\t * Record perf ksymbol unregister event before removing\n\t\t\t * the page.\n\t\t\t */\n\t\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t\t   (unsigned long)kip->insns, PAGE_SIZE, true,\n\t\t\t\t\t   kip->cache->sym);\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\t/*\n\t\t\t * Record perf ksymbol unregister event before removing\n\t\t\t * the page.\n\t\t\t */\n\t\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t\t   (unsigned long)kip->insns, PAGE_SIZE, true,\n\t\t\t\t\t   kip->cache->sym);\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slots_per_page",
          "args": [
            "c"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "slots_per_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "102-105",
          "snippet": "static int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "kip",
            "next",
            "&c->pages",
            "list"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "collect_one_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "205-232",
    "snippet": "static bool collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\t/*\n\t\t\t * Record perf ksymbol unregister event before removing\n\t\t\t * the page.\n\t\t\t */\n\t\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t\t   (unsigned long)kip->insns, PAGE_SIZE, true,\n\t\t\t\t\t   kip->cache->sym);\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kip"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kip->cache->free",
          "args": [
            "kip->insns"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_exp.h",
          "lines": "816-865",
          "snippet": "void synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_print_task_exp_stall(struct rcu_node *rnp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic int rcu_print_task_exp_stall(struct rcu_node *rnp);\n\nvoid synchronize_rcu_expedited(void)\n{\n\tbool boottime = (rcu_scheduler_active == RCU_SCHEDULER_INIT);\n\tstruct rcu_exp_work rew;\n\tstruct rcu_node *rnp;\n\tunsigned long s;\n\n\tRCU_LOCKDEP_WARN(lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_rcu_expedited() in RCU read-side critical section\");\n\n\t/* Is the state is such that the call is a grace period? */\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\n\t/* If expedited grace periods are prohibited, fall back to normal. */\n\tif (rcu_gp_is_normal()) {\n\t\twait_rcu_gp(call_rcu);\n\t\treturn;\n\t}\n\n\t/* Take a snapshot of the sequence number.  */\n\ts = rcu_exp_gp_seq_snap();\n\tif (exp_funnel_lock(s))\n\t\treturn;  /* Someone else did our work for us. */\n\n\t/* Ensure that load happens before action based on it. */\n\tif (unlikely(boottime)) {\n\t\t/* Direct call during scheduler init and early_initcalls(). */\n\t\trcu_exp_sel_wait_wake(s);\n\t} else {\n\t\t/* Marshall arguments & schedule the expedited grace period. */\n\t\trew.rew_s = s;\n\t\tINIT_WORK_ONSTACK(&rew.rew_work, wait_rcu_exp_gp);\n\t\tqueue_work(rcu_gp_wq, &rew.rew_work);\n\t}\n\n\t/* Wait for expedited grace period to complete. */\n\trnp = rcu_get_root();\n\twait_event(rnp->exp_wq[rcu_seq_ctr(s) & 0x3],\n\t\t   sync_exp_work_done(s));\n\tsmp_mb(); /* Workqueue actions happen before return. */\n\n\t/* Let the next expedited grace period start. */\n\tmutex_unlock(&rcu_state.exp_mutex);\n\n\tif (likely(!boottime))\n\t\tdestroy_work_on_stack(&rew.rew_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&kip->list"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_ksymbol",
          "args": [
            "PERF_RECORD_KSYMBOL_TYPE_OOL",
            "(unsigned long)kip->insns",
            "PAGE_SIZE",
            "true",
            "kip->cache->sym"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_ksymbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "8843-8887",
          "snippet": "void perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_ksymbol_events",
            "static __must_check struct",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic atomic_t nr_ksymbol_events;\nstatic __must_check struct;\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&kip->list"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic bool collect_one_slot(struct kprobe_insn_page *kip, int idx)\n{\n\tkip->slot_used[idx] = SLOT_CLEAN;\n\tkip->nused--;\n\tif (kip->nused == 0) {\n\t\t/*\n\t\t * Page is no longer in use.  Free it unless\n\t\t * it's the last one.  We keep the last one\n\t\t * so as not to have to set it up again the\n\t\t * next time somebody inserts a probe.\n\t\t */\n\t\tif (!list_is_singular(&kip->list)) {\n\t\t\t/*\n\t\t\t * Record perf ksymbol unregister event before removing\n\t\t\t * the page.\n\t\t\t */\n\t\t\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL,\n\t\t\t\t\t   (unsigned long)kip->insns, PAGE_SIZE, true,\n\t\t\t\t\t   kip->cache->sym);\n\t\t\tlist_del_rcu(&kip->list);\n\t\t\tsynchronize_rcu();\n\t\t\tkip->cache->free(kip->insns);\n\t\t\tkfree(kip);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "__get_insn_slot",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "144-202",
    "snippet": "kprobe_opcode_t *__get_insn_slot(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip;\n\tkprobe_opcode_t *slot = NULL;\n\n\t/* Since the slot array is not protected by rcu, we need a mutex */\n\tmutex_lock(&c->mutex);\n retry:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (kip->nused < slots_per_page(c)) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\t\tif (kip->slot_used[i] == SLOT_CLEAN) {\n\t\t\t\t\tkip->slot_used[i] = SLOT_USED;\n\t\t\t\t\tkip->nused++;\n\t\t\t\t\tslot = kip->insns + (i * c->insn_size);\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* kip->nused is broken. Fix it. */\n\t\t\tkip->nused = slots_per_page(c);\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* If there are any garbage slots, collect it and try again. */\n\tif (c->nr_garbage && collect_garbage_slots(c) == 0)\n\t\tgoto retry;\n\n\t/* All out of space.  Need to allocate a new page. */\n\tkip = kmalloc(KPROBE_INSN_PAGE_SIZE(slots_per_page(c)), GFP_KERNEL);\n\tif (!kip)\n\t\tgoto out;\n\n\tkip->insns = c->alloc();\n\tif (!kip->insns) {\n\t\tkfree(kip);\n\t\tgoto out;\n\t}\n\tINIT_LIST_HEAD(&kip->list);\n\tmemset(kip->slot_used, SLOT_CLEAN, slots_per_page(c));\n\tkip->slot_used[0] = SLOT_USED;\n\tkip->nused = 1;\n\tkip->ngarbage = 0;\n\tkip->cache = c;\n\tlist_add_rcu(&kip->list, &c->pages);\n\tslot = kip->insns;\n\n\t/* Record the perf ksymbol register event after adding the page */\n\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL, (unsigned long)kip->insns,\n\t\t\t   PAGE_SIZE, false, c->sym);\nout:\n\tmutex_unlock(&c->mutex);\n\treturn slot;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&c->mutex"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_ksymbol",
          "args": [
            "PERF_RECORD_KSYMBOL_TYPE_OOL",
            "(unsigned long)kip->insns",
            "PAGE_SIZE",
            "false",
            "c->sym"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "perf_event_ksymbol",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "8843-8887",
          "snippet": "void perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t nr_ksymbol_events",
            "static __must_check struct",
            "static DEVICE_ATTR_RO(type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic atomic_t nr_ksymbol_events;\nstatic __must_check struct;\nstatic DEVICE_ATTR_RO(type);\n\nvoid perf_event_ksymbol(u16 ksym_type, u64 addr, u32 len, bool unregister,\n\t\t\tconst char *sym)\n{\n\tstruct perf_ksymbol_event ksymbol_event;\n\tchar name[KSYM_NAME_LEN];\n\tu16 flags = 0;\n\tint name_len;\n\n\tif (!atomic_read(&nr_ksymbol_events))\n\t\treturn;\n\n\tif (ksym_type >= PERF_RECORD_KSYMBOL_TYPE_MAX ||\n\t    ksym_type == PERF_RECORD_KSYMBOL_TYPE_UNKNOWN)\n\t\tgoto err;\n\n\tstrlcpy(name, sym, KSYM_NAME_LEN);\n\tname_len = strlen(name) + 1;\n\twhile (!IS_ALIGNED(name_len, sizeof(u64)))\n\t\tname[name_len++] = '\\0';\n\tBUILD_BUG_ON(KSYM_NAME_LEN % sizeof(u64));\n\n\tif (unregister)\n\t\tflags |= PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER;\n\n\tksymbol_event = (struct perf_ksymbol_event){\n\t\t.name = name,\n\t\t.name_len = name_len,\n\t\t.event_id = {\n\t\t\t.header = {\n\t\t\t\t.type = PERF_RECORD_KSYMBOL,\n\t\t\t\t.size = sizeof(ksymbol_event.event_id) +\n\t\t\t\t\tname_len,\n\t\t\t},\n\t\t\t.addr = addr,\n\t\t\t.len = len,\n\t\t\t.ksym_type = ksym_type,\n\t\t\t.flags = flags,\n\t\t},\n\t};\n\n\tperf_iterate_sb(perf_event_ksymbol_output, &ksymbol_event, NULL);\n\treturn;\nerr:\n\tWARN_ONCE(1, \"%s: Invalid KSYMBOL type 0x%x\\n\", __func__, ksym_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&kip->list",
            "&c->pages"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kip->slot_used",
            "SLOT_CLEAN",
            "slots_per_page(c)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slots_per_page",
          "args": [
            "c"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "slots_per_page",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "102-105",
          "snippet": "static int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&kip->list"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kip"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->alloc",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "KPROBE_INSN_PAGE_SIZE(slots_per_page(c))",
            "GFP_KERNEL"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KPROBE_INSN_PAGE_SIZE",
          "args": [
            "slots_per_page(c)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collect_garbage_slots",
          "args": [
            "c"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "collect_garbage_slots",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
          "lines": "234-254",
          "snippet": "static int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/errno.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/sections.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/static_call.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/cpu.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memory.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/export.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/hash.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int collect_garbage_slots(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip, *next;\n\n\t/* Ensure no-one is interrupted on the garbages */\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(kip, next, &c->pages, list) {\n\t\tint i;\n\n\t\tif (kip->ngarbage == 0)\n\t\t\tcontinue;\n\t\tkip->ngarbage = 0;\t/* we will collect all garbages */\n\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\tif (kip->slot_used[i] == SLOT_DIRTY && collect_one_slot(kip, i))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tc->nr_garbage = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "kip",
            "&c->pages",
            "list"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&c->mutex"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nkprobe_opcode_t *__get_insn_slot(struct kprobe_insn_cache *c)\n{\n\tstruct kprobe_insn_page *kip;\n\tkprobe_opcode_t *slot = NULL;\n\n\t/* Since the slot array is not protected by rcu, we need a mutex */\n\tmutex_lock(&c->mutex);\n retry:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(kip, &c->pages, list) {\n\t\tif (kip->nused < slots_per_page(c)) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\t\tif (kip->slot_used[i] == SLOT_CLEAN) {\n\t\t\t\t\tkip->slot_used[i] = SLOT_USED;\n\t\t\t\t\tkip->nused++;\n\t\t\t\t\tslot = kip->insns + (i * c->insn_size);\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* kip->nused is broken. Fix it. */\n\t\t\tkip->nused = slots_per_page(c);\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/* If there are any garbage slots, collect it and try again. */\n\tif (c->nr_garbage && collect_garbage_slots(c) == 0)\n\t\tgoto retry;\n\n\t/* All out of space.  Need to allocate a new page. */\n\tkip = kmalloc(KPROBE_INSN_PAGE_SIZE(slots_per_page(c)), GFP_KERNEL);\n\tif (!kip)\n\t\tgoto out;\n\n\tkip->insns = c->alloc();\n\tif (!kip->insns) {\n\t\tkfree(kip);\n\t\tgoto out;\n\t}\n\tINIT_LIST_HEAD(&kip->list);\n\tmemset(kip->slot_used, SLOT_CLEAN, slots_per_page(c));\n\tkip->slot_used[0] = SLOT_USED;\n\tkip->nused = 1;\n\tkip->ngarbage = 0;\n\tkip->cache = c;\n\tlist_add_rcu(&kip->list, &c->pages);\n\tslot = kip->insns;\n\n\t/* Record the perf ksymbol register event after adding the page */\n\tperf_event_ksymbol(PERF_RECORD_KSYMBOL_TYPE_OOL, (unsigned long)kip->insns,\n\t\t\t   PAGE_SIZE, false, c->sym);\nout:\n\tmutex_unlock(&c->mutex);\n\treturn slot;\n}"
  },
  {
    "function_name": "free_insn_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "124-127",
    "snippet": "static void free_insn_page(void *page)\n{\n\tmodule_memfree(page);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_memfree",
          "args": [
            "page"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "module_memfree",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "2136-2144",
          "snippet": "void __weak module_memfree(void *module_region)\n{\n\t/*\n\t * This memory may be RO, and freeing RO memory in an interrupt is not\n\t * supported by vmalloc.\n\t */\n\tWARN_ON(in_interrupt());\n\tvfree(module_region);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid __weak module_memfree(void *module_region)\n{\n\t/*\n\t * This memory may be RO, and freeing RO memory in an interrupt is not\n\t * supported by vmalloc.\n\t */\n\tWARN_ON(in_interrupt());\n\tvfree(module_region);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic void free_insn_page(void *page)\n{\n\tmodule_memfree(page);\n}"
  },
  {
    "function_name": "alloc_insn_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "113-122",
    "snippet": "void __weak *alloc_insn_page(void)\n{\n\t/*\n\t * Use module_alloc() so this page is within +/- 2GB of where the\n\t * kernel image and loaded module images reside. This is required\n\t * for most of the architectures.\n\t * (e.g. x86-64 needs this to handle the %rip-relative fixups.)\n\t */\n\treturn module_alloc(PAGE_SIZE);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_alloc",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "module_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "2835-2840",
          "snippet": "void * __weak module_alloc(unsigned long size)\n{\n\treturn __vmalloc_node_range(size, 1, VMALLOC_START, VMALLOC_END,\n\t\t\tGFP_KERNEL, PAGE_KERNEL_EXEC, VM_FLUSH_RESET_PERMS,\n\t\t\tNUMA_NO_NODE, __builtin_return_address(0));\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid * __weak module_alloc(unsigned long size)\n{\n\treturn __vmalloc_node_range(size, 1, VMALLOC_START, VMALLOC_END,\n\t\t\tGFP_KERNEL, PAGE_KERNEL_EXEC, VM_FLUSH_RESET_PERMS,\n\t\t\tNUMA_NO_NODE, __builtin_return_address(0));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nvoid __weak *alloc_insn_page(void)\n{\n\t/*\n\t * Use module_alloc() so this page is within +/- 2GB of where the\n\t * kernel image and loaded module images reside. This is required\n\t * for most of the architectures.\n\t * (e.g. x86-64 needs this to handle the %rip-relative fixups.)\n\t */\n\treturn module_alloc(PAGE_SIZE);\n}"
  },
  {
    "function_name": "slots_per_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kprobes.c",
    "lines": "102-105",
    "snippet": "static int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <asm/errno.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/sections.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/static_call.h>",
      "#include <linux/jump_label.h>",
      "#include <linux/cpu.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/memory.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/freezer.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/export.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/hash.h>",
      "#include <linux/kprobes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/errno.h>\n#include <asm/cacheflush.h>\n#include <asm/sections.h>\n#include <linux/perf_event.h>\n#include <linux/static_call.h>\n#include <linux/jump_label.h>\n#include <linux/cpu.h>\n#include <linux/ftrace.h>\n#include <linux/memory.h>\n#include <linux/kdebug.h>\n#include <linux/sysctl.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/freezer.h>\n#include <linux/kallsyms.h>\n#include <linux/moduleloader.h>\n#include <linux/export.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/kprobes.h>\n\nstatic int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn PAGE_SIZE/(c->insn_size * sizeof(kprobe_opcode_t));\n}"
  }
]