[
  {
    "function_name": "ntp_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "1092-1096",
    "snippet": "void __init ntp_init(void)\n{\n\tntp_clear();\n\tntp_init_cmos_sync();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntp_init_cmos_sync",
          "args": [],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_init_cmos_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "680-680",
          "snippet": "static inline void __init ntp_init_cmos_sync(void) { }",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void __init ntp_init_cmos_sync(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "ntp_clear",
          "args": [],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "351-366",
          "snippet": "void ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_adjust;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nvoid ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nvoid __init ntp_init(void)\n{\n\tntp_clear();\n\tntp_init_cmos_sync();\n}"
  },
  {
    "function_name": "ntp_tick_adj_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "1080-1088",
    "snippet": "static int __init ntp_tick_adj_setup(char *str)\n{\n\tint rc = kstrtos64(str, 0, &ntp_tick_adj);\n\tif (rc)\n\t\treturn rc;\n\n\tntp_tick_adj <<= NTP_SCALE_SHIFT;\n\treturn 1;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64\t\t\tntp_tick_adj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtos64",
          "args": [
            "str",
            "0",
            "&ntp_tick_adj"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic s64\t\t\tntp_tick_adj;\n\nstatic int __init ntp_tick_adj_setup(char *str)\n{\n\tint rc = kstrtos64(str, 0, &ntp_tick_adj);\n\tif (rc)\n\t\treturn rc;\n\n\tntp_tick_adj <<= NTP_SCALE_SHIFT;\n\treturn 1;\n}"
  },
  {
    "function_name": "__hardpps",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "1030-1077",
    "snippet": "void __hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tstruct pps_normtime pts_norm, freq_norm;\n\n\tpts_norm = pps_normalize_ts(*phase_ts);\n\n\t/* clear the error bits, they will be set again if needed */\n\ttime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);\n\n\t/* indicate signal presence */\n\ttime_status |= STA_PPSSIGNAL;\n\tpps_valid = PPS_VALID;\n\n\t/* when called for the first time,\n\t * just start the frequency interval */\n\tif (unlikely(pps_fbase.tv_sec == 0)) {\n\t\tpps_fbase = *raw_ts;\n\t\treturn;\n\t}\n\n\t/* ok, now we have a base for frequency calculation */\n\tfreq_norm = pps_normalize_ts(timespec64_sub(*raw_ts, pps_fbase));\n\n\t/* check that the signal is in the range\n\t * [1s - MAXFREQ us, 1s + MAXFREQ us], otherwise reject it */\n\tif ((freq_norm.sec == 0) ||\n\t\t\t(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||\n\t\t\t(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {\n\t\ttime_status |= STA_PPSJITTER;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t/* signal is ok */\n\n\t/* check if the current frequency interval is finished */\n\tif (freq_norm.sec >= (1 << pps_shift)) {\n\t\tpps_calcnt++;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_VALID\t10\t/* PPS signal watchdog max (s) */"
    ],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hardpps_update_phase",
          "args": [
            "pts_norm.nsec"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "hardpps_update_phase",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "988-1016",
          "snippet": "static void hardpps_update_phase(long error)\n{\n\tlong correction = -error;\n\tlong jitter;\n\n\t/* add the sample to the median filter */\n\tpps_phase_filter_add(correction);\n\tcorrection = pps_phase_filter_get(&jitter);\n\n\t/* Nominal jitter is due to PPS signal noise. If it exceeds the\n\t * threshold, the sample is discarded; otherwise, if so enabled,\n\t * the time offset is updated.\n\t */\n\tif (jitter > (pps_jitter << PPS_POPCORN)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << PPS_POPCORN));\n\t\ttime_status |= STA_PPSJITTER;\n\t\tpps_jitcnt++;\n\t} else if (time_status & STA_PPSTIME) {\n\t\t/* correct the time using the phase offset */\n\t\ttime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,\n\t\t\t\tNTP_INTERVAL_FREQ);\n\t\t/* cancel running adjtime() */\n\t\ttime_adjust = 0;\n\t}\n\t/* update jitter */\n\tpps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */",
            "#define PPS_POPCORN\t4\t/* popcorn spike threshold (shift) */"
          ],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_adjust;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n#define PPS_POPCORN\t4\t/* popcorn spike threshold (shift) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_adjust;\n\nstatic void hardpps_update_phase(long error)\n{\n\tlong correction = -error;\n\tlong jitter;\n\n\t/* add the sample to the median filter */\n\tpps_phase_filter_add(correction);\n\tcorrection = pps_phase_filter_get(&jitter);\n\n\t/* Nominal jitter is due to PPS signal noise. If it exceeds the\n\t * threshold, the sample is discarded; otherwise, if so enabled,\n\t * the time offset is updated.\n\t */\n\tif (jitter > (pps_jitter << PPS_POPCORN)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << PPS_POPCORN));\n\t\ttime_status |= STA_PPSJITTER;\n\t\tpps_jitcnt++;\n\t} else if (time_status & STA_PPSTIME) {\n\t\t/* correct the time using the phase offset */\n\t\ttime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,\n\t\t\t\tNTP_INTERVAL_FREQ);\n\t\t/* cancel running adjtime() */\n\t\ttime_adjust = 0;\n\t}\n\t/* update jitter */\n\tpps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hardpps_update_freq",
          "args": [
            "freq_norm"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "hardpps_update_freq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "932-985",
          "snippet": "static long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t/* check if the frequency interval was too long */\n\tif (freq_norm.sec > (2 << pps_shift)) {\n\t\ttime_status |= STA_PPSERROR;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(KERN_ERR\n\t\t\t\"hardpps: PPSERROR: interval too long - %lld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t/* here the raw frequency offset and wander (stability) is\n\t * calculated. If the wander is less than the wander threshold\n\t * the interval is increased; otherwise it is decreased.\n\t */\n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);\n\tpps_freq = ftemp;\n\tif (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\", delta);\n\t\ttime_status |= STA_PPSWANDER;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t/* good sample */\n\t\tpps_inc_freq_interval();\n\t}\n\n\t/* the stability metric is calculated as the average of recent\n\t * frequency changes, but is used only for performance\n\t * monitoring\n\t */\n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC),\n\t\t\t\tNSEC_PER_USEC) - pps_stabil) >> PPS_INTMIN;\n\n\t/* if enabled, the system clock frequency is updated */\n\tif ((time_status & STA_PPSFREQ) != 0 &&\n\t    (time_status & STA_FREQHOLD) == 0) {\n\t\ttime_freq = pps_freq;\n\t\tntp_update_frequency();\n\t}\n\n\treturn delta;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define PPS_MAXWANDER\t100000\t/* max PPS freq wander (ns/s) */",
            "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */"
          ],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_freq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_MAXWANDER\t100000\t/* max PPS freq wander (ns/s) */\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_freq;\n\nstatic long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t/* check if the frequency interval was too long */\n\tif (freq_norm.sec > (2 << pps_shift)) {\n\t\ttime_status |= STA_PPSERROR;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(KERN_ERR\n\t\t\t\"hardpps: PPSERROR: interval too long - %lld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t/* here the raw frequency offset and wander (stability) is\n\t * calculated. If the wander is less than the wander threshold\n\t * the interval is increased; otherwise it is decreased.\n\t */\n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);\n\tpps_freq = ftemp;\n\tif (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\", delta);\n\t\ttime_status |= STA_PPSWANDER;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t/* good sample */\n\t\tpps_inc_freq_interval();\n\t}\n\n\t/* the stability metric is calculated as the average of recent\n\t * frequency changes, but is used only for performance\n\t * monitoring\n\t */\n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC),\n\t\t\t\tNSEC_PER_USEC) - pps_stabil) >> PPS_INTMIN;\n\n\t/* if enabled, the system clock frequency is updated */\n\tif ((time_status & STA_PPSFREQ) != 0 &&\n\t    (time_status & STA_FREQHOLD) == 0) {\n\t\ttime_freq = pps_freq;\n\t\tntp_update_frequency();\n\t}\n\n\treturn delta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\""
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "_printk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3285-3295",
          "snippet": "int _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_normalize_ts",
          "args": [
            "timespec64_sub(*raw_ts, pps_fbase)"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "pps_normalize_ts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "861-874",
          "snippet": "static inline struct pps_normtime pps_normalize_ts(struct timespec64 ts)\n{\n\tstruct pps_normtime norm = {\n\t\t.sec = ts.tv_sec,\n\t\t.nsec = ts.tv_nsec\n\t};\n\n\tif (norm.nsec > (NSEC_PER_SEC >> 1)) {\n\t\tnorm.nsec -= NSEC_PER_SEC;\n\t\tnorm.sec++;\n\t}\n\n\treturn norm;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline struct pps_normtime pps_normalize_ts(struct timespec64 ts)\n{\n\tstruct pps_normtime norm = {\n\t\t.sec = ts.tv_sec,\n\t\t.nsec = ts.tv_nsec\n\t};\n\n\tif (norm.nsec > (NSEC_PER_SEC >> 1)) {\n\t\tnorm.nsec -= NSEC_PER_SEC;\n\t\tnorm.sec++;\n\t}\n\n\treturn norm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "*raw_ts",
            "pps_fbase"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pps_fbase.tv_sec == 0"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_VALID\t10\t/* PPS signal watchdog max (s) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nvoid __hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tstruct pps_normtime pts_norm, freq_norm;\n\n\tpts_norm = pps_normalize_ts(*phase_ts);\n\n\t/* clear the error bits, they will be set again if needed */\n\ttime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);\n\n\t/* indicate signal presence */\n\ttime_status |= STA_PPSSIGNAL;\n\tpps_valid = PPS_VALID;\n\n\t/* when called for the first time,\n\t * just start the frequency interval */\n\tif (unlikely(pps_fbase.tv_sec == 0)) {\n\t\tpps_fbase = *raw_ts;\n\t\treturn;\n\t}\n\n\t/* ok, now we have a base for frequency calculation */\n\tfreq_norm = pps_normalize_ts(timespec64_sub(*raw_ts, pps_fbase));\n\n\t/* check that the signal is in the range\n\t * [1s - MAXFREQ us, 1s + MAXFREQ us], otherwise reject it */\n\tif ((freq_norm.sec == 0) ||\n\t\t\t(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||\n\t\t\t(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {\n\t\ttime_status |= STA_PPSJITTER;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t/* signal is ok */\n\n\t/* check if the current frequency interval is finished */\n\tif (freq_norm.sec >= (1 << pps_shift)) {\n\t\tpps_calcnt++;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}"
  },
  {
    "function_name": "hardpps_update_phase",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "988-1016",
    "snippet": "static void hardpps_update_phase(long error)\n{\n\tlong correction = -error;\n\tlong jitter;\n\n\t/* add the sample to the median filter */\n\tpps_phase_filter_add(correction);\n\tcorrection = pps_phase_filter_get(&jitter);\n\n\t/* Nominal jitter is due to PPS signal noise. If it exceeds the\n\t * threshold, the sample is discarded; otherwise, if so enabled,\n\t * the time offset is updated.\n\t */\n\tif (jitter > (pps_jitter << PPS_POPCORN)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << PPS_POPCORN));\n\t\ttime_status |= STA_PPSJITTER;\n\t\tpps_jitcnt++;\n\t} else if (time_status & STA_PPSTIME) {\n\t\t/* correct the time using the phase offset */\n\t\ttime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,\n\t\t\t\tNTP_INTERVAL_FREQ);\n\t\t/* cancel running adjtime() */\n\t\ttime_adjust = 0;\n\t}\n\t/* update jitter */\n\tpps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */",
      "#define PPS_POPCORN\t4\t/* popcorn spike threshold (shift) */"
    ],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_offset;",
      "static long\t\t\ttime_adjust;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_s64",
          "args": [
            "((s64)correction) << NTP_SCALE_SHIFT",
            "NTP_INTERVAL_FREQ"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\"",
            "jitter",
            "(pps_jitter << PPS_POPCORN)"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "_printk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3285-3295",
          "snippet": "int _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_phase_filter_get",
          "args": [
            "&jitter"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "pps_phase_filter_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "877-885",
          "snippet": "static inline long pps_phase_filter_get(long *jitter)\n{\n\t*jitter = pps_tf[0] - pps_tf[1];\n\tif (*jitter < 0)\n\t\t*jitter = -*jitter;\n\n\t/* TODO: test various filters */\n\treturn pps_tf[0];\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline long pps_phase_filter_get(long *jitter)\n{\n\t*jitter = pps_tf[0] - pps_tf[1];\n\tif (*jitter < 0)\n\t\t*jitter = -*jitter;\n\n\t/* TODO: test various filters */\n\treturn pps_tf[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_phase_filter_add",
          "args": [
            "correction"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "pps_phase_filter_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "888-893",
          "snippet": "static inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n#define PPS_POPCORN\t4\t/* popcorn spike threshold (shift) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_adjust;\n\nstatic void hardpps_update_phase(long error)\n{\n\tlong correction = -error;\n\tlong jitter;\n\n\t/* add the sample to the median filter */\n\tpps_phase_filter_add(correction);\n\tcorrection = pps_phase_filter_get(&jitter);\n\n\t/* Nominal jitter is due to PPS signal noise. If it exceeds the\n\t * threshold, the sample is discarded; otherwise, if so enabled,\n\t * the time offset is updated.\n\t */\n\tif (jitter > (pps_jitter << PPS_POPCORN)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << PPS_POPCORN));\n\t\ttime_status |= STA_PPSJITTER;\n\t\tpps_jitcnt++;\n\t} else if (time_status & STA_PPSTIME) {\n\t\t/* correct the time using the phase offset */\n\t\ttime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,\n\t\t\t\tNTP_INTERVAL_FREQ);\n\t\t/* cancel running adjtime() */\n\t\ttime_adjust = 0;\n\t}\n\t/* update jitter */\n\tpps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;\n}"
  },
  {
    "function_name": "hardpps_update_freq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "932-985",
    "snippet": "static long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t/* check if the frequency interval was too long */\n\tif (freq_norm.sec > (2 << pps_shift)) {\n\t\ttime_status |= STA_PPSERROR;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(KERN_ERR\n\t\t\t\"hardpps: PPSERROR: interval too long - %lld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t/* here the raw frequency offset and wander (stability) is\n\t * calculated. If the wander is less than the wander threshold\n\t * the interval is increased; otherwise it is decreased.\n\t */\n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);\n\tpps_freq = ftemp;\n\tif (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\", delta);\n\t\ttime_status |= STA_PPSWANDER;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t/* good sample */\n\t\tpps_inc_freq_interval();\n\t}\n\n\t/* the stability metric is calculated as the average of recent\n\t * frequency changes, but is used only for performance\n\t * monitoring\n\t */\n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC),\n\t\t\t\tNSEC_PER_USEC) - pps_stabil) >> PPS_INTMIN;\n\n\t/* if enabled, the system clock frequency is updated */\n\tif ((time_status & STA_PPSFREQ) != 0 &&\n\t    (time_status & STA_FREQHOLD) == 0) {\n\t\ttime_freq = pps_freq;\n\t\tntp_update_frequency();\n\t}\n\n\treturn delta;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_MAXWANDER\t100000\t/* max PPS freq wander (ns/s) */",
      "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */"
    ],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_freq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntp_update_frequency",
          "args": [],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_frequency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "259-279",
          "snippet": "static void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "unsigned long\t\t\ttick_nsec;",
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static s64\t\t\ttime_freq;",
            "static s64\t\t\tntp_tick_adj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nunsigned long\t\t\ttick_nsec;\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic s64\t\t\ttime_freq;\nstatic s64\t\t\tntp_tick_adj;\n\nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_s64",
          "args": [
            "((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC)",
            "NSEC_PER_USEC"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pps_inc_freq_interval",
          "args": [],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "pps_inc_freq_interval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "912-921",
          "snippet": "static inline void pps_inc_freq_interval(void)\n{\n\tif (++pps_intcnt >= PPS_INTCOUNT) {\n\t\tpps_intcnt = PPS_INTCOUNT;\n\t\tif (pps_shift < PPS_INTMAX) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */",
            "#define PPS_INTMAX\t8\t/* max freq interval (s) (shift) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */\n#define PPS_INTMAX\t8\t/* max freq interval (s) (shift) */\n\nstatic inline void pps_inc_freq_interval(void)\n{\n\tif (++pps_intcnt >= PPS_INTCOUNT) {\n\t\tpps_intcnt = PPS_INTCOUNT;\n\t\tif (pps_shift < PPS_INTMAX) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_dec_freq_interval",
          "args": [],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "pps_dec_freq_interval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "898-907",
          "snippet": "static inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -PPS_INTCOUNT) {\n\t\tpps_intcnt = -PPS_INTCOUNT;\n\t\tif (pps_shift > PPS_INTMIN) {\n\t\t\tpps_shift--;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */",
            "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n\nstatic inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -PPS_INTCOUNT) {\n\t\tpps_intcnt = -PPS_INTCOUNT;\n\t\tif (pps_shift > PPS_INTMIN) {\n\t\t\tpps_shift--;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\"",
            "delta"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "_printk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3285-3295",
          "snippet": "int _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint _printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "ftemp - pps_freq",
            "NTP_SCALE_SHIFT"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_s64",
          "args": [
            "((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT",
            "freq_norm.sec"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-freq_norm.nsec"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_MAXWANDER\t100000\t/* max PPS freq wander (ns/s) */\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_freq;\n\nstatic long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t/* check if the frequency interval was too long */\n\tif (freq_norm.sec > (2 << pps_shift)) {\n\t\ttime_status |= STA_PPSERROR;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(KERN_ERR\n\t\t\t\"hardpps: PPSERROR: interval too long - %lld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t/* here the raw frequency offset and wander (stability) is\n\t * calculated. If the wander is less than the wander threshold\n\t * the interval is increased; otherwise it is decreased.\n\t */\n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);\n\tpps_freq = ftemp;\n\tif (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\", delta);\n\t\ttime_status |= STA_PPSWANDER;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t/* good sample */\n\t\tpps_inc_freq_interval();\n\t}\n\n\t/* the stability metric is calculated as the average of recent\n\t * frequency changes, but is used only for performance\n\t * monitoring\n\t */\n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC),\n\t\t\t\tNSEC_PER_USEC) - pps_stabil) >> PPS_INTMIN;\n\n\t/* if enabled, the system clock frequency is updated */\n\tif ((time_status & STA_PPSFREQ) != 0 &&\n\t    (time_status & STA_FREQHOLD) == 0) {\n\t\ttime_freq = pps_freq;\n\t\tntp_update_frequency();\n\t}\n\n\treturn delta;\n}"
  },
  {
    "function_name": "pps_inc_freq_interval",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "912-921",
    "snippet": "static inline void pps_inc_freq_interval(void)\n{\n\tif (++pps_intcnt >= PPS_INTCOUNT) {\n\t\tpps_intcnt = PPS_INTCOUNT;\n\t\tif (pps_shift < PPS_INTMAX) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */",
      "#define PPS_INTMAX\t8\t/* max freq interval (s) (shift) */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */\n#define PPS_INTMAX\t8\t/* max freq interval (s) (shift) */\n\nstatic inline void pps_inc_freq_interval(void)\n{\n\tif (++pps_intcnt >= PPS_INTCOUNT) {\n\t\tpps_intcnt = PPS_INTCOUNT;\n\t\tif (pps_shift < PPS_INTMAX) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pps_dec_freq_interval",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "898-907",
    "snippet": "static inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -PPS_INTCOUNT) {\n\t\tpps_intcnt = -PPS_INTCOUNT;\n\t\tif (pps_shift > PPS_INTMIN) {\n\t\t\tpps_shift--;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */",
      "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n\nstatic inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -PPS_INTCOUNT) {\n\t\tpps_intcnt = -PPS_INTCOUNT;\n\t\tif (pps_shift > PPS_INTMIN) {\n\t\t\tpps_shift--;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pps_phase_filter_add",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "888-893",
    "snippet": "static inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}"
  },
  {
    "function_name": "pps_phase_filter_get",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "877-885",
    "snippet": "static inline long pps_phase_filter_get(long *jitter)\n{\n\t*jitter = pps_tf[0] - pps_tf[1];\n\tif (*jitter < 0)\n\t\t*jitter = -*jitter;\n\n\t/* TODO: test various filters */\n\treturn pps_tf[0];\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline long pps_phase_filter_get(long *jitter)\n{\n\t*jitter = pps_tf[0] - pps_tf[1];\n\tif (*jitter < 0)\n\t\t*jitter = -*jitter;\n\n\t/* TODO: test various filters */\n\treturn pps_tf[0];\n}"
  },
  {
    "function_name": "pps_normalize_ts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "861-874",
    "snippet": "static inline struct pps_normtime pps_normalize_ts(struct timespec64 ts)\n{\n\tstruct pps_normtime norm = {\n\t\t.sec = ts.tv_sec,\n\t\t.nsec = ts.tv_nsec\n\t};\n\n\tif (norm.nsec > (NSEC_PER_SEC >> 1)) {\n\t\tnorm.nsec -= NSEC_PER_SEC;\n\t\tnorm.sec++;\n\t}\n\n\treturn norm;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline struct pps_normtime pps_normalize_ts(struct timespec64 ts)\n{\n\tstruct pps_normtime norm = {\n\t\t.sec = ts.tv_sec,\n\t\t.nsec = ts.tv_nsec\n\t};\n\n\tif (norm.nsec > (NSEC_PER_SEC >> 1)) {\n\t\tnorm.nsec -= NSEC_PER_SEC;\n\t\tnorm.sec++;\n\t}\n\n\treturn norm;\n}"
  },
  {
    "function_name": "__do_adjtimex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "762-846",
    "snippet": "int __do_adjtimex(struct __kernel_timex *txc, const struct timespec64 *ts,\n\t\t  s32 *time_tai, struct audit_ntp_data *ad)\n{\n\tint result;\n\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\tlong save_adjust = time_adjust;\n\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY)) {\n\t\t\t/* adjtime() is independent from ntp_adjtime() */\n\t\t\ttime_adjust = txc->offset;\n\t\t\tntp_update_frequency();\n\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_ADJUST,\tsave_adjust);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_ADJUST,\ttime_adjust);\n\t\t}\n\t\ttxc->offset = save_adjust;\n\t} else {\n\t\t/* If there are input parameters, then process them: */\n\t\tif (txc->modes) {\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_OFFSET,\ttime_offset);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_FREQ,\ttime_freq);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_STATUS,\ttime_status);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TAI,\t*time_tai);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TICK,\ttick_usec);\n\n\t\t\tprocess_adjtimex_modes(txc, time_tai);\n\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_OFFSET,\ttime_offset);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_FREQ,\ttime_freq);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_STATUS,\ttime_status);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TAI,\t*time_tai);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TICK,\ttick_usec);\n\t\t}\n\n\t\ttxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,\n\t\t\t\t  NTP_SCALE_SHIFT);\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttxc->offset = (u32)txc->offset / NSEC_PER_USEC;\n\t}\n\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\t/* check for errors */\n\tif (is_error_status(time_status))\n\t\tresult = TIME_ERROR;\n\n\ttxc->freq\t   = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ_SCALED / PPM_SCALE;\n\ttxc->tick\t   = tick_usec;\n\ttxc->tai\t   = *time_tai;\n\n\t/* fill PPS status fields */\n\tpps_fill_timex(txc);\n\n\ttxc->time.tv_sec = ts->tv_sec;\n\ttxc->time.tv_usec = ts->tv_nsec;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->time.tv_usec = ts->tv_nsec / NSEC_PER_USEC;\n\n\t/* Handle leapsec adjustments */\n\tif (unlikely(ts->tv_sec >= ntp_next_leap_sec)) {\n\t\tif ((time_state == TIME_INS) && (time_status & STA_INS)) {\n\t\t\tresult = TIME_OOP;\n\t\t\ttxc->tai++;\n\t\t\ttxc->time.tv_sec--;\n\t\t}\n\t\tif ((time_state == TIME_DEL) && (time_status & STA_DEL)) {\n\t\t\tresult = TIME_WAIT;\n\t\t\ttxc->tai--;\n\t\t\ttxc->time.tv_sec++;\n\t\t}\n\t\tif ((time_state == TIME_OOP) &&\n\t\t\t\t\t(ts->tv_sec == ntp_next_leap_sec)) {\n\t\t\tresult = TIME_WAIT;\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
      "static int\t\t\ttime_state = TIME_OK;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_offset;",
      "static long\t\t\ttime_constant = 2;",
      "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
      "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
      "static s64\t\t\ttime_freq;",
      "static long\t\t\ttime_adjust;",
      "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ts->tv_sec >= ntp_next_leap_sec"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pps_fill_timex",
          "args": [
            "txc"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "pps_fill_timex",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "225-236",
          "snippet": "static inline void pps_fill_timex(struct __kernel_timex *txc)\n{\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_fill_timex(struct __kernel_timex *txc)\n{\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "(time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV",
            "NTP_SCALE_SHIFT"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_status",
          "args": [
            "time_status"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "is_error_status",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "220-223",
          "snippet": "static inline int is_error_status(int status)\n{\n\treturn status & (STA_UNSYNC|STA_CLOCKERR);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline int is_error_status(int status)\n{\n\treturn status & (STA_UNSYNC|STA_CLOCKERR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "time_offset * NTP_INTERVAL_FREQ",
            "NTP_SCALE_SHIFT"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_new",
          "args": [
            "ad",
            "AUDIT_NTP_TICK",
            "tick_usec"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_new",
          "args": [
            "ad",
            "AUDIT_NTP_TAI",
            "*time_tai"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_new",
          "args": [
            "ad",
            "AUDIT_NTP_STATUS",
            "time_status"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_new",
          "args": [
            "ad",
            "AUDIT_NTP_FREQ",
            "time_freq"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_new",
          "args": [
            "ad",
            "AUDIT_NTP_OFFSET",
            "time_offset"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_adjtimex_modes",
          "args": [
            "txc",
            "time_tai"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "process_adjtimex_modes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "709-755",
          "snippet": "static inline void process_adjtimex_modes(const struct __kernel_timex *txc,\n\t\t\t\t\t  s32 *time_tai)\n{\n\tif (txc->modes & ADJ_STATUS)\n\t\tprocess_adj_status(txc);\n\n\tif (txc->modes & ADJ_NANO)\n\t\ttime_status |= STA_NANO;\n\n\tif (txc->modes & ADJ_MICRO)\n\t\ttime_status &= ~STA_NANO;\n\n\tif (txc->modes & ADJ_FREQUENCY) {\n\t\ttime_freq = txc->freq * PPM_SCALE;\n\t\ttime_freq = min(time_freq, MAXFREQ_SCALED);\n\t\ttime_freq = max(time_freq, -MAXFREQ_SCALED);\n\t\t/* update pps_freq */\n\t\tpps_set_freq(time_freq);\n\t}\n\n\tif (txc->modes & ADJ_MAXERROR)\n\t\ttime_maxerror = txc->maxerror;\n\n\tif (txc->modes & ADJ_ESTERROR)\n\t\ttime_esterror = txc->esterror;\n\n\tif (txc->modes & ADJ_TIMECONST) {\n\t\ttime_constant = txc->constant;\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttime_constant += 4;\n\t\ttime_constant = min(time_constant, (long)MAXTC);\n\t\ttime_constant = max(time_constant, 0l);\n\t}\n\n\tif (txc->modes & ADJ_TAI &&\n\t\t\ttxc->constant >= 0 && txc->constant <= MAX_TAI_OFFSET)\n\t\t*time_tai = txc->constant;\n\n\tif (txc->modes & ADJ_OFFSET)\n\t\tntp_update_offset(txc->offset);\n\n\tif (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\tif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\tntp_update_frequency();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define MAX_TAI_OFFSET\t\t100000"
          ],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static long\t\t\ttime_constant = 2;",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
            "static s64\t\t\ttime_freq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define MAX_TAI_OFFSET\t\t100000\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic long\t\t\ttime_constant = 2;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic s64\t\t\ttime_freq;\n\nstatic inline void process_adjtimex_modes(const struct __kernel_timex *txc,\n\t\t\t\t\t  s32 *time_tai)\n{\n\tif (txc->modes & ADJ_STATUS)\n\t\tprocess_adj_status(txc);\n\n\tif (txc->modes & ADJ_NANO)\n\t\ttime_status |= STA_NANO;\n\n\tif (txc->modes & ADJ_MICRO)\n\t\ttime_status &= ~STA_NANO;\n\n\tif (txc->modes & ADJ_FREQUENCY) {\n\t\ttime_freq = txc->freq * PPM_SCALE;\n\t\ttime_freq = min(time_freq, MAXFREQ_SCALED);\n\t\ttime_freq = max(time_freq, -MAXFREQ_SCALED);\n\t\t/* update pps_freq */\n\t\tpps_set_freq(time_freq);\n\t}\n\n\tif (txc->modes & ADJ_MAXERROR)\n\t\ttime_maxerror = txc->maxerror;\n\n\tif (txc->modes & ADJ_ESTERROR)\n\t\ttime_esterror = txc->esterror;\n\n\tif (txc->modes & ADJ_TIMECONST) {\n\t\ttime_constant = txc->constant;\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttime_constant += 4;\n\t\ttime_constant = min(time_constant, (long)MAXTC);\n\t\ttime_constant = max(time_constant, 0l);\n\t}\n\n\tif (txc->modes & ADJ_TAI &&\n\t\t\ttxc->constant >= 0 && txc->constant <= MAX_TAI_OFFSET)\n\t\t*time_tai = txc->constant;\n\n\tif (txc->modes & ADJ_OFFSET)\n\t\tntp_update_offset(txc->offset);\n\n\tif (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\tif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\tntp_update_frequency();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_old",
          "args": [
            "ad",
            "AUDIT_NTP_TICK",
            "tick_usec"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_old",
          "args": [
            "ad",
            "AUDIT_NTP_TAI",
            "*time_tai"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_old",
          "args": [
            "ad",
            "AUDIT_NTP_STATUS",
            "time_status"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_old",
          "args": [
            "ad",
            "AUDIT_NTP_FREQ",
            "time_freq"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_old",
          "args": [
            "ad",
            "AUDIT_NTP_OFFSET",
            "time_offset"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_new",
          "args": [
            "ad",
            "AUDIT_NTP_ADJUST",
            "time_adjust"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ntp_set_old",
          "args": [
            "ad",
            "AUDIT_NTP_ADJUST",
            "save_adjust"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_update_frequency",
          "args": [],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_frequency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "259-279",
          "snippet": "static void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "unsigned long\t\t\ttick_nsec;",
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static s64\t\t\ttime_freq;",
            "static s64\t\t\tntp_tick_adj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nunsigned long\t\t\ttick_nsec;\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic s64\t\t\ttime_freq;\nstatic s64\t\t\tntp_tick_adj;\n\nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_constant = 2;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic s64\t\t\ttime_freq;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nint __do_adjtimex(struct __kernel_timex *txc, const struct timespec64 *ts,\n\t\t  s32 *time_tai, struct audit_ntp_data *ad)\n{\n\tint result;\n\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\tlong save_adjust = time_adjust;\n\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY)) {\n\t\t\t/* adjtime() is independent from ntp_adjtime() */\n\t\t\ttime_adjust = txc->offset;\n\t\t\tntp_update_frequency();\n\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_ADJUST,\tsave_adjust);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_ADJUST,\ttime_adjust);\n\t\t}\n\t\ttxc->offset = save_adjust;\n\t} else {\n\t\t/* If there are input parameters, then process them: */\n\t\tif (txc->modes) {\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_OFFSET,\ttime_offset);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_FREQ,\ttime_freq);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_STATUS,\ttime_status);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TAI,\t*time_tai);\n\t\t\taudit_ntp_set_old(ad, AUDIT_NTP_TICK,\ttick_usec);\n\n\t\t\tprocess_adjtimex_modes(txc, time_tai);\n\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_OFFSET,\ttime_offset);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_FREQ,\ttime_freq);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_STATUS,\ttime_status);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TAI,\t*time_tai);\n\t\t\taudit_ntp_set_new(ad, AUDIT_NTP_TICK,\ttick_usec);\n\t\t}\n\n\t\ttxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,\n\t\t\t\t  NTP_SCALE_SHIFT);\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttxc->offset = (u32)txc->offset / NSEC_PER_USEC;\n\t}\n\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\t/* check for errors */\n\tif (is_error_status(time_status))\n\t\tresult = TIME_ERROR;\n\n\ttxc->freq\t   = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ_SCALED / PPM_SCALE;\n\ttxc->tick\t   = tick_usec;\n\ttxc->tai\t   = *time_tai;\n\n\t/* fill PPS status fields */\n\tpps_fill_timex(txc);\n\n\ttxc->time.tv_sec = ts->tv_sec;\n\ttxc->time.tv_usec = ts->tv_nsec;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->time.tv_usec = ts->tv_nsec / NSEC_PER_USEC;\n\n\t/* Handle leapsec adjustments */\n\tif (unlikely(ts->tv_sec >= ntp_next_leap_sec)) {\n\t\tif ((time_state == TIME_INS) && (time_status & STA_INS)) {\n\t\t\tresult = TIME_OOP;\n\t\t\ttxc->tai++;\n\t\t\ttxc->time.tv_sec--;\n\t\t}\n\t\tif ((time_state == TIME_DEL) && (time_status & STA_DEL)) {\n\t\t\tresult = TIME_WAIT;\n\t\t\ttxc->tai--;\n\t\t\ttxc->time.tv_sec++;\n\t\t}\n\t\tif ((time_state == TIME_OOP) &&\n\t\t\t\t\t(ts->tv_sec == ntp_next_leap_sec)) {\n\t\t\tresult = TIME_WAIT;\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "process_adjtimex_modes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "709-755",
    "snippet": "static inline void process_adjtimex_modes(const struct __kernel_timex *txc,\n\t\t\t\t\t  s32 *time_tai)\n{\n\tif (txc->modes & ADJ_STATUS)\n\t\tprocess_adj_status(txc);\n\n\tif (txc->modes & ADJ_NANO)\n\t\ttime_status |= STA_NANO;\n\n\tif (txc->modes & ADJ_MICRO)\n\t\ttime_status &= ~STA_NANO;\n\n\tif (txc->modes & ADJ_FREQUENCY) {\n\t\ttime_freq = txc->freq * PPM_SCALE;\n\t\ttime_freq = min(time_freq, MAXFREQ_SCALED);\n\t\ttime_freq = max(time_freq, -MAXFREQ_SCALED);\n\t\t/* update pps_freq */\n\t\tpps_set_freq(time_freq);\n\t}\n\n\tif (txc->modes & ADJ_MAXERROR)\n\t\ttime_maxerror = txc->maxerror;\n\n\tif (txc->modes & ADJ_ESTERROR)\n\t\ttime_esterror = txc->esterror;\n\n\tif (txc->modes & ADJ_TIMECONST) {\n\t\ttime_constant = txc->constant;\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttime_constant += 4;\n\t\ttime_constant = min(time_constant, (long)MAXTC);\n\t\ttime_constant = max(time_constant, 0l);\n\t}\n\n\tif (txc->modes & ADJ_TAI &&\n\t\t\ttxc->constant >= 0 && txc->constant <= MAX_TAI_OFFSET)\n\t\t*time_tai = txc->constant;\n\n\tif (txc->modes & ADJ_OFFSET)\n\t\tntp_update_offset(txc->offset);\n\n\tif (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\tif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\tntp_update_frequency();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define MAX_TAI_OFFSET\t\t100000"
    ],
    "globals_used": [
      "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static long\t\t\ttime_constant = 2;",
      "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
      "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
      "static s64\t\t\ttime_freq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntp_update_frequency",
          "args": [],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_frequency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "259-279",
          "snippet": "static void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "unsigned long\t\t\ttick_nsec;",
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static s64\t\t\ttime_freq;",
            "static s64\t\t\tntp_tick_adj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nunsigned long\t\t\ttick_nsec;\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic s64\t\t\ttime_freq;\nstatic s64\t\t\tntp_tick_adj;\n\nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_update_offset",
          "args": [
            "txc->offset"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_offset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "296-346",
          "snippet": "static void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & STA_PLL))\n\t\treturn;\n\n\tif (!(time_status & STA_NANO)) {\n\t\t/* Make sure the multiplication below won't overflow */\n\t\toffset = clamp(offset, -USEC_PER_SEC, USEC_PER_SEC);\n\t\toffset *= NSEC_PER_USEC;\n\t}\n\n\t/*\n\t * Scale the phase adjustment and\n\t * clamp to the operating range.\n\t */\n\toffset = clamp(offset, -MAXPHASE, MAXPHASE);\n\n\t/*\n\t * Select how the frequency is to be controlled\n\t * and in which mode (PLL or FLL).\n\t */\n\tsecs = (long)(__ktime_get_real_seconds() - time_reftime);\n\tif (unlikely(time_status & STA_FREQHOLD))\n\t\tsecs = 0;\n\n\ttime_reftime = __ktime_get_real_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t/*\n\t * Clamp update interval to reduce PLL gain with low\n\t * sampling rate (e.g. intermittent network connection)\n\t * to avoid instability.\n\t */\n\tif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))\n\t\tsecs = 1 << (SHIFT_PLL + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, MAXFREQ_SCALED);\n\n\ttime_freq   = max(freq_adj, -MAXFREQ_SCALED);\n\n\ttime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_constant = 2;",
            "static s64\t\t\ttime_freq;",
            "static time64_t\t\ttime_reftime;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_constant = 2;\nstatic s64\t\t\ttime_freq;\nstatic time64_t\t\ttime_reftime;\n\nstatic void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & STA_PLL))\n\t\treturn;\n\n\tif (!(time_status & STA_NANO)) {\n\t\t/* Make sure the multiplication below won't overflow */\n\t\toffset = clamp(offset, -USEC_PER_SEC, USEC_PER_SEC);\n\t\toffset *= NSEC_PER_USEC;\n\t}\n\n\t/*\n\t * Scale the phase adjustment and\n\t * clamp to the operating range.\n\t */\n\toffset = clamp(offset, -MAXPHASE, MAXPHASE);\n\n\t/*\n\t * Select how the frequency is to be controlled\n\t * and in which mode (PLL or FLL).\n\t */\n\tsecs = (long)(__ktime_get_real_seconds() - time_reftime);\n\tif (unlikely(time_status & STA_FREQHOLD))\n\t\tsecs = 0;\n\n\ttime_reftime = __ktime_get_real_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t/*\n\t * Clamp update interval to reduce PLL gain with low\n\t * sampling rate (e.g. intermittent network connection)\n\t * to avoid instability.\n\t */\n\tif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))\n\t\tsecs = 1 << (SHIFT_PLL + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, MAXFREQ_SCALED);\n\n\ttime_freq   = max(freq_adj, -MAXFREQ_SCALED);\n\n\ttime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "time_constant",
            "0l"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "time_constant",
            "(long)MAXTC"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "776-808",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_set_freq",
          "args": [
            "time_freq"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "pps_set_freq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "218-218",
          "snippet": "static inline void pps_set_freq(s64 freq) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_set_freq(s64 freq) {}"
        }
      },
      {
        "call_info": {
          "callee": "process_adj_status",
          "args": [
            "txc"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "process_adj_status",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "686-706",
          "snippet": "static inline void process_adj_status(const struct __kernel_timex *txc)\n{\n\tif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {\n\t\ttime_state = TIME_OK;\n\t\ttime_status = STA_UNSYNC;\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t/* restart PPS frequency calibration */\n\t\tpps_reset_freq_interval();\n\t}\n\n\t/*\n\t * If we turn on PLL adjustments then reset the\n\t * reference time to current time.\n\t */\n\tif (!(time_status & STA_PLL) && (txc->status & STA_PLL))\n\t\ttime_reftime = __ktime_get_real_seconds();\n\n\t/* only set allowed bits */\n\ttime_status &= STA_RONLY;\n\ttime_status |= txc->status & ~STA_RONLY;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_state = TIME_OK;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static time64_t\t\ttime_reftime;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic time64_t\t\ttime_reftime;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nstatic inline void process_adj_status(const struct __kernel_timex *txc)\n{\n\tif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {\n\t\ttime_state = TIME_OK;\n\t\ttime_status = STA_UNSYNC;\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t/* restart PPS frequency calibration */\n\t\tpps_reset_freq_interval();\n\t}\n\n\t/*\n\t * If we turn on PLL adjustments then reset the\n\t * reference time to current time.\n\t */\n\tif (!(time_status & STA_PLL) && (txc->status & STA_PLL))\n\t\ttime_reftime = __ktime_get_real_seconds();\n\n\t/* only set allowed bits */\n\ttime_status &= STA_RONLY;\n\ttime_status |= txc->status & ~STA_RONLY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define MAX_TAI_OFFSET\t\t100000\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic long\t\t\ttime_constant = 2;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic s64\t\t\ttime_freq;\n\nstatic inline void process_adjtimex_modes(const struct __kernel_timex *txc,\n\t\t\t\t\t  s32 *time_tai)\n{\n\tif (txc->modes & ADJ_STATUS)\n\t\tprocess_adj_status(txc);\n\n\tif (txc->modes & ADJ_NANO)\n\t\ttime_status |= STA_NANO;\n\n\tif (txc->modes & ADJ_MICRO)\n\t\ttime_status &= ~STA_NANO;\n\n\tif (txc->modes & ADJ_FREQUENCY) {\n\t\ttime_freq = txc->freq * PPM_SCALE;\n\t\ttime_freq = min(time_freq, MAXFREQ_SCALED);\n\t\ttime_freq = max(time_freq, -MAXFREQ_SCALED);\n\t\t/* update pps_freq */\n\t\tpps_set_freq(time_freq);\n\t}\n\n\tif (txc->modes & ADJ_MAXERROR)\n\t\ttime_maxerror = txc->maxerror;\n\n\tif (txc->modes & ADJ_ESTERROR)\n\t\ttime_esterror = txc->esterror;\n\n\tif (txc->modes & ADJ_TIMECONST) {\n\t\ttime_constant = txc->constant;\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttime_constant += 4;\n\t\ttime_constant = min(time_constant, (long)MAXTC);\n\t\ttime_constant = max(time_constant, 0l);\n\t}\n\n\tif (txc->modes & ADJ_TAI &&\n\t\t\ttxc->constant >= 0 && txc->constant <= MAX_TAI_OFFSET)\n\t\t*time_tai = txc->constant;\n\n\tif (txc->modes & ADJ_OFFSET)\n\t\tntp_update_offset(txc->offset);\n\n\tif (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\tif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\tntp_update_frequency();\n}"
  },
  {
    "function_name": "process_adj_status",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "686-706",
    "snippet": "static inline void process_adj_status(const struct __kernel_timex *txc)\n{\n\tif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {\n\t\ttime_state = TIME_OK;\n\t\ttime_status = STA_UNSYNC;\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t/* restart PPS frequency calibration */\n\t\tpps_reset_freq_interval();\n\t}\n\n\t/*\n\t * If we turn on PLL adjustments then reset the\n\t * reference time to current time.\n\t */\n\tif (!(time_status & STA_PLL) && (txc->status & STA_PLL))\n\t\ttime_reftime = __ktime_get_real_seconds();\n\n\t/* only set allowed bits */\n\ttime_status &= STA_RONLY;\n\ttime_status |= txc->status & ~STA_RONLY;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_state = TIME_OK;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static time64_t\t\ttime_reftime;",
      "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ktime_get_real_seconds",
          "args": [],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_reset_freq_interval",
          "args": [],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "pps_reset_freq_interval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "215-215",
          "snippet": "static inline void pps_reset_freq_interval(void) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_reset_freq_interval(void) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic time64_t\t\ttime_reftime;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nstatic inline void process_adj_status(const struct __kernel_timex *txc)\n{\n\tif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {\n\t\ttime_state = TIME_OK;\n\t\ttime_status = STA_UNSYNC;\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t/* restart PPS frequency calibration */\n\t\tpps_reset_freq_interval();\n\t}\n\n\t/*\n\t * If we turn on PLL adjustments then reset the\n\t * reference time to current time.\n\t */\n\tif (!(time_status & STA_PLL) && (txc->status & STA_PLL))\n\t\ttime_reftime = __ktime_get_real_seconds();\n\n\t/* only set allowed bits */\n\ttime_status &= STA_RONLY;\n\ttime_status |= txc->status & ~STA_RONLY;\n}"
  },
  {
    "function_name": "ntp_init_cmos_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "680-680",
    "snippet": "static inline void __init ntp_init_cmos_sync(void) { }",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void __init ntp_init_cmos_sync(void) { }"
  },
  {
    "function_name": "ntp_init_cmos_sync",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "674-678",
    "snippet": "static void __init ntp_init_cmos_sync(void)\n{\n\thrtimer_init(&sync_hrtimer, CLOCK_REALTIME, HRTIMER_MODE_ABS);\n\tsync_hrtimer.function = sync_timer_callback;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&sync_hrtimer",
            "CLOCK_REALTIME",
            "HRTIMER_MODE_ABS"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic void __init ntp_init_cmos_sync(void)\n{\n\thrtimer_init(&sync_hrtimer, CLOCK_REALTIME, HRTIMER_MODE_ABS);\n\tsync_hrtimer.function = sync_timer_callback;\n}"
  },
  {
    "function_name": "ntp_notify_cmos_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "663-672",
    "snippet": "void ntp_notify_cmos_timer(void)\n{\n\t/*\n\t * When the work is currently executed but has not yet the timer\n\t * rearmed this queues the work immediately again. No big issue,\n\t * just a pointless work scheduled.\n\t */\n\tif (ntp_synced() && !hrtimer_is_queued(&sync_hrtimer))\n\t\tqueue_work(system_freezable_power_efficient_wq, &sync_work);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "system_freezable_power_efficient_wq",
            "&sync_work"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_is_queued",
          "args": [
            "&sync_hrtimer"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_synced",
          "args": [],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_synced",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "245-248",
          "snippet": "static inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nvoid ntp_notify_cmos_timer(void)\n{\n\t/*\n\t * When the work is currently executed but has not yet the timer\n\t * rearmed this queues the work immediately again. No big issue,\n\t * just a pointless work scheduled.\n\t */\n\tif (ntp_synced() && !hrtimer_is_queued(&sync_hrtimer))\n\t\tqueue_work(system_freezable_power_efficient_wq, &sync_work);\n}"
  },
  {
    "function_name": "sync_hw_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "622-661",
    "snippet": "static void sync_hw_clock(struct work_struct *work)\n{\n\t/*\n\t * The default synchronization offset is 500ms for the deprecated\n\t * update_persistent_clock64() under the assumption that it uses\n\t * the infamous CMOS clock (MC146818).\n\t */\n\tstatic unsigned long offset_nsec = NSEC_PER_SEC / 2;\n\tstruct timespec64 now, to_set;\n\tint res = -EAGAIN;\n\n\t/*\n\t * Don't update if STA_UNSYNC is set and if ntp_notify_cmos_timer()\n\t * managed to schedule the work between the timer firing and the\n\t * work being able to rearm the timer. Wait for the timer to expire.\n\t */\n\tif (!ntp_synced() || hrtimer_is_queued(&sync_hrtimer))\n\t\treturn;\n\n\tktime_get_real_ts64(&now);\n\t/* If @now is not in the allowed window, try again */\n\tif (!rtc_tv_nsec_ok(offset_nsec, &to_set, &now))\n\t\tgoto rearm;\n\n\t/* Take timezone adjusted RTCs into account */\n\tif (persistent_clock_is_local)\n\t\tto_set.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\n\t/* Try the legacy RTC first. */\n\tres = update_persistent_clock64(to_set);\n\tif (res != -ENODEV)\n\t\tgoto rearm;\n\n\t/* Try the RTC class */\n\tres = update_rtc(&to_set, &offset_nsec);\n\tif (res == -ENODEV)\n\t\treturn;\nrearm:\n\tsched_sync_hw_clock(offset_nsec, res != 0);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_sync_hw_clock",
          "args": [
            "offset_nsec",
            "res != 0"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "sched_sync_hw_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "510-520",
          "snippet": "static void sched_sync_hw_clock(unsigned long offset_nsec, bool retry)\n{\n\tktime_t exp = ktime_set(ktime_get_real_seconds(), 0);\n\n\tif (retry)\n\t\texp = ktime_add_ns(exp, 2ULL * NSEC_PER_SEC - offset_nsec);\n\telse\n\t\texp = ktime_add_ns(exp, SYNC_PERIOD_NS - offset_nsec);\n\n\thrtimer_start(&sync_hrtimer, exp, HRTIMER_MODE_ABS);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define SYNC_PERIOD_NS (11ULL * 60 * NSEC_PER_SEC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define SYNC_PERIOD_NS (11ULL * 60 * NSEC_PER_SEC)\n\nstatic void sched_sync_hw_clock(unsigned long offset_nsec, bool retry)\n{\n\tktime_t exp = ktime_set(ktime_get_real_seconds(), 0);\n\n\tif (retry)\n\t\texp = ktime_add_ns(exp, 2ULL * NSEC_PER_SEC - offset_nsec);\n\telse\n\t\texp = ktime_add_ns(exp, SYNC_PERIOD_NS - offset_nsec);\n\n\thrtimer_start(&sync_hrtimer, exp, HRTIMER_MODE_ABS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rtc",
          "args": [
            "&to_set",
            "&offset_nsec"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "update_rtc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "608-611",
          "snippet": "static inline int update_rtc(struct timespec64 *to_set, unsigned long *offset_nsec)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline int update_rtc(struct timespec64 *to_set, unsigned long *offset_nsec)\n{\n\treturn -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_persistent_clock64",
          "args": [
            "to_set"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "update_persistent_clock64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "573-576",
          "snippet": "static inline int update_persistent_clock64(struct timespec64 now64)\n{\n\treturn -ENODEV;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline int update_persistent_clock64(struct timespec64 now64)\n{\n\treturn -ENODEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_tv_nsec_ok",
          "args": [
            "offset_nsec",
            "&to_set",
            "&now"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_tv_nsec_ok",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "543-565",
          "snippet": "static inline bool rtc_tv_nsec_ok(unsigned long set_offset_nsec,\n\t\t\t\t  struct timespec64 *to_set,\n\t\t\t\t  const struct timespec64 *now)\n{\n\t/* Allowed error in tv_nsec, arbitrarily set to 5 jiffies in ns. */\n\tconst unsigned long TIME_SET_NSEC_FUZZ = TICK_NSEC * 5;\n\tstruct timespec64 delay = {.tv_sec = -1,\n\t\t\t\t   .tv_nsec = set_offset_nsec};\n\n\t*to_set = timespec64_add(*now, delay);\n\n\tif (to_set->tv_nsec < TIME_SET_NSEC_FUZZ) {\n\t\tto_set->tv_nsec = 0;\n\t\treturn true;\n\t}\n\n\tif (to_set->tv_nsec > NSEC_PER_SEC - TIME_SET_NSEC_FUZZ) {\n\t\tto_set->tv_sec++;\n\t\tto_set->tv_nsec = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline bool rtc_tv_nsec_ok(unsigned long set_offset_nsec,\n\t\t\t\t  struct timespec64 *to_set,\n\t\t\t\t  const struct timespec64 *now)\n{\n\t/* Allowed error in tv_nsec, arbitrarily set to 5 jiffies in ns. */\n\tconst unsigned long TIME_SET_NSEC_FUZZ = TICK_NSEC * 5;\n\tstruct timespec64 delay = {.tv_sec = -1,\n\t\t\t\t   .tv_nsec = set_offset_nsec};\n\n\t*to_set = timespec64_add(*now, delay);\n\n\tif (to_set->tv_nsec < TIME_SET_NSEC_FUZZ) {\n\t\tto_set->tv_nsec = 0;\n\t\treturn true;\n\t}\n\n\tif (to_set->tv_nsec > NSEC_PER_SEC - TIME_SET_NSEC_FUZZ) {\n\t\tto_set->tv_sec++;\n\t\tto_set->tv_nsec = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "&now"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "796-814",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned int seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_is_queued",
          "args": [
            "&sync_hrtimer"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_synced",
          "args": [],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_synced",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "245-248",
          "snippet": "static inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic void sync_hw_clock(struct work_struct *work)\n{\n\t/*\n\t * The default synchronization offset is 500ms for the deprecated\n\t * update_persistent_clock64() under the assumption that it uses\n\t * the infamous CMOS clock (MC146818).\n\t */\n\tstatic unsigned long offset_nsec = NSEC_PER_SEC / 2;\n\tstruct timespec64 now, to_set;\n\tint res = -EAGAIN;\n\n\t/*\n\t * Don't update if STA_UNSYNC is set and if ntp_notify_cmos_timer()\n\t * managed to schedule the work between the timer firing and the\n\t * work being able to rearm the timer. Wait for the timer to expire.\n\t */\n\tif (!ntp_synced() || hrtimer_is_queued(&sync_hrtimer))\n\t\treturn;\n\n\tktime_get_real_ts64(&now);\n\t/* If @now is not in the allowed window, try again */\n\tif (!rtc_tv_nsec_ok(offset_nsec, &to_set, &now))\n\t\tgoto rearm;\n\n\t/* Take timezone adjusted RTCs into account */\n\tif (persistent_clock_is_local)\n\t\tto_set.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\n\t/* Try the legacy RTC first. */\n\tres = update_persistent_clock64(to_set);\n\tif (res != -ENODEV)\n\t\tgoto rearm;\n\n\t/* Try the RTC class */\n\tres = update_rtc(&to_set, &offset_nsec);\n\tif (res == -ENODEV)\n\t\treturn;\nrearm:\n\tsched_sync_hw_clock(offset_nsec, res != 0);\n}"
  },
  {
    "function_name": "update_rtc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "608-611",
    "snippet": "static inline int update_rtc(struct timespec64 *to_set, unsigned long *offset_nsec)\n{\n\treturn -ENODEV;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline int update_rtc(struct timespec64 *to_set, unsigned long *offset_nsec)\n{\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "update_rtc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "581-606",
    "snippet": "static int update_rtc(struct timespec64 *to_set, unsigned long *offset_nsec)\n{\n\tstruct rtc_device *rtc;\n\tstruct rtc_time tm;\n\tint err = -ENODEV;\n\n\trtc = rtc_class_open(CONFIG_RTC_SYSTOHC_DEVICE);\n\tif (!rtc)\n\t\treturn -ENODEV;\n\n\tif (!rtc->ops || !rtc->ops->set_time)\n\t\tgoto out_close;\n\n\t/* First call might not have the correct offset */\n\tif (*offset_nsec == rtc->set_offset_nsec) {\n\t\trtc_time64_to_tm(to_set->tv_sec, &tm);\n\t\terr = rtc_set_time(rtc, &tm);\n\t} else {\n\t\t/* Store the update offset and let the caller try again */\n\t\t*offset_nsec = rtc->set_offset_nsec;\n\t\terr = -EAGAIN;\n\t}\nout_close:\n\trtc_class_close(rtc);\n\treturn err;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_class_close",
          "args": [
            "rtc"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_set_time",
          "args": [
            "rtc",
            "&tm"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_time64_to_tm",
          "args": [
            "to_set->tv_sec",
            "&tm"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_class_open",
          "args": [
            "CONFIG_RTC_SYSTOHC_DEVICE"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int update_rtc(struct timespec64 *to_set, unsigned long *offset_nsec)\n{\n\tstruct rtc_device *rtc;\n\tstruct rtc_time tm;\n\tint err = -ENODEV;\n\n\trtc = rtc_class_open(CONFIG_RTC_SYSTOHC_DEVICE);\n\tif (!rtc)\n\t\treturn -ENODEV;\n\n\tif (!rtc->ops || !rtc->ops->set_time)\n\t\tgoto out_close;\n\n\t/* First call might not have the correct offset */\n\tif (*offset_nsec == rtc->set_offset_nsec) {\n\t\trtc_time64_to_tm(to_set->tv_sec, &tm);\n\t\terr = rtc_set_time(rtc, &tm);\n\t} else {\n\t\t/* Store the update offset and let the caller try again */\n\t\t*offset_nsec = rtc->set_offset_nsec;\n\t\terr = -EAGAIN;\n\t}\nout_close:\n\trtc_class_close(rtc);\n\treturn err;\n}"
  },
  {
    "function_name": "update_persistent_clock64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "573-576",
    "snippet": "static inline int update_persistent_clock64(struct timespec64 now64)\n{\n\treturn -ENODEV;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline int update_persistent_clock64(struct timespec64 now64)\n{\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "update_persistent_clock64",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "568-571",
    "snippet": "int __weak update_persistent_clock64(struct timespec64 now64)\n{\n\treturn -ENODEV;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nint __weak update_persistent_clock64(struct timespec64 now64)\n{\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "rtc_tv_nsec_ok",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "543-565",
    "snippet": "static inline bool rtc_tv_nsec_ok(unsigned long set_offset_nsec,\n\t\t\t\t  struct timespec64 *to_set,\n\t\t\t\t  const struct timespec64 *now)\n{\n\t/* Allowed error in tv_nsec, arbitrarily set to 5 jiffies in ns. */\n\tconst unsigned long TIME_SET_NSEC_FUZZ = TICK_NSEC * 5;\n\tstruct timespec64 delay = {.tv_sec = -1,\n\t\t\t\t   .tv_nsec = set_offset_nsec};\n\n\t*to_set = timespec64_add(*now, delay);\n\n\tif (to_set->tv_nsec < TIME_SET_NSEC_FUZZ) {\n\t\tto_set->tv_nsec = 0;\n\t\treturn true;\n\t}\n\n\tif (to_set->tv_nsec > NSEC_PER_SEC - TIME_SET_NSEC_FUZZ) {\n\t\tto_set->tv_sec++;\n\t\tto_set->tv_nsec = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_add",
          "args": [
            "*now",
            "delay"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "timespec64_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "765-779",
          "snippet": "struct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct timespec64 timespec64_add_safe(const struct timespec64 lhs,\n\t\t\t\tconst struct timespec64 rhs)\n{\n\tstruct timespec64 res;\n\n\tset_normalized_timespec64(&res, (timeu64_t) lhs.tv_sec + rhs.tv_sec,\n\t\t\tlhs.tv_nsec + rhs.tv_nsec);\n\n\tif (unlikely(res.tv_sec < lhs.tv_sec || res.tv_sec < rhs.tv_sec)) {\n\t\tres.tv_sec = TIME64_MAX;\n\t\tres.tv_nsec = 0;\n\t}\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline bool rtc_tv_nsec_ok(unsigned long set_offset_nsec,\n\t\t\t\t  struct timespec64 *to_set,\n\t\t\t\t  const struct timespec64 *now)\n{\n\t/* Allowed error in tv_nsec, arbitrarily set to 5 jiffies in ns. */\n\tconst unsigned long TIME_SET_NSEC_FUZZ = TICK_NSEC * 5;\n\tstruct timespec64 delay = {.tv_sec = -1,\n\t\t\t\t   .tv_nsec = set_offset_nsec};\n\n\t*to_set = timespec64_add(*now, delay);\n\n\tif (to_set->tv_nsec < TIME_SET_NSEC_FUZZ) {\n\t\tto_set->tv_nsec = 0;\n\t\treturn true;\n\t}\n\n\tif (to_set->tv_nsec > NSEC_PER_SEC - TIME_SET_NSEC_FUZZ) {\n\t\tto_set->tv_sec++;\n\t\tto_set->tv_nsec = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "sched_sync_hw_clock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "510-520",
    "snippet": "static void sched_sync_hw_clock(unsigned long offset_nsec, bool retry)\n{\n\tktime_t exp = ktime_set(ktime_get_real_seconds(), 0);\n\n\tif (retry)\n\t\texp = ktime_add_ns(exp, 2ULL * NSEC_PER_SEC - offset_nsec);\n\telse\n\t\texp = ktime_add_ns(exp, SYNC_PERIOD_NS - offset_nsec);\n\n\thrtimer_start(&sync_hrtimer, exp, HRTIMER_MODE_ABS);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define SYNC_PERIOD_NS (11ULL * 60 * NSEC_PER_SEC)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&sync_hrtimer",
            "exp",
            "HRTIMER_MODE_ABS"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "exp",
            "SYNC_PERIOD_NS - offset_nsec"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "exp",
            "2ULL * NSEC_PER_SEC - offset_nsec"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "ktime_get_real_seconds()",
            "0"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define SYNC_PERIOD_NS (11ULL * 60 * NSEC_PER_SEC)\n\nstatic void sched_sync_hw_clock(unsigned long offset_nsec, bool retry)\n{\n\tktime_t exp = ktime_set(ktime_get_real_seconds(), 0);\n\n\tif (retry)\n\t\texp = ktime_add_ns(exp, 2ULL * NSEC_PER_SEC - offset_nsec);\n\telse\n\t\texp = ktime_add_ns(exp, SYNC_PERIOD_NS - offset_nsec);\n\n\thrtimer_start(&sync_hrtimer, exp, HRTIMER_MODE_ABS);\n}"
  },
  {
    "function_name": "sync_timer_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "503-508",
    "snippet": "static enum hrtimer_restart sync_timer_callback(struct hrtimer *timer)\n{\n\tqueue_work(system_freezable_power_efficient_wq, &sync_work);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "system_freezable_power_efficient_wq",
            "&sync_work"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic enum hrtimer_restart sync_timer_callback(struct hrtimer *timer)\n{\n\tqueue_work(system_freezable_power_efficient_wq, &sync_work);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "second_overflow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "400-495",
    "snippet": "int second_overflow(time64_t secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\ts32 rem;\n\n\t/*\n\t * Leap second processing. If in leap-insert state at the end of the\n\t * day, the system clock is set back one second; if in leap-delete\n\t * state, the system clock is set ahead one second.\n\t */\n\tswitch (time_state) {\n\tcase TIME_OK:\n\t\tif (time_status & STA_INS) {\n\t\t\ttime_state = TIME_INS;\n\t\t\tdiv_s64_rem(secs, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t} else if (time_status & STA_DEL) {\n\t\t\ttime_state = TIME_DEL;\n\t\t\tdiv_s64_rem(secs + 1, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t}\n\t\tbreak;\n\tcase TIME_INS:\n\t\tif (!(time_status & STA_INS)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = -1;\n\t\t\ttime_state = TIME_OOP;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: inserting leap second 23:59:60 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_DEL:\n\t\tif (!(time_status & STA_DEL)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = 1;\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_WAIT;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_OOP:\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\ttime_state = TIME_WAIT;\n\t\tbreak;\n\tcase TIME_WAIT:\n\t\tif (!(time_status & (STA_INS | STA_DEL)))\n\t\t\ttime_state = TIME_OK;\n\t\tbreak;\n\t}\n\n\n\t/* Bump the maxerror field */\n\ttime_maxerror += MAXFREQ / NSEC_PER_USEC;\n\tif (time_maxerror > NTP_PHASE_LIMIT) {\n\t\ttime_maxerror = NTP_PHASE_LIMIT;\n\t\ttime_status |= STA_UNSYNC;\n\t}\n\n\t/* Compute the phase adjustment for the next second */\n\ttick_length\t = tick_length_base;\n\n\tdelta\t\t = ntp_offset_chunk(time_offset);\n\ttime_offset\t-= delta;\n\ttick_length\t+= delta;\n\n\t/* Check PPS signal */\n\tpps_dec_valid();\n\n\tif (!time_adjust)\n\t\tgoto out;\n\n\tif (time_adjust > MAX_TICKADJ) {\n\t\ttime_adjust -= MAX_TICKADJ;\n\t\ttick_length += MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\tif (time_adjust < -MAX_TICKADJ) {\n\t\ttime_adjust += MAX_TICKADJ;\n\t\ttick_length -= MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)\n\t\t\t\t\t\t\t << NTP_SCALE_SHIFT;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define MAX_TICKADJ_SCALED \\\n\t(((MAX_TICKADJ * NSEC_PER_USEC) << NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)",
      "#define MAX_TICKADJ\t\t500LL\t\t/* usecs */",
      "#define SECS_PER_DAY\t\t86400"
    ],
    "globals_used": [
      "static u64\t\t\ttick_length;",
      "static u64\t\t\ttick_length_base;",
      "static int\t\t\ttime_state = TIME_OK;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_offset;",
      "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
      "static long\t\t\ttime_adjust;",
      "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pps_dec_valid",
          "args": [],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "pps_dec_valid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "217-217",
          "snippet": "static inline void pps_dec_valid(void) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_dec_valid(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_offset_chunk",
          "args": [
            "time_offset"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_offset_chunk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "210-213",
          "snippet": "static inline s64 ntp_offset_chunk(s64 offset)\n{\n\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long\t\t\ttime_constant = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic long\t\t\ttime_constant = 2;\n\nstatic inline s64 ntp_offset_chunk(s64 offset)\n{\n\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\""
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_s64_rem",
          "args": [
            "secs + 1",
            "SECS_PER_DAY",
            "&rem"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_s64_rem",
          "args": [
            "secs",
            "SECS_PER_DAY",
            "&rem"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define MAX_TICKADJ_SCALED \\\n\t(((MAX_TICKADJ * NSEC_PER_USEC) << NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)\n#define MAX_TICKADJ\t\t500LL\t\t/* usecs */\n#define SECS_PER_DAY\t\t86400\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nint second_overflow(time64_t secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\ts32 rem;\n\n\t/*\n\t * Leap second processing. If in leap-insert state at the end of the\n\t * day, the system clock is set back one second; if in leap-delete\n\t * state, the system clock is set ahead one second.\n\t */\n\tswitch (time_state) {\n\tcase TIME_OK:\n\t\tif (time_status & STA_INS) {\n\t\t\ttime_state = TIME_INS;\n\t\t\tdiv_s64_rem(secs, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t} else if (time_status & STA_DEL) {\n\t\t\ttime_state = TIME_DEL;\n\t\t\tdiv_s64_rem(secs + 1, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t}\n\t\tbreak;\n\tcase TIME_INS:\n\t\tif (!(time_status & STA_INS)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = -1;\n\t\t\ttime_state = TIME_OOP;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: inserting leap second 23:59:60 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_DEL:\n\t\tif (!(time_status & STA_DEL)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = 1;\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_WAIT;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_OOP:\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\ttime_state = TIME_WAIT;\n\t\tbreak;\n\tcase TIME_WAIT:\n\t\tif (!(time_status & (STA_INS | STA_DEL)))\n\t\t\ttime_state = TIME_OK;\n\t\tbreak;\n\t}\n\n\n\t/* Bump the maxerror field */\n\ttime_maxerror += MAXFREQ / NSEC_PER_USEC;\n\tif (time_maxerror > NTP_PHASE_LIMIT) {\n\t\ttime_maxerror = NTP_PHASE_LIMIT;\n\t\ttime_status |= STA_UNSYNC;\n\t}\n\n\t/* Compute the phase adjustment for the next second */\n\ttick_length\t = tick_length_base;\n\n\tdelta\t\t = ntp_offset_chunk(time_offset);\n\ttime_offset\t-= delta;\n\ttick_length\t+= delta;\n\n\t/* Check PPS signal */\n\tpps_dec_valid();\n\n\tif (!time_adjust)\n\t\tgoto out;\n\n\tif (time_adjust > MAX_TICKADJ) {\n\t\ttime_adjust -= MAX_TICKADJ;\n\t\ttick_length += MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\tif (time_adjust < -MAX_TICKADJ) {\n\t\ttime_adjust += MAX_TICKADJ;\n\t\ttick_length -= MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)\n\t\t\t\t\t\t\t << NTP_SCALE_SHIFT;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}"
  },
  {
    "function_name": "ntp_get_next_leap",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "380-388",
    "snippet": "ktime_t ntp_get_next_leap(void)\n{\n\tktime_t ret;\n\n\tif ((time_state == TIME_INS) && (time_status & STA_INS))\n\t\treturn ktime_set(ntp_next_leap_sec, 0);\n\tret = KTIME_MAX;\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_state = TIME_OK;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "ntp_next_leap_sec",
            "0"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nktime_t ntp_get_next_leap(void)\n{\n\tktime_t ret;\n\n\tif ((time_state == TIME_INS) && (time_status & STA_INS))\n\t\treturn ktime_set(ntp_next_leap_sec, 0);\n\tret = KTIME_MAX;\n\treturn ret;\n}"
  },
  {
    "function_name": "ntp_tick_length",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "369-372",
    "snippet": "u64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64\t\t\ttick_length;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\n\nu64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}"
  },
  {
    "function_name": "ntp_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "351-366",
    "snippet": "void ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64\t\t\ttick_length;",
      "static u64\t\t\ttick_length_base;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_offset;",
      "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
      "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
      "static long\t\t\ttime_adjust;",
      "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pps_clear",
          "args": [],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "pps_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "216-216",
          "snippet": "static inline void pps_clear(void) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_clear(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_update_frequency",
          "args": [],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_frequency",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "259-279",
          "snippet": "static void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "unsigned long\t\t\ttick_nsec;",
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static s64\t\t\ttime_freq;",
            "static s64\t\t\tntp_tick_adj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nunsigned long\t\t\ttick_nsec;\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic s64\t\t\ttime_freq;\nstatic s64\t\t\tntp_tick_adj;\n\nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nvoid ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}"
  },
  {
    "function_name": "ntp_update_offset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "296-346",
    "snippet": "static void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & STA_PLL))\n\t\treturn;\n\n\tif (!(time_status & STA_NANO)) {\n\t\t/* Make sure the multiplication below won't overflow */\n\t\toffset = clamp(offset, -USEC_PER_SEC, USEC_PER_SEC);\n\t\toffset *= NSEC_PER_USEC;\n\t}\n\n\t/*\n\t * Scale the phase adjustment and\n\t * clamp to the operating range.\n\t */\n\toffset = clamp(offset, -MAXPHASE, MAXPHASE);\n\n\t/*\n\t * Select how the frequency is to be controlled\n\t * and in which mode (PLL or FLL).\n\t */\n\tsecs = (long)(__ktime_get_real_seconds() - time_reftime);\n\tif (unlikely(time_status & STA_FREQHOLD))\n\t\tsecs = 0;\n\n\ttime_reftime = __ktime_get_real_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t/*\n\t * Clamp update interval to reduce PLL gain with low\n\t * sampling rate (e.g. intermittent network connection)\n\t * to avoid instability.\n\t */\n\tif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))\n\t\tsecs = 1 << (SHIFT_PLL + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, MAXFREQ_SCALED);\n\n\ttime_freq   = max(freq_adj, -MAXFREQ_SCALED);\n\n\ttime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_offset;",
      "static long\t\t\ttime_constant = 2;",
      "static s64\t\t\ttime_freq;",
      "static time64_t\t\ttime_reftime;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_s64",
          "args": [
            "offset64 << NTP_SCALE_SHIFT",
            "NTP_INTERVAL_FREQ"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "freq_adj",
            "-MAXFREQ_SCALED"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "module_extend_max_pages",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module_decompress.c",
          "lines": "17-32",
          "snippet": "static int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/xz.h>",
            "#include <linux/zlib.h>",
            "#include \"module-internal.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/kobject.h>",
            "#include <linux/highmem.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xz.h>\n#include <linux/zlib.h>\n#include \"module-internal.h\"\n#include <linux/vmalloc.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/kobject.h>\n#include <linux/highmem.h>\n#include <linux/init.h>\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "freq_adj + time_freq",
            "MAXFREQ_SCALED"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/clocksource.c",
          "lines": "776-808",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/cpu.h>",
            "#include <linux/prandom.h>",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/cpu.h>\n#include <linux/prandom.h>\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "secs > 1 << (SHIFT_PLL + 1 + time_constant)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_update_offset_fll",
          "args": [
            "offset64",
            "secs"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_offset_fll",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "281-294",
          "snippet": "static inline s64 ntp_update_offset_fll(s64 offset64, long secs)\n{\n\ttime_status &= ~STA_MODE;\n\n\tif (secs < MINSEC)\n\t\treturn 0;\n\n\tif (!(time_status & STA_FLL) && (secs <= MAXSEC))\n\t\treturn 0;\n\n\ttime_status |= STA_MODE;\n\n\treturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline s64 ntp_update_offset_fll(s64 offset64, long secs)\n{\n\ttime_status &= ~STA_MODE;\n\n\tif (secs < MINSEC)\n\t\treturn 0;\n\n\tif (!(time_status & STA_FLL) && (secs <= MAXSEC))\n\t\treturn 0;\n\n\ttime_status |= STA_MODE;\n\n\treturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ktime_get_real_seconds",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "time_status & STA_FREQHOLD"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "offset",
            "-MAXPHASE",
            "MAXPHASE"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "wq_clamp_max_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "4254-4264",
          "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_constant = 2;\nstatic s64\t\t\ttime_freq;\nstatic time64_t\t\ttime_reftime;\n\nstatic void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & STA_PLL))\n\t\treturn;\n\n\tif (!(time_status & STA_NANO)) {\n\t\t/* Make sure the multiplication below won't overflow */\n\t\toffset = clamp(offset, -USEC_PER_SEC, USEC_PER_SEC);\n\t\toffset *= NSEC_PER_USEC;\n\t}\n\n\t/*\n\t * Scale the phase adjustment and\n\t * clamp to the operating range.\n\t */\n\toffset = clamp(offset, -MAXPHASE, MAXPHASE);\n\n\t/*\n\t * Select how the frequency is to be controlled\n\t * and in which mode (PLL or FLL).\n\t */\n\tsecs = (long)(__ktime_get_real_seconds() - time_reftime);\n\tif (unlikely(time_status & STA_FREQHOLD))\n\t\tsecs = 0;\n\n\ttime_reftime = __ktime_get_real_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t/*\n\t * Clamp update interval to reduce PLL gain with low\n\t * sampling rate (e.g. intermittent network connection)\n\t * to avoid instability.\n\t */\n\tif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))\n\t\tsecs = 1 << (SHIFT_PLL + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, MAXFREQ_SCALED);\n\n\ttime_freq   = max(freq_adj, -MAXFREQ_SCALED);\n\n\ttime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);\n}"
  },
  {
    "function_name": "ntp_update_offset_fll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "281-294",
    "snippet": "static inline s64 ntp_update_offset_fll(s64 offset64, long secs)\n{\n\ttime_status &= ~STA_MODE;\n\n\tif (secs < MINSEC)\n\t\treturn 0;\n\n\tif (!(time_status & STA_FLL) && (secs <= MAXSEC))\n\t\treturn 0;\n\n\ttime_status |= STA_MODE;\n\n\treturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_long",
          "args": [
            "offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL)",
            "secs"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline s64 ntp_update_offset_fll(s64 offset64, long secs)\n{\n\ttime_status &= ~STA_MODE;\n\n\tif (secs < MINSEC)\n\t\treturn 0;\n\n\tif (!(time_status & STA_FLL) && (secs <= MAXSEC))\n\t\treturn 0;\n\n\ttime_status |= STA_MODE;\n\n\treturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);\n}"
  },
  {
    "function_name": "ntp_update_frequency",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "259-279",
    "snippet": "static void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
      "unsigned long\t\t\ttick_nsec;",
      "static u64\t\t\ttick_length;",
      "static u64\t\t\ttick_length_base;",
      "static s64\t\t\ttime_freq;",
      "static s64\t\t\tntp_tick_adj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "second_length",
            "NTP_INTERVAL_FREQ"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "second_length",
            "HZ"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tick_usec * NSEC_PER_USEC * USER_HZ"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nunsigned long\t\t\ttick_nsec;\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic s64\t\t\ttime_freq;\nstatic s64\t\t\tntp_tick_adj;\n\nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}"
  },
  {
    "function_name": "ntp_synced",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "245-248",
    "snippet": "static inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}"
  },
  {
    "function_name": "pps_fill_timex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "225-236",
    "snippet": "static inline void pps_fill_timex(struct __kernel_timex *txc)\n{\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_fill_timex(struct __kernel_timex *txc)\n{\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n}"
  },
  {
    "function_name": "is_error_status",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "220-223",
    "snippet": "static inline int is_error_status(int status)\n{\n\treturn status & (STA_UNSYNC|STA_CLOCKERR);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline int is_error_status(int status)\n{\n\treturn status & (STA_UNSYNC|STA_CLOCKERR);\n}"
  },
  {
    "function_name": "pps_set_freq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "218-218",
    "snippet": "static inline void pps_set_freq(s64 freq) {}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_set_freq(s64 freq) {}"
  },
  {
    "function_name": "pps_dec_valid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "217-217",
    "snippet": "static inline void pps_dec_valid(void) {}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_dec_valid(void) {}"
  },
  {
    "function_name": "pps_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "216-216",
    "snippet": "static inline void pps_clear(void) {}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_clear(void) {}"
  },
  {
    "function_name": "pps_reset_freq_interval",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "215-215",
    "snippet": "static inline void pps_reset_freq_interval(void) {}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_reset_freq_interval(void) {}"
  },
  {
    "function_name": "ntp_offset_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "210-213",
    "snippet": "static inline s64 ntp_offset_chunk(s64 offset)\n{\n\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long\t\t\ttime_constant = 2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "offset",
            "SHIFT_PLL + time_constant"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic long\t\t\ttime_constant = 2;\n\nstatic inline s64 ntp_offset_chunk(s64 offset)\n{\n\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}"
  },
  {
    "function_name": "pps_fill_timex",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "193-206",
    "snippet": "static inline void pps_fill_timex(struct __kernel_timex *txc)\n{\n\ttxc->ppsfreq\t   = shift_right((pps_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->jitter\t   = pps_jitter;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->jitter = pps_jitter / NSEC_PER_USEC;\n\ttxc->shift\t   = pps_shift;\n\ttxc->stabil\t   = pps_stabil;\n\ttxc->jitcnt\t   = pps_jitcnt;\n\ttxc->calcnt\t   = pps_calcnt;\n\ttxc->errcnt\t   = pps_errcnt;\n\ttxc->stbcnt\t   = pps_stbcnt;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "(pps_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV",
            "NTP_SCALE_SHIFT"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline void pps_fill_timex(struct __kernel_timex *txc)\n{\n\ttxc->ppsfreq\t   = shift_right((pps_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->jitter\t   = pps_jitter;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->jitter = pps_jitter / NSEC_PER_USEC;\n\ttxc->shift\t   = pps_shift;\n\ttxc->stabil\t   = pps_stabil;\n\ttxc->jitcnt\t   = pps_jitcnt;\n\ttxc->calcnt\t   = pps_calcnt;\n\ttxc->errcnt\t   = pps_errcnt;\n\ttxc->stbcnt\t   = pps_stbcnt;\n}"
  },
  {
    "function_name": "is_error_status",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "174-191",
    "snippet": "static inline int is_error_status(int status)\n{\n\treturn (status & (STA_UNSYNC|STA_CLOCKERR))\n\t\t/* PPS signal lost when either PPS time or\n\t\t * PPS frequency synchronization requested\n\t\t */\n\t\t|| ((status & (STA_PPSFREQ|STA_PPSTIME))\n\t\t\t&& !(status & STA_PPSSIGNAL))\n\t\t/* PPS jitter exceeded when\n\t\t * PPS time synchronization requested */\n\t\t|| ((status & (STA_PPSTIME|STA_PPSJITTER))\n\t\t\t== (STA_PPSTIME|STA_PPSJITTER))\n\t\t/* PPS wander exceeded or calibration error when\n\t\t * PPS frequency synchronization requested\n\t\t */\n\t\t|| ((status & STA_PPSFREQ)\n\t\t\t&& (status & (STA_PPSWANDER|STA_PPSERROR)));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline int is_error_status(int status)\n{\n\treturn (status & (STA_UNSYNC|STA_CLOCKERR))\n\t\t/* PPS signal lost when either PPS time or\n\t\t * PPS frequency synchronization requested\n\t\t */\n\t\t|| ((status & (STA_PPSFREQ|STA_PPSTIME))\n\t\t\t&& !(status & STA_PPSSIGNAL))\n\t\t/* PPS jitter exceeded when\n\t\t * PPS time synchronization requested */\n\t\t|| ((status & (STA_PPSTIME|STA_PPSJITTER))\n\t\t\t== (STA_PPSTIME|STA_PPSJITTER))\n\t\t/* PPS wander exceeded or calibration error when\n\t\t * PPS frequency synchronization requested\n\t\t */\n\t\t|| ((status & STA_PPSFREQ)\n\t\t\t&& (status & (STA_PPSWANDER|STA_PPSERROR)));\n}"
  },
  {
    "function_name": "pps_set_freq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "169-172",
    "snippet": "static inline void pps_set_freq(s64 freq)\n{\n\tpps_freq = freq;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_set_freq(s64 freq)\n{\n\tpps_freq = freq;\n}"
  },
  {
    "function_name": "pps_dec_valid",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "158-167",
    "snippet": "static inline void pps_dec_valid(void)\n{\n\tif (pps_valid > 0)\n\t\tpps_valid--;\n\telse {\n\t\ttime_status &= ~(STA_PPSSIGNAL | STA_PPSJITTER |\n\t\t\t\t STA_PPSWANDER | STA_PPSERROR);\n\t\tpps_clear();\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pps_clear",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "pps_clear",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "216-216",
          "snippet": "static inline void pps_clear(void) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_clear(void) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline void pps_dec_valid(void)\n{\n\tif (pps_valid > 0)\n\t\tpps_valid--;\n\telse {\n\t\ttime_status &= ~(STA_PPSSIGNAL | STA_PPSJITTER |\n\t\t\t\t STA_PPSWANDER | STA_PPSERROR);\n\t\tpps_clear();\n\t}\n}"
  },
  {
    "function_name": "pps_clear",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "144-152",
    "snippet": "static inline void pps_clear(void)\n{\n\tpps_reset_freq_interval();\n\tpps_tf[0] = 0;\n\tpps_tf[1] = 0;\n\tpps_tf[2] = 0;\n\tpps_fbase.tv_sec = pps_fbase.tv_nsec = 0;\n\tpps_freq = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pps_reset_freq_interval",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "pps_reset_freq_interval",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
          "lines": "215-215",
          "snippet": "static inline void pps_reset_freq_interval(void) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_reset_freq_interval(void) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_clear(void)\n{\n\tpps_reset_freq_interval();\n\tpps_tf[0] = 0;\n\tpps_tf[1] = 0;\n\tpps_tf[2] = 0;\n\tpps_fbase.tv_sec = pps_fbase.tv_nsec = 0;\n\tpps_freq = 0;\n}"
  },
  {
    "function_name": "pps_reset_freq_interval",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "133-139",
    "snippet": "static inline void pps_reset_freq_interval(void)\n{\n\t/* the PPS calibration interval may end\n\t   surprisingly early */\n\tpps_shift = PPS_INTMIN;\n\tpps_intcnt = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n\nstatic inline void pps_reset_freq_interval(void)\n{\n\t/* the PPS calibration interval may end\n\t   surprisingly early */\n\tpps_shift = PPS_INTMIN;\n\tpps_intcnt = 0;\n}"
  },
  {
    "function_name": "ntp_offset_chunk",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/ntp.c",
    "lines": "125-131",
    "snippet": "static inline s64 ntp_offset_chunk(s64 offset)\n{\n\tif (time_status & STA_PPSTIME && time_status & STA_PPSSIGNAL)\n\t\treturn offset;\n\telse\n\t\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/audit.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static long\t\t\ttime_constant = 2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "offset",
            "SHIFT_PLL + time_constant"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/audit.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic long\t\t\ttime_constant = 2;\n\nstatic inline s64 ntp_offset_chunk(s64 offset)\n{\n\tif (time_status & STA_PPSTIME && time_status & STA_PPSSIGNAL)\n\t\treturn offset;\n\telse\n\t\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}"
  }
]