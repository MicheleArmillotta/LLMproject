[
  {
    "function_name": "ok_to_run_trace_benchmark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_benchmark.c",
    "lines": "222-227",
    "snippet": "static __init int ok_to_run_trace_benchmark(void)\n{\n\tok_to_run = true;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_benchmark.h\"",
      "#include <linux/trace_clock.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ok_to_run;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_benchmark.h\"\n#include <linux/trace_clock.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\nstatic bool ok_to_run;\n\nstatic __init int ok_to_run_trace_benchmark(void)\n{\n\tok_to_run = true;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_benchmark_unreg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_benchmark.c",
    "lines": "200-220",
    "snippet": "void trace_benchmark_unreg(void)\n{\n\tif (!bm_event_thread)\n\t\treturn;\n\n\tkthread_stop(bm_event_thread);\n\tbm_event_thread = NULL;\n\n\tstrcpy(bm_str, \"START\");\n\tbm_total = 0;\n\tbm_totalsq = 0;\n\tbm_last = 0;\n\tbm_max = 0;\n\tbm_min = 0;\n\tbm_cnt = 0;\n\t/* These don't need to be reset but reset them anyway */\n\tbm_first = 0;\n\tbm_std = 0;\n\tbm_avg = 0;\n\tbm_stddev = 0;\n}",
    "includes": [
      "#include \"trace_benchmark.h\"",
      "#include <linux/trace_clock.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *bm_event_thread;",
      "static char bm_str[BENCHMARK_EVENT_STRLEN] = \"START\";",
      "static u64 bm_total;",
      "static u64 bm_totalsq;",
      "static u64 bm_last;",
      "static u64 bm_max;",
      "static u64 bm_min;",
      "static u64 bm_first;",
      "static u64 bm_cnt;",
      "static u64 bm_stddev;",
      "static unsigned int bm_avg;",
      "static unsigned int bm_std;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "bm_str",
            "\"START\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "bm_event_thread"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "697-715",
          "snippet": "int kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nint kthread_stop(struct task_struct *k)\n{\n\tstruct kthread *kthread;\n\tint ret;\n\n\ttrace_sched_kthread_stop(k);\n\n\tget_task_struct(k);\n\tkthread = to_kthread(k);\n\tset_bit(KTHREAD_SHOULD_STOP, &kthread->flags);\n\tkthread_unpark(k);\n\twake_up_process(k);\n\twait_for_completion(&kthread->exited);\n\tret = kthread->result;\n\tput_task_struct(k);\n\n\ttrace_sched_kthread_stop_ret(ret);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_benchmark.h\"\n#include <linux/trace_clock.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\nstatic struct task_struct *bm_event_thread;\nstatic char bm_str[BENCHMARK_EVENT_STRLEN] = \"START\";\nstatic u64 bm_total;\nstatic u64 bm_totalsq;\nstatic u64 bm_last;\nstatic u64 bm_max;\nstatic u64 bm_min;\nstatic u64 bm_first;\nstatic u64 bm_cnt;\nstatic u64 bm_stddev;\nstatic unsigned int bm_avg;\nstatic unsigned int bm_std;\n\nvoid trace_benchmark_unreg(void)\n{\n\tif (!bm_event_thread)\n\t\treturn;\n\n\tkthread_stop(bm_event_thread);\n\tbm_event_thread = NULL;\n\n\tstrcpy(bm_str, \"START\");\n\tbm_total = 0;\n\tbm_totalsq = 0;\n\tbm_last = 0;\n\tbm_max = 0;\n\tbm_min = 0;\n\tbm_cnt = 0;\n\t/* These don't need to be reset but reset them anyway */\n\tbm_first = 0;\n\tbm_std = 0;\n\tbm_avg = 0;\n\tbm_stddev = 0;\n}"
  },
  {
    "function_name": "trace_benchmark_reg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_benchmark.c",
    "lines": "178-193",
    "snippet": "int trace_benchmark_reg(void)\n{\n\tif (!ok_to_run) {\n\t\tpr_warn(\"trace benchmark cannot be started via kernel command line\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tbm_event_thread = kthread_run(benchmark_event_kthread,\n\t\t\t\t      NULL, \"event_benchmark\");\n\tif (IS_ERR(bm_event_thread)) {\n\t\tpr_warn(\"trace benchmark failed to create kernel thread\\n\");\n\t\treturn PTR_ERR(bm_event_thread);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_benchmark.h\"",
      "#include <linux/trace_clock.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct task_struct *bm_event_thread;",
      "static bool ok_to_run;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bm_event_thread"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"trace benchmark failed to create kernel thread\\n\""
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bm_event_thread"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "benchmark_event_kthread",
            "NULL",
            "\"event_benchmark\""
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"trace benchmark cannot be started via kernel command line\\n\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_benchmark.h\"\n#include <linux/trace_clock.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\nstatic struct task_struct *bm_event_thread;\nstatic bool ok_to_run;\n\nint trace_benchmark_reg(void)\n{\n\tif (!ok_to_run) {\n\t\tpr_warn(\"trace benchmark cannot be started via kernel command line\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tbm_event_thread = kthread_run(benchmark_event_kthread,\n\t\t\t\t      NULL, \"event_benchmark\");\n\tif (IS_ERR(bm_event_thread)) {\n\t\tpr_warn(\"trace benchmark failed to create kernel thread\\n\");\n\t\treturn PTR_ERR(bm_event_thread);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "benchmark_event_kthread",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_benchmark.c",
    "lines": "147-172",
    "snippet": "static int benchmark_event_kthread(void *arg)\n{\n\t/* sleep a bit to make sure the tracepoint gets activated */\n\tmsleep(100);\n\n\twhile (!kthread_should_stop()) {\n\n\t\ttrace_do_benchmark();\n\n\t\t/*\n\t\t * We don't go to sleep, but let others run as well.\n\t\t * This is basically a \"yield()\" to let any task that\n\t\t * wants to run, schedule in, but if the CPU is idle,\n\t\t * we'll keep burning cycles.\n\t\t *\n\t\t * Note the tasks_rcu_qs() version of cond_resched() will\n\t\t * notify synchronize_rcu_tasks() that this thread has\n\t\t * passed a quiescent state for rcu_tasks. Otherwise\n\t\t * this thread will never voluntarily schedule which would\n\t\t * block synchronize_rcu_tasks() indefinitely.\n\t\t */\n\t\tcond_resched_tasks_rcu_qs();\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_benchmark.h\"",
      "#include <linux/trace_clock.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched_tasks_rcu_qs",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_do_benchmark",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "trace_do_benchmark",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_benchmark.c",
          "lines": "37-145",
          "snippet": "static void trace_do_benchmark(void)\n{\n\tu64 start;\n\tu64 stop;\n\tu64 delta;\n\tu64 stddev;\n\tu64 seed;\n\tu64 last_seed;\n\tunsigned int avg;\n\tunsigned int std = 0;\n\n\t/* Only run if the tracepoint is actually active */\n\tif (!trace_benchmark_event_enabled() || !tracing_is_on())\n\t\treturn;\n\n\tlocal_irq_disable();\n\tstart = trace_clock_local();\n\ttrace_benchmark_event(bm_str);\n\tstop = trace_clock_local();\n\tlocal_irq_enable();\n\n\tbm_cnt++;\n\n\tdelta = stop - start;\n\n\t/*\n\t * The first read is cold cached, keep it separate from the\n\t * other calculations.\n\t */\n\tif (bm_cnt == 1) {\n\t\tbm_first = delta;\n\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t\t  \"first=%llu [COLD CACHED]\", bm_first);\n\t\treturn;\n\t}\n\n\tbm_last = delta;\n\n\tif (delta > bm_max)\n\t\tbm_max = delta;\n\tif (!bm_min || delta < bm_min)\n\t\tbm_min = delta;\n\n\t/*\n\t * When bm_cnt is greater than UINT_MAX, it breaks the statistics\n\t * accounting. Freeze the statistics when that happens.\n\t * We should have enough data for the avg and stddev anyway.\n\t */\n\tif (bm_cnt > UINT_MAX) {\n\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t    \"last=%llu first=%llu max=%llu min=%llu ** avg=%u std=%d std^2=%lld\",\n\t\t\t  bm_last, bm_first, bm_max, bm_min, bm_avg, bm_std, bm_stddev);\n\t\treturn;\n\t}\n\n\tbm_total += delta;\n\tbm_totalsq += delta * delta;\n\n\n\tif (bm_cnt > 1) {\n\t\t/*\n\t\t * Apply Welford's method to calculate standard deviation:\n\t\t * s^2 = 1 / (n * (n-1)) * (n * \\Sum (x_i)^2 - (\\Sum x_i)^2)\n\t\t */\n\t\tstddev = (u64)bm_cnt * bm_totalsq - bm_total * bm_total;\n\t\tdo_div(stddev, (u32)bm_cnt);\n\t\tdo_div(stddev, (u32)bm_cnt - 1);\n\t} else\n\t\tstddev = 0;\n\n\tdelta = bm_total;\n\tdo_div(delta, bm_cnt);\n\tavg = delta;\n\n\tif (stddev > 0) {\n\t\tint i = 0;\n\t\t/*\n\t\t * stddev is the square of standard deviation but\n\t\t * we want the actually number. Use the average\n\t\t * as our seed to find the std.\n\t\t *\n\t\t * The next try is:\n\t\t *  x = (x + N/x) / 2\n\t\t *\n\t\t * Where N is the squared number to find the square\n\t\t * root of.\n\t\t */\n\t\tseed = avg;\n\t\tdo {\n\t\t\tlast_seed = seed;\n\t\t\tseed = stddev;\n\t\t\tif (!last_seed)\n\t\t\t\tbreak;\n\t\t\tdo_div(seed, last_seed);\n\t\t\tseed += last_seed;\n\t\t\tdo_div(seed, 2);\n\t\t} while (i++ < 10 && last_seed != seed);\n\n\t\tstd = seed;\n\t}\n\n\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t  \"last=%llu first=%llu max=%llu min=%llu avg=%u std=%d std^2=%lld\",\n\t\t  bm_last, bm_first, bm_max, bm_min, avg, std, stddev);\n\n\tbm_std = std;\n\tbm_avg = avg;\n\tbm_stddev = stddev;\n}",
          "includes": [
            "#include \"trace_benchmark.h\"",
            "#include <linux/trace_clock.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char bm_str[BENCHMARK_EVENT_STRLEN] = \"START\";",
            "static u64 bm_total;",
            "static u64 bm_totalsq;",
            "static u64 bm_last;",
            "static u64 bm_max;",
            "static u64 bm_min;",
            "static u64 bm_first;",
            "static u64 bm_cnt;",
            "static u64 bm_stddev;",
            "static unsigned int bm_avg;",
            "static unsigned int bm_std;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_benchmark.h\"\n#include <linux/trace_clock.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\nstatic char bm_str[BENCHMARK_EVENT_STRLEN] = \"START\";\nstatic u64 bm_total;\nstatic u64 bm_totalsq;\nstatic u64 bm_last;\nstatic u64 bm_max;\nstatic u64 bm_min;\nstatic u64 bm_first;\nstatic u64 bm_cnt;\nstatic u64 bm_stddev;\nstatic unsigned int bm_avg;\nstatic unsigned int bm_std;\n\nstatic void trace_do_benchmark(void)\n{\n\tu64 start;\n\tu64 stop;\n\tu64 delta;\n\tu64 stddev;\n\tu64 seed;\n\tu64 last_seed;\n\tunsigned int avg;\n\tunsigned int std = 0;\n\n\t/* Only run if the tracepoint is actually active */\n\tif (!trace_benchmark_event_enabled() || !tracing_is_on())\n\t\treturn;\n\n\tlocal_irq_disable();\n\tstart = trace_clock_local();\n\ttrace_benchmark_event(bm_str);\n\tstop = trace_clock_local();\n\tlocal_irq_enable();\n\n\tbm_cnt++;\n\n\tdelta = stop - start;\n\n\t/*\n\t * The first read is cold cached, keep it separate from the\n\t * other calculations.\n\t */\n\tif (bm_cnt == 1) {\n\t\tbm_first = delta;\n\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t\t  \"first=%llu [COLD CACHED]\", bm_first);\n\t\treturn;\n\t}\n\n\tbm_last = delta;\n\n\tif (delta > bm_max)\n\t\tbm_max = delta;\n\tif (!bm_min || delta < bm_min)\n\t\tbm_min = delta;\n\n\t/*\n\t * When bm_cnt is greater than UINT_MAX, it breaks the statistics\n\t * accounting. Freeze the statistics when that happens.\n\t * We should have enough data for the avg and stddev anyway.\n\t */\n\tif (bm_cnt > UINT_MAX) {\n\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t    \"last=%llu first=%llu max=%llu min=%llu ** avg=%u std=%d std^2=%lld\",\n\t\t\t  bm_last, bm_first, bm_max, bm_min, bm_avg, bm_std, bm_stddev);\n\t\treturn;\n\t}\n\n\tbm_total += delta;\n\tbm_totalsq += delta * delta;\n\n\n\tif (bm_cnt > 1) {\n\t\t/*\n\t\t * Apply Welford's method to calculate standard deviation:\n\t\t * s^2 = 1 / (n * (n-1)) * (n * \\Sum (x_i)^2 - (\\Sum x_i)^2)\n\t\t */\n\t\tstddev = (u64)bm_cnt * bm_totalsq - bm_total * bm_total;\n\t\tdo_div(stddev, (u32)bm_cnt);\n\t\tdo_div(stddev, (u32)bm_cnt - 1);\n\t} else\n\t\tstddev = 0;\n\n\tdelta = bm_total;\n\tdo_div(delta, bm_cnt);\n\tavg = delta;\n\n\tif (stddev > 0) {\n\t\tint i = 0;\n\t\t/*\n\t\t * stddev is the square of standard deviation but\n\t\t * we want the actually number. Use the average\n\t\t * as our seed to find the std.\n\t\t *\n\t\t * The next try is:\n\t\t *  x = (x + N/x) / 2\n\t\t *\n\t\t * Where N is the squared number to find the square\n\t\t * root of.\n\t\t */\n\t\tseed = avg;\n\t\tdo {\n\t\t\tlast_seed = seed;\n\t\t\tseed = stddev;\n\t\t\tif (!last_seed)\n\t\t\t\tbreak;\n\t\t\tdo_div(seed, last_seed);\n\t\t\tseed += last_seed;\n\t\t\tdo_div(seed, 2);\n\t\t} while (i++ < 10 && last_seed != seed);\n\n\t\tstd = seed;\n\t}\n\n\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t  \"last=%llu first=%llu max=%llu min=%llu avg=%u std=%d std^2=%lld\",\n\t\t  bm_last, bm_first, bm_max, bm_min, avg, std, stddev);\n\n\tbm_std = std;\n\tbm_avg = avg;\n\tbm_stddev = stddev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_should_stop",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "156-159",
          "snippet": "bool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_should_stop(void)\n{\n\treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current)->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "100"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "msleep_interruptible",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "2045-2052",
          "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_benchmark.h\"\n#include <linux/trace_clock.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\nstatic int benchmark_event_kthread(void *arg)\n{\n\t/* sleep a bit to make sure the tracepoint gets activated */\n\tmsleep(100);\n\n\twhile (!kthread_should_stop()) {\n\n\t\ttrace_do_benchmark();\n\n\t\t/*\n\t\t * We don't go to sleep, but let others run as well.\n\t\t * This is basically a \"yield()\" to let any task that\n\t\t * wants to run, schedule in, but if the CPU is idle,\n\t\t * we'll keep burning cycles.\n\t\t *\n\t\t * Note the tasks_rcu_qs() version of cond_resched() will\n\t\t * notify synchronize_rcu_tasks() that this thread has\n\t\t * passed a quiescent state for rcu_tasks. Otherwise\n\t\t * this thread will never voluntarily schedule which would\n\t\t * block synchronize_rcu_tasks() indefinitely.\n\t\t */\n\t\tcond_resched_tasks_rcu_qs();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "trace_do_benchmark",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_benchmark.c",
    "lines": "37-145",
    "snippet": "static void trace_do_benchmark(void)\n{\n\tu64 start;\n\tu64 stop;\n\tu64 delta;\n\tu64 stddev;\n\tu64 seed;\n\tu64 last_seed;\n\tunsigned int avg;\n\tunsigned int std = 0;\n\n\t/* Only run if the tracepoint is actually active */\n\tif (!trace_benchmark_event_enabled() || !tracing_is_on())\n\t\treturn;\n\n\tlocal_irq_disable();\n\tstart = trace_clock_local();\n\ttrace_benchmark_event(bm_str);\n\tstop = trace_clock_local();\n\tlocal_irq_enable();\n\n\tbm_cnt++;\n\n\tdelta = stop - start;\n\n\t/*\n\t * The first read is cold cached, keep it separate from the\n\t * other calculations.\n\t */\n\tif (bm_cnt == 1) {\n\t\tbm_first = delta;\n\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t\t  \"first=%llu [COLD CACHED]\", bm_first);\n\t\treturn;\n\t}\n\n\tbm_last = delta;\n\n\tif (delta > bm_max)\n\t\tbm_max = delta;\n\tif (!bm_min || delta < bm_min)\n\t\tbm_min = delta;\n\n\t/*\n\t * When bm_cnt is greater than UINT_MAX, it breaks the statistics\n\t * accounting. Freeze the statistics when that happens.\n\t * We should have enough data for the avg and stddev anyway.\n\t */\n\tif (bm_cnt > UINT_MAX) {\n\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t    \"last=%llu first=%llu max=%llu min=%llu ** avg=%u std=%d std^2=%lld\",\n\t\t\t  bm_last, bm_first, bm_max, bm_min, bm_avg, bm_std, bm_stddev);\n\t\treturn;\n\t}\n\n\tbm_total += delta;\n\tbm_totalsq += delta * delta;\n\n\n\tif (bm_cnt > 1) {\n\t\t/*\n\t\t * Apply Welford's method to calculate standard deviation:\n\t\t * s^2 = 1 / (n * (n-1)) * (n * \\Sum (x_i)^2 - (\\Sum x_i)^2)\n\t\t */\n\t\tstddev = (u64)bm_cnt * bm_totalsq - bm_total * bm_total;\n\t\tdo_div(stddev, (u32)bm_cnt);\n\t\tdo_div(stddev, (u32)bm_cnt - 1);\n\t} else\n\t\tstddev = 0;\n\n\tdelta = bm_total;\n\tdo_div(delta, bm_cnt);\n\tavg = delta;\n\n\tif (stddev > 0) {\n\t\tint i = 0;\n\t\t/*\n\t\t * stddev is the square of standard deviation but\n\t\t * we want the actually number. Use the average\n\t\t * as our seed to find the std.\n\t\t *\n\t\t * The next try is:\n\t\t *  x = (x + N/x) / 2\n\t\t *\n\t\t * Where N is the squared number to find the square\n\t\t * root of.\n\t\t */\n\t\tseed = avg;\n\t\tdo {\n\t\t\tlast_seed = seed;\n\t\t\tseed = stddev;\n\t\t\tif (!last_seed)\n\t\t\t\tbreak;\n\t\t\tdo_div(seed, last_seed);\n\t\t\tseed += last_seed;\n\t\t\tdo_div(seed, 2);\n\t\t} while (i++ < 10 && last_seed != seed);\n\n\t\tstd = seed;\n\t}\n\n\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t  \"last=%llu first=%llu max=%llu min=%llu avg=%u std=%d std^2=%lld\",\n\t\t  bm_last, bm_first, bm_max, bm_min, avg, std, stddev);\n\n\tbm_std = std;\n\tbm_avg = avg;\n\tbm_stddev = stddev;\n}",
    "includes": [
      "#include \"trace_benchmark.h\"",
      "#include <linux/trace_clock.h>",
      "#include <linux/kthread.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char bm_str[BENCHMARK_EVENT_STRLEN] = \"START\";",
      "static u64 bm_total;",
      "static u64 bm_totalsq;",
      "static u64 bm_last;",
      "static u64 bm_max;",
      "static u64 bm_min;",
      "static u64 bm_first;",
      "static u64 bm_cnt;",
      "static u64 bm_stddev;",
      "static unsigned int bm_avg;",
      "static unsigned int bm_std;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "bm_str",
            "BENCHMARK_EVENT_STRLEN",
            "\"last=%llu first=%llu max=%llu min=%llu avg=%u std=%d std^2=%lld\"",
            "bm_last",
            "bm_first",
            "bm_max",
            "bm_min",
            "avg",
            "std",
            "stddev"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "seed",
            "2"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "seed",
            "last_seed"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "delta",
            "bm_cnt"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stddev",
            "(u32)bm_cnt - 1"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "stddev",
            "(u32)bm_cnt"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "bm_str",
            "BENCHMARK_EVENT_STRLEN",
            "\"last=%llu first=%llu max=%llu min=%llu ** avg=%u std=%d std^2=%lld\"",
            "bm_last",
            "bm_first",
            "bm_max",
            "bm_min",
            "bm_avg",
            "bm_std",
            "bm_stddev"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "bm_str",
            "BENCHMARK_EVENT_STRLEN",
            "\"first=%llu [COLD CACHED]\"",
            "bm_first"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_clock_local",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clock_local",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_clock.c",
          "lines": "32-46",
          "snippet": "u64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/trace_clock.h>",
            "#include <linux/ktime.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_clock.h>\n#include <linux/ktime.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/hardirq.h>\n#include <linux/irqflags.h>\n#include <linux/spinlock.h>\n\nu64 notrace trace_clock_local(void)\n{\n\tu64 clock;\n\n\t/*\n\t * sched_clock() is an architecture implemented, fast, scalable,\n\t * lockless clock. It is not guaranteed to be coherent across\n\t * CPUs, nor across CPU idle events.\n\t */\n\tpreempt_disable_notrace();\n\tclock = sched_clock();\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_benchmark_event",
          "args": [
            "bm_str"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_is_on",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_is_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace.c",
          "lines": "1460-1463",
          "snippet": "int tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/workqueue.h>\n#include <linux/irq_work.h>\n#include <linux/fsnotify.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/panic_notifier.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\n\nint tracing_is_on(void)\n{\n\treturn tracer_tracing_is_on(&global_trace);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_benchmark_event_enabled",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_benchmark.h\"\n#include <linux/trace_clock.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\nstatic char bm_str[BENCHMARK_EVENT_STRLEN] = \"START\";\nstatic u64 bm_total;\nstatic u64 bm_totalsq;\nstatic u64 bm_last;\nstatic u64 bm_max;\nstatic u64 bm_min;\nstatic u64 bm_first;\nstatic u64 bm_cnt;\nstatic u64 bm_stddev;\nstatic unsigned int bm_avg;\nstatic unsigned int bm_std;\n\nstatic void trace_do_benchmark(void)\n{\n\tu64 start;\n\tu64 stop;\n\tu64 delta;\n\tu64 stddev;\n\tu64 seed;\n\tu64 last_seed;\n\tunsigned int avg;\n\tunsigned int std = 0;\n\n\t/* Only run if the tracepoint is actually active */\n\tif (!trace_benchmark_event_enabled() || !tracing_is_on())\n\t\treturn;\n\n\tlocal_irq_disable();\n\tstart = trace_clock_local();\n\ttrace_benchmark_event(bm_str);\n\tstop = trace_clock_local();\n\tlocal_irq_enable();\n\n\tbm_cnt++;\n\n\tdelta = stop - start;\n\n\t/*\n\t * The first read is cold cached, keep it separate from the\n\t * other calculations.\n\t */\n\tif (bm_cnt == 1) {\n\t\tbm_first = delta;\n\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t\t  \"first=%llu [COLD CACHED]\", bm_first);\n\t\treturn;\n\t}\n\n\tbm_last = delta;\n\n\tif (delta > bm_max)\n\t\tbm_max = delta;\n\tif (!bm_min || delta < bm_min)\n\t\tbm_min = delta;\n\n\t/*\n\t * When bm_cnt is greater than UINT_MAX, it breaks the statistics\n\t * accounting. Freeze the statistics when that happens.\n\t * We should have enough data for the avg and stddev anyway.\n\t */\n\tif (bm_cnt > UINT_MAX) {\n\t\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t    \"last=%llu first=%llu max=%llu min=%llu ** avg=%u std=%d std^2=%lld\",\n\t\t\t  bm_last, bm_first, bm_max, bm_min, bm_avg, bm_std, bm_stddev);\n\t\treturn;\n\t}\n\n\tbm_total += delta;\n\tbm_totalsq += delta * delta;\n\n\n\tif (bm_cnt > 1) {\n\t\t/*\n\t\t * Apply Welford's method to calculate standard deviation:\n\t\t * s^2 = 1 / (n * (n-1)) * (n * \\Sum (x_i)^2 - (\\Sum x_i)^2)\n\t\t */\n\t\tstddev = (u64)bm_cnt * bm_totalsq - bm_total * bm_total;\n\t\tdo_div(stddev, (u32)bm_cnt);\n\t\tdo_div(stddev, (u32)bm_cnt - 1);\n\t} else\n\t\tstddev = 0;\n\n\tdelta = bm_total;\n\tdo_div(delta, bm_cnt);\n\tavg = delta;\n\n\tif (stddev > 0) {\n\t\tint i = 0;\n\t\t/*\n\t\t * stddev is the square of standard deviation but\n\t\t * we want the actually number. Use the average\n\t\t * as our seed to find the std.\n\t\t *\n\t\t * The next try is:\n\t\t *  x = (x + N/x) / 2\n\t\t *\n\t\t * Where N is the squared number to find the square\n\t\t * root of.\n\t\t */\n\t\tseed = avg;\n\t\tdo {\n\t\t\tlast_seed = seed;\n\t\t\tseed = stddev;\n\t\t\tif (!last_seed)\n\t\t\t\tbreak;\n\t\t\tdo_div(seed, last_seed);\n\t\t\tseed += last_seed;\n\t\t\tdo_div(seed, 2);\n\t\t} while (i++ < 10 && last_seed != seed);\n\n\t\tstd = seed;\n\t}\n\n\tscnprintf(bm_str, BENCHMARK_EVENT_STRLEN,\n\t\t  \"last=%llu first=%llu max=%llu min=%llu avg=%u std=%d std^2=%lld\",\n\t\t  bm_last, bm_first, bm_max, bm_min, avg, std, stddev);\n\n\tbm_std = std;\n\tbm_avg = avg;\n\tbm_stddev = stddev;\n}"
  }
]