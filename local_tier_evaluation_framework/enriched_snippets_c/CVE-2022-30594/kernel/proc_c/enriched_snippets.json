[
  {
    "function_name": "show_interrupts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "460-537",
    "snippet": "int show_interrupts(struct seq_file *p, void *v)\n{\n\tstatic int prec;\n\n\tunsigned long flags, any_count = 0;\n\tint i = *(loff_t *) v, j;\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\n\tif (i > ACTUAL_NR_IRQS)\n\t\treturn 0;\n\n\tif (i == ACTUAL_NR_IRQS)\n\t\treturn arch_show_interrupts(p, prec);\n\n\t/* print header and calculate the width of the first column */\n\tif (i == 0) {\n\t\tfor (prec = 3, j = 1000; prec < 10 && j <= nr_irqs; ++prec)\n\t\t\tj *= 10;\n\n\t\tseq_printf(p, \"%*s\", prec + 8, \"\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"CPU%-8d\", j);\n\t\tseq_putc(p, '\\n');\n\t}\n\n\trcu_read_lock();\n\tdesc = irq_to_desc(i);\n\tif (!desc || irq_settings_is_hidden(desc))\n\t\tgoto outsparse;\n\n\tif (desc->kstat_irqs) {\n\t\tfor_each_online_cpu(j)\n\t\t\tany_count |= data_race(*per_cpu_ptr(desc->kstat_irqs, j));\n\t}\n\n\tif ((!desc->action || irq_desc_is_chained(desc)) && !any_count)\n\t\tgoto outsparse;\n\n\tseq_printf(p, \"%*d: \", prec, i);\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", desc->kstat_irqs ?\n\t\t\t\t\t*per_cpu_ptr(desc->kstat_irqs, j) : 0);\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (desc->irq_data.chip) {\n\t\tif (desc->irq_data.chip->irq_print_chip)\n\t\t\tdesc->irq_data.chip->irq_print_chip(&desc->irq_data, p);\n\t\telse if (desc->irq_data.chip->name)\n\t\t\tseq_printf(p, \" %8s\", desc->irq_data.chip->name);\n\t\telse\n\t\t\tseq_printf(p, \" %8s\", \"-\");\n\t} else {\n\t\tseq_printf(p, \" %8s\", \"None\");\n\t}\n\tif (desc->irq_data.domain)\n\t\tseq_printf(p, \" %*lu\", prec, desc->irq_data.hwirq);\n\telse\n\t\tseq_printf(p, \" %*s\", prec, \"\");\n#ifdef CONFIG_GENERIC_IRQ_SHOW_LEVEL\n\tseq_printf(p, \" %-8s\", irqd_is_level_type(&desc->irq_data) ? \"Level\" : \"Edge\");\n#endif\n\tif (desc->name)\n\t\tseq_printf(p, \"-%-8s\", desc->name);\n\n\taction = desc->action;\n\tif (action) {\n\t\tseq_printf(p, \"  %s\", action->name);\n\t\twhile ((action = action->next) != NULL)\n\t\t\tseq_printf(p, \", %s\", action->name);\n\t}\n\n\tseq_putc(p, '\\n');\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\noutsparse:\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "p",
            "'\\n'"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "233-246",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "p",
            "\", %s\"",
            "action->name"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_level_type",
          "args": [
            "&desc->irq_data"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_print_chip",
          "args": [
            "&desc->irq_data",
            "p"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "desc->kstat_irqs",
            "j"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_desc_is_chained",
          "args": [
            "desc"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "irq_desc_is_chained",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "267-270",
          "snippet": "static inline int irq_desc_is_chained(struct irq_desc *desc)\n{\n\treturn (desc->action && desc->action == &chained_action);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct irqaction chained_action;",
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "void __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern struct irqaction chained_action;\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nvoid __irq_wake_thread(struct irq_desc *desc, struct irqaction *action);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline int irq_desc_is_chained(struct irq_desc *desc)\n{\n\treturn (desc->action && desc->action == &chained_action);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_hidden",
          "args": [
            "desc"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_hidden",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "175-178",
          "snippet": "static inline bool irq_settings_is_hidden(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_HIDDEN;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_hidden(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_HIDDEN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "i"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_show_interrupts",
          "args": [
            "p",
            "prec"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "arch_show_interrupts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "451-454",
          "snippet": "int __weak arch_show_interrupts(struct seq_file *p, int prec)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nint __weak arch_show_interrupts(struct seq_file *p, int prec)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nint show_interrupts(struct seq_file *p, void *v)\n{\n\tstatic int prec;\n\n\tunsigned long flags, any_count = 0;\n\tint i = *(loff_t *) v, j;\n\tstruct irqaction *action;\n\tstruct irq_desc *desc;\n\n\tif (i > ACTUAL_NR_IRQS)\n\t\treturn 0;\n\n\tif (i == ACTUAL_NR_IRQS)\n\t\treturn arch_show_interrupts(p, prec);\n\n\t/* print header and calculate the width of the first column */\n\tif (i == 0) {\n\t\tfor (prec = 3, j = 1000; prec < 10 && j <= nr_irqs; ++prec)\n\t\t\tj *= 10;\n\n\t\tseq_printf(p, \"%*s\", prec + 8, \"\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"CPU%-8d\", j);\n\t\tseq_putc(p, '\\n');\n\t}\n\n\trcu_read_lock();\n\tdesc = irq_to_desc(i);\n\tif (!desc || irq_settings_is_hidden(desc))\n\t\tgoto outsparse;\n\n\tif (desc->kstat_irqs) {\n\t\tfor_each_online_cpu(j)\n\t\t\tany_count |= data_race(*per_cpu_ptr(desc->kstat_irqs, j));\n\t}\n\n\tif ((!desc->action || irq_desc_is_chained(desc)) && !any_count)\n\t\tgoto outsparse;\n\n\tseq_printf(p, \"%*d: \", prec, i);\n\tfor_each_online_cpu(j)\n\t\tseq_printf(p, \"%10u \", desc->kstat_irqs ?\n\t\t\t\t\t*per_cpu_ptr(desc->kstat_irqs, j) : 0);\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (desc->irq_data.chip) {\n\t\tif (desc->irq_data.chip->irq_print_chip)\n\t\t\tdesc->irq_data.chip->irq_print_chip(&desc->irq_data, p);\n\t\telse if (desc->irq_data.chip->name)\n\t\t\tseq_printf(p, \" %8s\", desc->irq_data.chip->name);\n\t\telse\n\t\t\tseq_printf(p, \" %8s\", \"-\");\n\t} else {\n\t\tseq_printf(p, \" %8s\", \"None\");\n\t}\n\tif (desc->irq_data.domain)\n\t\tseq_printf(p, \" %*lu\", prec, desc->irq_data.hwirq);\n\telse\n\t\tseq_printf(p, \" %*s\", prec, \"\");\n#ifdef CONFIG_GENERIC_IRQ_SHOW_LEVEL\n\tseq_printf(p, \" %-8s\", irqd_is_level_type(&desc->irq_data) ? \"Level\" : \"Edge\");\n#endif\n\tif (desc->name)\n\t\tseq_printf(p, \"-%-8s\", desc->name);\n\n\taction = desc->action;\n\tif (action) {\n\t\tseq_printf(p, \"  %s\", action->name);\n\t\twhile ((action = action->next) != NULL)\n\t\t\tseq_printf(p, \", %s\", action->name);\n\t}\n\n\tseq_putc(p, '\\n');\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\noutsparse:\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_show_interrupts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "451-454",
    "snippet": "int __weak arch_show_interrupts(struct seq_file *p, int prec)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nint __weak arch_show_interrupts(struct seq_file *p, int prec)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "init_irq_proc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "430-447",
    "snippet": "void init_irq_proc(void)\n{\n\tunsigned int irq;\n\tstruct irq_desc *desc;\n\n\t/* create /proc/irq */\n\troot_irq_dir = proc_mkdir(\"irq\", NULL);\n\tif (!root_irq_dir)\n\t\treturn;\n\n\tregister_default_affinity_proc();\n\n\t/*\n\t * Create entries for all existing IRQs.\n\t */\n\tfor_each_irq_desc(irq, desc)\n\t\tregister_irq_proc(irq, desc);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *root_irq_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_irq_proc",
          "args": [
            "irq",
            "desc"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_irq_proc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "393-413",
          "snippet": "void unregister_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || !desc->dir)\n\t\treturn;\n#ifdef CONFIG_SMP\n\tremove_proc_entry(\"smp_affinity\", desc->dir);\n\tremove_proc_entry(\"affinity_hint\", desc->dir);\n\tremove_proc_entry(\"smp_affinity_list\", desc->dir);\n\tremove_proc_entry(\"node\", desc->dir);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tremove_proc_entry(\"effective_affinity\", desc->dir);\n\tremove_proc_entry(\"effective_affinity_list\", desc->dir);\n# endif\n#endif\n\tremove_proc_entry(\"spurious\", desc->dir);\n\n\tsprintf(name, \"%u\", irq);\n\tremove_proc_entry(name, root_irq_dir);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [
            "#define MAX_NAMELEN 10",
            "#define MAX_NAMELEN 128"
          ],
          "globals_used": [
            "static struct proc_dir_entry *root_irq_dir;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\n#define MAX_NAMELEN 10\n#define MAX_NAMELEN 128\n\nstatic struct proc_dir_entry *root_irq_dir;\n\nvoid unregister_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || !desc->dir)\n\t\treturn;\n#ifdef CONFIG_SMP\n\tremove_proc_entry(\"smp_affinity\", desc->dir);\n\tremove_proc_entry(\"affinity_hint\", desc->dir);\n\tremove_proc_entry(\"smp_affinity_list\", desc->dir);\n\tremove_proc_entry(\"node\", desc->dir);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tremove_proc_entry(\"effective_affinity\", desc->dir);\n\tremove_proc_entry(\"effective_affinity_list\", desc->dir);\n# endif\n#endif\n\tremove_proc_entry(\"spurious\", desc->dir);\n\n\tsprintf(name, \"%u\", irq);\n\tremove_proc_entry(name, root_irq_dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "irq",
            "desc"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_default_affinity_proc",
          "args": [],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "register_default_affinity_proc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "422-428",
          "snippet": "static void register_default_affinity_proc(void)\n{\n#ifdef CONFIG_SMP\n\tproc_create(\"irq/default_smp_affinity\", 0644, NULL,\n\t\t    &default_affinity_proc_ops);\n#endif\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic void register_default_affinity_proc(void)\n{\n#ifdef CONFIG_SMP\n\tproc_create(\"irq/default_smp_affinity\", 0644, NULL,\n\t\t    &default_affinity_proc_ops);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "\"irq\"",
            "NULL"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic struct proc_dir_entry *root_irq_dir;\n\nvoid init_irq_proc(void)\n{\n\tunsigned int irq;\n\tstruct irq_desc *desc;\n\n\t/* create /proc/irq */\n\troot_irq_dir = proc_mkdir(\"irq\", NULL);\n\tif (!root_irq_dir)\n\t\treturn;\n\n\tregister_default_affinity_proc();\n\n\t/*\n\t * Create entries for all existing IRQs.\n\t */\n\tfor_each_irq_desc(irq, desc)\n\t\tregister_irq_proc(irq, desc);\n}"
  },
  {
    "function_name": "register_default_affinity_proc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "422-428",
    "snippet": "static void register_default_affinity_proc(void)\n{\n#ifdef CONFIG_SMP\n\tproc_create(\"irq/default_smp_affinity\", 0644, NULL,\n\t\t    &default_affinity_proc_ops);\n#endif\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"irq/default_smp_affinity\"",
            "0644",
            "NULL",
            "&default_affinity_proc_ops"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic void register_default_affinity_proc(void)\n{\n#ifdef CONFIG_SMP\n\tproc_create(\"irq/default_smp_affinity\", 0644, NULL,\n\t\t    &default_affinity_proc_ops);\n#endif\n}"
  },
  {
    "function_name": "unregister_handler_proc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "417-420",
    "snippet": "void unregister_handler_proc(unsigned int irq, struct irqaction *action)\n{\n\tproc_remove(action->dir);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_remove",
          "args": [
            "action->dir"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nvoid unregister_handler_proc(unsigned int irq, struct irqaction *action)\n{\n\tproc_remove(action->dir);\n}"
  },
  {
    "function_name": "unregister_irq_proc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "393-413",
    "snippet": "void unregister_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || !desc->dir)\n\t\treturn;\n#ifdef CONFIG_SMP\n\tremove_proc_entry(\"smp_affinity\", desc->dir);\n\tremove_proc_entry(\"affinity_hint\", desc->dir);\n\tremove_proc_entry(\"smp_affinity_list\", desc->dir);\n\tremove_proc_entry(\"node\", desc->dir);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tremove_proc_entry(\"effective_affinity\", desc->dir);\n\tremove_proc_entry(\"effective_affinity_list\", desc->dir);\n# endif\n#endif\n\tremove_proc_entry(\"spurious\", desc->dir);\n\n\tsprintf(name, \"%u\", irq);\n\tremove_proc_entry(name, root_irq_dir);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [
      "#define MAX_NAMELEN 10",
      "#define MAX_NAMELEN 128"
    ],
    "globals_used": [
      "static struct proc_dir_entry *root_irq_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "name",
            "root_irq_dir"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"%u\"",
            "irq"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"spurious\"",
            "desc->dir"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"effective_affinity_list\"",
            "desc->dir"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"effective_affinity\"",
            "desc->dir"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"node\"",
            "desc->dir"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"smp_affinity_list\"",
            "desc->dir"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"affinity_hint\"",
            "desc->dir"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "\"smp_affinity\"",
            "desc->dir"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\n#define MAX_NAMELEN 10\n#define MAX_NAMELEN 128\n\nstatic struct proc_dir_entry *root_irq_dir;\n\nvoid unregister_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || !desc->dir)\n\t\treturn;\n#ifdef CONFIG_SMP\n\tremove_proc_entry(\"smp_affinity\", desc->dir);\n\tremove_proc_entry(\"affinity_hint\", desc->dir);\n\tremove_proc_entry(\"smp_affinity_list\", desc->dir);\n\tremove_proc_entry(\"node\", desc->dir);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tremove_proc_entry(\"effective_affinity\", desc->dir);\n\tremove_proc_entry(\"effective_affinity_list\", desc->dir);\n# endif\n#endif\n\tremove_proc_entry(\"spurious\", desc->dir);\n\n\tsprintf(name, \"%u\", irq);\n\tremove_proc_entry(name, root_irq_dir);\n}"
  },
  {
    "function_name": "register_irq_proc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "338-391",
    "snippet": "void register_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tstatic DEFINE_MUTEX(register_lock);\n\tvoid __maybe_unused *irqp = (void *)(unsigned long) irq;\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))\n\t\treturn;\n\n\t/*\n\t * irq directories are registered only when a handler is\n\t * added, not when the descriptor is created, so multiple\n\t * tasks might try to register at the same time.\n\t */\n\tmutex_lock(&register_lock);\n\n\tif (desc->dir)\n\t\tgoto out_unlock;\n\n\tsprintf(name, \"%d\", irq);\n\n\t/* create /proc/irq/1234 */\n\tdesc->dir = proc_mkdir(name, root_irq_dir);\n\tif (!desc->dir)\n\t\tgoto out_unlock;\n\n#ifdef CONFIG_SMP\n\t/* create /proc/irq/<irq>/smp_affinity */\n\tproc_create_data(\"smp_affinity\", 0644, desc->dir,\n\t\t\t &irq_affinity_proc_ops, irqp);\n\n\t/* create /proc/irq/<irq>/affinity_hint */\n\tproc_create_single_data(\"affinity_hint\", 0444, desc->dir,\n\t\t\tirq_affinity_hint_proc_show, irqp);\n\n\t/* create /proc/irq/<irq>/smp_affinity_list */\n\tproc_create_data(\"smp_affinity_list\", 0644, desc->dir,\n\t\t\t &irq_affinity_list_proc_ops, irqp);\n\n\tproc_create_single_data(\"node\", 0444, desc->dir, irq_node_proc_show,\n\t\t\tirqp);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tproc_create_single_data(\"effective_affinity\", 0444, desc->dir,\n\t\t\tirq_effective_aff_proc_show, irqp);\n\tproc_create_single_data(\"effective_affinity_list\", 0444, desc->dir,\n\t\t\tirq_effective_aff_list_proc_show, irqp);\n# endif\n#endif\n\tproc_create_single_data(\"spurious\", 0444, desc->dir,\n\t\t\tirq_spurious_proc_show, (void *)(long)irq);\n\nout_unlock:\n\tmutex_unlock(&register_lock);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [
      "#define MAX_NAMELEN 10",
      "#define MAX_NAMELEN 128"
    ],
    "globals_used": [
      "static struct proc_dir_entry *root_irq_dir;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&register_lock"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_create_single_data",
          "args": [
            "\"spurious\"",
            "0444",
            "desc->dir",
            "irq_spurious_proc_show",
            "(void *)(long)irq"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single_data",
          "args": [
            "\"effective_affinity_list\"",
            "0444",
            "desc->dir",
            "irq_effective_aff_list_proc_show",
            "irqp"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single_data",
          "args": [
            "\"effective_affinity\"",
            "0444",
            "desc->dir",
            "irq_effective_aff_proc_show",
            "irqp"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single_data",
          "args": [
            "\"node\"",
            "0444",
            "desc->dir",
            "irq_node_proc_show",
            "irqp"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "\"smp_affinity_list\"",
            "0644",
            "desc->dir",
            "&irq_affinity_list_proc_ops",
            "irqp"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_single_data",
          "args": [
            "\"affinity_hint\"",
            "0444",
            "desc->dir",
            "irq_affinity_hint_proc_show",
            "irqp"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "\"smp_affinity\"",
            "0644",
            "desc->dir",
            "&irq_affinity_proc_ops",
            "irqp"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "name",
            "root_irq_dir"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"%d\"",
            "irq"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&register_lock"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\n#define MAX_NAMELEN 10\n#define MAX_NAMELEN 128\n\nstatic struct proc_dir_entry *root_irq_dir;\n\nvoid register_irq_proc(unsigned int irq, struct irq_desc *desc)\n{\n\tstatic DEFINE_MUTEX(register_lock);\n\tvoid __maybe_unused *irqp = (void *)(unsigned long) irq;\n\tchar name [MAX_NAMELEN];\n\n\tif (!root_irq_dir || (desc->irq_data.chip == &no_irq_chip))\n\t\treturn;\n\n\t/*\n\t * irq directories are registered only when a handler is\n\t * added, not when the descriptor is created, so multiple\n\t * tasks might try to register at the same time.\n\t */\n\tmutex_lock(&register_lock);\n\n\tif (desc->dir)\n\t\tgoto out_unlock;\n\n\tsprintf(name, \"%d\", irq);\n\n\t/* create /proc/irq/1234 */\n\tdesc->dir = proc_mkdir(name, root_irq_dir);\n\tif (!desc->dir)\n\t\tgoto out_unlock;\n\n#ifdef CONFIG_SMP\n\t/* create /proc/irq/<irq>/smp_affinity */\n\tproc_create_data(\"smp_affinity\", 0644, desc->dir,\n\t\t\t &irq_affinity_proc_ops, irqp);\n\n\t/* create /proc/irq/<irq>/affinity_hint */\n\tproc_create_single_data(\"affinity_hint\", 0444, desc->dir,\n\t\t\tirq_affinity_hint_proc_show, irqp);\n\n\t/* create /proc/irq/<irq>/smp_affinity_list */\n\tproc_create_data(\"smp_affinity_list\", 0644, desc->dir,\n\t\t\t &irq_affinity_list_proc_ops, irqp);\n\n\tproc_create_single_data(\"node\", 0444, desc->dir, irq_node_proc_show,\n\t\t\tirqp);\n# ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\tproc_create_single_data(\"effective_affinity\", 0444, desc->dir,\n\t\t\tirq_effective_aff_proc_show, irqp);\n\tproc_create_single_data(\"effective_affinity_list\", 0444, desc->dir,\n\t\t\tirq_effective_aff_list_proc_show, irqp);\n# endif\n#endif\n\tproc_create_single_data(\"spurious\", 0444, desc->dir,\n\t\t\tirq_spurious_proc_show, (void *)(long)irq);\n\nout_unlock:\n\tmutex_unlock(&register_lock);\n}"
  },
  {
    "function_name": "register_handler_proc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "319-332",
    "snippet": "void register_handler_proc(unsigned int irq, struct irqaction *action)\n{\n\tchar name [MAX_NAMELEN];\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (!desc->dir || action->dir || !action->name ||\n\t\t\t\t\t!name_unique(irq, action))\n\t\treturn;\n\n\tsnprintf(name, MAX_NAMELEN, \"%s\", action->name);\n\n\t/* create /proc/irq/1234/handler/ */\n\taction->dir = proc_mkdir(name, desc->dir);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [
      "#define MAX_NAMELEN 10",
      "#define MAX_NAMELEN 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "name",
            "desc->dir"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "MAX_NAMELEN",
            "\"%s\"",
            "action->name"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_unique",
          "args": [
            "irq",
            "action"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "name_unique",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "300-317",
          "snippet": "static int name_unique(unsigned int irq, struct irqaction *new_action)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\tint ret = 1;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif ((action != new_action) && action->name &&\n\t\t\t\t!strcmp(new_action->name, action->name)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int name_unique(unsigned int irq, struct irqaction *new_action)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\tint ret = 1;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif ((action != new_action) && action->name &&\n\t\t\t\t!strcmp(new_action->name, action->name)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\n#define MAX_NAMELEN 10\n#define MAX_NAMELEN 128\n\nvoid register_handler_proc(unsigned int irq, struct irqaction *action)\n{\n\tchar name [MAX_NAMELEN];\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (!desc->dir || action->dir || !action->name ||\n\t\t\t\t\t!name_unique(irq, action))\n\t\treturn;\n\n\tsnprintf(name, MAX_NAMELEN, \"%s\", action->name);\n\n\t/* create /proc/irq/1234/handler/ */\n\taction->dir = proc_mkdir(name, desc->dir);\n}"
  },
  {
    "function_name": "name_unique",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "300-317",
    "snippet": "static int name_unique(unsigned int irq, struct irqaction *new_action)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\tint ret = 1;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif ((action != new_action) && action->name &&\n\t\t\t\t!strcmp(new_action->name, action->name)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "new_action->name",
            "action->name"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_action_of_desc",
          "args": [
            "desc",
            "action"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int name_unique(unsigned int irq, struct irqaction *new_action)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\tint ret = 1;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tif ((action != new_action) && action->name &&\n\t\t\t\t!strcmp(new_action->name, action->name)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_spurious_proc_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "288-296",
    "snippet": "static int irq_spurious_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long) m->private);\n\n\tseq_printf(m, \"count %u\\n\" \"unhandled %u\\n\" \"last_unhandled %u ms\\n\",\n\t\t   desc->irq_count, desc->irqs_unhandled,\n\t\t   jiffies_to_msecs(desc->last_unhandled));\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"count %u\\n\" \"unhandled %u\\n\" \"last_unhandled %u ms\\n\"",
            "desc->irq_count",
            "desc->irqs_unhandled",
            "jiffies_to_msecs(desc->last_unhandled)"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "desc->last_unhandled"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "jiffies_to_msecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "374-388",
          "snippet": "unsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "(long) m->private"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_spurious_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long) m->private);\n\n\tseq_printf(m, \"count %u\\n\" \"unhandled %u\\n\" \"last_unhandled %u ms\\n\",\n\t\t   desc->irq_count, desc->irqs_unhandled,\n\t\t   jiffies_to_msecs(desc->last_unhandled));\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_node_proc_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "279-285",
    "snippet": "static int irq_node_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long) m->private);\n\n\tseq_printf(m, \"%d\\n\", irq_desc_get_node(desc));\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%d\\n\"",
            "irq_desc_get_node(desc)"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_node",
          "args": [
            "desc"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "irq_desc_get_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "262-265",
          "snippet": "static inline int irq_desc_get_node(struct irq_desc *desc)\n{\n\treturn irq_common_data_get_node(&desc->irq_common_data);\n}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline int irq_desc_get_node(struct irq_desc *desc)\n{\n\treturn irq_common_data_get_node(&desc->irq_common_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "(long) m->private"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_node_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long) m->private);\n\n\tseq_printf(m, \"%d\\n\", irq_desc_get_node(desc));\n\treturn 0;\n}"
  },
  {
    "function_name": "default_affinity_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "266-269",
    "snippet": "static int default_affinity_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, default_affinity_show, pde_data(inode));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "default_affinity_show",
            "pde_data(inode)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pde_data",
          "args": [
            "inode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int default_affinity_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, default_affinity_show, pde_data(inode));\n}"
  },
  {
    "function_name": "default_affinity_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "235-264",
    "snippet": "static ssize_t default_affinity_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *ppos)\n{\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcpumask_copy(irq_default_affinity, new_value);\n\terr = count;\n\nout:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "new_value"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "irq_default_affinity",
            "new_value"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "new_value",
            "cpu_online_mask"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_parse_user",
          "args": [
            "buffer",
            "count",
            "new_value"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&new_value",
            "GFP_KERNEL"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t default_affinity_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *ppos)\n{\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto out;\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcpumask_copy(irq_default_affinity, new_value);\n\terr = count;\n\nout:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}"
  },
  {
    "function_name": "default_affinity_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "229-233",
    "snippet": "static int default_affinity_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(irq_default_affinity));\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*pb\\n\"",
            "cpumask_pr_args(irq_default_affinity)"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "irq_default_affinity"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int default_affinity_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(irq_default_affinity));\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_effective_aff_list_proc_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "223-226",
    "snippet": "static int irq_effective_aff_list_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(EFFECTIVE_LIST, m);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_irq_affinity",
          "args": [
            "EFFECTIVE_LIST",
            "m"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "show_irq_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "46-81",
          "snippet": "static int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_effective_aff_list_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(EFFECTIVE_LIST, m);\n}"
  },
  {
    "function_name": "irq_effective_aff_proc_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "218-221",
    "snippet": "static int irq_effective_aff_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(EFFECTIVE, m);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_irq_affinity",
          "args": [
            "EFFECTIVE",
            "m"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "show_irq_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "46-81",
          "snippet": "static int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_effective_aff_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(EFFECTIVE, m);\n}"
  },
  {
    "function_name": "irq_affinity_list_proc_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "196-199",
    "snippet": "static int irq_affinity_list_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_affinity_list_proc_show, pde_data(inode));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "irq_affinity_list_proc_show",
            "pde_data(inode)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pde_data",
          "args": [
            "inode"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_affinity_list_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_affinity_list_proc_show, pde_data(inode));\n}"
  },
  {
    "function_name": "irq_affinity_proc_open",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "191-194",
    "snippet": "static int irq_affinity_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_affinity_proc_show, pde_data(inode));\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "irq_affinity_proc_show",
            "pde_data(inode)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pde_data",
          "args": [
            "inode"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_affinity_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, irq_affinity_proc_show, pde_data(inode));\n}"
  },
  {
    "function_name": "irq_affinity_list_proc_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "185-189",
    "snippet": "static ssize_t irq_affinity_list_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\treturn write_irq_affinity(1, file, buffer, count, pos);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_irq_affinity",
          "args": [
            "1",
            "file",
            "buffer",
            "count",
            "pos"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "write_irq_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "137-177",
          "snippet": "static ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)pde_data(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)pde_data(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t irq_affinity_list_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\treturn write_irq_affinity(1, file, buffer, count, pos);\n}"
  },
  {
    "function_name": "irq_affinity_proc_write",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "179-183",
    "snippet": "static ssize_t irq_affinity_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\treturn write_irq_affinity(0, file, buffer, count, pos);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_irq_affinity",
          "args": [
            "0",
            "file",
            "buffer",
            "count",
            "pos"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "write_irq_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "137-177",
          "snippet": "static ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)pde_data(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)pde_data(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t irq_affinity_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\treturn write_irq_affinity(0, file, buffer, count, pos);\n}"
  },
  {
    "function_name": "write_irq_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "137-177",
    "snippet": "static ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)pde_data(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "new_value"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_affinity",
          "args": [
            "irq",
            "new_value"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_affinity_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "541-575",
          "snippet": "int\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc || desc->istate & IRQS_NMI)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify) {\n\t\tif (cancel_work_sync(&old_notify->work)) {\n\t\t\t/* Pending work had a ref, put that one too */\n\t\t\tkref_put(&old_notify->kref, old_notify->release);\n\t\t}\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nint\nirq_set_affinity_notifier(unsigned int irq, struct irq_affinity_notify *notify)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tstruct irq_affinity_notify *old_notify;\n\tunsigned long flags;\n\n\t/* The release function is promised process context */\n\tmight_sleep();\n\n\tif (!desc || desc->istate & IRQS_NMI)\n\t\treturn -EINVAL;\n\n\t/* Complete initialisation of *notify */\n\tif (notify) {\n\t\tnotify->irq = irq;\n\t\tkref_init(&notify->kref);\n\t\tINIT_WORK(&notify->work, irq_affinity_notify);\n\t}\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\told_notify = desc->affinity_notify;\n\tdesc->affinity_notify = notify;\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tif (old_notify) {\n\t\tif (cancel_work_sync(&old_notify->work)) {\n\t\t\t/* Pending work had a ref, put that one too */\n\t\t\tkref_put(&old_notify->kref, old_notify->release);\n\t\t}\n\t\tkref_put(&old_notify->kref, old_notify->release);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_select_affinity_usr",
          "args": [
            "irq"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "irq_select_affinity_usr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "131-134",
          "snippet": "static inline int irq_select_affinity_usr(unsigned int irq)\n{\n\treturn irq_select_affinity(irq);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic inline int irq_select_affinity_usr(unsigned int irq)\n{\n\treturn irq_select_affinity(irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "new_value",
            "cpu_online_mask"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_parse_user",
          "args": [
            "buffer",
            "count",
            "new_value"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_parselist_user",
          "args": [
            "buffer",
            "count",
            "new_value"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&new_value",
            "GFP_KERNEL"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_can_set_affinity_usr",
          "args": [
            "irq"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "irq_can_set_affinity_usr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/manage.c",
          "lines": "171-177",
          "snippet": "bool irq_can_set_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn __irq_can_set_affinity(desc) &&\n\t\t!irqd_affinity_is_managed(&desc->irq_data);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/irqdomain.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nbool irq_can_set_affinity_usr(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn __irq_can_set_affinity(desc) &&\n\t\t!irqd_affinity_is_managed(&desc->irq_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pde_data",
          "args": [
            "file_inode(file)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic ssize_t write_irq_affinity(int type, struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tunsigned int irq = (int)(long)pde_data(file_inode(file));\n\tcpumask_var_t new_value;\n\tint err;\n\n\tif (!irq_can_set_affinity_usr(irq) || no_irq_affinity)\n\t\treturn -EIO;\n\n\tif (!zalloc_cpumask_var(&new_value, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tif (type)\n\t\terr = cpumask_parselist_user(buffer, count, new_value);\n\telse\n\t\terr = cpumask_parse_user(buffer, count, new_value);\n\tif (err)\n\t\tgoto free_cpumask;\n\n\t/*\n\t * Do not allow disabling IRQs completely - it's a too easy\n\t * way to make the system unusable accidentally :-) At least\n\t * one online CPU still has to be targeted.\n\t */\n\tif (!cpumask_intersects(new_value, cpu_online_mask)) {\n\t\t/*\n\t\t * Special case for empty set - allow the architecture code\n\t\t * to set default SMP affinity.\n\t\t */\n\t\terr = irq_select_affinity_usr(irq) ? -EINVAL : count;\n\t} else {\n\t\terr = irq_set_affinity(irq, new_value);\n\t\tif (!err)\n\t\t\terr = count;\n\t}\n\nfree_cpumask:\n\tfree_cpumask_var(new_value);\n\treturn err;\n}"
  },
  {
    "function_name": "irq_select_affinity_usr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "131-134",
    "snippet": "static inline int irq_select_affinity_usr(unsigned int irq)\n{\n\treturn irq_select_affinity(irq);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_select_affinity",
          "args": [
            "irq"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "irq_select_affinity_usr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "131-134",
          "snippet": "static inline int irq_select_affinity_usr(unsigned int irq)\n{\n\treturn irq_select_affinity(irq);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic inline int irq_select_affinity_usr(unsigned int irq)\n{\n\treturn irq_select_affinity(irq);\n}"
  },
  {
    "function_name": "irq_select_affinity_usr",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "115-128",
    "snippet": "static inline int irq_select_affinity_usr(unsigned int irq)\n{\n\t/*\n\t * If the interrupt is started up already then this fails. The\n\t * interrupt is assigned to an online CPU already. There is no\n\t * point to move it around randomly. Tell user space that the\n\t * selected mask is bogus.\n\t *\n\t * If not then any change to the affinity is pointless because the\n\t * startup code invokes irq_setup_affinity() which will select\n\t * a online CPU anyway.\n\t */\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic inline int irq_select_affinity_usr(unsigned int irq)\n{\n\t/*\n\t * If the interrupt is started up already then this fails. The\n\t * interrupt is assigned to an online CPU already. There is no\n\t * point to move it around randomly. Tell user space that the\n\t * selected mask is bogus.\n\t *\n\t * If not then any change to the affinity is pointless because the\n\t * startup code invokes irq_setup_affinity() which will select\n\t * a online CPU anyway.\n\t */\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "irq_affinity_list_proc_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "109-112",
    "snippet": "static int irq_affinity_list_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(AFFINITY_LIST, m);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_irq_affinity",
          "args": [
            "AFFINITY_LIST",
            "m"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "show_irq_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "46-81",
          "snippet": "static int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_affinity_list_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(AFFINITY_LIST, m);\n}"
  },
  {
    "function_name": "irq_affinity_proc_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "104-107",
    "snippet": "static int irq_affinity_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(AFFINITY, m);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_irq_affinity",
          "args": [
            "AFFINITY",
            "m"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "show_irq_affinity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
          "lines": "46-81",
          "snippet": "static int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/mutex.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_affinity_proc_show(struct seq_file *m, void *v)\n{\n\treturn show_irq_affinity(AFFINITY, m);\n}"
  },
  {
    "function_name": "irq_affinity_hint_proc_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "83-101",
    "snippet": "static int irq_affinity_hint_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tunsigned long flags;\n\tcpumask_var_t mask;\n\n\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (desc->affinity_hint)\n\t\tcpumask_copy(mask, desc->affinity_hint);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\tfree_cpumask_var(mask);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "mask"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*pb\\n\"",
            "cpumask_pr_args(mask)"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "mask"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "mask",
            "desc->affinity_hint"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zalloc_cpumask_var",
          "args": [
            "&mask",
            "GFP_KERNEL"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "(long)m->private"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int irq_affinity_hint_proc_show(struct seq_file *m, void *v)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tunsigned long flags;\n\tcpumask_var_t mask;\n\n\tif (!zalloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tif (desc->affinity_hint)\n\t\tcpumask_copy(mask, desc->affinity_hint);\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\n\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\tfree_cpumask_var(mask);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "show_irq_affinity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/proc.c",
    "lines": "46-81",
    "snippet": "static int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/gfp.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*pb\\n\"",
            "cpumask_pr_args(mask)"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "mask"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "mask"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_effective_affinity_mask",
          "args": [
            "&desc->irq_data"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_is_setaffinity_pending",
          "args": [
            "&desc->irq_data"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "(long)m->private"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/irqdesc.c",
          "lines": "583-586",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/mutex.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/gfp.h>\n#include <linux/irq.h>\n\nstatic int show_irq_affinity(int type, struct seq_file *m)\n{\n\tstruct irq_desc *desc = irq_to_desc((long)m->private);\n\tconst struct cpumask *mask;\n\n\tswitch (type) {\n\tcase AFFINITY:\n\tcase AFFINITY_LIST:\n\t\tmask = desc->irq_common_data.affinity;\n#ifdef CONFIG_GENERIC_PENDING_IRQ\n\t\tif (irqd_is_setaffinity_pending(&desc->irq_data))\n\t\t\tmask = desc->pending_mask;\n#endif\n\t\tbreak;\n\tcase EFFECTIVE:\n\tcase EFFECTIVE_LIST:\n#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK\n\t\tmask = irq_data_get_effective_affinity_mask(&desc->irq_data);\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase AFFINITY_LIST:\n\tcase EFFECTIVE_LIST:\n\t\tseq_printf(m, \"%*pbl\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\tcase AFFINITY:\n\tcase EFFECTIVE:\n\t\tseq_printf(m, \"%*pb\\n\", cpumask_pr_args(mask));\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  }
]