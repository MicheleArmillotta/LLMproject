[
  {
    "function_name": "irq_matrix_debug_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "490-512",
    "snippet": "void irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind)\n{\n\tunsigned int nsys = bitmap_weight(m->system_map, m->matrix_bits);\n\tint cpu;\n\n\tseq_printf(sf, \"Online bitmaps:   %6u\\n\", m->online_maps);\n\tseq_printf(sf, \"Global available: %6u\\n\", m->global_available);\n\tseq_printf(sf, \"Global reserved:  %6u\\n\", m->global_reserved);\n\tseq_printf(sf, \"Total allocated:  %6u\\n\", m->total_allocated);\n\tseq_printf(sf, \"System: %u: %*pbl\\n\", nsys, m->matrix_bits,\n\t\t   m->system_map);\n\tseq_printf(sf, \"%*s| CPU | avl | man | mac | act | vectors\\n\", ind, \" \");\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\n\t\tseq_printf(sf, \"%*s %4d  %4u  %4u  %4u %4u  %*pbl\\n\", ind, \" \",\n\t\t\t   cpu, cm->available, cm->managed,\n\t\t\t   cm->managed_allocated, cm->allocated,\n\t\t\t   m->matrix_bits, cm->alloc_map);\n\t}\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "319-322",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "sf",
            "\"%*s %4d  %4u  %4u  %4u %4u  %*pbl\\n\"",
            "ind",
            "\" \"",
            "cpu",
            "cm->available",
            "cm->managed",
            "cm->managed_allocated",
            "cm->allocated",
            "m->matrix_bits",
            "cm->alloc_map"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "81-100",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "m->maps",
            "cpu"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cpu.c",
          "lines": "307-310",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/scs.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sched/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/cpuset.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/scs.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/task.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/mm.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "m->system_map",
            "m->matrix_bits"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nvoid irq_matrix_debug_show(struct seq_file *sf, struct irq_matrix *m, int ind)\n{\n\tunsigned int nsys = bitmap_weight(m->system_map, m->matrix_bits);\n\tint cpu;\n\n\tseq_printf(sf, \"Online bitmaps:   %6u\\n\", m->online_maps);\n\tseq_printf(sf, \"Global available: %6u\\n\", m->global_available);\n\tseq_printf(sf, \"Global reserved:  %6u\\n\", m->global_reserved);\n\tseq_printf(sf, \"Total allocated:  %6u\\n\", m->total_allocated);\n\tseq_printf(sf, \"System: %u: %*pbl\\n\", nsys, m->matrix_bits,\n\t\t   m->system_map);\n\tseq_printf(sf, \"%*s| CPU | avl | man | mac | act | vectors\\n\", ind, \" \");\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\n\t\tseq_printf(sf, \"%*s %4d  %4u  %4u  %4u %4u  %*pbl\\n\", ind, \" \",\n\t\t\t   cpu, cm->available, cm->managed,\n\t\t\t   cm->managed_allocated, cm->allocated,\n\t\t\t   m->matrix_bits, cm->alloc_map);\n\t}\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "irq_matrix_allocated",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "474-479",
    "snippet": "unsigned int irq_matrix_allocated(struct irq_matrix *m)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\treturn cm->allocated;\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "m->maps"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nunsigned int irq_matrix_allocated(struct irq_matrix *m)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\treturn cm->allocated;\n}"
  },
  {
    "function_name": "irq_matrix_reserved",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "463-466",
    "snippet": "unsigned int irq_matrix_reserved(struct irq_matrix *m)\n{\n\treturn m->global_reserved;\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nunsigned int irq_matrix_reserved(struct irq_matrix *m)\n{\n\treturn m->global_reserved;\n}"
  },
  {
    "function_name": "irq_matrix_available",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "450-457",
    "snippet": "unsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tif (!cpudown)\n\t\treturn m->global_available;\n\treturn m->global_available - cm->available;\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "m->maps"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nunsigned int irq_matrix_available(struct irq_matrix *m, bool cpudown)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tif (!cpudown)\n\t\treturn m->global_available;\n\treturn m->global_available - cm->available;\n}"
  },
  {
    "function_name": "irq_matrix_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "418-442",
    "snippet": "void irq_matrix_free(struct irq_matrix *m, unsigned int cpu,\n\t\t     unsigned int bit, bool managed)\n{\n\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\n\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(!test_and_clear_bit(bit, cm->alloc_map)))\n\t\treturn;\n\n\tcm->allocated--;\n\tif(managed)\n\t\tcm->managed_allocated--;\n\n\tif (cm->online)\n\t\tm->total_allocated--;\n\n\tif (!managed) {\n\t\tcm->available++;\n\t\tif (cm->online)\n\t\t\tm->global_available++;\n\t}\n\ttrace_irq_matrix_free(bit, cpu, m, cm);\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_matrix_free",
          "args": [
            "bit",
            "cpu",
            "m",
            "cm"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!test_and_clear_bit(bit, cm->alloc_map)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "bit",
            "cm->alloc_map"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "bit < m->alloc_start || bit >= m->alloc_end"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "m->maps",
            "cpu"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nvoid irq_matrix_free(struct irq_matrix *m, unsigned int cpu,\n\t\t     unsigned int bit, bool managed)\n{\n\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\n\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(!test_and_clear_bit(bit, cm->alloc_map)))\n\t\treturn;\n\n\tcm->allocated--;\n\tif(managed)\n\t\tcm->managed_allocated--;\n\n\tif (cm->online)\n\t\tm->total_allocated--;\n\n\tif (!managed) {\n\t\tcm->available++;\n\t\tif (cm->online)\n\t\t\tm->global_available++;\n\t}\n\ttrace_irq_matrix_free(bit, cpu, m, cm);\n}"
  },
  {
    "function_name": "irq_matrix_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "377-408",
    "snippet": "int irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,\n\t\t     bool reserved, unsigned int *mapped_cpu)\n{\n\tunsigned int cpu, bit;\n\tstruct cpumap *cm;\n\n\t/*\n\t * Not required in theory, but matrix_find_best_cpu() uses\n\t * for_each_cpu() which ignores the cpumask on UP .\n\t */\n\tif (cpumask_empty(msk))\n\t\treturn -EINVAL;\n\n\tcpu = matrix_find_best_cpu(m, msk);\n\tif (cpu == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tcm = per_cpu_ptr(m->maps, cpu);\n\tbit = matrix_alloc_area(m, cm, 1, false);\n\tif (bit >= m->alloc_end)\n\t\treturn -ENOSPC;\n\tcm->allocated++;\n\tcm->available--;\n\tm->total_allocated++;\n\tm->global_available--;\n\tif (reserved)\n\t\tm->global_reserved--;\n\t*mapped_cpu = cpu;\n\ttrace_irq_matrix_alloc(bit, cpu, m, cm);\n\treturn bit;\n\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_matrix_alloc",
          "args": [
            "bit",
            "cpu",
            "m",
            "cm"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matrix_alloc_area",
          "args": [
            "m",
            "cm",
            "1",
            "false"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "matrix_alloc_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
          "lines": "110-126",
          "snippet": "static unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,\n\t\t\t\t      unsigned int num, bool managed)\n{\n\tunsigned int area, start = m->alloc_start;\n\tunsigned int end = m->alloc_end;\n\n\tbitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);\n\tbitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);\n\tarea = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);\n\tif (area >= end)\n\t\treturn area;\n\tif (managed)\n\t\tbitmap_set(cm->managed_map, area, num);\n\telse\n\t\tbitmap_set(cm->alloc_map, area, num);\n\treturn area;\n}",
          "includes": [
            "#include <trace/events/irq_matrix.h>",
            "#include <linux/irq.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nstatic unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,\n\t\t\t\t      unsigned int num, bool managed)\n{\n\tunsigned int area, start = m->alloc_start;\n\tunsigned int end = m->alloc_end;\n\n\tbitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);\n\tbitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);\n\tarea = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);\n\tif (area >= end)\n\t\treturn area;\n\tif (managed)\n\t\tbitmap_set(cm->managed_map, area, num);\n\telse\n\t\tbitmap_set(cm->alloc_map, area, num);\n\treturn area;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "m->maps",
            "cpu"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matrix_find_best_cpu",
          "args": [
            "m",
            "msk"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "matrix_find_best_cpu_managed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
          "lines": "150-168",
          "snippet": "static unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,\n\t\t\t\t\t\tconst struct cpumask *msk)\n{\n\tunsigned int cpu, best_cpu, allocated = UINT_MAX;\n\tstruct cpumap *cm;\n\n\tbest_cpu = UINT_MAX;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tcm = per_cpu_ptr(m->maps, cpu);\n\n\t\tif (!cm->online || cm->managed_allocated > allocated)\n\t\t\tcontinue;\n\n\t\tbest_cpu = cpu;\n\t\tallocated = cm->managed_allocated;\n\t}\n\treturn best_cpu;\n}",
          "includes": [
            "#include <trace/events/irq_matrix.h>",
            "#include <linux/irq.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nstatic unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,\n\t\t\t\t\t\tconst struct cpumask *msk)\n{\n\tunsigned int cpu, best_cpu, allocated = UINT_MAX;\n\tstruct cpumap *cm;\n\n\tbest_cpu = UINT_MAX;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tcm = per_cpu_ptr(m->maps, cpu);\n\n\t\tif (!cm->online || cm->managed_allocated > allocated)\n\t\t\tcontinue;\n\n\t\tbest_cpu = cpu;\n\t\tallocated = cm->managed_allocated;\n\t}\n\treturn best_cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "msk"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nint irq_matrix_alloc(struct irq_matrix *m, const struct cpumask *msk,\n\t\t     bool reserved, unsigned int *mapped_cpu)\n{\n\tunsigned int cpu, bit;\n\tstruct cpumap *cm;\n\n\t/*\n\t * Not required in theory, but matrix_find_best_cpu() uses\n\t * for_each_cpu() which ignores the cpumask on UP .\n\t */\n\tif (cpumask_empty(msk))\n\t\treturn -EINVAL;\n\n\tcpu = matrix_find_best_cpu(m, msk);\n\tif (cpu == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tcm = per_cpu_ptr(m->maps, cpu);\n\tbit = matrix_alloc_area(m, cm, 1, false);\n\tif (bit >= m->alloc_end)\n\t\treturn -ENOSPC;\n\tcm->allocated++;\n\tcm->available--;\n\tm->total_allocated++;\n\tm->global_available--;\n\tif (reserved)\n\t\tm->global_reserved--;\n\t*mapped_cpu = cpu;\n\ttrace_irq_matrix_alloc(bit, cpu, m, cm);\n\treturn bit;\n\n}"
  },
  {
    "function_name": "irq_matrix_remove_reserved",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "364-368",
    "snippet": "void irq_matrix_remove_reserved(struct irq_matrix *m)\n{\n\tm->global_reserved--;\n\ttrace_irq_matrix_remove_reserved(m);\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_matrix_remove_reserved",
          "args": [
            "m"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nvoid irq_matrix_remove_reserved(struct irq_matrix *m)\n{\n\tm->global_reserved--;\n\ttrace_irq_matrix_remove_reserved(m);\n}"
  },
  {
    "function_name": "irq_matrix_reserve",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "346-353",
    "snippet": "void irq_matrix_reserve(struct irq_matrix *m)\n{\n\tif (m->global_reserved == m->global_available)\n\t\tpr_warn(\"Interrupt reservation exceeds available resources\\n\");\n\n\tm->global_reserved++;\n\ttrace_irq_matrix_reserve(m);\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_matrix_reserve",
          "args": [
            "m"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Interrupt reservation exceeds available resources\\n\""
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nvoid irq_matrix_reserve(struct irq_matrix *m)\n{\n\tif (m->global_reserved == m->global_available)\n\t\tpr_warn(\"Interrupt reservation exceeds available resources\\n\");\n\n\tm->global_reserved++;\n\ttrace_irq_matrix_reserve(m);\n}"
  },
  {
    "function_name": "irq_matrix_assign",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "322-335",
    "snippet": "void irq_matrix_assign(struct irq_matrix *m, unsigned int bit)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))\n\t\treturn;\n\tif (WARN_ON_ONCE(test_and_set_bit(bit, cm->alloc_map)))\n\t\treturn;\n\tcm->allocated++;\n\tm->total_allocated++;\n\tcm->available--;\n\tm->global_available--;\n\ttrace_irq_matrix_assign(bit, smp_processor_id(), m, cm);\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_matrix_assign",
          "args": [
            "bit",
            "smp_processor_id()",
            "m",
            "cm"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "test_and_set_bit(bit, cm->alloc_map)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "bit",
            "cm->alloc_map"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "bit < m->alloc_start || bit >= m->alloc_end"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "m->maps"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nvoid irq_matrix_assign(struct irq_matrix *m, unsigned int bit)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tif (WARN_ON_ONCE(bit < m->alloc_start || bit >= m->alloc_end))\n\t\treturn;\n\tif (WARN_ON_ONCE(test_and_set_bit(bit, cm->alloc_map)))\n\t\treturn;\n\tcm->allocated++;\n\tm->total_allocated++;\n\tcm->available--;\n\tm->global_available--;\n\ttrace_irq_matrix_assign(bit, smp_processor_id(), m, cm);\n}"
  },
  {
    "function_name": "irq_matrix_alloc_managed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "286-313",
    "snippet": "int irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,\n\t\t\t     unsigned int *mapped_cpu)\n{\n\tunsigned int bit, cpu, end = m->alloc_end;\n\tstruct cpumap *cm;\n\n\tif (cpumask_empty(msk))\n\t\treturn -EINVAL;\n\n\tcpu = matrix_find_best_cpu_managed(m, msk);\n\tif (cpu == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tcm = per_cpu_ptr(m->maps, cpu);\n\tend = m->alloc_end;\n\t/* Get managed bit which are not allocated */\n\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);\n\tbit = find_first_bit(m->scratch_map, end);\n\tif (bit >= end)\n\t\treturn -ENOSPC;\n\tset_bit(bit, cm->alloc_map);\n\tcm->allocated++;\n\tcm->managed_allocated++;\n\tm->total_allocated++;\n\t*mapped_cpu = cpu;\n\ttrace_irq_matrix_alloc_managed(bit, cpu, m, cm);\n\treturn bit;\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_matrix_alloc_managed",
          "args": [
            "bit",
            "cpu",
            "m",
            "cm"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit",
            "cm->alloc_map"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "m->scratch_map",
            "end"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_andnot",
          "args": [
            "m->scratch_map",
            "cm->managed_map",
            "cm->alloc_map",
            "end"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "m->maps",
            "cpu"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matrix_find_best_cpu_managed",
          "args": [
            "m",
            "msk"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "matrix_find_best_cpu_managed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
          "lines": "150-168",
          "snippet": "static unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,\n\t\t\t\t\t\tconst struct cpumask *msk)\n{\n\tunsigned int cpu, best_cpu, allocated = UINT_MAX;\n\tstruct cpumap *cm;\n\n\tbest_cpu = UINT_MAX;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tcm = per_cpu_ptr(m->maps, cpu);\n\n\t\tif (!cm->online || cm->managed_allocated > allocated)\n\t\t\tcontinue;\n\n\t\tbest_cpu = cpu;\n\t\tallocated = cm->managed_allocated;\n\t}\n\treturn best_cpu;\n}",
          "includes": [
            "#include <trace/events/irq_matrix.h>",
            "#include <linux/irq.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nstatic unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,\n\t\t\t\t\t\tconst struct cpumask *msk)\n{\n\tunsigned int cpu, best_cpu, allocated = UINT_MAX;\n\tstruct cpumap *cm;\n\n\tbest_cpu = UINT_MAX;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tcm = per_cpu_ptr(m->maps, cpu);\n\n\t\tif (!cm->online || cm->managed_allocated > allocated)\n\t\t\tcontinue;\n\n\t\tbest_cpu = cpu;\n\t\tallocated = cm->managed_allocated;\n\t}\n\treturn best_cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "msk"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nint irq_matrix_alloc_managed(struct irq_matrix *m, const struct cpumask *msk,\n\t\t\t     unsigned int *mapped_cpu)\n{\n\tunsigned int bit, cpu, end = m->alloc_end;\n\tstruct cpumap *cm;\n\n\tif (cpumask_empty(msk))\n\t\treturn -EINVAL;\n\n\tcpu = matrix_find_best_cpu_managed(m, msk);\n\tif (cpu == UINT_MAX)\n\t\treturn -ENOSPC;\n\n\tcm = per_cpu_ptr(m->maps, cpu);\n\tend = m->alloc_end;\n\t/* Get managed bit which are not allocated */\n\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);\n\tbit = find_first_bit(m->scratch_map, end);\n\tif (bit >= end)\n\t\treturn -ENOSPC;\n\tset_bit(bit, cm->alloc_map);\n\tcm->allocated++;\n\tcm->managed_allocated++;\n\tm->total_allocated++;\n\t*mapped_cpu = cpu;\n\ttrace_irq_matrix_alloc_managed(bit, cpu, m, cm);\n\treturn bit;\n}"
  },
  {
    "function_name": "irq_matrix_remove_managed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "251-278",
    "snippet": "void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\t\tunsigned int bit, end = m->alloc_end;\n\n\t\tif (WARN_ON_ONCE(!cm->managed))\n\t\t\tcontinue;\n\n\t\t/* Get managed bit which are not allocated */\n\t\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);\n\n\t\tbit = find_first_bit(m->scratch_map, end);\n\t\tif (WARN_ON_ONCE(bit >= end))\n\t\t\tcontinue;\n\n\t\tclear_bit(bit, cm->managed_map);\n\n\t\tcm->managed--;\n\t\tif (cm->online) {\n\t\t\tcm->available++;\n\t\t\tm->global_available++;\n\t\t}\n\t\ttrace_irq_matrix_remove_managed(bit, cpu, m, cm);\n\t}\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_matrix_remove_managed",
          "args": [
            "bit",
            "cpu",
            "m",
            "cm"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "bit",
            "cm->managed_map"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "830-839",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "bit >= end"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "m->scratch_map",
            "end"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_andnot",
          "args": [
            "m->scratch_map",
            "cm->managed_map",
            "cm->alloc_map",
            "end"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!cm->managed"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "m->maps",
            "cpu"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "msk"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nvoid irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\t\tunsigned int bit, end = m->alloc_end;\n\n\t\tif (WARN_ON_ONCE(!cm->managed))\n\t\t\tcontinue;\n\n\t\t/* Get managed bit which are not allocated */\n\t\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);\n\n\t\tbit = find_first_bit(m->scratch_map, end);\n\t\tif (WARN_ON_ONCE(bit >= end))\n\t\t\tcontinue;\n\n\t\tclear_bit(bit, cm->managed_map);\n\n\t\tcm->managed--;\n\t\tif (cm->online) {\n\t\t\tcm->available++;\n\t\t\tm->global_available++;\n\t\t}\n\t\ttrace_irq_matrix_remove_managed(bit, cpu, m, cm);\n\t}\n}"
  },
  {
    "function_name": "irq_matrix_reserve_managed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "210-237",
    "snippet": "int irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk)\n{\n\tunsigned int cpu, failed_cpu;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\t\tunsigned int bit;\n\n\t\tbit = matrix_alloc_area(m, cm, 1, true);\n\t\tif (bit >= m->alloc_end)\n\t\t\tgoto cleanup;\n\t\tcm->managed++;\n\t\tif (cm->online) {\n\t\t\tcm->available--;\n\t\t\tm->global_available--;\n\t\t}\n\t\ttrace_irq_matrix_reserve_managed(bit, cpu, m, cm);\n\t}\n\treturn 0;\ncleanup:\n\tfailed_cpu = cpu;\n\tfor_each_cpu(cpu, msk) {\n\t\tif (cpu == failed_cpu)\n\t\t\tbreak;\n\t\tirq_matrix_remove_managed(m, cpumask_of(cpu));\n\t}\n\treturn -ENOSPC;\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_matrix_remove_managed",
          "args": [
            "m",
            "cpumask_of(cpu)"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "irq_matrix_remove_managed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
          "lines": "251-278",
          "snippet": "void irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\t\tunsigned int bit, end = m->alloc_end;\n\n\t\tif (WARN_ON_ONCE(!cm->managed))\n\t\t\tcontinue;\n\n\t\t/* Get managed bit which are not allocated */\n\t\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);\n\n\t\tbit = find_first_bit(m->scratch_map, end);\n\t\tif (WARN_ON_ONCE(bit >= end))\n\t\t\tcontinue;\n\n\t\tclear_bit(bit, cm->managed_map);\n\n\t\tcm->managed--;\n\t\tif (cm->online) {\n\t\t\tcm->available++;\n\t\t\tm->global_available++;\n\t\t}\n\t\ttrace_irq_matrix_remove_managed(bit, cpu, m, cm);\n\t}\n}",
          "includes": [
            "#include <trace/events/irq_matrix.h>",
            "#include <linux/irq.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nvoid irq_matrix_remove_managed(struct irq_matrix *m, const struct cpumask *msk)\n{\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\t\tunsigned int bit, end = m->alloc_end;\n\n\t\tif (WARN_ON_ONCE(!cm->managed))\n\t\t\tcontinue;\n\n\t\t/* Get managed bit which are not allocated */\n\t\tbitmap_andnot(m->scratch_map, cm->managed_map, cm->alloc_map, end);\n\n\t\tbit = find_first_bit(m->scratch_map, end);\n\t\tif (WARN_ON_ONCE(bit >= end))\n\t\t\tcontinue;\n\n\t\tclear_bit(bit, cm->managed_map);\n\n\t\tcm->managed--;\n\t\tif (cm->online) {\n\t\t\tcm->available++;\n\t\t\tm->global_available++;\n\t\t}\n\t\ttrace_irq_matrix_remove_managed(bit, cpu, m, cm);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_of",
          "args": [
            "cpu"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "cpumask_of_bp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/hw_breakpoint.c",
          "lines": "121-126",
          "snippet": "static const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}",
          "includes": [
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/irqflags.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hw_breakpoint.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/irqflags.h>\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "msk"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_irq_matrix_reserve_managed",
          "args": [
            "bit",
            "cpu",
            "m",
            "cm"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matrix_alloc_area",
          "args": [
            "m",
            "cm",
            "1",
            "true"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "matrix_alloc_area",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
          "lines": "110-126",
          "snippet": "static unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,\n\t\t\t\t      unsigned int num, bool managed)\n{\n\tunsigned int area, start = m->alloc_start;\n\tunsigned int end = m->alloc_end;\n\n\tbitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);\n\tbitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);\n\tarea = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);\n\tif (area >= end)\n\t\treturn area;\n\tif (managed)\n\t\tbitmap_set(cm->managed_map, area, num);\n\telse\n\t\tbitmap_set(cm->alloc_map, area, num);\n\treturn area;\n}",
          "includes": [
            "#include <trace/events/irq_matrix.h>",
            "#include <linux/irq.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__init struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nstatic unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,\n\t\t\t\t      unsigned int num, bool managed)\n{\n\tunsigned int area, start = m->alloc_start;\n\tunsigned int end = m->alloc_end;\n\n\tbitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);\n\tbitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);\n\tarea = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);\n\tif (area >= end)\n\t\treturn area;\n\tif (managed)\n\t\tbitmap_set(cm->managed_map, area, num);\n\telse\n\t\tbitmap_set(cm->alloc_map, area, num);\n\treturn area;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "m->maps",
            "cpu"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "msk"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nint irq_matrix_reserve_managed(struct irq_matrix *m, const struct cpumask *msk)\n{\n\tunsigned int cpu, failed_cpu;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tstruct cpumap *cm = per_cpu_ptr(m->maps, cpu);\n\t\tunsigned int bit;\n\n\t\tbit = matrix_alloc_area(m, cm, 1, true);\n\t\tif (bit >= m->alloc_end)\n\t\t\tgoto cleanup;\n\t\tcm->managed++;\n\t\tif (cm->online) {\n\t\t\tcm->available--;\n\t\t\tm->global_available--;\n\t\t}\n\t\ttrace_irq_matrix_reserve_managed(bit, cpu, m, cm);\n\t}\n\treturn 0;\ncleanup:\n\tfailed_cpu = cpu;\n\tfor_each_cpu(cpu, msk) {\n\t\tif (cpu == failed_cpu)\n\t\t\tbreak;\n\t\tirq_matrix_remove_managed(m, cpumask_of(cpu));\n\t}\n\treturn -ENOSPC;\n}"
  },
  {
    "function_name": "irq_matrix_assign_system",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "181-199",
    "snippet": "void irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit,\n\t\t\t      bool replace)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tBUG_ON(bit > m->matrix_bits);\n\tBUG_ON(m->online_maps > 1 || (m->online_maps && !replace));\n\n\tset_bit(bit, m->system_map);\n\tif (replace) {\n\t\tBUG_ON(!test_and_clear_bit(bit, cm->alloc_map));\n\t\tcm->allocated--;\n\t\tm->total_allocated--;\n\t}\n\tif (bit >= m->alloc_start && bit < m->alloc_end)\n\t\tm->systembits_inalloc++;\n\n\ttrace_irq_matrix_assign_system(bit, m);\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_matrix_assign_system",
          "args": [
            "bit",
            "m"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!test_and_clear_bit(bit, cm->alloc_map)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "bit",
            "cm->alloc_map"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit",
            "m->system_map"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "817-828",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "m->online_maps > 1 || (m->online_maps && !replace)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bit > m->matrix_bits"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "m->maps"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nvoid irq_matrix_assign_system(struct irq_matrix *m, unsigned int bit,\n\t\t\t      bool replace)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tBUG_ON(bit > m->matrix_bits);\n\tBUG_ON(m->online_maps > 1 || (m->online_maps && !replace));\n\n\tset_bit(bit, m->system_map);\n\tif (replace) {\n\t\tBUG_ON(!test_and_clear_bit(bit, cm->alloc_map));\n\t\tcm->allocated--;\n\t\tm->total_allocated--;\n\t}\n\tif (bit >= m->alloc_start && bit < m->alloc_end)\n\t\tm->systembits_inalloc++;\n\n\ttrace_irq_matrix_assign_system(bit, m);\n}"
  },
  {
    "function_name": "matrix_find_best_cpu_managed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "150-168",
    "snippet": "static unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,\n\t\t\t\t\t\tconst struct cpumask *msk)\n{\n\tunsigned int cpu, best_cpu, allocated = UINT_MAX;\n\tstruct cpumap *cm;\n\n\tbest_cpu = UINT_MAX;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tcm = per_cpu_ptr(m->maps, cpu);\n\n\t\tif (!cm->online || cm->managed_allocated > allocated)\n\t\t\tcontinue;\n\n\t\tbest_cpu = cpu;\n\t\tallocated = cm->managed_allocated;\n\t}\n\treturn best_cpu;\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "m->maps",
            "cpu"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "msk"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nstatic unsigned int matrix_find_best_cpu_managed(struct irq_matrix *m,\n\t\t\t\t\t\tconst struct cpumask *msk)\n{\n\tunsigned int cpu, best_cpu, allocated = UINT_MAX;\n\tstruct cpumap *cm;\n\n\tbest_cpu = UINT_MAX;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tcm = per_cpu_ptr(m->maps, cpu);\n\n\t\tif (!cm->online || cm->managed_allocated > allocated)\n\t\t\tcontinue;\n\n\t\tbest_cpu = cpu;\n\t\tallocated = cm->managed_allocated;\n\t}\n\treturn best_cpu;\n}"
  },
  {
    "function_name": "matrix_find_best_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "129-147",
    "snippet": "static unsigned int matrix_find_best_cpu(struct irq_matrix *m,\n\t\t\t\t\tconst struct cpumask *msk)\n{\n\tunsigned int cpu, best_cpu, maxavl = 0;\n\tstruct cpumap *cm;\n\n\tbest_cpu = UINT_MAX;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tcm = per_cpu_ptr(m->maps, cpu);\n\n\t\tif (!cm->online || cm->available <= maxavl)\n\t\t\tcontinue;\n\n\t\tbest_cpu = cpu;\n\t\tmaxavl = cm->available;\n\t}\n\treturn best_cpu;\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "m->maps",
            "cpu"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "msk"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nstatic unsigned int matrix_find_best_cpu(struct irq_matrix *m,\n\t\t\t\t\tconst struct cpumask *msk)\n{\n\tunsigned int cpu, best_cpu, maxavl = 0;\n\tstruct cpumap *cm;\n\n\tbest_cpu = UINT_MAX;\n\n\tfor_each_cpu(cpu, msk) {\n\t\tcm = per_cpu_ptr(m->maps, cpu);\n\n\t\tif (!cm->online || cm->available <= maxavl)\n\t\t\tcontinue;\n\n\t\tbest_cpu = cpu;\n\t\tmaxavl = cm->available;\n\t}\n\treturn best_cpu;\n}"
  },
  {
    "function_name": "matrix_alloc_area",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "110-126",
    "snippet": "static unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,\n\t\t\t\t      unsigned int num, bool managed)\n{\n\tunsigned int area, start = m->alloc_start;\n\tunsigned int end = m->alloc_end;\n\n\tbitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);\n\tbitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);\n\tarea = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);\n\tif (area >= end)\n\t\treturn area;\n\tif (managed)\n\t\tbitmap_set(cm->managed_map, area, num);\n\telse\n\t\tbitmap_set(cm->alloc_map, area, num);\n\treturn area;\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "cm->alloc_map",
            "area",
            "num"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "cm->managed_map",
            "area",
            "num"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_find_next_zero_area",
          "args": [
            "m->scratch_map",
            "end",
            "start",
            "num",
            "0"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_or",
          "args": [
            "m->scratch_map",
            "m->scratch_map",
            "cm->alloc_map",
            "end"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_or",
          "args": [
            "m->scratch_map",
            "cm->managed_map",
            "m->system_map",
            "end"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nstatic unsigned int matrix_alloc_area(struct irq_matrix *m, struct cpumap *cm,\n\t\t\t\t      unsigned int num, bool managed)\n{\n\tunsigned int area, start = m->alloc_start;\n\tunsigned int end = m->alloc_end;\n\n\tbitmap_or(m->scratch_map, cm->managed_map, m->system_map, end);\n\tbitmap_or(m->scratch_map, m->scratch_map, cm->alloc_map, end);\n\tarea = bitmap_find_next_zero_area(m->scratch_map, end, start, num, 0);\n\tif (area >= end)\n\t\treturn area;\n\tif (managed)\n\t\tbitmap_set(cm->managed_map, area, num);\n\telse\n\t\tbitmap_set(cm->alloc_map, area, num);\n\treturn area;\n}"
  },
  {
    "function_name": "irq_matrix_offline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "99-108",
    "snippet": "void irq_matrix_offline(struct irq_matrix *m)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\t/* Update the global available size */\n\tm->global_available -= cm->available;\n\tcm->online = false;\n\tm->online_maps--;\n\ttrace_irq_matrix_offline(m);\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_matrix_offline",
          "args": [
            "m"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "m->maps"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nvoid irq_matrix_offline(struct irq_matrix *m)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\t/* Update the global available size */\n\tm->global_available -= cm->available;\n\tcm->online = false;\n\tm->online_maps--;\n\ttrace_irq_matrix_offline(m);\n}"
  },
  {
    "function_name": "irq_matrix_online",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "78-93",
    "snippet": "void irq_matrix_online(struct irq_matrix *m)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tBUG_ON(cm->online);\n\n\tif (!cm->initialized) {\n\t\tcm->available = m->alloc_size;\n\t\tcm->available -= cm->managed + m->systembits_inalloc;\n\t\tcm->initialized = true;\n\t}\n\tm->global_available += cm->available;\n\tcm->online = true;\n\tm->online_maps++;\n\ttrace_irq_matrix_online(m);\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_irq_matrix_online",
          "args": [
            "m"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cm->online"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "m->maps"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nvoid irq_matrix_online(struct irq_matrix *m)\n{\n\tstruct cpumap *cm = this_cpu_ptr(m->maps);\n\n\tBUG_ON(cm->online);\n\n\tif (!cm->initialized) {\n\t\tcm->available = m->alloc_size;\n\t\tcm->available -= cm->managed + m->systembits_inalloc;\n\t\tcm->initialized = true;\n\t}\n\tm->global_available += cm->available;\n\tcm->online = true;\n\tm->online_maps++;\n\ttrace_irq_matrix_online(m);\n}"
  },
  {
    "function_name": "irq_alloc_matrix",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/matrix.c",
    "lines": "49-72",
    "snippet": "irq_matrix *irq_alloc_matrix(unsigned int matrix_bits,\n\t\t\t\t\t   unsigned int alloc_start,\n\t\t\t\t\t   unsigned int alloc_end)\n{\n\tstruct irq_matrix *m;\n\n\tif (matrix_bits > IRQ_MATRIX_BITS)\n\t\treturn NULL;\n\n\tm = kzalloc(sizeof(*m), GFP_KERNEL);\n\tif (!m)\n\t\treturn NULL;\n\n\tm->matrix_bits = matrix_bits;\n\tm->alloc_start = alloc_start;\n\tm->alloc_end = alloc_end;\n\tm->alloc_size = alloc_end - alloc_start;\n\tm->maps = alloc_percpu(*m->maps);\n\tif (!m->maps) {\n\t\tkfree(m);\n\t\treturn NULL;\n\t}\n\treturn m;\n}",
    "includes": [
      "#include <trace/events/irq_matrix.h>",
      "#include <linux/irq.h>",
      "#include <linux/cpu.h>",
      "#include <linux/percpu.h>",
      "#include <linux/bitmap.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__init struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "m"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "*m->maps"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*m)",
            "GFP_KERNEL"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/irq_matrix.h>\n#include <linux/irq.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/bitmap.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n\n__init struct;\n\nirq_matrix *irq_alloc_matrix(unsigned int matrix_bits,\n\t\t\t\t\t   unsigned int alloc_start,\n\t\t\t\t\t   unsigned int alloc_end)\n{\n\tstruct irq_matrix *m;\n\n\tif (matrix_bits > IRQ_MATRIX_BITS)\n\t\treturn NULL;\n\n\tm = kzalloc(sizeof(*m), GFP_KERNEL);\n\tif (!m)\n\t\treturn NULL;\n\n\tm->matrix_bits = matrix_bits;\n\tm->alloc_start = alloc_start;\n\tm->alloc_end = alloc_end;\n\tm->alloc_size = alloc_end - alloc_start;\n\tm->maps = alloc_percpu(*m->maps);\n\tif (!m->maps) {\n\t\tkfree(m);\n\t\treturn NULL;\n\t}\n\treturn m;\n}"
  }
]