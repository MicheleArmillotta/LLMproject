[
  {
    "function_name": "alarmtimer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "907-938",
    "snippet": "static int __init alarmtimer_init(void)\n{\n\tint error;\n\tint i;\n\n\talarmtimer_rtc_timer_init();\n\n\t/* Initialize alarm bases */\n\talarm_bases[ALARM_REALTIME].base_clockid = CLOCK_REALTIME;\n\talarm_bases[ALARM_REALTIME].get_ktime = &ktime_get_real;\n\talarm_bases[ALARM_REALTIME].get_timespec = ktime_get_real_ts64;\n\talarm_bases[ALARM_BOOTTIME].base_clockid = CLOCK_BOOTTIME;\n\talarm_bases[ALARM_BOOTTIME].get_ktime = &ktime_get_boottime;\n\talarm_bases[ALARM_BOOTTIME].get_timespec = get_boottime_timespec;\n\tfor (i = 0; i < ALARM_NUMTYPE; i++) {\n\t\ttimerqueue_init_head(&alarm_bases[i].timerqueue);\n\t\tspin_lock_init(&alarm_bases[i].lock);\n\t}\n\n\terror = alarmtimer_rtc_interface_setup();\n\tif (error)\n\t\treturn error;\n\n\terror = platform_driver_register(&alarmtimer_driver);\n\tif (error)\n\t\tgoto out_if;\n\n\treturn 0;\nout_if:\n\talarmtimer_rtc_interface_remove();\n\treturn error;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];",
      "static struct platform_driver alarmtimer_driver = {\n\t.driver = {\n\t\t.name = \"alarmtimer\",\n\t\t.pm = &alarmtimer_pm_ops,\n\t}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarmtimer_rtc_interface_remove",
          "args": [],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_rtc_interface_remove",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "147-147",
          "snippet": "static inline void alarmtimer_rtc_interface_remove(void) { }",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline void alarmtimer_rtc_interface_remove(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "platform_driver_register",
          "args": [
            "&alarmtimer_driver"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_rtc_interface_setup",
          "args": [],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_rtc_interface_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "146-146",
          "snippet": "static inline int alarmtimer_rtc_interface_setup(void) { return 0; }",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline int alarmtimer_rtc_interface_setup(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&alarm_bases[i].lock"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_init_head",
          "args": [
            "&alarm_bases[i].timerqueue"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_rtc_timer_init",
          "args": [],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_rtc_timer_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "148-148",
          "snippet": "static inline void alarmtimer_rtc_timer_init(void) { }",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline void alarmtimer_rtc_timer_init(void) { }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\nstatic struct platform_driver alarmtimer_driver = {\n\t.driver = {\n\t\t.name = \"alarmtimer\",\n\t\t.pm = &alarmtimer_pm_ops,\n\t}\n};\n\nstatic int __init alarmtimer_init(void)\n{\n\tint error;\n\tint i;\n\n\talarmtimer_rtc_timer_init();\n\n\t/* Initialize alarm bases */\n\talarm_bases[ALARM_REALTIME].base_clockid = CLOCK_REALTIME;\n\talarm_bases[ALARM_REALTIME].get_ktime = &ktime_get_real;\n\talarm_bases[ALARM_REALTIME].get_timespec = ktime_get_real_ts64;\n\talarm_bases[ALARM_BOOTTIME].base_clockid = CLOCK_BOOTTIME;\n\talarm_bases[ALARM_BOOTTIME].get_ktime = &ktime_get_boottime;\n\talarm_bases[ALARM_BOOTTIME].get_timespec = get_boottime_timespec;\n\tfor (i = 0; i < ALARM_NUMTYPE; i++) {\n\t\ttimerqueue_init_head(&alarm_bases[i].timerqueue);\n\t\tspin_lock_init(&alarm_bases[i].lock);\n\t}\n\n\terror = alarmtimer_rtc_interface_setup();\n\tif (error)\n\t\treturn error;\n\n\terror = platform_driver_register(&alarmtimer_driver);\n\tif (error)\n\t\tgoto out_if;\n\n\treturn 0;\nout_if:\n\talarmtimer_rtc_interface_remove();\n\treturn error;\n}"
  },
  {
    "function_name": "get_boottime_timespec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "895-899",
    "snippet": "static void get_boottime_timespec(struct timespec64 *tp)\n{\n\tktime_get_boottime_ts64(tp);\n\ttimens_add_boottime(tp);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timens_add_boottime",
          "args": [
            "tp"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_boottime_ts64",
          "args": [
            "tp"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void get_boottime_timespec(struct timespec64 *tp)\n{\n\tktime_get_boottime_ts64(tp);\n\ttimens_add_boottime(tp);\n}"
  },
  {
    "function_name": "alarm_timer_nsleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "819-861",
    "snippet": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec64_to_ktime(*tsreq);\n\t/* Convert (if necessary) to absolute time */\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].get_ktime();\n\n\t\texp = ktime_add_safe(now, exp);\n\t} else {\n\t\texp = timens_ktime_to_host(which_clock, exp);\n\t}\n\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\n\t/* abs timers don't set remaining time or restart */\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\tset_restart_fn(restart, alarm_timer_nsleep_restart);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_restart_fn",
          "args": [
            "restart",
            "alarm_timer_nsleep_restart"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_do_nsleep",
          "args": [
            "&alarm",
            "exp",
            "type"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_do_nsleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "746-783",
          "snippet": "static int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].get_ktime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].get_ktime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timens_ktime_to_host",
          "args": [
            "which_clock",
            "exp"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "now",
            "exp"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm_bases[type].get_ktime",
          "args": [],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*tsreq"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm_init_on_stack",
          "args": [
            "&alarm",
            "type",
            "alarmtimer_nsleep_wakeup"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_init_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "785-792",
          "snippet": "static void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_WAKE_ALARM"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "71-81",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock2alarm",
          "args": [
            "which_clock"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "clock2alarm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "518-525",
          "snippet": "static enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec64_to_ktime(*tsreq);\n\t/* Convert (if necessary) to absolute time */\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].get_ktime();\n\n\t\texp = ktime_add_safe(now, exp);\n\t} else {\n\t\texp = timens_ktime_to_host(which_clock, exp);\n\t}\n\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\n\t/* abs timers don't set remaining time or restart */\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\tset_restart_fn(restart, alarm_timer_nsleep_restart);\n\treturn ret;\n}"
  },
  {
    "function_name": "alarm_timer_nsleep_restart",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "800-809",
    "snippet": "static long __sched alarm_timer_nsleep_restart(struct restart_block *restart)\n{\n\tenum  alarmtimer_type type = restart->nanosleep.clockid;\n\tktime_t exp = restart->nanosleep.expires;\n\tstruct alarm alarm;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\treturn alarmtimer_do_nsleep(&alarm, exp, type);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarmtimer_do_nsleep",
          "args": [
            "&alarm",
            "exp",
            "type"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_do_nsleep",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "746-783",
          "snippet": "static int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].get_ktime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].get_ktime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm_init_on_stack",
          "args": [
            "&alarm",
            "type",
            "alarmtimer_nsleep_wakeup"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_init_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "785-792",
          "snippet": "static void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic long __sched alarm_timer_nsleep_restart(struct restart_block *restart)\n{\n\tenum  alarmtimer_type type = restart->nanosleep.clockid;\n\tktime_t exp = restart->nanosleep.expires;\n\tstruct alarm alarm;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\treturn alarmtimer_do_nsleep(&alarm, exp, type);\n}"
  },
  {
    "function_name": "alarm_init_on_stack",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "785-792",
    "snippet": "static void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alarm_init",
          "args": [
            "alarm",
            "type",
            "function"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "__alarm_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "325-334",
          "snippet": "static void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init_on_stack",
          "args": [
            "&alarm->timer",
            "alarm_bases[type].base_clockid",
            "HRTIMER_MODE_ABS"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "431-436",
          "snippet": "void hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}"
  },
  {
    "function_name": "alarmtimer_do_nsleep",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "746-783",
    "snippet": "static int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].get_ktime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nanosleep_copyout",
          "args": [
            "restart",
            "&rmt"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "nanosleep_copyout",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2016-2033",
          "snippet": "int nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint nanosleep_copyout(struct restart_block *restart, struct timespec64 *ts)\n{\n\tswitch(restart->nanosleep.type) {\n#ifdef CONFIG_COMPAT_32BIT_TIME\n\tcase TT_COMPAT:\n\t\tif (put_old_timespec32(ts, restart->nanosleep.compat_rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n#endif\n\tcase TT_NATIVE:\n\t\tif (put_timespec64(ts, restart->nanosleep.rmtp))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_timespec64",
          "args": [
            "rem"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "absexp",
            "alarm_bases[type].get_ktime()"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm_bases[type].get_ktime",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_freezerset",
          "args": [
            "absexp",
            "type"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_freezerset",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "483-512",
          "snippet": "static void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tstruct alarm_base *base;\n\tunsigned long flags;\n\tktime_t delta;\n\n\tswitch(type) {\n\tcase ALARM_REALTIME:\n\t\tbase = &alarm_bases[ALARM_REALTIME];\n\t\ttype = ALARM_REALTIME_FREEZER;\n\t\tbreak;\n\tcase ALARM_BOOTTIME:\n\t\tbase = &alarm_bases[ALARM_BOOTTIME];\n\t\ttype = ALARM_BOOTTIME_FREEZER;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid alarm type: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tdelta = ktime_sub(absexp, base->get_ktime());\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tif (!freezer_delta || (delta < freezer_delta)) {\n\t\tfreezer_delta = delta;\n\t\tfreezer_expires = absexp;\n\t\tfreezer_alarmtype = type;\n\t}\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tstruct alarm_base *base;\n\tunsigned long flags;\n\tktime_t delta;\n\n\tswitch(type) {\n\tcase ALARM_REALTIME:\n\t\tbase = &alarm_bases[ALARM_REALTIME];\n\t\ttype = ALARM_REALTIME_FREEZER;\n\t\tbreak;\n\tcase ALARM_BOOTTIME:\n\t\tbase = &alarm_bases[ALARM_BOOTTIME];\n\t\ttype = ALARM_BOOTTIME_FREEZER;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid alarm type: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tdelta = ktime_sub(absexp, base->get_ktime());\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tif (!freezer_delta || (delta < freezer_delta)) {\n\t\tfreezer_delta = delta;\n\t\tfreezer_expires = absexp;\n\t\tfreezer_alarmtype = type;\n\t}\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "freezing_slow_path",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/freezer.c",
          "lines": "37-52",
          "snippet": "bool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool pm_freezing;",
            "bool pm_nosig_freezing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nbool pm_freezing;\nbool pm_nosig_freezing;\n\nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hrtimer_on_stack",
          "args": [
            "&alarm->timer"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hrtimer_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "450-453",
          "snippet": "void destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm_cancel",
          "args": [
            "alarm"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "429-437",
          "snippet": "int alarm_cancel(struct alarm *alarm)\n{\n\tfor (;;) {\n\t\tint ret = alarm_try_to_cancel(alarm);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\thrtimer_cancel_wait_running(&alarm->timer);\n\t}\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nint alarm_cancel(struct alarm *alarm)\n{\n\tfor (;;) {\n\t\tint ret = alarm_try_to_cancel(alarm);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\thrtimer_cancel_wait_running(&alarm->timer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit_tree.c",
          "lines": "963-966",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "alarm->data"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarm_start",
          "args": [
            "alarm",
            "absexp"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_start_relative",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "376-382",
          "snippet": "void alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->get_ktime());\n\talarm_start(alarm, start);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->get_ktime());\n\talarm_start(alarm, start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp,\n\t\t\t\tenum alarmtimer_type type)\n{\n\tstruct restart_block *restart;\n\talarm->data = (void *)current;\n\tdo {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\talarm_start(alarm, absexp);\n\t\tif (likely(alarm->data))\n\t\t\tschedule();\n\n\t\talarm_cancel(alarm);\n\t} while (alarm->data && !signal_pending(current));\n\n\t__set_current_state(TASK_RUNNING);\n\n\tdestroy_hrtimer_on_stack(&alarm->timer);\n\n\tif (!alarm->data)\n\t\treturn 0;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(absexp, type);\n\trestart = &current->restart_block;\n\tif (restart->nanosleep.type != TT_NONE) {\n\t\tstruct timespec64 rmt;\n\t\tktime_t rem;\n\n\t\trem = ktime_sub(absexp, alarm_bases[type].get_ktime());\n\n\t\tif (rem <= 0)\n\t\t\treturn 0;\n\t\trmt = ktime_to_timespec64(rem);\n\n\t\treturn nanosleep_copyout(restart, &rmt);\n\t}\n\treturn -ERESTART_RESTARTBLOCK;\n}"
  },
  {
    "function_name": "alarmtimer_nsleep_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "727-736",
    "snippet": "static enum alarmtimer_restart alarmtimer_nsleep_wakeup(struct alarm *alarm,\n\t\t\t\t\t\t\t\tktime_t now)\n{\n\tstruct task_struct *task = (struct task_struct *)alarm->data;\n\n\talarm->data = NULL;\n\tif (task)\n\t\twake_up_process(task);\n\treturn ALARMTIMER_NORESTART;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4215-4218",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_restart alarmtimer_nsleep_wakeup(struct alarm *alarm,\n\t\t\t\t\t\t\t\tktime_t now)\n{\n\tstruct task_struct *task = (struct task_struct *)alarm->data;\n\n\talarm->data = NULL;\n\tif (task)\n\t\twake_up_process(task);\n\treturn ALARMTIMER_NORESTART;\n}"
  },
  {
    "function_name": "alarm_timer_create",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "703-716",
    "snippet": "static int alarm_timer_create(struct k_itimer *new_timer)\n{\n\tenum  alarmtimer_type type;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EOPNOTSUPP;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\ttype = clock2alarm(new_timer->it_clock);\n\talarm_init(&new_timer->it.alarm.alarmtimer, type, alarm_handle_timer);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_init",
          "args": [
            "&new_timer->it.alarm.alarmtimer",
            "type",
            "alarm_handle_timer"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_init_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "785-792",
          "snippet": "static void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void\nalarm_init_on_stack(struct alarm *alarm, enum alarmtimer_type type,\n\t\t    enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init_on_stack(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t\t      HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock2alarm",
          "args": [
            "new_timer->it_clock"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "clock2alarm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "518-525",
          "snippet": "static enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_WAKE_ALARM"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/capability.c",
          "lines": "447-450",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "71-81",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarm_timer_create(struct k_itimer *new_timer)\n{\n\tenum  alarmtimer_type type;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EOPNOTSUPP;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\ttype = clock2alarm(new_timer->it_clock);\n\talarm_init(&new_timer->it.alarm.alarmtimer, type, alarm_handle_timer);\n\treturn 0;\n}"
  },
  {
    "function_name": "alarm_clock_get_ktime",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "687-695",
    "snippet": "static ktime_t alarm_clock_get_ktime(clockid_t which_clock)\n{\n\tstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\treturn base->get_ktime();\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "71-81",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock2alarm",
          "args": [
            "which_clock"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "clock2alarm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "518-525",
          "snippet": "static enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic ktime_t alarm_clock_get_ktime(clockid_t which_clock)\n{\n\tstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\treturn base->get_ktime();\n}"
  },
  {
    "function_name": "alarm_clock_get_timespec",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "669-679",
    "snippet": "static int alarm_clock_get_timespec(clockid_t which_clock, struct timespec64 *tp)\n{\n\tstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\tbase->get_timespec(tp);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "base->get_timespec",
          "args": [
            "tp"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "71-81",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clock2alarm",
          "args": [
            "which_clock"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "clock2alarm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "518-525",
          "snippet": "static enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarm_clock_get_timespec(clockid_t which_clock, struct timespec64 *tp)\n{\n\tstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\tbase->get_timespec(tp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "alarm_clock_getres",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "652-660",
    "snippet": "static int alarm_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = hrtimer_resolution;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "71-81",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarm_clock_getres(const clockid_t which_clock, struct timespec64 *tp)\n{\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -EINVAL;\n\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = hrtimer_resolution;\n\treturn 0;\n}"
  },
  {
    "function_name": "alarm_timer_arm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "631-643",
    "snippet": "static void alarm_timer_arm(struct k_itimer *timr, ktime_t expires,\n\t\t\t    bool absolute, bool sigev_none)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tif (!absolute)\n\t\texpires = ktime_add_safe(expires, base->get_ktime());\n\tif (sigev_none)\n\t\talarm->node.expires = expires;\n\telse\n\t\talarm_start(&timr->it.alarm.alarmtimer, expires);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_start",
          "args": [
            "&timr->it.alarm.alarmtimer",
            "expires"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_start_relative",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "376-382",
          "snippet": "void alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->get_ktime());\n\talarm_start(alarm, start);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->get_ktime());\n\talarm_start(alarm, start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "expires",
            "base->get_ktime()"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void alarm_timer_arm(struct k_itimer *timr, ktime_t expires,\n\t\t\t    bool absolute, bool sigev_none)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tif (!absolute)\n\t\texpires = ktime_add_safe(expires, base->get_ktime());\n\tif (sigev_none)\n\t\talarm->node.expires = expires;\n\telse\n\t\talarm_start(&timr->it.alarm.alarmtimer, expires);\n}"
  },
  {
    "function_name": "alarm_timer_wait_running",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "619-622",
    "snippet": "static void alarm_timer_wait_running(struct k_itimer *timr)\n{\n\thrtimer_cancel_wait_running(&timr->it.alarm.alarmtimer.timer);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cancel_wait_running",
          "args": [
            "&timr->it.alarm.alarmtimer.timer"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel_wait_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1393-1418",
          "snippet": "void hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarm_timer_wait_running(struct k_itimer *timr)\n{\n\thrtimer_cancel_wait_running(&timr->it.alarm.alarmtimer.timer);\n}"
  },
  {
    "function_name": "alarm_timer_try_to_cancel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "606-609",
    "snippet": "static int alarm_timer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn alarm_try_to_cancel(&timr->it.alarm.alarmtimer);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_try_to_cancel",
          "args": [
            "&timr->it.alarm.alarmtimer"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "405-419",
          "snippet": "int alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->get_ktime());\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nint alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->get_ktime());\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarm_timer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn alarm_try_to_cancel(&timr->it.alarm.alarmtimer);\n}"
  },
  {
    "function_name": "alarm_timer_remaining",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "595-600",
    "snippet": "static ktime_t alarm_timer_remaining(struct k_itimer *timr, ktime_t now)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\treturn ktime_sub(alarm->node.expires, now);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "alarm->node.expires",
            "now"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic ktime_t alarm_timer_remaining(struct k_itimer *timr, ktime_t now)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\treturn ktime_sub(alarm->node.expires, now);\n}"
  },
  {
    "function_name": "alarm_timer_forward",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "583-588",
    "snippet": "static s64 alarm_timer_forward(struct k_itimer *timr, ktime_t now)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\treturn alarm_forward(alarm, timr->it_interval, now);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_forward",
          "args": [
            "alarm",
            "timr->it_interval",
            "now"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_forward",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "441-470",
          "snippet": "u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nu64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic s64 alarm_timer_forward(struct k_itimer *timr, ktime_t now)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\treturn alarm_forward(alarm, timr->it_interval, now);\n}"
  },
  {
    "function_name": "alarm_timer_rearm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "570-576",
    "snippet": "static void alarm_timer_rearm(struct k_itimer *timr)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\ttimr->it_overrun += alarm_forward_now(alarm, timr->it_interval);\n\talarm_start(alarm, alarm->node.expires);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_start",
          "args": [
            "alarm",
            "alarm->node.expires"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_start_relative",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "376-382",
          "snippet": "void alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->get_ktime());\n\talarm_start(alarm, start);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->get_ktime());\n\talarm_start(alarm, start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm_forward_now",
          "args": [
            "alarm",
            "timr->it_interval"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_forward_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "473-478",
          "snippet": "u64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->get_ktime(), interval);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nu64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->get_ktime(), interval);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarm_timer_rearm(struct k_itimer *timr)\n{\n\tstruct alarm *alarm = &timr->it.alarm.alarmtimer;\n\n\ttimr->it_overrun += alarm_forward_now(alarm, timr->it_interval);\n\talarm_start(alarm, alarm->node.expires);\n}"
  },
  {
    "function_name": "alarm_handle_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "536-564",
    "snippet": "static enum alarmtimer_restart alarm_handle_timer(struct alarm *alarm,\n\t\t\t\t\t\t\tktime_t now)\n{\n\tstruct k_itimer *ptr = container_of(alarm, struct k_itimer,\n\t\t\t\t\t    it.alarm.alarmtimer);\n\tenum alarmtimer_restart result = ALARMTIMER_NORESTART;\n\tunsigned long flags;\n\tint si_private = 0;\n\n\tspin_lock_irqsave(&ptr->it_lock, flags);\n\n\tptr->it_active = 0;\n\tif (ptr->it_interval)\n\t\tsi_private = ++ptr->it_requeue_pending;\n\n\tif (posix_timer_event(ptr, si_private) && ptr->it_interval) {\n\t\t/*\n\t\t * Handle ignored signals and rearm the timer. This will go\n\t\t * away once we handle ignored signals proper.\n\t\t */\n\t\tptr->it_overrun += alarm_forward_now(alarm, ptr->it_interval);\n\t\t++ptr->it_requeue_pending;\n\t\tptr->it_active = 1;\n\t\tresult = ALARMTIMER_RESTART;\n\t}\n\tspin_unlock_irqrestore(&ptr->it_lock, flags);\n\n\treturn result;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ptr->it_lock",
            "flags"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm_forward_now",
          "args": [
            "alarm",
            "ptr->it_interval"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_forward_now",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "473-478",
          "snippet": "u64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->get_ktime(), interval);\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nu64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->get_ktime(), interval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_timer_event",
          "args": [
            "ptr",
            "si_private"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "336-357",
          "snippet": "int posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nint posix_timer_event(struct k_itimer *timr, int si_private)\n{\n\tenum pid_type type;\n\tint ret;\n\t/*\n\t * FIXME: if ->sigq is queued we can race with\n\t * dequeue_signal()->posixtimer_rearm().\n\t *\n\t * If dequeue_signal() sees the \"right\" value of\n\t * si_sys_private it calls posixtimer_rearm().\n\t * We re-queue ->sigq and drop ->it_lock().\n\t * posixtimer_rearm() locks the timer\n\t * and re-schedules it while ->sigq is pending.\n\t * Not really bad, but not that we want.\n\t */\n\ttimr->sigq->info.si_sys_private = si_private;\n\n\ttype = !(timr->it_sigev_notify & SIGEV_THREAD_ID) ? PIDTYPE_TGID : PIDTYPE_PID;\n\tret = send_sigqueue(timr->sigq, timr->it_pid, type);\n\t/* If we failed to send the signal the timer stops. */\n\treturn ret > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ptr->it_lock",
            "flags"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "alarm",
            "structk_itimer",
            "it.alarm.alarmtimer"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_restart alarm_handle_timer(struct alarm *alarm,\n\t\t\t\t\t\t\tktime_t now)\n{\n\tstruct k_itimer *ptr = container_of(alarm, struct k_itimer,\n\t\t\t\t\t    it.alarm.alarmtimer);\n\tenum alarmtimer_restart result = ALARMTIMER_NORESTART;\n\tunsigned long flags;\n\tint si_private = 0;\n\n\tspin_lock_irqsave(&ptr->it_lock, flags);\n\n\tptr->it_active = 0;\n\tif (ptr->it_interval)\n\t\tsi_private = ++ptr->it_requeue_pending;\n\n\tif (posix_timer_event(ptr, si_private) && ptr->it_interval) {\n\t\t/*\n\t\t * Handle ignored signals and rearm the timer. This will go\n\t\t * away once we handle ignored signals proper.\n\t\t */\n\t\tptr->it_overrun += alarm_forward_now(alarm, ptr->it_interval);\n\t\t++ptr->it_requeue_pending;\n\t\tptr->it_active = 1;\n\t\tresult = ALARMTIMER_RESTART;\n\t}\n\tspin_unlock_irqrestore(&ptr->it_lock, flags);\n\n\treturn result;\n}"
  },
  {
    "function_name": "clock2alarm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "518-525",
    "snippet": "static enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\n{\n\tif (clockid == CLOCK_REALTIME_ALARM)\n\t\treturn ALARM_REALTIME;\n\tif (clockid == CLOCK_BOOTTIME_ALARM)\n\t\treturn ALARM_BOOTTIME;\n\treturn -1;\n}"
  },
  {
    "function_name": "alarmtimer_freezerset",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "483-512",
    "snippet": "static void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tstruct alarm_base *base;\n\tunsigned long flags;\n\tktime_t delta;\n\n\tswitch(type) {\n\tcase ALARM_REALTIME:\n\t\tbase = &alarm_bases[ALARM_REALTIME];\n\t\ttype = ALARM_REALTIME_FREEZER;\n\t\tbreak;\n\tcase ALARM_BOOTTIME:\n\t\tbase = &alarm_bases[ALARM_BOOTTIME];\n\t\ttype = ALARM_BOOTTIME_FREEZER;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid alarm type: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tdelta = ktime_sub(absexp, base->get_ktime());\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tif (!freezer_delta || (delta < freezer_delta)) {\n\t\tfreezer_delta = delta;\n\t\tfreezer_expires = absexp;\n\t\tfreezer_alarmtype = type;\n\t}\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&freezer_delta_lock",
            "flags"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&freezer_delta_lock",
            "flags"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "absexp",
            "base->get_ktime()"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Invalid alarm type: %d\\n\"",
            "type"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tstruct alarm_base *base;\n\tunsigned long flags;\n\tktime_t delta;\n\n\tswitch(type) {\n\tcase ALARM_REALTIME:\n\t\tbase = &alarm_bases[ALARM_REALTIME];\n\t\ttype = ALARM_REALTIME_FREEZER;\n\t\tbreak;\n\tcase ALARM_BOOTTIME:\n\t\tbase = &alarm_bases[ALARM_BOOTTIME];\n\t\ttype = ALARM_BOOTTIME_FREEZER;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid alarm type: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tdelta = ktime_sub(absexp, base->get_ktime());\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tif (!freezer_delta || (delta < freezer_delta)) {\n\t\tfreezer_delta = delta;\n\t\tfreezer_expires = absexp;\n\t\tfreezer_alarmtype = type;\n\t}\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}"
  },
  {
    "function_name": "alarm_forward_now",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "473-478",
    "snippet": "u64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->get_ktime(), interval);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_forward",
          "args": [
            "alarm",
            "base->get_ktime()",
            "interval"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_forward",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "441-470",
          "snippet": "u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nu64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nu64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\treturn alarm_forward(alarm, base->get_ktime(), interval);\n}"
  },
  {
    "function_name": "alarm_forward",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "441-470",
    "snippet": "u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "alarm->node.expires",
            "interval"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "alarm->node.expires",
            "incr*overrun"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_divns",
          "args": [
            "delta",
            "incr"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_divns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "303-320",
          "snippet": "s64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (u32) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\ns64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tint sft = 0;\n\ts64 dclc;\n\tu64 tmp;\n\n\tdclc = ktime_to_ns(kt);\n\ttmp = dclc < 0 ? -dclc : dclc;\n\n\t/* Make sure the divisor is less than 2^32: */\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\ttmp >>= sft;\n\tdo_div(tmp, (u32) div);\n\treturn dclc < 0 ? -tmp : tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "interval"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta >= interval"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "now",
            "alarm->node.expires"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nu64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\n{\n\tu64 overrun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, alarm->node.expires);\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\toverrun = ktime_divns(delta, incr);\n\n\t\talarm->node.expires = ktime_add_ns(alarm->node.expires,\n\t\t\t\t\t\t\tincr*overrun);\n\n\t\tif (alarm->node.expires > now)\n\t\t\treturn overrun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\toverrun++;\n\t}\n\n\talarm->node.expires = ktime_add_safe(alarm->node.expires, interval);\n\treturn overrun;\n}"
  },
  {
    "function_name": "alarm_cancel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "429-437",
    "snippet": "int alarm_cancel(struct alarm *alarm)\n{\n\tfor (;;) {\n\t\tint ret = alarm_try_to_cancel(alarm);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\thrtimer_cancel_wait_running(&alarm->timer);\n\t}\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cancel_wait_running",
          "args": [
            "&alarm->timer"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_cancel_wait_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1393-1418",
          "snippet": "void hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_cancel_wait_running(const struct hrtimer *timer)\n{\n\t/* Lockless read. Prevent the compiler from reloading it below */\n\tstruct hrtimer_clock_base *base = READ_ONCE(timer->base);\n\n\t/*\n\t * Just relax if the timer expires in hard interrupt context or if\n\t * it is currently on the migration base.\n\t */\n\tif (!timer->is_soft || is_migration_base(base)) {\n\t\tcpu_relax();\n\t\treturn;\n\t}\n\n\t/*\n\t * Mark the base as contended and grab the expiry lock, which is\n\t * held by the softirq across the timer callback. Drop the lock\n\t * immediately so the softirq can expire the next timer. In theory\n\t * the timer could already be running again, but that's more than\n\t * unlikely and just causes another wait loop.\n\t */\n\tatomic_inc(&base->cpu_base->timer_waiters);\n\tspin_lock_bh(&base->cpu_base->softirq_expiry_lock);\n\tatomic_dec(&base->cpu_base->timer_waiters);\n\tspin_unlock_bh(&base->cpu_base->softirq_expiry_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm_try_to_cancel",
          "args": [
            "alarm"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "405-419",
          "snippet": "int alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->get_ktime());\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nint alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->get_ktime());\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nint alarm_cancel(struct alarm *alarm)\n{\n\tfor (;;) {\n\t\tint ret = alarm_try_to_cancel(alarm);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\thrtimer_cancel_wait_running(&alarm->timer);\n\t}\n}"
  },
  {
    "function_name": "alarm_try_to_cancel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "405-419",
    "snippet": "int alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->get_ktime());\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_alarmtimer_cancel",
          "args": [
            "alarm",
            "base->get_ktime()"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_dequeue",
          "args": [
            "base",
            "alarm"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_dequeue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "178-185",
          "snippet": "static void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&alarm->timer"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "823-826",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nint alarm_try_to_cancel(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tret = hrtimer_try_to_cancel(&alarm->timer);\n\tif (ret >= 0)\n\t\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_cancel(alarm, base->get_ktime());\n\treturn ret;\n}"
  },
  {
    "function_name": "alarm_restart",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "385-395",
    "snippet": "void alarm_restart(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\thrtimer_set_expires(&alarm->timer, alarm->node.expires);\n\thrtimer_restart(&alarm->timer);\n\talarmtimer_enqueue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_enqueue",
          "args": [
            "base",
            "alarm"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "160-167",
          "snippet": "static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_restart",
          "args": [
            "&alarm->timer"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mux_hrtimer_restart",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/core.c",
          "lines": "1175-1194",
          "snippet": "static int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED_HARD);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/buildid.h>",
            "#include <linux/pgtable.h>",
            "#include <linux/highmem.h>",
            "#include <linux/min_heap.h>",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static __must_check struct",
            "static void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);",
            "static bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);",
            "static void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/buildid.h>\n#include <linux/pgtable.h>\n#include <linux/highmem.h>\n#include <linux/min_heap.h>\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hugetlb.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic __must_check struct;\nstatic void event_sched_out(struct perf_event *event,\n\t\t\t    struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx);\nstatic bool exclusive_event_installable(struct perf_event *event,\n\t\t\t\t\tstruct perf_event_context *ctx);\nstatic void perf_event_exit_event(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx);\n\nstatic int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED_HARD);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&alarm->timer",
            "alarm->node.expires"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_restart(struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\thrtimer_set_expires(&alarm->timer, alarm->node.expires);\n\thrtimer_restart(&alarm->timer);\n\talarmtimer_enqueue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n}"
  },
  {
    "function_name": "alarm_start_relative",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "376-382",
    "snippet": "void alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->get_ktime());\n\talarm_start(alarm, start);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alarm_start",
          "args": [
            "alarm",
            "start"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "alarm_start_relative",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "376-382",
          "snippet": "void alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->get_ktime());\n\talarm_start(alarm, start);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ktime_add_safe",
          "args": [
            "start",
            "base->get_ktime()"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_start_relative(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\n\tstart = ktime_add_safe(start, base->get_ktime());\n\talarm_start(alarm, start);\n}"
  },
  {
    "function_name": "alarm_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "356-368",
    "snippet": "void alarm_start(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\talarm->node.expires = start;\n\talarmtimer_enqueue(base, alarm);\n\thrtimer_start(&alarm->timer, alarm->node.expires, HRTIMER_MODE_ABS);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_start(alarm, base->get_ktime());\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_alarmtimer_start",
          "args": [
            "alarm",
            "base->get_ktime()"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&alarm->timer",
            "alarm->node.expires",
            "HRTIMER_MODE_ABS"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_enqueue",
          "args": [
            "base",
            "alarm"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "160-167",
          "snippet": "static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_start(struct alarm *alarm, ktime_t start)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\talarm->node.expires = start;\n\talarmtimer_enqueue(base, alarm);\n\thrtimer_start(&alarm->timer, alarm->node.expires, HRTIMER_MODE_ABS);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_start(alarm, base->get_ktime());\n}"
  },
  {
    "function_name": "alarm_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "342-348",
    "snippet": "void alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t\tenum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t     HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alarm_init",
          "args": [
            "alarm",
            "type",
            "function"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__alarm_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "325-334",
          "snippet": "static void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&alarm->timer",
            "alarm_bases[type].base_clockid",
            "HRTIMER_MODE_ABS"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nvoid alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t\tenum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\thrtimer_init(&alarm->timer, alarm_bases[type].base_clockid,\n\t\t     HRTIMER_MODE_ABS);\n\t__alarm_init(alarm, type, function);\n}"
  },
  {
    "function_name": "__alarm_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "325-334",
    "snippet": "static void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_init",
          "args": [
            "&alarm->node"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void\n__alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t     enum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->node);\n\talarm->timer.function = alarmtimer_fired;\n\talarm->function = function;\n\talarm->type = type;\n\talarm->state = ALARMTIMER_STATE_INACTIVE;\n}"
  },
  {
    "function_name": "alarmtimer_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "319-322",
    "snippet": "static int alarmtimer_resume(struct device *dev)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarmtimer_resume(struct device *dev)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "alarmtimer_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "314-317",
    "snippet": "static int alarmtimer_suspend(struct device *dev)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarmtimer_suspend(struct device *dev)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "alarmtimer_resume",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "303-311",
    "snippet": "static int alarmtimer_resume(struct device *dev)\n{\n\tstruct rtc_device *rtc;\n\n\trtc = alarmtimer_get_rtcdev();\n\tif (rtc)\n\t\trtc_timer_cancel(rtc, &rtctimer);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_timer_cancel",
          "args": [
            "rtc",
            "&rtctimer"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "71-81",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarmtimer_resume(struct device *dev)\n{\n\tstruct rtc_device *rtc;\n\n\trtc = alarmtimer_get_rtcdev();\n\tif (rtc)\n\t\trtc_timer_cancel(rtc, &rtctimer);\n\treturn 0;\n}"
  },
  {
    "function_name": "alarmtimer_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "242-301",
    "snippet": "static int alarmtimer_suspend(struct device *dev)\n{\n\tktime_t min, now, expires;\n\tint i, ret, type;\n\tstruct rtc_device *rtc;\n\tunsigned long flags;\n\tstruct rtc_time tm;\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tmin = freezer_delta;\n\texpires = freezer_expires;\n\ttype = freezer_alarmtype;\n\tfreezer_delta = 0;\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n\n\trtc = alarmtimer_get_rtcdev();\n\t/* If we have no rtcdev, just return */\n\tif (!rtc)\n\t\treturn 0;\n\n\t/* Find the soonest timer to expire*/\n\tfor (i = 0; i < ALARM_NUMTYPE; i++) {\n\t\tstruct alarm_base *base = &alarm_bases[i];\n\t\tstruct timerqueue_node *next;\n\t\tktime_t delta;\n\n\t\tspin_lock_irqsave(&base->lock, flags);\n\t\tnext = timerqueue_getnext(&base->timerqueue);\n\t\tspin_unlock_irqrestore(&base->lock, flags);\n\t\tif (!next)\n\t\t\tcontinue;\n\t\tdelta = ktime_sub(next->expires, base->get_ktime());\n\t\tif (!min || (delta < min)) {\n\t\t\texpires = next->expires;\n\t\t\tmin = delta;\n\t\t\ttype = i;\n\t\t}\n\t}\n\tif (min == 0)\n\t\treturn 0;\n\n\tif (ktime_to_ns(min) < 2 * NSEC_PER_SEC) {\n\t\tpm_wakeup_event(dev, 2 * MSEC_PER_SEC);\n\t\treturn -EBUSY;\n\t}\n\n\ttrace_alarmtimer_suspend(expires, type);\n\n\t/* Setup an rtc timer to fire that far in the future */\n\trtc_timer_cancel(rtc, &rtctimer);\n\trtc_read_time(rtc, &tm);\n\tnow = rtc_tm_to_ktime(tm);\n\tnow = ktime_add(now, min);\n\n\t/* Set alarm, if in the past reject suspend briefly to handle */\n\tret = rtc_timer_start(rtc, &rtctimer, now, 0);\n\tif (ret < 0)\n\t\tpm_wakeup_event(dev, MSEC_PER_SEC);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_wakeup_event",
          "args": [
            "dev",
            "MSEC_PER_SEC"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_timer_start",
          "args": [
            "rtc",
            "&rtctimer",
            "now",
            "0"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add",
          "args": [
            "now",
            "min"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_add_safe",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "327-339",
          "snippet": "ktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add_unsafe(lhs, rhs);\n\n\t/*\n\t * We use KTIME_SEC_MAX here, the maximum timeout which we can\n\t * return to user space in a timespec:\n\t */\n\tif (res < 0 || res < lhs || res < rhs)\n\t\tres = ktime_set(KTIME_SEC_MAX, 0);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_tm_to_ktime",
          "args": [
            "tm"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_read_time",
          "args": [
            "rtc",
            "&tm"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_timer_cancel",
          "args": [
            "rtc",
            "&rtctimer"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_alarmtimer_suspend",
          "args": [
            "expires",
            "type"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_wakeup_event",
          "args": [
            "dev",
            "2 * MSEC_PER_SEC"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "min"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "next->expires",
            "base->get_ktime()"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&base->timerqueue"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_get_rtcdev",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_get_rtcdev",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "71-81",
          "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic int alarmtimer_suspend(struct device *dev)\n{\n\tktime_t min, now, expires;\n\tint i, ret, type;\n\tstruct rtc_device *rtc;\n\tunsigned long flags;\n\tstruct rtc_time tm;\n\n\tspin_lock_irqsave(&freezer_delta_lock, flags);\n\tmin = freezer_delta;\n\texpires = freezer_expires;\n\ttype = freezer_alarmtype;\n\tfreezer_delta = 0;\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n\n\trtc = alarmtimer_get_rtcdev();\n\t/* If we have no rtcdev, just return */\n\tif (!rtc)\n\t\treturn 0;\n\n\t/* Find the soonest timer to expire*/\n\tfor (i = 0; i < ALARM_NUMTYPE; i++) {\n\t\tstruct alarm_base *base = &alarm_bases[i];\n\t\tstruct timerqueue_node *next;\n\t\tktime_t delta;\n\n\t\tspin_lock_irqsave(&base->lock, flags);\n\t\tnext = timerqueue_getnext(&base->timerqueue);\n\t\tspin_unlock_irqrestore(&base->lock, flags);\n\t\tif (!next)\n\t\t\tcontinue;\n\t\tdelta = ktime_sub(next->expires, base->get_ktime());\n\t\tif (!min || (delta < min)) {\n\t\t\texpires = next->expires;\n\t\t\tmin = delta;\n\t\t\ttype = i;\n\t\t}\n\t}\n\tif (min == 0)\n\t\treturn 0;\n\n\tif (ktime_to_ns(min) < 2 * NSEC_PER_SEC) {\n\t\tpm_wakeup_event(dev, 2 * MSEC_PER_SEC);\n\t\treturn -EBUSY;\n\t}\n\n\ttrace_alarmtimer_suspend(expires, type);\n\n\t/* Setup an rtc timer to fire that far in the future */\n\trtc_timer_cancel(rtc, &rtctimer);\n\trtc_read_time(rtc, &tm);\n\tnow = rtc_tm_to_ktime(tm);\n\tnow = ktime_add(now, min);\n\n\t/* Set alarm, if in the past reject suspend briefly to handle */\n\tret = rtc_timer_start(rtc, &rtctimer, now, 0);\n\tif (ret < 0)\n\t\tpm_wakeup_event(dev, MSEC_PER_SEC);\n\treturn ret;\n}"
  },
  {
    "function_name": "alarm_expires_remaining",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "225-229",
    "snippet": "ktime_t alarm_expires_remaining(const struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\treturn ktime_sub(alarm->node.expires, base->get_ktime());\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "alarm->node.expires",
            "base->get_ktime()"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nktime_t alarm_expires_remaining(const struct alarm *alarm)\n{\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\treturn ktime_sub(alarm->node.expires, base->get_ktime());\n}"
  },
  {
    "function_name": "alarmtimer_fired",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "197-223",
    "snippet": "static enum hrtimer_restart alarmtimer_fired(struct hrtimer *timer)\n{\n\tstruct alarm *alarm = container_of(timer, struct alarm, timer);\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret = HRTIMER_NORESTART;\n\tint restart = ALARMTIMER_NORESTART;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\tif (alarm->function)\n\t\trestart = alarm->function(alarm, base->get_ktime());\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tif (restart != ALARMTIMER_NORESTART) {\n\t\thrtimer_set_expires(&alarm->timer, alarm->node.expires);\n\t\talarmtimer_enqueue(base, alarm);\n\t\tret = HRTIMER_RESTART;\n\t}\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_fired(alarm, base->get_ktime());\n\treturn ret;\n\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_alarmtimer_fired",
          "args": [
            "alarm",
            "base->get_ktime()"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarmtimer_enqueue",
          "args": [
            "base",
            "alarm"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "160-167",
          "snippet": "static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&alarm->timer",
            "alarm->node.expires"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alarm->function",
          "args": [
            "alarm",
            "base->get_ktime()"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "base->get_ktime",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alarmtimer_dequeue",
          "args": [
            "base",
            "alarm"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "alarmtimer_dequeue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
          "lines": "178-185",
          "snippet": "static void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}",
          "includes": [
            "#include <trace/events/alarmtimer.h>",
            "#include \"posix-timers.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/platform_device.h>",
            "#include <linux/mutex.h>",
            "#include <linux/alarmtimer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/rtc.h>",
            "#include <linux/timerqueue.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structalarm",
            "timer"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic struct alarm_base {\n\tspinlock_t\t\tlock;\n\tstruct timerqueue_head\ttimerqueue;\n\tktime_t\t\t\t(*get_ktime)(void);\n\tvoid\t\t\t(*get_timespec)(struct timespec64 *tp);\n\tclockid_t\t\tbase_clockid;\n} alarm_bases[ALARM_NUMTYPE];\n\nstatic enum hrtimer_restart alarmtimer_fired(struct hrtimer *timer)\n{\n\tstruct alarm *alarm = container_of(timer, struct alarm, timer);\n\tstruct alarm_base *base = &alarm_bases[alarm->type];\n\tunsigned long flags;\n\tint ret = HRTIMER_NORESTART;\n\tint restart = ALARMTIMER_NORESTART;\n\n\tspin_lock_irqsave(&base->lock, flags);\n\talarmtimer_dequeue(base, alarm);\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\tif (alarm->function)\n\t\trestart = alarm->function(alarm, base->get_ktime());\n\n\tspin_lock_irqsave(&base->lock, flags);\n\tif (restart != ALARMTIMER_NORESTART) {\n\t\thrtimer_set_expires(&alarm->timer, alarm->node.expires);\n\t\talarmtimer_enqueue(base, alarm);\n\t\tret = HRTIMER_RESTART;\n\t}\n\tspin_unlock_irqrestore(&base->lock, flags);\n\n\ttrace_alarmtimer_fired(alarm, base->get_ktime());\n\treturn ret;\n\n}"
  },
  {
    "function_name": "alarmtimer_dequeue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "178-185",
    "snippet": "static void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_del",
          "args": [
            "&base->timerqueue",
            "&alarm->node"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\n\t\treturn;\n\n\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\talarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\n}"
  },
  {
    "function_name": "alarmtimer_enqueue",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "160-167",
    "snippet": "static void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timerqueue_add",
          "args": [
            "&base->timerqueue",
            "&alarm->node"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_del",
          "args": [
            "&base->timerqueue",
            "&alarm->node"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\n{\n\tif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\n\t\ttimerqueue_del(&base->timerqueue, &alarm->node);\n\n\ttimerqueue_add(&base->timerqueue, &alarm->node);\n\talarm->state |= ALARMTIMER_STATE_ENQUEUED;\n}"
  },
  {
    "function_name": "alarmtimer_rtc_timer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "148-148",
    "snippet": "static inline void alarmtimer_rtc_timer_init(void) { }",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline void alarmtimer_rtc_timer_init(void) { }"
  },
  {
    "function_name": "alarmtimer_rtc_interface_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "147-147",
    "snippet": "static inline void alarmtimer_rtc_interface_remove(void) { }",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline void alarmtimer_rtc_interface_remove(void) { }"
  },
  {
    "function_name": "alarmtimer_rtc_interface_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "146-146",
    "snippet": "static inline int alarmtimer_rtc_interface_setup(void) { return 0; }",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline int alarmtimer_rtc_interface_setup(void) { return 0; }"
  },
  {
    "function_name": "alarmtimer_rtc_interface_remove",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "141-144",
    "snippet": "static void alarmtimer_rtc_interface_remove(void)\n{\n\tclass_interface_unregister(&alarmtimer_rtc_interface);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_interface_unregister",
          "args": [
            "&alarmtimer_rtc_interface"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic void alarmtimer_rtc_interface_remove(void)\n{\n\tclass_interface_unregister(&alarmtimer_rtc_interface);\n}"
  },
  {
    "function_name": "alarmtimer_rtc_interface_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "136-140",
    "snippet": "static int alarmtimer_rtc_interface_setup(void)\n{\n\talarmtimer_rtc_interface.class = rtc_class;\n\treturn class_interface_register(&alarmtimer_rtc_interface);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "class_interface_register",
          "args": [
            "&alarmtimer_rtc_interface"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarmtimer_rtc_interface_setup(void)\n{\n\talarmtimer_rtc_interface.class = rtc_class;\n\treturn class_interface_register(&alarmtimer_rtc_interface);\n}"
  },
  {
    "function_name": "alarmtimer_rtc_timer_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "127-130",
    "snippet": "static inline void alarmtimer_rtc_timer_init(void)\n{\n\trtc_timer_init(&rtctimer, NULL, NULL);\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_timer_init",
          "args": [
            "&rtctimer",
            "NULL",
            "NULL"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic inline void alarmtimer_rtc_timer_init(void)\n{\n\trtc_timer_init(&rtctimer, NULL, NULL);\n}"
  },
  {
    "function_name": "alarmtimer_rtc_add_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "84-125",
    "snippet": "static int alarmtimer_rtc_add_device(struct device *dev,\n\t\t\t\tstruct class_interface *class_intf)\n{\n\tunsigned long flags;\n\tstruct rtc_device *rtc = to_rtc_device(dev);\n\tstruct platform_device *pdev;\n\tint ret = 0;\n\n\tif (rtcdev)\n\t\treturn -EBUSY;\n\n\tif (!test_bit(RTC_FEATURE_ALARM, rtc->features))\n\t\treturn -1;\n\tif (!device_may_wakeup(rtc->dev.parent))\n\t\treturn -1;\n\n\tpdev = platform_device_register_data(dev, \"alarmtimer\",\n\t\t\t\t\t     PLATFORM_DEVID_AUTO, NULL, 0);\n\tif (!IS_ERR(pdev))\n\t\tdevice_init_wakeup(&pdev->dev, true);\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tif (!IS_ERR(pdev) && !rtcdev) {\n\t\tif (!try_module_get(rtc->owner)) {\n\t\t\tret = -1;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\trtcdev = rtc;\n\t\t/* hold a reference so it doesn't go away */\n\t\tget_device(dev);\n\t\tpdev = NULL;\n\t} else {\n\t\tret = -1;\n\t}\nunlock:\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\tplatform_device_unregister(pdev);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "platform_device_unregister",
          "args": [
            "pdev"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtcdev_lock",
            "flags"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_device",
          "args": [
            "dev"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-common.c",
          "lines": "63-66",
          "snippet": "struct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <trace/events/power.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/nmi.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <trace/events/power.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/nmi.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "rtc->owner"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "1068-1084",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pdev"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rtcdev_lock",
            "flags"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_init_wakeup",
          "args": [
            "&pdev->dev",
            "true"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pdev"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "platform_device_register_data",
          "args": [
            "dev",
            "\"alarmtimer\"",
            "PLATFORM_DEVID_AUTO",
            "NULL",
            "0"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_may_wakeup",
          "args": [
            "rtc->dev.parent"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RTC_FEATURE_ALARM",
            "rtc->features"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_rtc_device",
          "args": [
            "dev"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstatic int alarmtimer_rtc_add_device(struct device *dev,\n\t\t\t\tstruct class_interface *class_intf)\n{\n\tunsigned long flags;\n\tstruct rtc_device *rtc = to_rtc_device(dev);\n\tstruct platform_device *pdev;\n\tint ret = 0;\n\n\tif (rtcdev)\n\t\treturn -EBUSY;\n\n\tif (!test_bit(RTC_FEATURE_ALARM, rtc->features))\n\t\treturn -1;\n\tif (!device_may_wakeup(rtc->dev.parent))\n\t\treturn -1;\n\n\tpdev = platform_device_register_data(dev, \"alarmtimer\",\n\t\t\t\t\t     PLATFORM_DEVID_AUTO, NULL, 0);\n\tif (!IS_ERR(pdev))\n\t\tdevice_init_wakeup(&pdev->dev, true);\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tif (!IS_ERR(pdev) && !rtcdev) {\n\t\tif (!try_module_get(rtc->owner)) {\n\t\t\tret = -1;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\trtcdev = rtc;\n\t\t/* hold a reference so it doesn't go away */\n\t\tget_device(dev);\n\t\tpdev = NULL;\n\t} else {\n\t\tret = -1;\n\t}\nunlock:\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\tplatform_device_unregister(pdev);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "alarmtimer_get_rtcdev",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/alarmtimer.c",
    "lines": "71-81",
    "snippet": "struct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/alarmtimer.h>",
      "#include \"posix-timers.h\"",
      "#include <linux/time_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/compat.h>",
      "#include <linux/freezer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/platform_device.h>",
      "#include <linux/mutex.h>",
      "#include <linux/alarmtimer.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/rtc.h>",
      "#include <linux/timerqueue.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rtcdev_lock",
            "flags"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rtcdev_lock",
            "flags"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/alarmtimer.h>\n#include \"posix-timers.h\"\n#include <linux/time_namespace.h>\n#include <linux/module.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/workqueue.h>\n#include <linux/posix-timers.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/alarmtimer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/rtc.h>\n#include <linux/timerqueue.h>\n#include <linux/hrtimer.h>\n#include <linux/time.h>\n\nstruct rtc_device *alarmtimer_get_rtcdev(void)\n{\n\tunsigned long flags;\n\tstruct rtc_device *ret;\n\n\tspin_lock_irqsave(&rtcdev_lock, flags);\n\tret = rtcdev;\n\tspin_unlock_irqrestore(&rtcdev_lock, flags);\n\n\treturn ret;\n}"
  }
]