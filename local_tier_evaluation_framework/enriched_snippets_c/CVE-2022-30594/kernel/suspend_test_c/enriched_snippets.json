[
  {
    "function_name": "test_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend_test.c",
    "lines": "179-218",
    "snippet": "static int __init test_suspend(void)\n{\n\tstatic char\t\twarn_no_rtc[] __initdata =\n\t\tKERN_WARNING \"PM: no wakealarm-capable RTC driver is ready\\n\";\n\n\tstruct rtc_device\t*rtc = NULL;\n\tstruct device\t\t*dev;\n\tsuspend_state_t test_state;\n\n\t/* PM is initialized by now; is that state testable? */\n\tif (!test_state_label)\n\t\treturn 0;\n\n\tfor (test_state = PM_SUSPEND_MIN; test_state < PM_SUSPEND_MAX; test_state++) {\n\t\tconst char *state_label = pm_states[test_state];\n\n\t\tif (state_label && !strcmp(test_state_label, state_label))\n\t\t\tbreak;\n\t}\n\tif (test_state == PM_SUSPEND_MAX) {\n\t\tprintk(warn_bad_state, test_state_label);\n\t\treturn 0;\n\t}\n\n\t/* RTCs have initialized by now too ... can we use one? */\n\tdev = class_find_device(rtc_class, NULL, NULL, has_wakealarm);\n\tif (dev) {\n\t\trtc = rtc_class_open(dev_name(dev));\n\t\tput_device(dev);\n\t}\n\tif (!rtc) {\n\t\tprintk(warn_no_rtc);\n\t\treturn 0;\n\t}\n\n\t/* go for it */\n\ttest_wakealarm(rtc, test_state);\n\trtc_class_close(rtc);\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/rtc.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *test_state_label",
      "static char warn_bad_state[]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_class_close",
          "args": [
            "rtc"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_wakealarm",
          "args": [
            "rtc",
            "test_state"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "test_wakealarm",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend_test.c",
          "lines": "62-126",
          "snippet": "static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)\n{\n\tstatic char err_readtime[] __initdata =\n\t\tKERN_ERR \"PM: can't read %s time, err %d\\n\";\n\tstatic char err_wakealarm [] __initdata =\n\t\tKERN_ERR \"PM: can't set %s wakealarm, err %d\\n\";\n\tstatic char err_suspend[] __initdata =\n\t\tKERN_ERR \"PM: suspend test failed, error %d\\n\";\n\tstatic char info_test[] __initdata =\n\t\tKERN_INFO \"PM: test RTC wakeup from '%s' suspend\\n\";\n\n\ttime64_t\t\tnow;\n\tstruct rtc_wkalrm\talm;\n\tint\t\t\tstatus;\n\n\t/* this may fail if the RTC hasn't been initialized */\nrepeat:\n\tstatus = rtc_read_time(rtc, &alm.time);\n\tif (status < 0) {\n\t\tprintk(err_readtime, dev_name(&rtc->dev), status);\n\t\treturn;\n\t}\n\tnow = rtc_tm_to_time64(&alm.time);\n\n\tmemset(&alm, 0, sizeof alm);\n\trtc_time64_to_tm(now + TEST_SUSPEND_SECONDS, &alm.time);\n\talm.enabled = true;\n\n\tstatus = rtc_set_alarm(rtc, &alm);\n\tif (status < 0) {\n\t\tprintk(err_wakealarm, dev_name(&rtc->dev), status);\n\t\treturn;\n\t}\n\n\tif (state == PM_SUSPEND_MEM) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t\tif (status == -ENODEV)\n\t\t\tstate = PM_SUSPEND_STANDBY;\n\t}\n\tif (state == PM_SUSPEND_STANDBY) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t\tif (status < 0)\n\t\t\tstate = PM_SUSPEND_TO_IDLE;\n\t}\n\tif (state == PM_SUSPEND_TO_IDLE) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t}\n\n\tif (status < 0)\n\t\tprintk(err_suspend, status);\n\n\ttest_repeat_count_current++;\n\tif (test_repeat_count_current < test_repeat_count_max)\n\t\tgoto repeat;\n\n\t/* Some platforms can't detect that the alarm triggered the\n\t * wakeup, or (accordingly) disable it after it afterwards.\n\t * It's supposed to give oneshot behavior; cope.\n\t */\n\talm.enabled = false;\n\trtc_set_alarm(rtc, &alm);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/rtc.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define TEST_SUSPEND_SECONDS\t10"
          ],
          "globals_used": [
            "static u32 test_repeat_count_max = 1;",
            "static u32 test_repeat_count_current;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/rtc.h>\n#include <linux/init.h>\n\n#define TEST_SUSPEND_SECONDS\t10\n\nstatic u32 test_repeat_count_max = 1;\nstatic u32 test_repeat_count_current;\n\nstatic void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)\n{\n\tstatic char err_readtime[] __initdata =\n\t\tKERN_ERR \"PM: can't read %s time, err %d\\n\";\n\tstatic char err_wakealarm [] __initdata =\n\t\tKERN_ERR \"PM: can't set %s wakealarm, err %d\\n\";\n\tstatic char err_suspend[] __initdata =\n\t\tKERN_ERR \"PM: suspend test failed, error %d\\n\";\n\tstatic char info_test[] __initdata =\n\t\tKERN_INFO \"PM: test RTC wakeup from '%s' suspend\\n\";\n\n\ttime64_t\t\tnow;\n\tstruct rtc_wkalrm\talm;\n\tint\t\t\tstatus;\n\n\t/* this may fail if the RTC hasn't been initialized */\nrepeat:\n\tstatus = rtc_read_time(rtc, &alm.time);\n\tif (status < 0) {\n\t\tprintk(err_readtime, dev_name(&rtc->dev), status);\n\t\treturn;\n\t}\n\tnow = rtc_tm_to_time64(&alm.time);\n\n\tmemset(&alm, 0, sizeof alm);\n\trtc_time64_to_tm(now + TEST_SUSPEND_SECONDS, &alm.time);\n\talm.enabled = true;\n\n\tstatus = rtc_set_alarm(rtc, &alm);\n\tif (status < 0) {\n\t\tprintk(err_wakealarm, dev_name(&rtc->dev), status);\n\t\treturn;\n\t}\n\n\tif (state == PM_SUSPEND_MEM) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t\tif (status == -ENODEV)\n\t\t\tstate = PM_SUSPEND_STANDBY;\n\t}\n\tif (state == PM_SUSPEND_STANDBY) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t\tif (status < 0)\n\t\t\tstate = PM_SUSPEND_TO_IDLE;\n\t}\n\tif (state == PM_SUSPEND_TO_IDLE) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t}\n\n\tif (status < 0)\n\t\tprintk(err_suspend, status);\n\n\ttest_repeat_count_current++;\n\tif (test_repeat_count_current < test_repeat_count_max)\n\t\tgoto repeat;\n\n\t/* Some platforms can't detect that the alarm triggered the\n\t * wakeup, or (accordingly) disable it after it afterwards.\n\t * It's supposed to give oneshot behavior; cope.\n\t */\n\talm.enabled = false;\n\trtc_set_alarm(rtc, &alm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "warn_no_rtc"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_device",
          "args": [
            "dev"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_class_open",
          "args": [
            "dev_name(dev)"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "dev"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "class_find_device",
          "args": [
            "rtc_class",
            "NULL",
            "NULL",
            "has_wakealarm"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "warn_bad_state",
            "test_state_label"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "test_state_label",
            "state_label"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/rtc.h>\n#include <linux/init.h>\n\nstatic const char *test_state_label;\nstatic char warn_bad_state[];\n\nstatic int __init test_suspend(void)\n{\n\tstatic char\t\twarn_no_rtc[] __initdata =\n\t\tKERN_WARNING \"PM: no wakealarm-capable RTC driver is ready\\n\";\n\n\tstruct rtc_device\t*rtc = NULL;\n\tstruct device\t\t*dev;\n\tsuspend_state_t test_state;\n\n\t/* PM is initialized by now; is that state testable? */\n\tif (!test_state_label)\n\t\treturn 0;\n\n\tfor (test_state = PM_SUSPEND_MIN; test_state < PM_SUSPEND_MAX; test_state++) {\n\t\tconst char *state_label = pm_states[test_state];\n\n\t\tif (state_label && !strcmp(test_state_label, state_label))\n\t\t\tbreak;\n\t}\n\tif (test_state == PM_SUSPEND_MAX) {\n\t\tprintk(warn_bad_state, test_state_label);\n\t\treturn 0;\n\t}\n\n\t/* RTCs have initialized by now too ... can we use one? */\n\tdev = class_find_device(rtc_class, NULL, NULL, has_wakealarm);\n\tif (dev) {\n\t\trtc = rtc_class_open(dev_name(dev));\n\t\tput_device(dev);\n\t}\n\tif (!rtc) {\n\t\tprintk(warn_no_rtc);\n\t\treturn 0;\n\t}\n\n\t/* go for it */\n\ttest_wakealarm(rtc, test_state);\n\trtc_class_close(rtc);\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_test_suspend",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend_test.c",
    "lines": "150-176",
    "snippet": "static int __init setup_test_suspend(char *value)\n{\n\tint i;\n\tchar *repeat;\n\tchar *suspend_type;\n\n\t/* example : \"=mem[,N]\" ==> \"mem[,N]\" */\n\tvalue++;\n\tsuspend_type = strsep(&value, \",\");\n\tif (!suspend_type)\n\t\treturn 0;\n\n\trepeat = strsep(&value, \",\");\n\tif (repeat) {\n\t\tif (kstrtou32(repeat, 0, &test_repeat_count_max))\n\t\t\treturn 0;\n\t}\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (!strcmp(pm_labels[i], suspend_type)) {\n\t\t\ttest_state_label = pm_labels[i];\n\t\t\treturn 0;\n\t\t}\n\n\tprintk(warn_bad_state, suspend_type);\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/rtc.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 test_repeat_count_max = 1;",
      "static const char *test_state_label",
      "static char warn_bad_state[]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "warn_bad_state",
            "suspend_type"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "pm_labels[i]",
            "suspend_type"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "sym_strcmp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/report.c",
          "lines": "356-365",
          "snippet": "static int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}",
          "includes": [
            "#include \"encoding.h\"",
            "#include \"kcsan.h\"",
            "#include <linux/stacktrace.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/printk.h>",
            "#include <linux/preempt.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"encoding.h\"\n#include \"kcsan.h\"\n#include <linux/stacktrace.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/printk.h>\n#include <linux/preempt.h>\n#include <linux/lockdep.h>\n#include <linux/kernel.h>\n#include <linux/kallsyms.h>\n#include <linux/jiffies.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n\nstatic int sym_strcmp(void *addr1, void *addr2)\n{\n\tchar buf1[64];\n\tchar buf2[64];\n\n\tsnprintf(buf1, sizeof(buf1), \"%pS\", addr1);\n\tsnprintf(buf2, sizeof(buf2), \"%pS\", addr2);\n\n\treturn strncmp(buf1, buf2, sizeof(buf1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtou32",
          "args": [
            "repeat",
            "0",
            "&test_repeat_count_max"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&value",
            "\",\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&value",
            "\",\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/rtc.h>\n#include <linux/init.h>\n\nstatic u32 test_repeat_count_max = 1;\nstatic const char *test_state_label;\nstatic char warn_bad_state[];\n\nstatic int __init setup_test_suspend(char *value)\n{\n\tint i;\n\tchar *repeat;\n\tchar *suspend_type;\n\n\t/* example : \"=mem[,N]\" ==> \"mem[,N]\" */\n\tvalue++;\n\tsuspend_type = strsep(&value, \",\");\n\tif (!suspend_type)\n\t\treturn 0;\n\n\trepeat = strsep(&value, \",\");\n\tif (repeat) {\n\t\tif (kstrtou32(repeat, 0, &test_repeat_count_max))\n\t\t\treturn 0;\n\t}\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (!strcmp(pm_labels[i], suspend_type)) {\n\t\t\ttest_state_label = pm_labels[i];\n\t\t\treturn 0;\n\t\t}\n\n\tprintk(warn_bad_state, suspend_type);\n\treturn 0;\n}"
  },
  {
    "function_name": "has_wakealarm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend_test.c",
    "lines": "128-138",
    "snippet": "static int __init has_wakealarm(struct device *dev, const void *data)\n{\n\tstruct rtc_device *candidate = to_rtc_device(dev);\n\n\tif (!test_bit(RTC_FEATURE_ALARM, candidate->features))\n\t\treturn 0;\n\tif (!device_may_wakeup(candidate->dev.parent))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/rtc.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "device_may_wakeup",
          "args": [
            "candidate->dev.parent"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "RTC_FEATURE_ALARM",
            "candidate->features"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_test_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/snapshot.c",
          "lines": "849-858",
          "snippet": "static int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int memory_bm_test_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\treturn test_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_rtc_device",
          "args": [
            "dev"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/rtc.h>\n#include <linux/init.h>\n\nstatic int __init has_wakealarm(struct device *dev, const void *data)\n{\n\tstruct rtc_device *candidate = to_rtc_device(dev);\n\n\tif (!test_bit(RTC_FEATURE_ALARM, candidate->features))\n\t\treturn 0;\n\tif (!device_may_wakeup(candidate->dev.parent))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "test_wakealarm",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend_test.c",
    "lines": "62-126",
    "snippet": "static void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)\n{\n\tstatic char err_readtime[] __initdata =\n\t\tKERN_ERR \"PM: can't read %s time, err %d\\n\";\n\tstatic char err_wakealarm [] __initdata =\n\t\tKERN_ERR \"PM: can't set %s wakealarm, err %d\\n\";\n\tstatic char err_suspend[] __initdata =\n\t\tKERN_ERR \"PM: suspend test failed, error %d\\n\";\n\tstatic char info_test[] __initdata =\n\t\tKERN_INFO \"PM: test RTC wakeup from '%s' suspend\\n\";\n\n\ttime64_t\t\tnow;\n\tstruct rtc_wkalrm\talm;\n\tint\t\t\tstatus;\n\n\t/* this may fail if the RTC hasn't been initialized */\nrepeat:\n\tstatus = rtc_read_time(rtc, &alm.time);\n\tif (status < 0) {\n\t\tprintk(err_readtime, dev_name(&rtc->dev), status);\n\t\treturn;\n\t}\n\tnow = rtc_tm_to_time64(&alm.time);\n\n\tmemset(&alm, 0, sizeof alm);\n\trtc_time64_to_tm(now + TEST_SUSPEND_SECONDS, &alm.time);\n\talm.enabled = true;\n\n\tstatus = rtc_set_alarm(rtc, &alm);\n\tif (status < 0) {\n\t\tprintk(err_wakealarm, dev_name(&rtc->dev), status);\n\t\treturn;\n\t}\n\n\tif (state == PM_SUSPEND_MEM) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t\tif (status == -ENODEV)\n\t\t\tstate = PM_SUSPEND_STANDBY;\n\t}\n\tif (state == PM_SUSPEND_STANDBY) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t\tif (status < 0)\n\t\t\tstate = PM_SUSPEND_TO_IDLE;\n\t}\n\tif (state == PM_SUSPEND_TO_IDLE) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t}\n\n\tif (status < 0)\n\t\tprintk(err_suspend, status);\n\n\ttest_repeat_count_current++;\n\tif (test_repeat_count_current < test_repeat_count_max)\n\t\tgoto repeat;\n\n\t/* Some platforms can't detect that the alarm triggered the\n\t * wakeup, or (accordingly) disable it after it afterwards.\n\t * It's supposed to give oneshot behavior; cope.\n\t */\n\talm.enabled = false;\n\trtc_set_alarm(rtc, &alm);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/rtc.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define TEST_SUSPEND_SECONDS\t10"
    ],
    "globals_used": [
      "static u32 test_repeat_count_max = 1;",
      "static u32 test_repeat_count_current;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_set_alarm",
          "args": [
            "rtc",
            "&alm"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "err_suspend",
            "status"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_suspend",
          "args": [
            "state"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "pm_suspend",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend.c",
          "lines": "605-622",
          "snippet": "int pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n\n\tpr_info(\"suspend entry (%s)\\n\", mem_sleep_labels[state]);\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\tpr_info(\"suspend exit\\n\");\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/moduleparam.h>",
            "#include <linux/compiler.h>",
            "#include <trace/events/power.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/swait.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/moduleparam.h>\n#include <linux/compiler.h>\n#include <trace/events/power.h>\n#include <linux/ftrace.h>\n#include <linux/swait.h>\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/gfp.h>\n#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n\nstatic const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};\n\nint pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n\n\tpr_info(\"suspend entry (%s)\\n\", mem_sleep_labels[state]);\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\tpr_info(\"suspend exit\\n\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "&rtc->dev"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_set_alarm",
          "args": [
            "rtc",
            "&alm"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_time64_to_tm",
          "args": [
            "now + TEST_SUSPEND_SECONDS",
            "&alm.time"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&alm",
            "0",
            "sizeof alm"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_tm_to_time64",
          "args": [
            "&alm.time"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "&rtc->dev"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_read_time",
          "args": [
            "rtc",
            "&alm.time"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/rtc.h>\n#include <linux/init.h>\n\n#define TEST_SUSPEND_SECONDS\t10\n\nstatic u32 test_repeat_count_max = 1;\nstatic u32 test_repeat_count_current;\n\nstatic void __init test_wakealarm(struct rtc_device *rtc, suspend_state_t state)\n{\n\tstatic char err_readtime[] __initdata =\n\t\tKERN_ERR \"PM: can't read %s time, err %d\\n\";\n\tstatic char err_wakealarm [] __initdata =\n\t\tKERN_ERR \"PM: can't set %s wakealarm, err %d\\n\";\n\tstatic char err_suspend[] __initdata =\n\t\tKERN_ERR \"PM: suspend test failed, error %d\\n\";\n\tstatic char info_test[] __initdata =\n\t\tKERN_INFO \"PM: test RTC wakeup from '%s' suspend\\n\";\n\n\ttime64_t\t\tnow;\n\tstruct rtc_wkalrm\talm;\n\tint\t\t\tstatus;\n\n\t/* this may fail if the RTC hasn't been initialized */\nrepeat:\n\tstatus = rtc_read_time(rtc, &alm.time);\n\tif (status < 0) {\n\t\tprintk(err_readtime, dev_name(&rtc->dev), status);\n\t\treturn;\n\t}\n\tnow = rtc_tm_to_time64(&alm.time);\n\n\tmemset(&alm, 0, sizeof alm);\n\trtc_time64_to_tm(now + TEST_SUSPEND_SECONDS, &alm.time);\n\talm.enabled = true;\n\n\tstatus = rtc_set_alarm(rtc, &alm);\n\tif (status < 0) {\n\t\tprintk(err_wakealarm, dev_name(&rtc->dev), status);\n\t\treturn;\n\t}\n\n\tif (state == PM_SUSPEND_MEM) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t\tif (status == -ENODEV)\n\t\t\tstate = PM_SUSPEND_STANDBY;\n\t}\n\tif (state == PM_SUSPEND_STANDBY) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t\tif (status < 0)\n\t\t\tstate = PM_SUSPEND_TO_IDLE;\n\t}\n\tif (state == PM_SUSPEND_TO_IDLE) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t}\n\n\tif (status < 0)\n\t\tprintk(err_suspend, status);\n\n\ttest_repeat_count_current++;\n\tif (test_repeat_count_current < test_repeat_count_max)\n\t\tgoto repeat;\n\n\t/* Some platforms can't detect that the alarm triggered the\n\t * wakeup, or (accordingly) disable it after it afterwards.\n\t * It's supposed to give oneshot behavior; cope.\n\t */\n\talm.enabled = false;\n\trtc_set_alarm(rtc, &alm);\n}"
  },
  {
    "function_name": "suspend_test_finish",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend_test.c",
    "lines": "36-55",
    "snippet": "void suspend_test_finish(const char *label)\n{\n\tlong nj = jiffies - suspend_test_start_time;\n\tunsigned msec;\n\n\tmsec = jiffies_to_msecs(abs(nj));\n\tpr_info(\"PM: %s took %d.%03d seconds\\n\", label,\n\t\t\tmsec / 1000, msec % 1000);\n\n\t/* Warning on suspend means the RTC alarm period needs to be\n\t * larger -- the system was sooo slooowwww to suspend that the\n\t * alarm (should have) fired before the system went to sleep!\n\t *\n\t * Warning on either suspend or resume also means the system\n\t * has some performance issues.  The stack dump of a WARN_ON\n\t * is more likely to get the right attention than a printk...\n\t */\n\tWARN(msec > (TEST_SUSPEND_SECONDS * 1000),\n\t     \"Component: %s, time: %u\\n\", label, msec);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/rtc.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define TEST_SUSPEND_SECONDS\t10"
    ],
    "globals_used": [
      "static unsigned long suspend_test_start_time;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "msec > (TEST_SUSPEND_SECONDS * 1000)",
            "\"Component: %s, time: %u\\n\"",
            "label",
            "msec"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"PM: %s took %d.%03d seconds\\n\"",
            "label",
            "msec / 1000",
            "msec % 1000"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "abs(nj)"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "jiffies_to_msecs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/time.c",
          "lines": "374-388",
          "snippet": "unsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "nj"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/torture.c",
          "lines": "608-615",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/rtc.h>\n#include <linux/init.h>\n\n#define TEST_SUSPEND_SECONDS\t10\n\nstatic unsigned long suspend_test_start_time;\n\nvoid suspend_test_finish(const char *label)\n{\n\tlong nj = jiffies - suspend_test_start_time;\n\tunsigned msec;\n\n\tmsec = jiffies_to_msecs(abs(nj));\n\tpr_info(\"PM: %s took %d.%03d seconds\\n\", label,\n\t\t\tmsec / 1000, msec % 1000);\n\n\t/* Warning on suspend means the RTC alarm period needs to be\n\t * larger -- the system was sooo slooowwww to suspend that the\n\t * alarm (should have) fired before the system went to sleep!\n\t *\n\t * Warning on either suspend or resume also means the system\n\t * has some performance issues.  The stack dump of a WARN_ON\n\t * is more likely to get the right attention than a printk...\n\t */\n\tWARN(msec > (TEST_SUSPEND_SECONDS * 1000),\n\t     \"Component: %s, time: %u\\n\", label, msec);\n}"
  },
  {
    "function_name": "suspend_test_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/suspend_test.c",
    "lines": "27-34",
    "snippet": "void suspend_test_start(void)\n{\n\t/* FIXME Use better timebase than \"jiffies\", ideally a clocksource.\n\t * What we want is a hardware counter that will work correctly even\n\t * during the irqs-are-off stages of the suspend/resume cycle...\n\t */\n\tsuspend_test_start_time = jiffies;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/rtc.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long suspend_test_start_time;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/rtc.h>\n#include <linux/init.h>\n\nstatic unsigned long suspend_test_start_time;\n\nvoid suspend_test_start(void)\n{\n\t/* FIXME Use better timebase than \"jiffies\", ideally a clocksource.\n\t * What we want is a hardware counter that will work correctly even\n\t * during the irqs-are-off stages of the suspend/resume cycle...\n\t */\n\tsuspend_test_start_time = jiffies;\n}"
  }
]