[
  {
    "function_name": "utsname_sysctl_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname_sysctl.c",
    "lines": "138-142",
    "snippet": "static int __init utsname_sysctl_init(void)\n{\n\tregister_sysctl_table(uts_root_table);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/rwsem.h>",
      "#include <linux/wait.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table uts_root_table[] = {\n\t{\n\t\t.procname\t= \"kernel\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= uts_kern_table,\n\t},\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_table",
          "args": [
            "uts_root_table"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/wait.h>\n#include <linux/sysctl.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct ctl_table uts_root_table[] = {\n\t{\n\t\t.procname\t= \"kernel\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= uts_kern_table,\n\t},\n\t{}\n};\n\nstatic int __init utsname_sysctl_init(void)\n{\n\tregister_sysctl_table(uts_root_table);\n\treturn 0;\n}"
  },
  {
    "function_name": "uts_proc_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname_sysctl.c",
    "lines": "130-135",
    "snippet": "void uts_proc_notify(enum uts_proc proc)\n{\n\tstruct ctl_table *table = &uts_kern_table[proc];\n\n\tproc_sys_poll_notify(table->poll);\n}",
    "includes": [
      "#include <linux/rwsem.h>",
      "#include <linux/wait.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table uts_kern_table[] = {\n\t{\n\t\t.procname\t= \"ostype\",\n\t\t.data\t\t= init_uts_ns.name.sysname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.sysname),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"osrelease\",\n\t\t.data\t\t= init_uts_ns.name.release,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.release),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"version\",\n\t\t.data\t\t= init_uts_ns.name.version,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.version),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"hostname\",\n\t\t.data\t\t= init_uts_ns.name.nodename,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.nodename),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &hostname_poll,\n\t},\n\t{\n\t\t.procname\t= \"domainname\",\n\t\t.data\t\t= init_uts_ns.name.domainname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.domainname),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &domainname_poll,\n\t},\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sys_poll_notify",
          "args": [
            "table->poll"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/wait.h>\n#include <linux/sysctl.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct ctl_table uts_kern_table[] = {\n\t{\n\t\t.procname\t= \"ostype\",\n\t\t.data\t\t= init_uts_ns.name.sysname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.sysname),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"osrelease\",\n\t\t.data\t\t= init_uts_ns.name.release,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.release),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"version\",\n\t\t.data\t\t= init_uts_ns.name.version,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.version),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"hostname\",\n\t\t.data\t\t= init_uts_ns.name.nodename,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.nodename),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &hostname_poll,\n\t},\n\t{\n\t\t.procname\t= \"domainname\",\n\t\t.data\t\t= init_uts_ns.name.domainname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.domainname),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &domainname_poll,\n\t},\n\t{}\n};\n\nvoid uts_proc_notify(enum uts_proc proc)\n{\n\tstruct ctl_table *table = &uts_kern_table[proc];\n\n\tproc_sys_poll_notify(table->poll);\n}"
  },
  {
    "function_name": "proc_do_uts_string",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname_sysctl.c",
    "lines": "32-67",
    "snippet": "static int proc_do_uts_string(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table uts_table;\n\tint r;\n\tchar tmp_data[__NEW_UTS_LEN + 1];\n\n\tmemcpy(&uts_table, table, sizeof(uts_table));\n\tuts_table.data = tmp_data;\n\n\t/*\n\t * Buffer the value in tmp_data so that proc_dostring() can be called\n\t * without holding any locks.\n\t * We also need to read the original value in the write==1 case to\n\t * support partial writes.\n\t */\n\tdown_read(&uts_sem);\n\tmemcpy(tmp_data, get_uts(table), sizeof(tmp_data));\n\tup_read(&uts_sem);\n\tr = proc_dostring(&uts_table, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\t/*\n\t\t * Write back the new value.\n\t\t * Note that, since we dropped uts_sem, the result can\n\t\t * theoretically be incorrect if there are two parallel writes\n\t\t * at non-zero offsets to the same sysctl.\n\t\t */\n\t\tdown_write(&uts_sem);\n\t\tmemcpy(get_uts(table), tmp_data, sizeof(tmp_data));\n\t\tup_write(&uts_sem);\n\t\tproc_sys_poll_notify(table->poll);\n\t}\n\n\treturn r;\n}",
    "includes": [
      "#include <linux/rwsem.h>",
      "#include <linux/wait.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define proc_do_uts_string NULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sys_poll_notify",
          "args": [
            "table->poll"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uts_sem"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "242-269",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\trwsem_release(&sem->dep_map, _RET_IP_);\n\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tatomic_set_release(&sem->block, 0);\n\n\t/*\n\t * Prod any pending reader/writer to make progress.\n\t */\n\t__wake_up(&sem->waiters, TASK_NORMAL, 1, sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "get_uts(table)",
            "tmp_data",
            "sizeof(tmp_data)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_uts",
          "args": [
            "table"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "get_uts",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname_sysctl.c",
          "lines": "17-26",
          "snippet": "static void *get_uts(struct ctl_table *table)\n{\n\tchar *which = table->data;\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = current->nsproxy->uts_ns;\n\twhich = (which - (char *)&init_uts_ns) + (char *)uts_ns;\n\n\treturn which;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/wait.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/wait.h>\n#include <linux/sysctl.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic void *get_uts(struct ctl_table *table)\n{\n\tchar *which = table->data;\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = current->nsproxy->uts_ns;\n\twhich = (which - (char *)&init_uts_ns) + (char *)uts_ns;\n\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uts_sem"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "214-239",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\tmight_sleep();\n\trwsem_acquire(&sem->dep_map, 0, 0, _RET_IP_);\n\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\t/*\n\t * Try set sem->block; this provides writer-writer exclusion.\n\t * Having sem->block set makes new readers block.\n\t */\n\tif (!__percpu_down_write_trylock(sem))\n\t\tpercpu_rwsem_wait(sem, /* .reader = */ false);\n\n\t/* smp_mb() implied by __percpu_down_write_trylock() on success -- D matches A */\n\n\t/*\n\t * If they don't see our store of sem->block, then we are guaranteed to\n\t * see their sem->read_count increment, and therefore will wait for\n\t * them.\n\t */\n\n\t/* Wait for all active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem), TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dostring",
          "args": [
            "&uts_table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dostring",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sysctl.c",
          "lines": "1543-1547",
          "snippet": "int proc_dostring(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include \"../lib/kstrtox.h\"",
            "#include <linux/delayacct.h>",
            "#include <linux/pid.h>",
            "#include <linux/latencytop.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/filter.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/panic.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include \"../lib/kstrtox.h\"\n#include <linux/delayacct.h>\n#include <linux/pid.h>\n#include <linux/latencytop.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/filter.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/panic.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&uts_sem"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/relay.c",
          "lines": "271-277",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&uts_sem"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "__percpu_down_read_trylock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/percpu-rwsem.c",
          "lines": "46-80",
          "snippet": "static bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/wait.h>",
            "#include <linux/percpu.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/wait.h>\n#include <linux/percpu.h>\n#include <linux/atomic.h>\n\nstatic bool __percpu_down_read_trylock(struct percpu_rw_semaphore *sem)\n{\n\tthis_cpu_inc(*sem->read_count);\n\n\t/*\n\t * Due to having preemption disabled the decrement happens on\n\t * the same CPU as the increment, avoiding the\n\t * increment-on-one-CPU-and-decrement-on-another problem.\n\t *\n\t * If the reader misses the writer's assignment of sem->block, then the\n\t * writer is guaranteed to see the reader's increment.\n\t *\n\t * Conversely, any readers that increment their sem->read_count after\n\t * the writer looks are guaranteed to see the sem->block value, which\n\t * in turn means that they are guaranteed to immediately decrement\n\t * their sem->read_count, so that it doesn't matter that the writer\n\t * missed them.\n\t */\n\n\tsmp_mb(); /* A matches D */\n\n\t/*\n\t * If !sem->block the critical section starts here, matched by the\n\t * release in percpu_up_write().\n\t */\n\tif (likely(!atomic_read_acquire(&sem->block)))\n\t\treturn true;\n\n\tthis_cpu_dec(*sem->read_count);\n\n\t/* Prod writer to re-evaluate readers_active_check() */\n\trcuwait_wake_up(&sem->writer);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/wait.h>\n#include <linux/sysctl.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\n#define proc_do_uts_string NULL\n\nstatic int proc_do_uts_string(struct ctl_table *table, int write,\n\t\t  void *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table uts_table;\n\tint r;\n\tchar tmp_data[__NEW_UTS_LEN + 1];\n\n\tmemcpy(&uts_table, table, sizeof(uts_table));\n\tuts_table.data = tmp_data;\n\n\t/*\n\t * Buffer the value in tmp_data so that proc_dostring() can be called\n\t * without holding any locks.\n\t * We also need to read the original value in the write==1 case to\n\t * support partial writes.\n\t */\n\tdown_read(&uts_sem);\n\tmemcpy(tmp_data, get_uts(table), sizeof(tmp_data));\n\tup_read(&uts_sem);\n\tr = proc_dostring(&uts_table, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\t/*\n\t\t * Write back the new value.\n\t\t * Note that, since we dropped uts_sem, the result can\n\t\t * theoretically be incorrect if there are two parallel writes\n\t\t * at non-zero offsets to the same sysctl.\n\t\t */\n\t\tdown_write(&uts_sem);\n\t\tmemcpy(get_uts(table), tmp_data, sizeof(tmp_data));\n\t\tup_write(&uts_sem);\n\t\tproc_sys_poll_notify(table->poll);\n\t}\n\n\treturn r;\n}"
  },
  {
    "function_name": "get_uts",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/utsname_sysctl.c",
    "lines": "17-26",
    "snippet": "static void *get_uts(struct ctl_table *table)\n{\n\tchar *which = table->data;\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = current->nsproxy->uts_ns;\n\twhich = (which - (char *)&init_uts_ns) + (char *)uts_ns;\n\n\treturn which;\n}",
    "includes": [
      "#include <linux/rwsem.h>",
      "#include <linux/wait.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/wait.h>\n#include <linux/sysctl.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic void *get_uts(struct ctl_table *table)\n{\n\tchar *which = table->data;\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = current->nsproxy->uts_ns;\n\twhich = (which - (char *)&init_uts_ns) + (char *)uts_ns;\n\n\treturn which;\n}"
  }
]