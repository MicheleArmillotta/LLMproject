[
  {
    "function_name": "context_tracking_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
    "lines": "216-222",
    "snippet": "void __init context_tracking_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcontext_tracking_cpu_set(cpu);\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid __init context_tracking_init(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcontext_tracking_cpu_set(cpu);\n}"
  },
  {
    "function_name": "context_tracking_cpu_set",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
    "lines": "191-213",
    "snippet": "void __init context_tracking_cpu_set(int cpu)\n{\n\tstatic __initdata bool initialized = false;\n\n\tif (!per_cpu(context_tracking.active, cpu)) {\n\t\tper_cpu(context_tracking.active, cpu) = true;\n\t\tstatic_branch_inc(&context_tracking_key);\n\t}\n\n\tif (initialized)\n\t\treturn;\n\n#ifdef CONFIG_HAVE_TIF_NOHZ\n\t/*\n\t * Set TIF_NOHZ to init/0 and let it propagate to all tasks through fork\n\t * This assumes that init is the only task at this early boot stage.\n\t */\n\tset_tsk_thread_flag(&init_task, TIF_NOHZ);\n#endif\n\tWARN_ON_ONCE(!tasklist_empty());\n\n\tinitialized = true;\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tasklist_empty()"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tasklist_empty",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "&init_task",
            "TIF_NOHZ"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&context_tracking_key"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "context_tracking.active",
            "cpu"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid __init context_tracking_cpu_set(int cpu)\n{\n\tstatic __initdata bool initialized = false;\n\n\tif (!per_cpu(context_tracking.active, cpu)) {\n\t\tper_cpu(context_tracking.active, cpu) = true;\n\t\tstatic_branch_inc(&context_tracking_key);\n\t}\n\n\tif (initialized)\n\t\treturn;\n\n#ifdef CONFIG_HAVE_TIF_NOHZ\n\t/*\n\t * Set TIF_NOHZ to init/0 and let it propagate to all tasks through fork\n\t * This assumes that init is the only task at this early boot stage.\n\t */\n\tset_tsk_thread_flag(&init_task, TIF_NOHZ);\n#endif\n\tWARN_ON_ONCE(!tasklist_empty());\n\n\tinitialized = true;\n}"
  },
  {
    "function_name": "context_tracking_user_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
    "lines": "185-188",
    "snippet": "void context_tracking_user_exit(void)\n{\n\tuser_exit();\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_exit",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_user_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
          "lines": "185-188",
          "snippet": "void context_tracking_user_exit(void)\n{\n\tuser_exit();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid context_tracking_user_exit(void)\n{\n\tuser_exit();\n}"
  },
  {
    "function_name": "context_tracking_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
    "lines": "171-181",
    "snippet": "void context_tracking_exit(enum ctx_state state)\n{\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\t__context_tracking_exit(state);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__context_tracking_exit",
          "args": [
            "state"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "__context_tracking_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
          "lines": "146-168",
          "snippet": "void noinstr __context_tracking_exit(enum ctx_state state)\n{\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif (__this_cpu_read(context_tracking.state) == state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * We are going to run code that may use RCU. Inform\n\t\t\t * RCU core about that (ie: we may need the tick again).\n\t\t\t */\n\t\t\trcu_user_exit();\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tinstrumentation_begin();\n\t\t\t\tvtime_user_exit(current);\n\t\t\t\ttrace_user_exit(0);\n\t\t\t\tinstrumentation_end();\n\t\t\t}\n\t\t}\n\t\t__this_cpu_write(context_tracking.state, CONTEXT_KERNEL);\n\t}\n\tcontext_tracking_recursion_exit();\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid noinstr __context_tracking_exit(enum ctx_state state)\n{\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif (__this_cpu_read(context_tracking.state) == state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * We are going to run code that may use RCU. Inform\n\t\t\t * RCU core about that (ie: we may need the tick again).\n\t\t\t */\n\t\t\trcu_user_exit();\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tinstrumentation_begin();\n\t\t\t\tvtime_user_exit(current);\n\t\t\t\ttrace_user_exit(0);\n\t\t\t\tinstrumentation_end();\n\t\t\t}\n\t\t}\n\t\t__this_cpu_write(context_tracking.state, CONTEXT_KERNEL);\n\t}\n\tcontext_tracking_recursion_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid context_tracking_exit(enum ctx_state state)\n{\n\tunsigned long flags;\n\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\t__context_tracking_exit(state);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__context_tracking_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
    "lines": "146-168",
    "snippet": "void noinstr __context_tracking_exit(enum ctx_state state)\n{\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif (__this_cpu_read(context_tracking.state) == state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * We are going to run code that may use RCU. Inform\n\t\t\t * RCU core about that (ie: we may need the tick again).\n\t\t\t */\n\t\t\trcu_user_exit();\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tinstrumentation_begin();\n\t\t\t\tvtime_user_exit(current);\n\t\t\t\ttrace_user_exit(0);\n\t\t\t\tinstrumentation_end();\n\t\t\t}\n\t\t}\n\t\t__this_cpu_write(context_tracking.state, CONTEXT_KERNEL);\n\t}\n\tcontext_tracking_recursion_exit();\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_tracking_recursion_exit",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_recursion_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
          "lines": "48-51",
          "snippet": "static __always_inline void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "context_tracking.state",
            "CONTEXT_KERNEL"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_user_exit",
          "args": [
            "0"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_user_exit",
          "args": [
            "current"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_user_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "716-728",
          "snippet": "void vtime_user_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->utime += get_vtime_delta(vtime);\n\tif (vtime->utime >= TICK_NSEC) {\n\t\taccount_user_time(tsk, vtime->utime);\n\t\tvtime->utime = 0;\n\t}\n\tvtime->state = VTIME_SYS;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_user_exit(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime->utime += get_vtime_delta(vtime);\n\tif (vtime->utime >= TICK_NSEC) {\n\t\taccount_user_time(tsk, vtime->utime);\n\t\tvtime->utime = 0;\n\t}\n\tvtime->state = VTIME_SYS;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_user_exit",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_user_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "908-911",
          "snippet": "void noinstr rcu_user_exit(void)\n{\n\trcu_eqs_exit(true);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline noinstr"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\n\nvoid noinstr rcu_user_exit(void)\n{\n\trcu_eqs_exit(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "context_tracking.active"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "context_tracking.state"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_tracking_recursion_enter",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_recursion_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
          "lines": "34-46",
          "snippet": "static noinstr bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic noinstr bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid noinstr __context_tracking_exit(enum ctx_state state)\n{\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif (__this_cpu_read(context_tracking.state) == state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * We are going to run code that may use RCU. Inform\n\t\t\t * RCU core about that (ie: we may need the tick again).\n\t\t\t */\n\t\t\trcu_user_exit();\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tinstrumentation_begin();\n\t\t\t\tvtime_user_exit(current);\n\t\t\t\ttrace_user_exit(0);\n\t\t\t\tinstrumentation_end();\n\t\t\t}\n\t\t}\n\t\t__this_cpu_write(context_tracking.state, CONTEXT_KERNEL);\n\t}\n\tcontext_tracking_recursion_exit();\n}"
  },
  {
    "function_name": "context_tracking_user_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
    "lines": "128-131",
    "snippet": "void context_tracking_user_enter(void)\n{\n\tuser_enter();\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_enter",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_user_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
          "lines": "128-131",
          "snippet": "void context_tracking_user_enter(void)\n{\n\tuser_enter();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid context_tracking_user_enter(void)\n{\n\tuser_enter();\n}"
  },
  {
    "function_name": "context_tracking_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
    "lines": "106-124",
    "snippet": "void context_tracking_enter(enum ctx_state state)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Some contexts may involve an exception occuring in an irq,\n\t * leading to that nesting:\n\t * rcu_irq_enter() rcu_user_exit() rcu_user_exit() rcu_irq_exit()\n\t * This would mess up the dyntick_nesting count though. And rcu_irq_*()\n\t * helpers are enough to protect RCU uses inside the exception. So\n\t * just return immediately if we detect we are in an IRQ.\n\t */\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\t__context_tracking_enter(state);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__context_tracking_enter",
          "args": [
            "state"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__context_tracking_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
          "lines": "62-103",
          "snippet": "void noinstr __context_tracking_enter(enum ctx_state state)\n{\n\t/* Kernel threads aren't supposed to go to userspace */\n\tWARN_ON_ONCE(!current->mm);\n\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif ( __this_cpu_read(context_tracking.state) != state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * At this stage, only low level arch entry code remains and\n\t\t\t * then we'll run in userspace. We can assume there won't be\n\t\t\t * any RCU read-side critical section until the next call to\n\t\t\t * user_exit() or rcu_irq_enter(). Let's remove RCU's dependency\n\t\t\t * on the tick.\n\t\t\t */\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tinstrumentation_begin();\n\t\t\t\ttrace_user_enter(0);\n\t\t\t\tvtime_user_enter(current);\n\t\t\t\tinstrumentation_end();\n\t\t\t}\n\t\t\trcu_user_enter();\n\t\t}\n\t\t/*\n\t\t * Even if context tracking is disabled on this CPU, because it's outside\n\t\t * the full dynticks mask for example, we still have to keep track of the\n\t\t * context transitions and states to prevent inconsistency on those of\n\t\t * other CPUs.\n\t\t * If a task triggers an exception in userspace, sleep on the exception\n\t\t * handler and then migrate to another CPU, that new CPU must know where\n\t\t * the exception returns by the time we call exception_exit().\n\t\t * This information can only be provided by the previous CPU when it called\n\t\t * exception_enter().\n\t\t * OTOH we can spare the calls to vtime and RCU when context_tracking.active\n\t\t * is false because we know that CPU is not tickless.\n\t\t */\n\t\t__this_cpu_write(context_tracking.state, state);\n\t}\n\tcontext_tracking_recursion_exit();\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid noinstr __context_tracking_enter(enum ctx_state state)\n{\n\t/* Kernel threads aren't supposed to go to userspace */\n\tWARN_ON_ONCE(!current->mm);\n\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif ( __this_cpu_read(context_tracking.state) != state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * At this stage, only low level arch entry code remains and\n\t\t\t * then we'll run in userspace. We can assume there won't be\n\t\t\t * any RCU read-side critical section until the next call to\n\t\t\t * user_exit() or rcu_irq_enter(). Let's remove RCU's dependency\n\t\t\t * on the tick.\n\t\t\t */\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tinstrumentation_begin();\n\t\t\t\ttrace_user_enter(0);\n\t\t\t\tvtime_user_enter(current);\n\t\t\t\tinstrumentation_end();\n\t\t\t}\n\t\t\trcu_user_enter();\n\t\t}\n\t\t/*\n\t\t * Even if context tracking is disabled on this CPU, because it's outside\n\t\t * the full dynticks mask for example, we still have to keep track of the\n\t\t * context transitions and states to prevent inconsistency on those of\n\t\t * other CPUs.\n\t\t * If a task triggers an exception in userspace, sleep on the exception\n\t\t * handler and then migrate to another CPU, that new CPU must know where\n\t\t * the exception returns by the time we call exception_exit().\n\t\t * This information can only be provided by the previous CPU when it called\n\t\t * exception_enter().\n\t\t * OTOH we can spare the calls to vtime and RCU when context_tracking.active\n\t\t * is false because we know that CPU is not tickless.\n\t\t */\n\t\t__this_cpu_write(context_tracking.state, state);\n\t}\n\tcontext_tracking_recursion_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_interrupt",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid context_tracking_enter(enum ctx_state state)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Some contexts may involve an exception occuring in an irq,\n\t * leading to that nesting:\n\t * rcu_irq_enter() rcu_user_exit() rcu_user_exit() rcu_irq_exit()\n\t * This would mess up the dyntick_nesting count though. And rcu_irq_*()\n\t * helpers are enough to protect RCU uses inside the exception. So\n\t * just return immediately if we detect we are in an IRQ.\n\t */\n\tif (in_interrupt())\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\t__context_tracking_enter(state);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "__context_tracking_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
    "lines": "62-103",
    "snippet": "void noinstr __context_tracking_enter(enum ctx_state state)\n{\n\t/* Kernel threads aren't supposed to go to userspace */\n\tWARN_ON_ONCE(!current->mm);\n\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif ( __this_cpu_read(context_tracking.state) != state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * At this stage, only low level arch entry code remains and\n\t\t\t * then we'll run in userspace. We can assume there won't be\n\t\t\t * any RCU read-side critical section until the next call to\n\t\t\t * user_exit() or rcu_irq_enter(). Let's remove RCU's dependency\n\t\t\t * on the tick.\n\t\t\t */\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tinstrumentation_begin();\n\t\t\t\ttrace_user_enter(0);\n\t\t\t\tvtime_user_enter(current);\n\t\t\t\tinstrumentation_end();\n\t\t\t}\n\t\t\trcu_user_enter();\n\t\t}\n\t\t/*\n\t\t * Even if context tracking is disabled on this CPU, because it's outside\n\t\t * the full dynticks mask for example, we still have to keep track of the\n\t\t * context transitions and states to prevent inconsistency on those of\n\t\t * other CPUs.\n\t\t * If a task triggers an exception in userspace, sleep on the exception\n\t\t * handler and then migrate to another CPU, that new CPU must know where\n\t\t * the exception returns by the time we call exception_exit().\n\t\t * This information can only be provided by the previous CPU when it called\n\t\t * exception_enter().\n\t\t * OTOH we can spare the calls to vtime and RCU when context_tracking.active\n\t\t * is false because we know that CPU is not tickless.\n\t\t */\n\t\t__this_cpu_write(context_tracking.state, state);\n\t}\n\tcontext_tracking_recursion_exit();\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "context_tracking_recursion_exit",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_recursion_exit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
          "lines": "48-51",
          "snippet": "static __always_inline void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "context_tracking.state",
            "state"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_user_enter",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_user_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "714-725",
          "snippet": "noinstr void rcu_user_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * Other than generic entry implementation, we may be past the last\n\t * rescheduling opportunity in the entry code. Trigger a self IPI\n\t * that will fire and reschedule once we resume in user/guest mode.\n\t */\n\trcu_irq_work_resched();\n\trcu_eqs_enter(true);\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline noinstr",
            "static int rcu_pending(int user);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic noinline noinstr;\nstatic int rcu_pending(int user);\n\nnoinstr void rcu_user_enter(void)\n{\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * Other than generic entry implementation, we may be past the last\n\t * rescheduling opportunity in the entry code. Trigger a self IPI\n\t * that will fire and reschedule once we resume in user/guest mode.\n\t */\n\trcu_irq_work_resched();\n\trcu_eqs_enter(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "instrumentation_end",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtime_user_enter",
          "args": [
            "current"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "vtime_user_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cputime.c",
          "lines": "706-714",
          "snippet": "void vtime_user_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime_account_system(tsk, vtime);\n\tvtime->state = VTIME_USER;\n\twrite_seqcount_end(&vtime->seqcount);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid vtime_user_enter(struct task_struct *tsk)\n{\n\tstruct vtime *vtime = &tsk->vtime;\n\n\twrite_seqcount_begin(&vtime->seqcount);\n\tvtime_account_system(tsk, vtime);\n\tvtime->state = VTIME_USER;\n\twrite_seqcount_end(&vtime->seqcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_user_enter",
          "args": [
            "0"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instrumentation_begin",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "context_tracking.active"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "context_tracking.state"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context_tracking_recursion_enter",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "context_tracking_recursion_enter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
          "lines": "34-46",
          "snippet": "static noinstr bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/context_tracking.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/export.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/context_tracking.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic noinstr bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!current->mm"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nvoid noinstr __context_tracking_enter(enum ctx_state state)\n{\n\t/* Kernel threads aren't supposed to go to userspace */\n\tWARN_ON_ONCE(!current->mm);\n\n\tif (!context_tracking_recursion_enter())\n\t\treturn;\n\n\tif ( __this_cpu_read(context_tracking.state) != state) {\n\t\tif (__this_cpu_read(context_tracking.active)) {\n\t\t\t/*\n\t\t\t * At this stage, only low level arch entry code remains and\n\t\t\t * then we'll run in userspace. We can assume there won't be\n\t\t\t * any RCU read-side critical section until the next call to\n\t\t\t * user_exit() or rcu_irq_enter(). Let's remove RCU's dependency\n\t\t\t * on the tick.\n\t\t\t */\n\t\t\tif (state == CONTEXT_USER) {\n\t\t\t\tinstrumentation_begin();\n\t\t\t\ttrace_user_enter(0);\n\t\t\t\tvtime_user_enter(current);\n\t\t\t\tinstrumentation_end();\n\t\t\t}\n\t\t\trcu_user_enter();\n\t\t}\n\t\t/*\n\t\t * Even if context tracking is disabled on this CPU, because it's outside\n\t\t * the full dynticks mask for example, we still have to keep track of the\n\t\t * context transitions and states to prevent inconsistency on those of\n\t\t * other CPUs.\n\t\t * If a task triggers an exception in userspace, sleep on the exception\n\t\t * handler and then migrate to another CPU, that new CPU must know where\n\t\t * the exception returns by the time we call exception_exit().\n\t\t * This information can only be provided by the previous CPU when it called\n\t\t * exception_enter().\n\t\t * OTOH we can spare the calls to vtime and RCU when context_tracking.active\n\t\t * is false because we know that CPU is not tickless.\n\t\t */\n\t\t__this_cpu_write(context_tracking.state, state);\n\t}\n\tcontext_tracking_recursion_exit();\n}"
  },
  {
    "function_name": "context_tracking_recursion_exit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
    "lines": "48-51",
    "snippet": "static __always_inline void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "context_tracking.recursion"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic __always_inline void context_tracking_recursion_exit(void)\n{\n\t__this_cpu_dec(context_tracking.recursion);\n}"
  },
  {
    "function_name": "context_tracking_recursion_enter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/context_tracking.c",
    "lines": "34-46",
    "snippet": "static noinstr bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/context_tracking.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/export.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/context_tracking.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "context_tracking.recursion"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "(recursion < 1)",
            "\"Invalid context tracking recursion value %d\\n\"",
            "recursion"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "context_tracking.recursion"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/context_tracking.h>\n#include <linux/kprobes.h>\n#include <linux/export.h>\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/context_tracking.h>\n\nstatic noinstr bool context_tracking_recursion_enter(void)\n{\n\tint recursion;\n\n\trecursion = __this_cpu_inc_return(context_tracking.recursion);\n\tif (recursion == 1)\n\t\treturn true;\n\n\tWARN_ONCE((recursion < 1), \"Invalid context tracking recursion value %d\\n\", recursion);\n\t__this_cpu_dec(context_tracking.recursion);\n\n\treturn false;\n}"
  }
]