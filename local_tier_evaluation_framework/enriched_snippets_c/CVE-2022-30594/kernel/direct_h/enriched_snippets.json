[
  {
    "function_name": "dma_direct_unmap_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
    "lines": "108-118",
    "snippet": "static inline void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = dma_to_phys(dev, addr);\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n\n\tif (unlikely(is_swiotlb_buffer(dev, phys)))\n\t\tswiotlb_tbl_unmap_single(dev, phys, size, dir, attrs);\n}",
    "includes": [
      "#include <linux/dma-direct.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swiotlb_tbl_unmap_single",
          "args": [
            "dev",
            "phys",
            "size",
            "dir",
            "attrs"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_tbl_unmap_single",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "682-694",
          "snippet": "void swiotlb_tbl_unmap_single(struct device *dev, phys_addr_t tlb_addr,\n\t\t\t      size_t mapping_size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_FROM_DEVICE);\n\n\tswiotlb_release_slots(dev, tlb_addr);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_tbl_unmap_single(struct device *dev, phys_addr_t tlb_addr,\n\t\t\t      size_t mapping_size, enum dma_data_direction dir,\n\t\t\t      unsigned long attrs)\n{\n\t/*\n\t * First, sync the memory before unmapping the entry\n\t */\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC) &&\n\t    (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL))\n\t\tswiotlb_bounce(dev, tlb_addr, mapping_size, DMA_FROM_DEVICE);\n\n\tswiotlb_release_slots(dev, tlb_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_swiotlb_buffer(dev, phys)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swiotlb_buffer",
          "args": [
            "dev",
            "phys"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_direct_sync_single_for_cpu",
          "args": [
            "dev",
            "addr",
            "size",
            "dir"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "dma_direct_sync_single_for_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
          "lines": "66-81",
          "snippet": "static inline void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tarch_sync_dma_for_cpu(paddr, size, dir);\n\t\tarch_sync_dma_for_cpu_all();\n\t}\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_cpu(dev, paddr, size, dir);\n\n\tif (dir == DMA_FROM_DEVICE)\n\t\tarch_dma_mark_clean(paddr, size);\n}",
          "includes": [
            "#include <linux/dma-direct.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tarch_sync_dma_for_cpu(paddr, size, dir);\n\t\tarch_sync_dma_for_cpu_all();\n\t}\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_cpu(dev, paddr, size, dir);\n\n\tif (dir == DMA_FROM_DEVICE)\n\t\tarch_dma_mark_clean(paddr, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "addr"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = dma_to_phys(dev, addr);\n\n\tif (!(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tdma_direct_sync_single_for_cpu(dev, addr, size, dir);\n\n\tif (unlikely(is_swiotlb_buffer(dev, phys)))\n\t\tswiotlb_tbl_unmap_single(dev, phys, size, dir, attrs);\n}"
  },
  {
    "function_name": "dma_direct_map_page",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
    "lines": "83-106",
    "snippet": "static inline dma_addr_t dma_direct_map_page(struct device *dev,\n\t\tstruct page *page, unsigned long offset, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dma_addr = phys_to_dma(dev, phys);\n\n\tif (is_swiotlb_force_bounce(dev))\n\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true))) {\n\t\tif (swiotlb_force != SWIOTLB_NO_FORCE)\n\t\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(phys, size, dir);\n\treturn dma_addr;\n}",
    "includes": [
      "#include <linux/dma-direct.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_sync_dma_for_device",
          "args": [
            "phys",
            "size",
            "dir"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_WARN_ONCE",
          "args": [
            "dev",
            "1",
            "\"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\"",
            "&dma_addr",
            "size",
            "*dev->dma_mask",
            "dev->bus_dma_limit"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_map",
          "args": [
            "dev",
            "phys",
            "size",
            "dir",
            "attrs"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_map",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "718-746",
          "snippet": "dma_addr_t swiotlb_map(struct device *dev, phys_addr_t paddr, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t swiotlb_addr;\n\tdma_addr_t dma_addr;\n\n\ttrace_swiotlb_bounced(dev, phys_to_dma(dev, paddr), size,\n\t\t\t      swiotlb_force);\n\n\tswiotlb_addr = swiotlb_tbl_map_single(dev, paddr, size, size, 0, dir,\n\t\t\tattrs);\n\tif (swiotlb_addr == (phys_addr_t)DMA_MAPPING_ERROR)\n\t\treturn DMA_MAPPING_ERROR;\n\n\t/* Ensure that the address returned is DMA'ble */\n\tdma_addr = phys_to_dma_unencrypted(dev, swiotlb_addr);\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true))) {\n\t\tswiotlb_tbl_unmap_single(dev, swiotlb_addr, size, dir,\n\t\t\tattrs | DMA_ATTR_SKIP_CPU_SYNC);\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"swiotlb addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t&dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(swiotlb_addr, size, dir);\n\treturn dma_addr;\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "enum swiotlb_force swiotlb_force;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nenum swiotlb_force swiotlb_force;\n\ndma_addr_t swiotlb_map(struct device *dev, phys_addr_t paddr, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t swiotlb_addr;\n\tdma_addr_t dma_addr;\n\n\ttrace_swiotlb_bounced(dev, phys_to_dma(dev, paddr), size,\n\t\t\t      swiotlb_force);\n\n\tswiotlb_addr = swiotlb_tbl_map_single(dev, paddr, size, size, 0, dir,\n\t\t\tattrs);\n\tif (swiotlb_addr == (phys_addr_t)DMA_MAPPING_ERROR)\n\t\treturn DMA_MAPPING_ERROR;\n\n\t/* Ensure that the address returned is DMA'ble */\n\tdma_addr = phys_to_dma_unencrypted(dev, swiotlb_addr);\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true))) {\n\t\tswiotlb_tbl_unmap_single(dev, swiotlb_addr, size, dir,\n\t\t\tattrs | DMA_ATTR_SKIP_CPU_SYNC);\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t\"swiotlb addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t&dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(swiotlb_addr, size, dir);\n\treturn dma_addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dma_capable(dev, dma_addr, size, true)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_capable",
          "args": [
            "dev",
            "dma_addr",
            "size",
            "true"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swiotlb_force_bounce",
          "args": [
            "dev"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_dma",
          "args": [
            "dev",
            "phys"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "phys_to_dma_direct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.c",
          "lines": "25-31",
          "snippet": "static inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}",
          "includes": [
            "#include \"direct.h\"",
            "#include <linux/slab.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/pfn.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>",
            "#include <linux/memblock.h> /* for max_pfn */"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"direct.h\"\n#include <linux/slab.h>\n#include <linux/set_memory.h>\n#include <linux/vmalloc.h>\n#include <linux/pfn.h>\n#include <linux/scatterlist.h>\n#include <linux/dma-map-ops.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n#include <linux/memblock.h> /* for max_pfn */\n\nstatic inline dma_addr_t phys_to_dma_direct(struct device *dev,\n\t\tphys_addr_t phys)\n{\n\tif (force_dma_unencrypted(dev))\n\t\treturn phys_to_dma_unencrypted(dev, phys);\n\treturn phys_to_dma(dev, phys);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "page"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline dma_addr_t dma_direct_map_page(struct device *dev,\n\t\tstruct page *page, unsigned long offset, size_t size,\n\t\tenum dma_data_direction dir, unsigned long attrs)\n{\n\tphys_addr_t phys = page_to_phys(page) + offset;\n\tdma_addr_t dma_addr = phys_to_dma(dev, phys);\n\n\tif (is_swiotlb_force_bounce(dev))\n\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\tif (unlikely(!dma_capable(dev, dma_addr, size, true))) {\n\t\tif (swiotlb_force != SWIOTLB_NO_FORCE)\n\t\t\treturn swiotlb_map(dev, phys, size, dir, attrs);\n\n\t\tdev_WARN_ONCE(dev, 1,\n\t\t\t     \"DMA addr %pad+%zu overflow (mask %llx, bus limit %llx).\\n\",\n\t\t\t     &dma_addr, size, *dev->dma_mask, dev->bus_dma_limit);\n\t\treturn DMA_MAPPING_ERROR;\n\t}\n\n\tif (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))\n\t\tarch_sync_dma_for_device(phys, size, dir);\n\treturn dma_addr;\n}"
  },
  {
    "function_name": "dma_direct_sync_single_for_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
    "lines": "66-81",
    "snippet": "static inline void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tarch_sync_dma_for_cpu(paddr, size, dir);\n\t\tarch_sync_dma_for_cpu_all();\n\t}\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_cpu(dev, paddr, size, dir);\n\n\tif (dir == DMA_FROM_DEVICE)\n\t\tarch_dma_mark_clean(paddr, size);\n}",
    "includes": [
      "#include <linux/dma-direct.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_dma_mark_clean",
          "args": [
            "paddr",
            "size"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_sync_single_for_cpu",
          "args": [
            "dev",
            "paddr",
            "size",
            "dir"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_sync_single_for_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "705-712",
          "snippet": "void swiotlb_sync_single_for_cpu(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_FROM_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_TO_DEVICE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_sync_single_for_cpu(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_FROM_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_FROM_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_TO_DEVICE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_swiotlb_buffer(dev, paddr)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swiotlb_buffer",
          "args": [
            "dev",
            "paddr"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_sync_dma_for_cpu_all",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_sync_dma_for_cpu",
          "args": [
            "paddr",
            "size",
            "dir"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "addr"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_sync_single_for_cpu(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (!dev_is_dma_coherent(dev)) {\n\t\tarch_sync_dma_for_cpu(paddr, size, dir);\n\t\tarch_sync_dma_for_cpu_all();\n\t}\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_cpu(dev, paddr, size, dir);\n\n\tif (dir == DMA_FROM_DEVICE)\n\t\tarch_dma_mark_clean(paddr, size);\n}"
  },
  {
    "function_name": "dma_direct_sync_single_for_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
    "lines": "54-64",
    "snippet": "static inline void dma_direct_sync_single_for_device(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_device(dev, paddr, size, dir);\n\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_sync_dma_for_device(paddr, size, dir);\n}",
    "includes": [
      "#include <linux/dma-direct.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_sync_dma_for_device",
          "args": [
            "paddr",
            "size",
            "dir"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_is_dma_coherent",
          "args": [
            "dev"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swiotlb_sync_single_for_device",
          "args": [
            "dev",
            "paddr",
            "size",
            "dir"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "swiotlb_sync_single_for_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/swiotlb.c",
          "lines": "696-703",
          "snippet": "void swiotlb_sync_single_for_device(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n}",
          "includes": [
            "#include <trace/events/swiotlb.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/io.h>",
            "#include <asm/dma.h>",
            "#include <asm/io.h>",
            "#include <linux/slab.h>",
            "#include <linux/of_reserved_mem.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/io.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/cc_platform.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/gfp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/pfn.h>",
            "#include <linux/swiotlb.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/dma-map-ops.h>",
            "#include <linux/dma-direct.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/swiotlb.h>\n#include <linux/iommu-helper.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <asm/dma.h>\n#include <asm/io.h>\n#include <linux/slab.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/set_memory.h>\n#include <linux/cc_platform.h>\n#include <linux/scatterlist.h>\n#include <linux/gfp.h>\n#include <linux/highmem.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/pfn.h>\n#include <linux/swiotlb.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-direct.h>\n#include <linux/cache.h>\n\nvoid swiotlb_sync_single_for_device(struct device *dev, phys_addr_t tlb_addr,\n\t\tsize_t size, enum dma_data_direction dir)\n{\n\tif (dir == DMA_TO_DEVICE || dir == DMA_BIDIRECTIONAL)\n\t\tswiotlb_bounce(dev, tlb_addr, size, DMA_TO_DEVICE);\n\telse\n\t\tBUG_ON(dir != DMA_FROM_DEVICE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_swiotlb_buffer(dev, paddr)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_swiotlb_buffer",
          "args": [
            "dev",
            "paddr"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_to_phys",
          "args": [
            "dev",
            "addr"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_sync_single_for_device(struct device *dev,\n\t\tdma_addr_t addr, size_t size, enum dma_data_direction dir)\n{\n\tphys_addr_t paddr = dma_to_phys(dev, addr);\n\n\tif (unlikely(is_swiotlb_buffer(dev, paddr)))\n\t\tswiotlb_sync_single_for_device(dev, paddr, size, dir);\n\n\tif (!dev_is_dma_coherent(dev))\n\t\tarch_sync_dma_for_device(paddr, size, dir);\n}"
  },
  {
    "function_name": "dma_direct_sync_sg_for_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
    "lines": "48-51",
    "snippet": "static inline void dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n}",
    "includes": [
      "#include <linux/dma-direct.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_sync_sg_for_cpu(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n}"
  },
  {
    "function_name": "dma_direct_unmap_sg",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
    "lines": "43-47",
    "snippet": "static inline void dma_direct_unmap_sg(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n}",
    "includes": [
      "#include <linux/dma-direct.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_unmap_sg(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir,\n\t\tunsigned long attrs)\n{\n}"
  },
  {
    "function_name": "dma_direct_sync_sg_for_device",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/dma/direct.h",
    "lines": "29-32",
    "snippet": "static inline void dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n}",
    "includes": [
      "#include <linux/dma-direct.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/dma-direct.h>\n\nstatic inline void dma_direct_sync_sg_for_device(struct device *dev,\n\t\tstruct scatterlist *sgl, int nents, enum dma_data_direction dir)\n{\n}"
  }
]