[
  {
    "function_name": "print_bpf_insn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/disasm.c",
    "lines": "131-304",
    "snippet": "void print_bpf_insn(const struct bpf_insn_cbs *cbs,\n\t\t    const struct bpf_insn *insn,\n\t\t    bool allow_ptr_leaks)\n{\n\tconst bpf_insn_print_t verbose = cbs->cb_print;\n\tu8 class = BPF_CLASS(insn->code);\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_OP(insn->code) == BPF_END) {\n\t\t\tif (class == BPF_ALU64)\n\t\t\t\tverbose(cbs->private_data, \"BUG_alu64_%02x\\n\", insn->code);\n\t\t\telse\n\t\t\t\tprint_bpf_end_insn(verbose, cbs->private_data, insn);\n\t\t} else if (BPF_OP(insn->code) == BPF_NEG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) %c%d = -%c%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(cbs->private_data, \"(%02x) %c%d %s %c%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->src_reg);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"(%02x) %c%d %s %d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm);\n\t\t}\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t (insn->imm == BPF_ADD || insn->imm == BPF_AND ||\n\t\t\t  insn->imm == BPF_OR || insn->imm == BPF_XOR)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) lock *(%s *)(r%d %+d) %s r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->imm) >> 4],\n\t\t\t\tinsn->src_reg);\n\t\t} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t   (insn->imm == (BPF_ADD | BPF_FETCH) ||\n\t\t\t    insn->imm == (BPF_AND | BPF_FETCH) ||\n\t\t\t    insn->imm == (BPF_OR | BPF_FETCH) ||\n\t\t\t    insn->imm == (BPF_XOR | BPF_FETCH))) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = atomic%s_fetch_%s((%s *)(r%d %+d), r%d)\\n\",\n\t\t\t\tinsn->code, insn->src_reg,\n\t\t\t\tBPF_SIZE(insn->code) == BPF_DW ? \"64\" : \"\",\n\t\t\t\tbpf_atomic_alu_string[BPF_OP(insn->imm) >> 4],\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off, insn->src_reg);\n\t\t} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t   insn->imm == BPF_CMPXCHG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = atomic%s_cmpxchg((%s *)(r%d %+d), r0, r%d)\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tBPF_SIZE(insn->code) == BPF_DW ? \"64\" : \"\",\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\t} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t   insn->imm == BPF_XCHG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = atomic%s_xchg((%s *)(r%d %+d), r%d)\\n\",\n\t\t\t\tinsn->code, insn->src_reg,\n\t\t\t\tBPF_SIZE(insn->code) == BPF_DW ? \"64\" : \"\",\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off, insn->src_reg);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_%02x\\n\", insn->code);\n\t\t}\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM) {\n\t\t\tverbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == 0xc0 /* BPF_NOSPEC, no UAPI */) {\n\t\t\tverbose(cbs->private_data, \"(%02x) nospec\\n\", insn->code);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_st_%02x\\n\", insn->code);\n\t\t}\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(cbs->private_data, \"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(cbs->private_data, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&\n\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {\n\t\t\t/* At this point, we already made sure that the second\n\t\t\t * part of the ldimm64 insn is accessible.\n\t\t\t */\n\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\t\t\tbool is_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD ||\n\t\t\t\t      insn->src_reg == BPF_PSEUDO_MAP_VALUE;\n\t\t\tchar tmp[64];\n\n\t\t\tif (is_ptr && !allow_ptr_leaks)\n\t\t\t\timm = 0;\n\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = %s\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\t__func_imm_name(cbs, insn, imm,\n\t\t\t\t\t\ttmp, sizeof(tmp)));\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_ld_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP32 || class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tchar tmp[64];\n\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL) {\n\t\t\t\tverbose(cbs->private_data, \"(%02x) call pc%s\\n\",\n\t\t\t\t\tinsn->code,\n\t\t\t\t\t__func_get_name(cbs, insn,\n\t\t\t\t\t\t\ttmp, sizeof(tmp)));\n\t\t\t} else {\n\t\t\t\tstrcpy(tmp, \"unknown\");\n\t\t\t\tverbose(cbs->private_data, \"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\t\t__func_get_name(cbs, insn,\n\t\t\t\t\t\t\ttmp, sizeof(tmp)),\n\t\t\t\t\tinsn->imm);\n\t\t\t}\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(cbs->private_data,\n\t\t\t\t\"(%02x) if %c%d %s %c%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, class == BPF_JMP32 ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_JMP32 ? 'w' : 'r',\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(cbs->private_data,\n\t\t\t\t\"(%02x) if %c%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, class == BPF_JMP32 ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(cbs->private_data, \"(%02x) %s\\n\",\n\t\t\tinsn->code, bpf_class_string[class]);\n\t}\n}",
    "includes": [
      "#include \"disasm.h\"",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char *const bpf_class_string[8] = {\n\t[BPF_LD]    = \"ld\",\n\t[BPF_LDX]   = \"ldx\",\n\t[BPF_ST]    = \"st\",\n\t[BPF_STX]   = \"stx\",\n\t[BPF_ALU]   = \"alu\",\n\t[BPF_JMP]   = \"jmp\",\n\t[BPF_JMP32] = \"jmp32\",\n\t[BPF_ALU64] = \"alu64\",\n};",
      "const char *const bpf_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"+=\",\n\t[BPF_SUB >> 4]  = \"-=\",\n\t[BPF_MUL >> 4]  = \"*=\",\n\t[BPF_DIV >> 4]  = \"/=\",\n\t[BPF_OR  >> 4]  = \"|=\",\n\t[BPF_AND >> 4]  = \"&=\",\n\t[BPF_LSH >> 4]  = \"<<=\",\n\t[BPF_RSH >> 4]  = \">>=\",\n\t[BPF_NEG >> 4]  = \"neg\",\n\t[BPF_MOD >> 4]  = \"%=\",\n\t[BPF_XOR >> 4]  = \"^=\",\n\t[BPF_MOV >> 4]  = \"=\",\n\t[BPF_ARSH >> 4] = \"s>>=\",\n\t[BPF_END >> 4]  = \"endian\",\n};",
      "static const char *const bpf_atomic_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"add\",\n\t[BPF_AND >> 4]  = \"and\",\n\t[BPF_OR >> 4]  = \"or\",\n\t[BPF_XOR >> 4]  = \"xor\",\n};",
      "static const char *const bpf_ldst_string[] = {\n\t[BPF_W >> 3]  = \"u32\",\n\t[BPF_H >> 3]  = \"u16\",\n\t[BPF_B >> 3]  = \"u8\",\n\t[BPF_DW >> 3] = \"u64\",\n};",
      "static const char *const bpf_jmp_string[16] = {\n\t[BPF_JA >> 4]   = \"jmp\",\n\t[BPF_JEQ >> 4]  = \"==\",\n\t[BPF_JGT >> 4]  = \">\",\n\t[BPF_JLT >> 4]  = \"<\",\n\t[BPF_JGE >> 4]  = \">=\",\n\t[BPF_JLE >> 4]  = \"<=\",\n\t[BPF_JSET >> 4] = \"&\",\n\t[BPF_JNE >> 4]  = \"!=\",\n\t[BPF_JSGT >> 4] = \"s>\",\n\t[BPF_JSLT >> 4] = \"s<\",\n\t[BPF_JSGE >> 4] = \"s>=\",\n\t[BPF_JSLE >> 4] = \"s<=\",\n\t[BPF_CALL >> 4] = \"call\",\n\t[BPF_EXIT >> 4] = \"exit\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "cbs->private_data",
            "\"(%02x) %s\\n\"",
            "insn->code",
            "bpf_class_string[class]"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "342-353",
          "snippet": "static void verbose(void *private_data, const char *fmt, ...)\n{\n\tstruct bpf_verifier_env *env = private_data;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void verbose(void *private_data, const char *fmt, ...)\n{\n\tstruct bpf_verifier_env *env = private_data;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SRC",
          "args": [
            "insn->code"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__func_get_name",
          "args": [
            "cbs",
            "insn",
            "tmp",
            "sizeof(tmp)"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "__func_get_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/disasm.c",
          "lines": "16-41",
          "snippet": "static const char *__func_get_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   char *buff, size_t len)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (!insn->src_reg &&\n\t    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&\n\t    func_id_str[insn->imm])\n\t\treturn func_id_str[insn->imm];\n\n\tif (cbs && cbs->cb_call) {\n\t\tconst char *res;\n\n\t\tres = cbs->cb_call(cbs->private_data, insn);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\tsnprintf(buff, len, \"%+d\", insn->imm);\n\telse if (insn->src_reg == BPF_PSEUDO_KFUNC_CALL)\n\t\tsnprintf(buff, len, \"kernel-function\");\n\n\treturn buff;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};\n\nstatic const char *__func_get_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   char *buff, size_t len)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (!insn->src_reg &&\n\t    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&\n\t    func_id_str[insn->imm])\n\t\treturn func_id_str[insn->imm];\n\n\tif (cbs && cbs->cb_call) {\n\t\tconst char *res;\n\n\t\tres = cbs->cb_call(cbs->private_data, insn);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\tsnprintf(buff, len, \"%+d\", insn->imm);\n\telse if (insn->src_reg == BPF_PSEUDO_KFUNC_CALL)\n\t\tsnprintf(buff, len, \"kernel-function\");\n\n\treturn buff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tmp",
            "\"unknown\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__func_imm_name",
          "args": [
            "cbs",
            "insn",
            "imm",
            "tmp",
            "sizeof(tmp)"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "__func_imm_name",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/disasm.c",
          "lines": "43-52",
          "snippet": "static const char *__func_imm_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   u64 full_imm, char *buff, size_t len)\n{\n\tif (cbs && cbs->cb_imm)\n\t\treturn cbs->cb_imm(cbs->private_data, insn, full_imm);\n\n\tsnprintf(buff, len, \"0x%llx\", (unsigned long long)full_imm);\n\treturn buff;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic const char *__func_imm_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   u64 full_imm, char *buff, size_t len)\n{\n\tif (cbs && cbs->cb_imm)\n\t\treturn cbs->cb_imm(cbs->private_data, insn, full_imm);\n\n\tsnprintf(buff, len, \"0x%llx\", (unsigned long long)full_imm);\n\treturn buff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "insn + 1"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->imm"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->imm"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SIZE",
          "args": [
            "insn->code"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_MODE",
          "args": [
            "insn->code"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_SRC",
          "args": [
            "insn->code"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_bpf_end_insn",
          "args": [
            "verbose",
            "cbs->private_data",
            "insn"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "print_bpf_end_insn",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/disasm.c",
          "lines": "121-129",
          "snippet": "static void print_bpf_end_insn(bpf_insn_print_t verbose,\n\t\t\t       void *private_data,\n\t\t\t       const struct bpf_insn *insn)\n{\n\tverbose(private_data, \"(%02x) r%d = %s%d r%d\\n\",\n\t\tinsn->code, insn->dst_reg,\n\t\tBPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",\n\t\tinsn->imm, insn->dst_reg);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic void print_bpf_end_insn(bpf_insn_print_t verbose,\n\t\t\t       void *private_data,\n\t\t\t       const struct bpf_insn *insn)\n{\n\tverbose(private_data, \"(%02x) r%d = %s%d r%d\\n\",\n\t\tinsn->code, insn->dst_reg,\n\t\tBPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",\n\t\tinsn->imm, insn->dst_reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_OP",
          "args": [
            "insn->code"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BPF_CLASS",
          "args": [
            "insn->code"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nconst char *const bpf_class_string[8] = {\n\t[BPF_LD]    = \"ld\",\n\t[BPF_LDX]   = \"ldx\",\n\t[BPF_ST]    = \"st\",\n\t[BPF_STX]   = \"stx\",\n\t[BPF_ALU]   = \"alu\",\n\t[BPF_JMP]   = \"jmp\",\n\t[BPF_JMP32] = \"jmp32\",\n\t[BPF_ALU64] = \"alu64\",\n};\nconst char *const bpf_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"+=\",\n\t[BPF_SUB >> 4]  = \"-=\",\n\t[BPF_MUL >> 4]  = \"*=\",\n\t[BPF_DIV >> 4]  = \"/=\",\n\t[BPF_OR  >> 4]  = \"|=\",\n\t[BPF_AND >> 4]  = \"&=\",\n\t[BPF_LSH >> 4]  = \"<<=\",\n\t[BPF_RSH >> 4]  = \">>=\",\n\t[BPF_NEG >> 4]  = \"neg\",\n\t[BPF_MOD >> 4]  = \"%=\",\n\t[BPF_XOR >> 4]  = \"^=\",\n\t[BPF_MOV >> 4]  = \"=\",\n\t[BPF_ARSH >> 4] = \"s>>=\",\n\t[BPF_END >> 4]  = \"endian\",\n};\nstatic const char *const bpf_atomic_alu_string[16] = {\n\t[BPF_ADD >> 4]  = \"add\",\n\t[BPF_AND >> 4]  = \"and\",\n\t[BPF_OR >> 4]  = \"or\",\n\t[BPF_XOR >> 4]  = \"xor\",\n};\nstatic const char *const bpf_ldst_string[] = {\n\t[BPF_W >> 3]  = \"u32\",\n\t[BPF_H >> 3]  = \"u16\",\n\t[BPF_B >> 3]  = \"u8\",\n\t[BPF_DW >> 3] = \"u64\",\n};\nstatic const char *const bpf_jmp_string[16] = {\n\t[BPF_JA >> 4]   = \"jmp\",\n\t[BPF_JEQ >> 4]  = \"==\",\n\t[BPF_JGT >> 4]  = \">\",\n\t[BPF_JLT >> 4]  = \"<\",\n\t[BPF_JGE >> 4]  = \">=\",\n\t[BPF_JLE >> 4]  = \"<=\",\n\t[BPF_JSET >> 4] = \"&\",\n\t[BPF_JNE >> 4]  = \"!=\",\n\t[BPF_JSGT >> 4] = \"s>\",\n\t[BPF_JSLT >> 4] = \"s<\",\n\t[BPF_JSGE >> 4] = \"s>=\",\n\t[BPF_JSLE >> 4] = \"s<=\",\n\t[BPF_CALL >> 4] = \"call\",\n\t[BPF_EXIT >> 4] = \"exit\",\n};\n\nvoid print_bpf_insn(const struct bpf_insn_cbs *cbs,\n\t\t    const struct bpf_insn *insn,\n\t\t    bool allow_ptr_leaks)\n{\n\tconst bpf_insn_print_t verbose = cbs->cb_print;\n\tu8 class = BPF_CLASS(insn->code);\n\n\tif (class == BPF_ALU || class == BPF_ALU64) {\n\t\tif (BPF_OP(insn->code) == BPF_END) {\n\t\t\tif (class == BPF_ALU64)\n\t\t\t\tverbose(cbs->private_data, \"BUG_alu64_%02x\\n\", insn->code);\n\t\t\telse\n\t\t\t\tprint_bpf_end_insn(verbose, cbs->private_data, insn);\n\t\t} else if (BPF_OP(insn->code) == BPF_NEG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) %c%d = -%c%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(cbs->private_data, \"(%02x) %c%d %s %c%d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->src_reg);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"(%02x) %c%d %s %d\\n\",\n\t\t\t\tinsn->code, class == BPF_ALU ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm);\n\t\t}\n\t} else if (class == BPF_STX) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM)\n\t\t\tverbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->src_reg);\n\t\telse if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t (insn->imm == BPF_ADD || insn->imm == BPF_AND ||\n\t\t\t  insn->imm == BPF_OR || insn->imm == BPF_XOR)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) lock *(%s *)(r%d %+d) %s r%d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tbpf_alu_string[BPF_OP(insn->imm) >> 4],\n\t\t\t\tinsn->src_reg);\n\t\t} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t   (insn->imm == (BPF_ADD | BPF_FETCH) ||\n\t\t\t    insn->imm == (BPF_AND | BPF_FETCH) ||\n\t\t\t    insn->imm == (BPF_OR | BPF_FETCH) ||\n\t\t\t    insn->imm == (BPF_XOR | BPF_FETCH))) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = atomic%s_fetch_%s((%s *)(r%d %+d), r%d)\\n\",\n\t\t\t\tinsn->code, insn->src_reg,\n\t\t\t\tBPF_SIZE(insn->code) == BPF_DW ? \"64\" : \"\",\n\t\t\t\tbpf_atomic_alu_string[BPF_OP(insn->imm) >> 4],\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off, insn->src_reg);\n\t\t} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t   insn->imm == BPF_CMPXCHG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = atomic%s_cmpxchg((%s *)(r%d %+d), r0, r%d)\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tBPF_SIZE(insn->code) == BPF_DW ? \"64\" : \"\",\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off,\n\t\t\t\tinsn->src_reg);\n\t\t} else if (BPF_MODE(insn->code) == BPF_ATOMIC &&\n\t\t\t   insn->imm == BPF_XCHG) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = atomic%s_xchg((%s *)(r%d %+d), r%d)\\n\",\n\t\t\t\tinsn->code, insn->src_reg,\n\t\t\t\tBPF_SIZE(insn->code) == BPF_DW ? \"64\" : \"\",\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg, insn->off, insn->src_reg);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_%02x\\n\", insn->code);\n\t\t}\n\t} else if (class == BPF_ST) {\n\t\tif (BPF_MODE(insn->code) == BPF_MEM) {\n\t\t\tverbose(cbs->private_data, \"(%02x) *(%s *)(r%d %+d) = %d\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tinsn->off, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == 0xc0 /* BPF_NOSPEC, no UAPI */) {\n\t\t\tverbose(cbs->private_data, \"(%02x) nospec\\n\", insn->code);\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_st_%02x\\n\", insn->code);\n\t\t}\n\t} else if (class == BPF_LDX) {\n\t\tif (BPF_MODE(insn->code) != BPF_MEM) {\n\t\t\tverbose(cbs->private_data, \"BUG_ldx_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t\tverbose(cbs->private_data, \"(%02x) r%d = *(%s *)(r%d %+d)\\n\",\n\t\t\tinsn->code, insn->dst_reg,\n\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\tinsn->src_reg, insn->off);\n\t} else if (class == BPF_LD) {\n\t\tif (BPF_MODE(insn->code) == BPF_ABS) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[%d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IND) {\n\t\t\tverbose(cbs->private_data, \"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\",\n\t\t\t\tinsn->code,\n\t\t\t\tbpf_ldst_string[BPF_SIZE(insn->code) >> 3],\n\t\t\t\tinsn->src_reg, insn->imm);\n\t\t} else if (BPF_MODE(insn->code) == BPF_IMM &&\n\t\t\t   BPF_SIZE(insn->code) == BPF_DW) {\n\t\t\t/* At this point, we already made sure that the second\n\t\t\t * part of the ldimm64 insn is accessible.\n\t\t\t */\n\t\t\tu64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;\n\t\t\tbool is_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD ||\n\t\t\t\t      insn->src_reg == BPF_PSEUDO_MAP_VALUE;\n\t\t\tchar tmp[64];\n\n\t\t\tif (is_ptr && !allow_ptr_leaks)\n\t\t\t\timm = 0;\n\n\t\t\tverbose(cbs->private_data, \"(%02x) r%d = %s\\n\",\n\t\t\t\tinsn->code, insn->dst_reg,\n\t\t\t\t__func_imm_name(cbs, insn, imm,\n\t\t\t\t\t\ttmp, sizeof(tmp)));\n\t\t} else {\n\t\t\tverbose(cbs->private_data, \"BUG_ld_%02x\\n\", insn->code);\n\t\t\treturn;\n\t\t}\n\t} else if (class == BPF_JMP32 || class == BPF_JMP) {\n\t\tu8 opcode = BPF_OP(insn->code);\n\n\t\tif (opcode == BPF_CALL) {\n\t\t\tchar tmp[64];\n\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL) {\n\t\t\t\tverbose(cbs->private_data, \"(%02x) call pc%s\\n\",\n\t\t\t\t\tinsn->code,\n\t\t\t\t\t__func_get_name(cbs, insn,\n\t\t\t\t\t\t\ttmp, sizeof(tmp)));\n\t\t\t} else {\n\t\t\t\tstrcpy(tmp, \"unknown\");\n\t\t\t\tverbose(cbs->private_data, \"(%02x) call %s#%d\\n\", insn->code,\n\t\t\t\t\t__func_get_name(cbs, insn,\n\t\t\t\t\t\t\ttmp, sizeof(tmp)),\n\t\t\t\t\tinsn->imm);\n\t\t\t}\n\t\t} else if (insn->code == (BPF_JMP | BPF_JA)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) goto pc%+d\\n\",\n\t\t\t\tinsn->code, insn->off);\n\t\t} else if (insn->code == (BPF_JMP | BPF_EXIT)) {\n\t\t\tverbose(cbs->private_data, \"(%02x) exit\\n\", insn->code);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tverbose(cbs->private_data,\n\t\t\t\t\"(%02x) if %c%d %s %c%d goto pc%+d\\n\",\n\t\t\t\tinsn->code, class == BPF_JMP32 ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tclass == BPF_JMP32 ? 'w' : 'r',\n\t\t\t\tinsn->src_reg, insn->off);\n\t\t} else {\n\t\t\tverbose(cbs->private_data,\n\t\t\t\t\"(%02x) if %c%d %s 0x%x goto pc%+d\\n\",\n\t\t\t\tinsn->code, class == BPF_JMP32 ? 'w' : 'r',\n\t\t\t\tinsn->dst_reg,\n\t\t\t\tbpf_jmp_string[BPF_OP(insn->code) >> 4],\n\t\t\t\tinsn->imm, insn->off);\n\t\t}\n\t} else {\n\t\tverbose(cbs->private_data, \"(%02x) %s\\n\",\n\t\t\tinsn->code, bpf_class_string[class]);\n\t}\n}"
  },
  {
    "function_name": "print_bpf_end_insn",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/disasm.c",
    "lines": "121-129",
    "snippet": "static void print_bpf_end_insn(bpf_insn_print_t verbose,\n\t\t\t       void *private_data,\n\t\t\t       const struct bpf_insn *insn)\n{\n\tverbose(private_data, \"(%02x) r%d = %s%d r%d\\n\",\n\t\tinsn->code, insn->dst_reg,\n\t\tBPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",\n\t\tinsn->imm, insn->dst_reg);\n}",
    "includes": [
      "#include \"disasm.h\"",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "private_data",
            "\"(%02x) r%d = %s%d r%d\\n\"",
            "insn->code",
            "insn->dst_reg",
            "BPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\"",
            "insn->imm",
            "insn->dst_reg"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "verbose",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "342-353",
          "snippet": "static void verbose(void *private_data, const char *fmt, ...)\n{\n\tstruct bpf_verifier_env *env = private_data;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void verbose(void *private_data, const char *fmt, ...)\n{\n\tstruct bpf_verifier_env *env = private_data;\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BPF_SRC",
          "args": [
            "insn->code"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic void print_bpf_end_insn(bpf_insn_print_t verbose,\n\t\t\t       void *private_data,\n\t\t\t       const struct bpf_insn *insn)\n{\n\tverbose(private_data, \"(%02x) r%d = %s%d r%d\\n\",\n\t\tinsn->code, insn->dst_reg,\n\t\tBPF_SRC(insn->code) == BPF_TO_BE ? \"be\" : \"le\",\n\t\tinsn->imm, insn->dst_reg);\n}"
  },
  {
    "function_name": "func_id_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/disasm.c",
    "lines": "54-60",
    "snippet": "const char *func_id_name(int id)\n{\n\tif (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])\n\t\treturn func_id_str[id];\n\telse\n\t\treturn \"unknown\";\n}",
    "includes": [
      "#include \"disasm.h\"",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};\n\nconst char *func_id_name(int id)\n{\n\tif (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])\n\t\treturn func_id_str[id];\n\telse\n\t\treturn \"unknown\";\n}"
  },
  {
    "function_name": "__func_imm_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/disasm.c",
    "lines": "43-52",
    "snippet": "static const char *__func_imm_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   u64 full_imm, char *buff, size_t len)\n{\n\tif (cbs && cbs->cb_imm)\n\t\treturn cbs->cb_imm(cbs->private_data, insn, full_imm);\n\n\tsnprintf(buff, len, \"0x%llx\", (unsigned long long)full_imm);\n\treturn buff;\n}",
    "includes": [
      "#include \"disasm.h\"",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buff",
            "len",
            "\"0x%llx\"",
            "(unsigned long long)full_imm"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbs->cb_imm",
          "args": [
            "cbs->private_data",
            "insn",
            "full_imm"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic const char *__func_imm_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   u64 full_imm, char *buff, size_t len)\n{\n\tif (cbs && cbs->cb_imm)\n\t\treturn cbs->cb_imm(cbs->private_data, insn, full_imm);\n\n\tsnprintf(buff, len, \"0x%llx\", (unsigned long long)full_imm);\n\treturn buff;\n}"
  },
  {
    "function_name": "__func_get_name",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/disasm.c",
    "lines": "16-41",
    "snippet": "static const char *__func_get_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   char *buff, size_t len)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (!insn->src_reg &&\n\t    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&\n\t    func_id_str[insn->imm])\n\t\treturn func_id_str[insn->imm];\n\n\tif (cbs && cbs->cb_call) {\n\t\tconst char *res;\n\n\t\tres = cbs->cb_call(cbs->private_data, insn);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\tsnprintf(buff, len, \"%+d\", insn->imm);\n\telse if (insn->src_reg == BPF_PSEUDO_KFUNC_CALL)\n\t\tsnprintf(buff, len, \"kernel-function\");\n\n\treturn buff;\n}",
    "includes": [
      "#include \"disasm.h\"",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buff",
            "len",
            "\"kernel-function\""
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "btf_snprintf_show",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/btf.c",
          "lines": "5972-5992",
          "snippet": "static void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}",
          "includes": [
            "#include <linux/bpf_types.h>",
            "#include \"../tools/lib/bpf/relo_core.h\"",
            "#include <net/sock.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/skmsg.h>",
            "#include <linux/btf_ids.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/bpf_perf_event.h>",
            "#include <uapi/linux/bpf.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_types.h>\n#include \"../tools/lib/bpf/relo_core.h\"\n#include <net/sock.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/bsearch.h>\n#include <linux/perf_event.h>\n#include <linux/skmsg.h>\n#include <linux/btf_ids.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/ctype.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/bpf_perf_event.h>\n#include <uapi/linux/bpf.h>\n#include <uapi/linux/btf.h>\n\nstatic void btf_snprintf_show(struct btf_show *show, const char *fmt,\n\t\t\t      va_list args)\n{\n\tstruct btf_show_snprintf *ssnprintf = (struct btf_show_snprintf *)show;\n\tint len;\n\n\tlen = vsnprintf(show->target, ssnprintf->len_left, fmt, args);\n\n\tif (len < 0) {\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len = len;\n\t} else if (len > ssnprintf->len_left) {\n\t\t/* no space, drive on to get length we would have written */\n\t\tssnprintf->len_left = 0;\n\t\tssnprintf->len += len;\n\t} else {\n\t\tssnprintf->len_left -= len;\n\t\tssnprintf->len += len;\n\t\tshow->target += len;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buff",
            "len",
            "\"%+d\"",
            "insn->imm"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbs->cb_call",
          "args": [
            "cbs->private_data",
            "insn"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "func_id_str"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"disasm.h\"\n#include <linux/bpf.h>\n\nstatic const char * const func_id_str[] = {\n\t__BPF_FUNC_MAPPER(__BPF_FUNC_STR_FN)\n};\n\nstatic const char *__func_get_name(const struct bpf_insn_cbs *cbs,\n\t\t\t\t   const struct bpf_insn *insn,\n\t\t\t\t   char *buff, size_t len)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (!insn->src_reg &&\n\t    insn->imm >= 0 && insn->imm < __BPF_FUNC_MAX_ID &&\n\t    func_id_str[insn->imm])\n\t\treturn func_id_str[insn->imm];\n\n\tif (cbs && cbs->cb_call) {\n\t\tconst char *res;\n\n\t\tres = cbs->cb_call(cbs->private_data, insn);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\tsnprintf(buff, len, \"%+d\", insn->imm);\n\telse if (insn->src_reg == BPF_PSEUDO_KFUNC_CALL)\n\t\tsnprintf(buff, len, \"kernel-function\");\n\n\treturn buff;\n}"
  }
]