[
  {
    "function_name": "irqpoll_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "464-476",
    "snippet": "static int __init irqpoll_setup(char *str)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tpr_warn(\"irqpoll boot option not supported with PREEMPT_RT\\n\");\n\t\treturn 1;\n\t}\n\tirqfixup = 2;\n\tprintk(KERN_WARNING \"Misrouted IRQ fixup and polling support \"\n\t\t\t\t\"enabled\\n\");\n\tprintk(KERN_WARNING \"This may significantly impact system \"\n\t\t\t\t\"performance\\n\");\n\treturn 1;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"This may significantly impact system \"\n\t\t\t\t\"performance\\n\""
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"irqpoll boot option not supported with PREEMPT_RT\\n\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic int __init irqpoll_setup(char *str)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tpr_warn(\"irqpoll boot option not supported with PREEMPT_RT\\n\");\n\t\treturn 1;\n\t}\n\tirqfixup = 2;\n\tprintk(KERN_WARNING \"Misrouted IRQ fixup and polling support \"\n\t\t\t\t\"enabled\\n\");\n\tprintk(KERN_WARNING \"This may significantly impact system \"\n\t\t\t\t\"performance\\n\");\n\treturn 1;\n}"
  },
  {
    "function_name": "irqfixup_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "448-459",
    "snippet": "static int __init irqfixup_setup(char *str)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tpr_warn(\"irqfixup boot option not supported with PREEMPT_RT\\n\");\n\t\treturn 1;\n\t}\n\tirqfixup = 1;\n\tprintk(KERN_WARNING \"Misrouted IRQ fixup support enabled.\\n\");\n\tprintk(KERN_WARNING \"This may impact system performance.\\n\");\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"This may impact system performance.\\n\""
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"irqfixup boot option not supported with PREEMPT_RT\\n\""
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_PREEMPT_RT"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic int __init irqfixup_setup(char *str)\n{\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT)) {\n\t\tpr_warn(\"irqfixup boot option not supported with PREEMPT_RT\\n\");\n\t\treturn 1;\n\t}\n\tirqfixup = 1;\n\tprintk(KERN_WARNING \"Misrouted IRQ fixup support enabled.\\n\");\n\tprintk(KERN_WARNING \"This may impact system performance.\\n\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "noirqdebug_setup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "436-442",
    "snippet": "int noirqdebug_setup(char *str)\n{\n\tnoirqdebug = 1;\n\tprintk(KERN_INFO \"IRQ lockup detection disabled\\n\");\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool noirqdebug"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"IRQ lockup detection disabled\\n\""
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nbool noirqdebug;\n\nint noirqdebug_setup(char *str)\n{\n\tnoirqdebug = 1;\n\tprintk(KERN_INFO \"IRQ lockup detection disabled\\n\");\n\n\treturn 1;\n}"
  },
  {
    "function_name": "note_interrupt",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "272-432",
    "snippet": "void note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq;\n\n\tif (desc->istate & IRQS_POLL_INPROGRESS ||\n\t    irq_settings_is_polled(desc))\n\t\treturn;\n\n\tif (bad_action_ret(action_ret)) {\n\t\treport_bad_irq(desc, action_ret);\n\t\treturn;\n\t}\n\n\t/*\n\t * We cannot call note_interrupt from the threaded handler\n\t * because we need to look at the compound of all handlers\n\t * (primary and threaded). Aside of that in the threaded\n\t * shared case we have no serialization against an incoming\n\t * hardware interrupt while we are dealing with a threaded\n\t * result.\n\t *\n\t * So in case a thread is woken, we just note the fact and\n\t * defer the analysis to the next hardware interrupt.\n\t *\n\t * The threaded handlers store whether they successfully\n\t * handled an interrupt and we check whether that number\n\t * changed versus the last invocation.\n\t *\n\t * We could handle all interrupts with the delayed by one\n\t * mechanism, but for the non forced threaded case we'd just\n\t * add pointless overhead to the straight hardirq interrupts\n\t * for the sake of a few lines less code.\n\t */\n\tif (action_ret & IRQ_WAKE_THREAD) {\n\t\t/*\n\t\t * There is a thread woken. Check whether one of the\n\t\t * shared primary handlers returned IRQ_HANDLED. If\n\t\t * not we defer the spurious detection to the next\n\t\t * interrupt.\n\t\t */\n\t\tif (action_ret == IRQ_WAKE_THREAD) {\n\t\t\tint handled;\n\t\t\t/*\n\t\t\t * We use bit 31 of thread_handled_last to\n\t\t\t * denote the deferred spurious detection\n\t\t\t * active. No locking necessary as\n\t\t\t * thread_handled_last is only accessed here\n\t\t\t * and we have the guarantee that hard\n\t\t\t * interrupts are not reentrant.\n\t\t\t */\n\t\t\tif (!(desc->threads_handled_last & SPURIOUS_DEFERRED)) {\n\t\t\t\tdesc->threads_handled_last |= SPURIOUS_DEFERRED;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Check whether one of the threaded handlers\n\t\t\t * returned IRQ_HANDLED since the last\n\t\t\t * interrupt happened.\n\t\t\t *\n\t\t\t * For simplicity we just set bit 31, as it is\n\t\t\t * set in threads_handled_last as well. So we\n\t\t\t * avoid extra masking. And we really do not\n\t\t\t * care about the high bits of the handled\n\t\t\t * count. We just care about the count being\n\t\t\t * different than the one we saw before.\n\t\t\t */\n\t\t\thandled = atomic_read(&desc->threads_handled);\n\t\t\thandled |= SPURIOUS_DEFERRED;\n\t\t\tif (handled != desc->threads_handled_last) {\n\t\t\t\taction_ret = IRQ_HANDLED;\n\t\t\t\t/*\n\t\t\t\t * Note: We keep the SPURIOUS_DEFERRED\n\t\t\t\t * bit set. We are handling the\n\t\t\t\t * previous invocation right now.\n\t\t\t\t * Keep it for the current one, so the\n\t\t\t\t * next hardware interrupt will\n\t\t\t\t * account for it.\n\t\t\t\t */\n\t\t\t\tdesc->threads_handled_last = handled;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * None of the threaded handlers felt\n\t\t\t\t * responsible for the last interrupt\n\t\t\t\t *\n\t\t\t\t * We keep the SPURIOUS_DEFERRED bit\n\t\t\t\t * set in threads_handled_last as we\n\t\t\t\t * need to account for the current\n\t\t\t\t * interrupt as well.\n\t\t\t\t */\n\t\t\t\taction_ret = IRQ_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * One of the primary handlers returned\n\t\t\t * IRQ_HANDLED. So we don't care about the\n\t\t\t * threaded handlers on the same line. Clear\n\t\t\t * the deferred detection bit.\n\t\t\t *\n\t\t\t * In theory we could/should check whether the\n\t\t\t * deferred bit is set and take the result of\n\t\t\t * the previous run into account here as\n\t\t\t * well. But it's really not worth the\n\t\t\t * trouble. If every other interrupt is\n\t\t\t * handled we never trigger the spurious\n\t\t\t * detector. And if this is just the one out\n\t\t\t * of 100k unhandled ones which is handled\n\t\t\t * then we merily delay the spurious detection\n\t\t\t * by one hard interrupt. Not a real problem.\n\t\t\t */\n\t\t\tdesc->threads_handled_last &= ~SPURIOUS_DEFERRED;\n\t\t}\n\t}\n\n\tif (unlikely(action_ret == IRQ_NONE)) {\n\t\t/*\n\t\t * If we are seeing only the odd spurious IRQ caused by\n\t\t * bus asynchronicity then don't eventually trigger an error,\n\t\t * otherwise the counter becomes a doomsday timer for otherwise\n\t\t * working systems\n\t\t */\n\t\tif (time_after(jiffies, desc->last_unhandled + HZ/10))\n\t\t\tdesc->irqs_unhandled = 1;\n\t\telse\n\t\t\tdesc->irqs_unhandled++;\n\t\tdesc->last_unhandled = jiffies;\n\t}\n\n\tirq = irq_desc_get_irq(desc);\n\tif (unlikely(try_misrouted_irq(irq, desc, action_ret))) {\n\t\tint ok = misrouted_irq(irq);\n\t\tif (action_ret == IRQ_NONE)\n\t\t\tdesc->irqs_unhandled -= ok;\n\t}\n\n\tif (likely(!desc->irqs_unhandled))\n\t\treturn;\n\n\t/* Now getting into unhandled irq detection */\n\tdesc->irq_count++;\n\tif (likely(desc->irq_count < 100000))\n\t\treturn;\n\n\tdesc->irq_count = 0;\n\tif (unlikely(desc->irqs_unhandled > 99900)) {\n\t\t/*\n\t\t * The interrupt is stuck\n\t\t */\n\t\t__report_bad_irq(desc, action_ret);\n\t\t/*\n\t\t * Now kill the IRQ\n\t\t */\n\t\tprintk(KERN_EMERG \"Disabling IRQ #%d\\n\", irq);\n\t\tdesc->istate |= IRQS_SPURIOUS_DISABLED;\n\t\tdesc->depth++;\n\t\tirq_disable(desc);\n\n\t\tmod_timer(&poll_spurious_irq_timer,\n\t\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);\n\t}\n\tdesc->irqs_unhandled = 0;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [
      "#define SPURIOUS_DEFERRED\t0x80000000",
      "#define POLL_SPURIOUS_IRQ_INTERVAL (HZ/10)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&poll_spurious_irq_timer",
            "jiffies + POLL_SPURIOUS_IRQ_INTERVAL"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_disable",
          "args": [
            "desc"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "irq_disable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/chip.c",
          "lines": "386-389",
          "snippet": "void irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid irq_disable(struct irq_desc *desc)\n{\n\t__irq_disable(desc, irq_settings_disable_unlazy(desc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Disabling IRQ #%d\\n\"",
            "irq"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__report_bad_irq",
          "args": [
            "desc",
            "action_ret"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "__report_bad_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "192-223",
          "snippet": "static void __report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (bad_action_ret(action_ret)) {\n\t\tprintk(KERN_ERR \"irq event %d: bogus return value %x\\n\",\n\t\t\t\tirq, action_ret);\n\t} else {\n\t\tprintk(KERN_ERR \"irq %d: nobody cared (try booting with \"\n\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);\n\t}\n\tdump_stack();\n\tprintk(KERN_ERR \"handlers:\\n\");\n\n\t/*\n\t * We need to take desc->lock here. note_interrupt() is called\n\t * w/o desc->lock held, but IRQ_PROGRESS set. We might race\n\t * with something else removing an action. It's ok to take\n\t * desc->lock here. See synchronize_irq().\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tprintk(KERN_ERR \"[<%p>] %ps\", action->handler, action->handler);\n\t\tif (action->thread_fn)\n\t\t\tprintk(KERN_CONT \" threaded [<%p>] %ps\",\n\t\t\t\t\taction->thread_fn, action->thread_fn);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic void __report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (bad_action_ret(action_ret)) {\n\t\tprintk(KERN_ERR \"irq event %d: bogus return value %x\\n\",\n\t\t\t\tirq, action_ret);\n\t} else {\n\t\tprintk(KERN_ERR \"irq %d: nobody cared (try booting with \"\n\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);\n\t}\n\tdump_stack();\n\tprintk(KERN_ERR \"handlers:\\n\");\n\n\t/*\n\t * We need to take desc->lock here. note_interrupt() is called\n\t * w/o desc->lock held, but IRQ_PROGRESS set. We might race\n\t * with something else removing an action. It's ok to take\n\t * desc->lock here. See synchronize_irq().\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tprintk(KERN_ERR \"[<%p>] %ps\", action->handler, action->handler);\n\t\tif (action->thread_fn)\n\t\t\tprintk(KERN_CONT \" threaded [<%p>] %ps\",\n\t\t\t\t\taction->thread_fn, action->thread_fn);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "desc->irqs_unhandled > 99900"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "desc->irq_count < 100000"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!desc->irqs_unhandled"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misrouted_irq",
          "args": [
            "irq"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "misrouted_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "118-142",
          "snippet": "static int misrouted_irq(int irq)\n{\n\tstruct irq_desc *desc;\n\tint i, ok = 0;\n\n\tif (atomic_inc_return(&irq_poll_active) != 1)\n\t\tgoto out;\n\n\tirq_poll_cpu = smp_processor_id();\n\n\tfor_each_irq_desc(i, desc) {\n\t\tif (!i)\n\t\t\t continue;\n\n\t\tif (i == irq)\t/* Already tried */\n\t\t\tcontinue;\n\n\t\tif (try_one_irq(desc, false))\n\t\t\tok = 1;\n\t}\nout:\n\tatomic_dec(&irq_poll_active);\n\t/* So the caller can adjust the irq error counts */\n\treturn ok;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int irq_poll_cpu;",
            "static atomic_t irq_poll_active;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic int irq_poll_cpu;\nstatic atomic_t irq_poll_active;\n\nstatic int misrouted_irq(int irq)\n{\n\tstruct irq_desc *desc;\n\tint i, ok = 0;\n\n\tif (atomic_inc_return(&irq_poll_active) != 1)\n\t\tgoto out;\n\n\tirq_poll_cpu = smp_processor_id();\n\n\tfor_each_irq_desc(i, desc) {\n\t\tif (!i)\n\t\t\t continue;\n\n\t\tif (i == irq)\t/* Already tried */\n\t\t\tcontinue;\n\n\t\tif (try_one_irq(desc, false))\n\t\t\tok = 1;\n\t}\nout:\n\tatomic_dec(&irq_poll_active);\n\t/* So the caller can adjust the irq error counts */\n\treturn ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "try_misrouted_irq(irq, desc, action_ret)"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_misrouted_irq",
          "args": [
            "irq",
            "desc",
            "action_ret"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "try_misrouted_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "235-268",
          "snippet": "static inline int\ntry_misrouted_irq(unsigned int irq, struct irq_desc *desc,\n\t\t  irqreturn_t action_ret)\n{\n\tstruct irqaction *action;\n\n\tif (!irqfixup)\n\t\treturn 0;\n\n\t/* We didn't actually handle the IRQ - see if it was misrouted? */\n\tif (action_ret == IRQ_NONE)\n\t\treturn 1;\n\n\t/*\n\t * But for 'irqfixup == 2' we also do it for handled interrupts if\n\t * they are marked as IRQF_IRQPOLL (or for irq zero, which is the\n\t * traditional PC timer interrupt.. Legacy)\n\t */\n\tif (irqfixup < 2)\n\t\treturn 0;\n\n\tif (!irq)\n\t\treturn 1;\n\n\t/*\n\t * Since we don't get the descriptor lock, \"action\" can\n\t * change under us.  We don't really care, but we don't\n\t * want to follow a NULL pointer. So tell the compiler to\n\t * just load it once by using a barrier.\n\t */\n\taction = desc->action;\n\tbarrier();\n\treturn action && (action->flags & IRQF_IRQPOLL);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic inline int\ntry_misrouted_irq(unsigned int irq, struct irq_desc *desc,\n\t\t  irqreturn_t action_ret)\n{\n\tstruct irqaction *action;\n\n\tif (!irqfixup)\n\t\treturn 0;\n\n\t/* We didn't actually handle the IRQ - see if it was misrouted? */\n\tif (action_ret == IRQ_NONE)\n\t\treturn 1;\n\n\t/*\n\t * But for 'irqfixup == 2' we also do it for handled interrupts if\n\t * they are marked as IRQF_IRQPOLL (or for irq zero, which is the\n\t * traditional PC timer interrupt.. Legacy)\n\t */\n\tif (irqfixup < 2)\n\t\treturn 0;\n\n\tif (!irq)\n\t\treturn 1;\n\n\t/*\n\t * Since we don't get the descriptor lock, \"action\" can\n\t * change under us.  We don't really care, but we don't\n\t * want to follow a NULL pointer. So tell the compiler to\n\t * just load it once by using a barrier.\n\t */\n\taction = desc->action;\n\tbarrier();\n\treturn action && (action->flags & IRQF_IRQPOLL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "desc->last_unhandled + HZ/10"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "action_ret == IRQ_NONE"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&desc->threads_handled"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "report_bad_irq",
          "args": [
            "desc",
            "action_ret"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "report_bad_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "225-233",
          "snippet": "static void report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tstatic int count = 100;\n\n\tif (count > 0) {\n\t\tcount--;\n\t\t__report_bad_irq(desc, action_ret);\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic void report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tstatic int count = 100;\n\n\tif (count > 0) {\n\t\tcount--;\n\t\t__report_bad_irq(desc, action_ret);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bad_action_ret",
          "args": [
            "action_ret"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "bad_action_ret",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "175-182",
          "snippet": "static inline int bad_action_ret(irqreturn_t action_ret)\n{\n\tunsigned int r = action_ret;\n\n\tif (likely(r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic inline int bad_action_ret(irqreturn_t action_ret)\n{\n\tunsigned int r = action_ret;\n\n\tif (likely(r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_polled",
          "args": [
            "desc"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_polled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "160-163",
          "snippet": "static inline bool irq_settings_is_polled(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_IS_POLLED;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_polled(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_IS_POLLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\n#define SPURIOUS_DEFERRED\t0x80000000\n#define POLL_SPURIOUS_IRQ_INTERVAL (HZ/10)\n\nvoid note_interrupt(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq;\n\n\tif (desc->istate & IRQS_POLL_INPROGRESS ||\n\t    irq_settings_is_polled(desc))\n\t\treturn;\n\n\tif (bad_action_ret(action_ret)) {\n\t\treport_bad_irq(desc, action_ret);\n\t\treturn;\n\t}\n\n\t/*\n\t * We cannot call note_interrupt from the threaded handler\n\t * because we need to look at the compound of all handlers\n\t * (primary and threaded). Aside of that in the threaded\n\t * shared case we have no serialization against an incoming\n\t * hardware interrupt while we are dealing with a threaded\n\t * result.\n\t *\n\t * So in case a thread is woken, we just note the fact and\n\t * defer the analysis to the next hardware interrupt.\n\t *\n\t * The threaded handlers store whether they successfully\n\t * handled an interrupt and we check whether that number\n\t * changed versus the last invocation.\n\t *\n\t * We could handle all interrupts with the delayed by one\n\t * mechanism, but for the non forced threaded case we'd just\n\t * add pointless overhead to the straight hardirq interrupts\n\t * for the sake of a few lines less code.\n\t */\n\tif (action_ret & IRQ_WAKE_THREAD) {\n\t\t/*\n\t\t * There is a thread woken. Check whether one of the\n\t\t * shared primary handlers returned IRQ_HANDLED. If\n\t\t * not we defer the spurious detection to the next\n\t\t * interrupt.\n\t\t */\n\t\tif (action_ret == IRQ_WAKE_THREAD) {\n\t\t\tint handled;\n\t\t\t/*\n\t\t\t * We use bit 31 of thread_handled_last to\n\t\t\t * denote the deferred spurious detection\n\t\t\t * active. No locking necessary as\n\t\t\t * thread_handled_last is only accessed here\n\t\t\t * and we have the guarantee that hard\n\t\t\t * interrupts are not reentrant.\n\t\t\t */\n\t\t\tif (!(desc->threads_handled_last & SPURIOUS_DEFERRED)) {\n\t\t\t\tdesc->threads_handled_last |= SPURIOUS_DEFERRED;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Check whether one of the threaded handlers\n\t\t\t * returned IRQ_HANDLED since the last\n\t\t\t * interrupt happened.\n\t\t\t *\n\t\t\t * For simplicity we just set bit 31, as it is\n\t\t\t * set in threads_handled_last as well. So we\n\t\t\t * avoid extra masking. And we really do not\n\t\t\t * care about the high bits of the handled\n\t\t\t * count. We just care about the count being\n\t\t\t * different than the one we saw before.\n\t\t\t */\n\t\t\thandled = atomic_read(&desc->threads_handled);\n\t\t\thandled |= SPURIOUS_DEFERRED;\n\t\t\tif (handled != desc->threads_handled_last) {\n\t\t\t\taction_ret = IRQ_HANDLED;\n\t\t\t\t/*\n\t\t\t\t * Note: We keep the SPURIOUS_DEFERRED\n\t\t\t\t * bit set. We are handling the\n\t\t\t\t * previous invocation right now.\n\t\t\t\t * Keep it for the current one, so the\n\t\t\t\t * next hardware interrupt will\n\t\t\t\t * account for it.\n\t\t\t\t */\n\t\t\t\tdesc->threads_handled_last = handled;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * None of the threaded handlers felt\n\t\t\t\t * responsible for the last interrupt\n\t\t\t\t *\n\t\t\t\t * We keep the SPURIOUS_DEFERRED bit\n\t\t\t\t * set in threads_handled_last as we\n\t\t\t\t * need to account for the current\n\t\t\t\t * interrupt as well.\n\t\t\t\t */\n\t\t\t\taction_ret = IRQ_NONE;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * One of the primary handlers returned\n\t\t\t * IRQ_HANDLED. So we don't care about the\n\t\t\t * threaded handlers on the same line. Clear\n\t\t\t * the deferred detection bit.\n\t\t\t *\n\t\t\t * In theory we could/should check whether the\n\t\t\t * deferred bit is set and take the result of\n\t\t\t * the previous run into account here as\n\t\t\t * well. But it's really not worth the\n\t\t\t * trouble. If every other interrupt is\n\t\t\t * handled we never trigger the spurious\n\t\t\t * detector. And if this is just the one out\n\t\t\t * of 100k unhandled ones which is handled\n\t\t\t * then we merily delay the spurious detection\n\t\t\t * by one hard interrupt. Not a real problem.\n\t\t\t */\n\t\t\tdesc->threads_handled_last &= ~SPURIOUS_DEFERRED;\n\t\t}\n\t}\n\n\tif (unlikely(action_ret == IRQ_NONE)) {\n\t\t/*\n\t\t * If we are seeing only the odd spurious IRQ caused by\n\t\t * bus asynchronicity then don't eventually trigger an error,\n\t\t * otherwise the counter becomes a doomsday timer for otherwise\n\t\t * working systems\n\t\t */\n\t\tif (time_after(jiffies, desc->last_unhandled + HZ/10))\n\t\t\tdesc->irqs_unhandled = 1;\n\t\telse\n\t\t\tdesc->irqs_unhandled++;\n\t\tdesc->last_unhandled = jiffies;\n\t}\n\n\tirq = irq_desc_get_irq(desc);\n\tif (unlikely(try_misrouted_irq(irq, desc, action_ret))) {\n\t\tint ok = misrouted_irq(irq);\n\t\tif (action_ret == IRQ_NONE)\n\t\t\tdesc->irqs_unhandled -= ok;\n\t}\n\n\tif (likely(!desc->irqs_unhandled))\n\t\treturn;\n\n\t/* Now getting into unhandled irq detection */\n\tdesc->irq_count++;\n\tif (likely(desc->irq_count < 100000))\n\t\treturn;\n\n\tdesc->irq_count = 0;\n\tif (unlikely(desc->irqs_unhandled > 99900)) {\n\t\t/*\n\t\t * The interrupt is stuck\n\t\t */\n\t\t__report_bad_irq(desc, action_ret);\n\t\t/*\n\t\t * Now kill the IRQ\n\t\t */\n\t\tprintk(KERN_EMERG \"Disabling IRQ #%d\\n\", irq);\n\t\tdesc->istate |= IRQS_SPURIOUS_DISABLED;\n\t\tdesc->depth++;\n\t\tirq_disable(desc);\n\n\t\tmod_timer(&poll_spurious_irq_timer,\n\t\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);\n\t}\n\tdesc->irqs_unhandled = 0;\n}"
  },
  {
    "function_name": "try_misrouted_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "235-268",
    "snippet": "static inline int\ntry_misrouted_irq(unsigned int irq, struct irq_desc *desc,\n\t\t  irqreturn_t action_ret)\n{\n\tstruct irqaction *action;\n\n\tif (!irqfixup)\n\t\treturn 0;\n\n\t/* We didn't actually handle the IRQ - see if it was misrouted? */\n\tif (action_ret == IRQ_NONE)\n\t\treturn 1;\n\n\t/*\n\t * But for 'irqfixup == 2' we also do it for handled interrupts if\n\t * they are marked as IRQF_IRQPOLL (or for irq zero, which is the\n\t * traditional PC timer interrupt.. Legacy)\n\t */\n\tif (irqfixup < 2)\n\t\treturn 0;\n\n\tif (!irq)\n\t\treturn 1;\n\n\t/*\n\t * Since we don't get the descriptor lock, \"action\" can\n\t * change under us.  We don't really care, but we don't\n\t * want to follow a NULL pointer. So tell the compiler to\n\t * just load it once by using a barrier.\n\t */\n\taction = desc->action;\n\tbarrier();\n\treturn action && (action->flags & IRQF_IRQPOLL);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic inline int\ntry_misrouted_irq(unsigned int irq, struct irq_desc *desc,\n\t\t  irqreturn_t action_ret)\n{\n\tstruct irqaction *action;\n\n\tif (!irqfixup)\n\t\treturn 0;\n\n\t/* We didn't actually handle the IRQ - see if it was misrouted? */\n\tif (action_ret == IRQ_NONE)\n\t\treturn 1;\n\n\t/*\n\t * But for 'irqfixup == 2' we also do it for handled interrupts if\n\t * they are marked as IRQF_IRQPOLL (or for irq zero, which is the\n\t * traditional PC timer interrupt.. Legacy)\n\t */\n\tif (irqfixup < 2)\n\t\treturn 0;\n\n\tif (!irq)\n\t\treturn 1;\n\n\t/*\n\t * Since we don't get the descriptor lock, \"action\" can\n\t * change under us.  We don't really care, but we don't\n\t * want to follow a NULL pointer. So tell the compiler to\n\t * just load it once by using a barrier.\n\t */\n\taction = desc->action;\n\tbarrier();\n\treturn action && (action->flags & IRQF_IRQPOLL);\n}"
  },
  {
    "function_name": "report_bad_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "225-233",
    "snippet": "static void report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tstatic int count = 100;\n\n\tif (count > 0) {\n\t\tcount--;\n\t\t__report_bad_irq(desc, action_ret);\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__report_bad_irq",
          "args": [
            "desc",
            "action_ret"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__report_bad_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "192-223",
          "snippet": "static void __report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (bad_action_ret(action_ret)) {\n\t\tprintk(KERN_ERR \"irq event %d: bogus return value %x\\n\",\n\t\t\t\tirq, action_ret);\n\t} else {\n\t\tprintk(KERN_ERR \"irq %d: nobody cared (try booting with \"\n\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);\n\t}\n\tdump_stack();\n\tprintk(KERN_ERR \"handlers:\\n\");\n\n\t/*\n\t * We need to take desc->lock here. note_interrupt() is called\n\t * w/o desc->lock held, but IRQ_PROGRESS set. We might race\n\t * with something else removing an action. It's ok to take\n\t * desc->lock here. See synchronize_irq().\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tprintk(KERN_ERR \"[<%p>] %ps\", action->handler, action->handler);\n\t\tif (action->thread_fn)\n\t\t\tprintk(KERN_CONT \" threaded [<%p>] %ps\",\n\t\t\t\t\taction->thread_fn, action->thread_fn);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic void __report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (bad_action_ret(action_ret)) {\n\t\tprintk(KERN_ERR \"irq event %d: bogus return value %x\\n\",\n\t\t\t\tirq, action_ret);\n\t} else {\n\t\tprintk(KERN_ERR \"irq %d: nobody cared (try booting with \"\n\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);\n\t}\n\tdump_stack();\n\tprintk(KERN_ERR \"handlers:\\n\");\n\n\t/*\n\t * We need to take desc->lock here. note_interrupt() is called\n\t * w/o desc->lock held, but IRQ_PROGRESS set. We might race\n\t * with something else removing an action. It's ok to take\n\t * desc->lock here. See synchronize_irq().\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tprintk(KERN_ERR \"[<%p>] %ps\", action->handler, action->handler);\n\t\tif (action->thread_fn)\n\t\t\tprintk(KERN_CONT \" threaded [<%p>] %ps\",\n\t\t\t\t\taction->thread_fn, action->thread_fn);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic void report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tstatic int count = 100;\n\n\tif (count > 0) {\n\t\tcount--;\n\t\t__report_bad_irq(desc, action_ret);\n\t}\n}"
  },
  {
    "function_name": "__report_bad_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "192-223",
    "snippet": "static void __report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (bad_action_ret(action_ret)) {\n\t\tprintk(KERN_ERR \"irq event %d: bogus return value %x\\n\",\n\t\t\t\tirq, action_ret);\n\t} else {\n\t\tprintk(KERN_ERR \"irq %d: nobody cared (try booting with \"\n\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);\n\t}\n\tdump_stack();\n\tprintk(KERN_ERR \"handlers:\\n\");\n\n\t/*\n\t * We need to take desc->lock here. note_interrupt() is called\n\t * w/o desc->lock held, but IRQ_PROGRESS set. We might race\n\t * with something else removing an action. It's ok to take\n\t * desc->lock here. See synchronize_irq().\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tprintk(KERN_ERR \"[<%p>] %ps\", action->handler, action->handler);\n\t\tif (action->thread_fn)\n\t\t\tprintk(KERN_CONT \" threaded [<%p>] %ps\",\n\t\t\t\t\taction->thread_fn, action->thread_fn);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"\\n\""
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/audit.c",
          "lines": "532-539",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" threaded [<%p>] %ps\"",
            "action->thread_fn",
            "action->thread_fn"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/panic.c",
          "lines": "623-632",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <trace/events/error_report.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/vt_kern.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <trace/events/error_report.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/panic_notifier.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/vt_kern.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kgdb.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_action_of_desc",
          "args": [
            "desc",
            "action"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&desc->lock",
            "flags"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bad_action_ret",
          "args": [
            "action_ret"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "bad_action_ret",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "175-182",
          "snippet": "static inline int bad_action_ret(irqreturn_t action_ret)\n{\n\tunsigned int r = action_ret;\n\n\tif (likely(r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic inline int bad_action_ret(irqreturn_t action_ret)\n{\n\tunsigned int r = action_ret;\n\n\tif (likely(r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic void __report_bad_irq(struct irq_desc *desc, irqreturn_t action_ret)\n{\n\tunsigned int irq = irq_desc_get_irq(desc);\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (bad_action_ret(action_ret)) {\n\t\tprintk(KERN_ERR \"irq event %d: bogus return value %x\\n\",\n\t\t\t\tirq, action_ret);\n\t} else {\n\t\tprintk(KERN_ERR \"irq %d: nobody cared (try booting with \"\n\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);\n\t}\n\tdump_stack();\n\tprintk(KERN_ERR \"handlers:\\n\");\n\n\t/*\n\t * We need to take desc->lock here. note_interrupt() is called\n\t * w/o desc->lock held, but IRQ_PROGRESS set. We might race\n\t * with something else removing an action. It's ok to take\n\t * desc->lock here. See synchronize_irq().\n\t */\n\traw_spin_lock_irqsave(&desc->lock, flags);\n\tfor_each_action_of_desc(desc, action) {\n\t\tprintk(KERN_ERR \"[<%p>] %ps\", action->handler, action->handler);\n\t\tif (action->thread_fn)\n\t\t\tprintk(KERN_CONT \" threaded [<%p>] %ps\",\n\t\t\t\t\taction->thread_fn, action->thread_fn);\n\t\tprintk(KERN_CONT \"\\n\");\n\t}\n\traw_spin_unlock_irqrestore(&desc->lock, flags);\n}"
  },
  {
    "function_name": "bad_action_ret",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "175-182",
    "snippet": "static inline int bad_action_ret(irqreturn_t action_ret)\n{\n\tunsigned int r = action_ret;\n\n\tif (likely(r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic inline int bad_action_ret(irqreturn_t action_ret)\n{\n\tunsigned int r = action_ret;\n\n\tif (likely(r <= (IRQ_HANDLED | IRQ_WAKE_THREAD)))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "poll_spurious_irqs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "144-173",
    "snippet": "static void poll_spurious_irqs(struct timer_list *unused)\n{\n\tstruct irq_desc *desc;\n\tint i;\n\n\tif (atomic_inc_return(&irq_poll_active) != 1)\n\t\tgoto out;\n\tirq_poll_cpu = smp_processor_id();\n\n\tfor_each_irq_desc(i, desc) {\n\t\tunsigned int state;\n\n\t\tif (!i)\n\t\t\t continue;\n\n\t\t/* Racy but it doesn't matter */\n\t\tstate = desc->istate;\n\t\tbarrier();\n\t\tif (!(state & IRQS_SPURIOUS_DISABLED))\n\t\t\tcontinue;\n\n\t\tlocal_irq_disable();\n\t\ttry_one_irq(desc, true);\n\t\tlocal_irq_enable();\n\t}\nout:\n\tatomic_dec(&irq_poll_active);\n\tmod_timer(&poll_spurious_irq_timer,\n\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [
      "#define POLL_SPURIOUS_IRQ_INTERVAL (HZ/10)"
    ],
    "globals_used": [
      "static void poll_spurious_irqs(struct timer_list *unused);",
      "static DEFINE_TIMER(poll_spurious_irq_timer, poll_spurious_irqs);",
      "static int irq_poll_cpu;",
      "static atomic_t irq_poll_active;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "&poll_spurious_irq_timer",
            "jiffies + POLL_SPURIOUS_IRQ_INTERVAL"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1106-1109",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&irq_poll_active"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_one_irq",
          "args": [
            "desc",
            "true"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "try_one_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "62-116",
          "snippet": "static int try_one_irq(struct irq_desc *desc, bool force)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct irqaction *action;\n\n\traw_spin_lock(&desc->lock);\n\n\t/*\n\t * PER_CPU, nested thread interrupts and interrupts explicitly\n\t * marked polled are excluded from polling.\n\t */\n\tif (irq_settings_is_per_cpu(desc) ||\n\t    irq_settings_is_nested_thread(desc) ||\n\t    irq_settings_is_polled(desc))\n\t\tgoto out;\n\n\t/*\n\t * Do not poll disabled interrupts unless the spurious\n\t * disabled poller asks explicitly.\n\t */\n\tif (irqd_irq_disabled(&desc->irq_data) && !force)\n\t\tgoto out;\n\n\t/*\n\t * All handlers must agree on IRQF_SHARED, so we test just the\n\t * first.\n\t */\n\taction = desc->action;\n\tif (!action || !(action->flags & IRQF_SHARED) ||\n\t    (action->flags & __IRQF_TIMER))\n\t\tgoto out;\n\n\t/* Already running on another processor */\n\tif (irqd_irq_inprogress(&desc->irq_data)) {\n\t\t/*\n\t\t * Already running: If it is shared get the other\n\t\t * CPU to go looking for our mystery interrupt too\n\t\t */\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out;\n\t}\n\n\t/* Mark it poll in progress */\n\tdesc->istate |= IRQS_POLL_INPROGRESS;\n\tdo {\n\t\tif (handle_irq_event(desc) == IRQ_HANDLED)\n\t\t\tret = IRQ_HANDLED;\n\t\t/* Make sure that there is still a valid action */\n\t\taction = desc->action;\n\t} while ((desc->istate & IRQS_PENDING) && action);\n\tdesc->istate &= ~IRQS_POLL_INPROGRESS;\nout:\n\traw_spin_unlock(&desc->lock);\n\treturn ret == IRQ_HANDLED;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic int try_one_irq(struct irq_desc *desc, bool force)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct irqaction *action;\n\n\traw_spin_lock(&desc->lock);\n\n\t/*\n\t * PER_CPU, nested thread interrupts and interrupts explicitly\n\t * marked polled are excluded from polling.\n\t */\n\tif (irq_settings_is_per_cpu(desc) ||\n\t    irq_settings_is_nested_thread(desc) ||\n\t    irq_settings_is_polled(desc))\n\t\tgoto out;\n\n\t/*\n\t * Do not poll disabled interrupts unless the spurious\n\t * disabled poller asks explicitly.\n\t */\n\tif (irqd_irq_disabled(&desc->irq_data) && !force)\n\t\tgoto out;\n\n\t/*\n\t * All handlers must agree on IRQF_SHARED, so we test just the\n\t * first.\n\t */\n\taction = desc->action;\n\tif (!action || !(action->flags & IRQF_SHARED) ||\n\t    (action->flags & __IRQF_TIMER))\n\t\tgoto out;\n\n\t/* Already running on another processor */\n\tif (irqd_irq_inprogress(&desc->irq_data)) {\n\t\t/*\n\t\t * Already running: If it is shared get the other\n\t\t * CPU to go looking for our mystery interrupt too\n\t\t */\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out;\n\t}\n\n\t/* Mark it poll in progress */\n\tdesc->istate |= IRQS_POLL_INPROGRESS;\n\tdo {\n\t\tif (handle_irq_event(desc) == IRQ_HANDLED)\n\t\t\tret = IRQ_HANDLED;\n\t\t/* Make sure that there is still a valid action */\n\t\taction = desc->action;\n\t} while ((desc->istate & IRQS_PENDING) && action);\n\tdesc->istate &= ~IRQS_POLL_INPROGRESS;\nout:\n\traw_spin_unlock(&desc->lock);\n\treturn ret == IRQ_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "membarrier_register_global_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/membarrier.c",
          "lines": "482-499",
          "snippet": "static int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nstatic int membarrier_register_global_expedited(void)\n{\n\tstruct task_struct *p = current;\n\tstruct mm_struct *mm = p->mm;\n\tint ret;\n\n\tif (atomic_read(&mm->membarrier_state) &\n\t    MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY)\n\t\treturn 0;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED, &mm->membarrier_state);\n\tret = sync_runqueues_membarrier_state(mm);\n\tif (ret)\n\t\treturn ret;\n\tatomic_or(MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY,\n\t\t  &mm->membarrier_state);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "i",
            "desc"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&irq_poll_active"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\n#define POLL_SPURIOUS_IRQ_INTERVAL (HZ/10)\n\nstatic void poll_spurious_irqs(struct timer_list *unused);\nstatic DEFINE_TIMER(poll_spurious_irq_timer, poll_spurious_irqs);\nstatic int irq_poll_cpu;\nstatic atomic_t irq_poll_active;\n\nstatic void poll_spurious_irqs(struct timer_list *unused)\n{\n\tstruct irq_desc *desc;\n\tint i;\n\n\tif (atomic_inc_return(&irq_poll_active) != 1)\n\t\tgoto out;\n\tirq_poll_cpu = smp_processor_id();\n\n\tfor_each_irq_desc(i, desc) {\n\t\tunsigned int state;\n\n\t\tif (!i)\n\t\t\t continue;\n\n\t\t/* Racy but it doesn't matter */\n\t\tstate = desc->istate;\n\t\tbarrier();\n\t\tif (!(state & IRQS_SPURIOUS_DISABLED))\n\t\t\tcontinue;\n\n\t\tlocal_irq_disable();\n\t\ttry_one_irq(desc, true);\n\t\tlocal_irq_enable();\n\t}\nout:\n\tatomic_dec(&irq_poll_active);\n\tmod_timer(&poll_spurious_irq_timer,\n\t\t  jiffies + POLL_SPURIOUS_IRQ_INTERVAL);\n}"
  },
  {
    "function_name": "misrouted_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "118-142",
    "snippet": "static int misrouted_irq(int irq)\n{\n\tstruct irq_desc *desc;\n\tint i, ok = 0;\n\n\tif (atomic_inc_return(&irq_poll_active) != 1)\n\t\tgoto out;\n\n\tirq_poll_cpu = smp_processor_id();\n\n\tfor_each_irq_desc(i, desc) {\n\t\tif (!i)\n\t\t\t continue;\n\n\t\tif (i == irq)\t/* Already tried */\n\t\t\tcontinue;\n\n\t\tif (try_one_irq(desc, false))\n\t\t\tok = 1;\n\t}\nout:\n\tatomic_dec(&irq_poll_active);\n\t/* So the caller can adjust the irq error counts */\n\treturn ok;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int irq_poll_cpu;",
      "static atomic_t irq_poll_active;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&irq_poll_active"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_one_irq",
          "args": [
            "desc",
            "false"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "try_one_irq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
          "lines": "62-116",
          "snippet": "static int try_one_irq(struct irq_desc *desc, bool force)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct irqaction *action;\n\n\traw_spin_lock(&desc->lock);\n\n\t/*\n\t * PER_CPU, nested thread interrupts and interrupts explicitly\n\t * marked polled are excluded from polling.\n\t */\n\tif (irq_settings_is_per_cpu(desc) ||\n\t    irq_settings_is_nested_thread(desc) ||\n\t    irq_settings_is_polled(desc))\n\t\tgoto out;\n\n\t/*\n\t * Do not poll disabled interrupts unless the spurious\n\t * disabled poller asks explicitly.\n\t */\n\tif (irqd_irq_disabled(&desc->irq_data) && !force)\n\t\tgoto out;\n\n\t/*\n\t * All handlers must agree on IRQF_SHARED, so we test just the\n\t * first.\n\t */\n\taction = desc->action;\n\tif (!action || !(action->flags & IRQF_SHARED) ||\n\t    (action->flags & __IRQF_TIMER))\n\t\tgoto out;\n\n\t/* Already running on another processor */\n\tif (irqd_irq_inprogress(&desc->irq_data)) {\n\t\t/*\n\t\t * Already running: If it is shared get the other\n\t\t * CPU to go looking for our mystery interrupt too\n\t\t */\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out;\n\t}\n\n\t/* Mark it poll in progress */\n\tdesc->istate |= IRQS_POLL_INPROGRESS;\n\tdo {\n\t\tif (handle_irq_event(desc) == IRQ_HANDLED)\n\t\t\tret = IRQ_HANDLED;\n\t\t/* Make sure that there is still a valid action */\n\t\taction = desc->action;\n\t} while ((desc->istate & IRQS_PENDING) && action);\n\tdesc->istate &= ~IRQS_POLL_INPROGRESS;\nout:\n\traw_spin_unlock(&desc->lock);\n\treturn ret == IRQ_HANDLED;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/timer.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic int try_one_irq(struct irq_desc *desc, bool force)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct irqaction *action;\n\n\traw_spin_lock(&desc->lock);\n\n\t/*\n\t * PER_CPU, nested thread interrupts and interrupts explicitly\n\t * marked polled are excluded from polling.\n\t */\n\tif (irq_settings_is_per_cpu(desc) ||\n\t    irq_settings_is_nested_thread(desc) ||\n\t    irq_settings_is_polled(desc))\n\t\tgoto out;\n\n\t/*\n\t * Do not poll disabled interrupts unless the spurious\n\t * disabled poller asks explicitly.\n\t */\n\tif (irqd_irq_disabled(&desc->irq_data) && !force)\n\t\tgoto out;\n\n\t/*\n\t * All handlers must agree on IRQF_SHARED, so we test just the\n\t * first.\n\t */\n\taction = desc->action;\n\tif (!action || !(action->flags & IRQF_SHARED) ||\n\t    (action->flags & __IRQF_TIMER))\n\t\tgoto out;\n\n\t/* Already running on another processor */\n\tif (irqd_irq_inprogress(&desc->irq_data)) {\n\t\t/*\n\t\t * Already running: If it is shared get the other\n\t\t * CPU to go looking for our mystery interrupt too\n\t\t */\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out;\n\t}\n\n\t/* Mark it poll in progress */\n\tdesc->istate |= IRQS_POLL_INPROGRESS;\n\tdo {\n\t\tif (handle_irq_event(desc) == IRQ_HANDLED)\n\t\t\tret = IRQ_HANDLED;\n\t\t/* Make sure that there is still a valid action */\n\t\taction = desc->action;\n\t} while ((desc->istate & IRQS_PENDING) && action);\n\tdesc->istate &= ~IRQS_POLL_INPROGRESS;\nout:\n\traw_spin_unlock(&desc->lock);\n\treturn ret == IRQ_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_irq_desc",
          "args": [
            "i",
            "desc"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&irq_poll_active"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic int irq_poll_cpu;\nstatic atomic_t irq_poll_active;\n\nstatic int misrouted_irq(int irq)\n{\n\tstruct irq_desc *desc;\n\tint i, ok = 0;\n\n\tif (atomic_inc_return(&irq_poll_active) != 1)\n\t\tgoto out;\n\n\tirq_poll_cpu = smp_processor_id();\n\n\tfor_each_irq_desc(i, desc) {\n\t\tif (!i)\n\t\t\t continue;\n\n\t\tif (i == irq)\t/* Already tried */\n\t\t\tcontinue;\n\n\t\tif (try_one_irq(desc, false))\n\t\t\tok = 1;\n\t}\nout:\n\tatomic_dec(&irq_poll_active);\n\t/* So the caller can adjust the irq error counts */\n\treturn ok;\n}"
  },
  {
    "function_name": "try_one_irq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "62-116",
    "snippet": "static int try_one_irq(struct irq_desc *desc, bool force)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct irqaction *action;\n\n\traw_spin_lock(&desc->lock);\n\n\t/*\n\t * PER_CPU, nested thread interrupts and interrupts explicitly\n\t * marked polled are excluded from polling.\n\t */\n\tif (irq_settings_is_per_cpu(desc) ||\n\t    irq_settings_is_nested_thread(desc) ||\n\t    irq_settings_is_polled(desc))\n\t\tgoto out;\n\n\t/*\n\t * Do not poll disabled interrupts unless the spurious\n\t * disabled poller asks explicitly.\n\t */\n\tif (irqd_irq_disabled(&desc->irq_data) && !force)\n\t\tgoto out;\n\n\t/*\n\t * All handlers must agree on IRQF_SHARED, so we test just the\n\t * first.\n\t */\n\taction = desc->action;\n\tif (!action || !(action->flags & IRQF_SHARED) ||\n\t    (action->flags & __IRQF_TIMER))\n\t\tgoto out;\n\n\t/* Already running on another processor */\n\tif (irqd_irq_inprogress(&desc->irq_data)) {\n\t\t/*\n\t\t * Already running: If it is shared get the other\n\t\t * CPU to go looking for our mystery interrupt too\n\t\t */\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out;\n\t}\n\n\t/* Mark it poll in progress */\n\tdesc->istate |= IRQS_POLL_INPROGRESS;\n\tdo {\n\t\tif (handle_irq_event(desc) == IRQ_HANDLED)\n\t\t\tret = IRQ_HANDLED;\n\t\t/* Make sure that there is still a valid action */\n\t\taction = desc->action;\n\t} while ((desc->istate & IRQS_PENDING) && action);\n\tdesc->istate &= ~IRQS_POLL_INPROGRESS;\nout:\n\traw_spin_unlock(&desc->lock);\n\treturn ret == IRQ_HANDLED;\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&desc->lock"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_irq_event",
          "args": [
            "desc"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "handle_irq_event",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/handle.c",
          "lines": "202-215",
          "snippet": "irqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <asm/irq_regs.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/irq.h>\n\nirqreturn_t handle_irq_event(struct irq_desc *desc)\n{\n\tirqreturn_t ret;\n\n\tdesc->istate &= ~IRQS_PENDING;\n\tirqd_set(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\traw_spin_unlock(&desc->lock);\n\n\tret = handle_irq_event_percpu(desc);\n\n\traw_spin_lock(&desc->lock);\n\tirqd_clear(&desc->irq_data, IRQD_IRQ_INPROGRESS);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_irq_inprogress",
          "args": [
            "&desc->irq_data"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_settings_is_polled",
          "args": [
            "desc"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_polled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "160-163",
          "snippet": "static inline bool irq_settings_is_polled(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_IS_POLLED;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_polled(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_IS_POLLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_nested_thread",
          "args": [
            "desc"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_nested_thread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "155-158",
          "snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_per_cpu",
          "args": [
            "desc"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_per_cpu_devid",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/settings.h",
          "lines": "53-56",
          "snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_per_cpu_devid(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_PER_CPU_DEVID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&desc->lock"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic int try_one_irq(struct irq_desc *desc, bool force)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct irqaction *action;\n\n\traw_spin_lock(&desc->lock);\n\n\t/*\n\t * PER_CPU, nested thread interrupts and interrupts explicitly\n\t * marked polled are excluded from polling.\n\t */\n\tif (irq_settings_is_per_cpu(desc) ||\n\t    irq_settings_is_nested_thread(desc) ||\n\t    irq_settings_is_polled(desc))\n\t\tgoto out;\n\n\t/*\n\t * Do not poll disabled interrupts unless the spurious\n\t * disabled poller asks explicitly.\n\t */\n\tif (irqd_irq_disabled(&desc->irq_data) && !force)\n\t\tgoto out;\n\n\t/*\n\t * All handlers must agree on IRQF_SHARED, so we test just the\n\t * first.\n\t */\n\taction = desc->action;\n\tif (!action || !(action->flags & IRQF_SHARED) ||\n\t    (action->flags & __IRQF_TIMER))\n\t\tgoto out;\n\n\t/* Already running on another processor */\n\tif (irqd_irq_inprogress(&desc->irq_data)) {\n\t\t/*\n\t\t * Already running: If it is shared get the other\n\t\t * CPU to go looking for our mystery interrupt too\n\t\t */\n\t\tdesc->istate |= IRQS_PENDING;\n\t\tgoto out;\n\t}\n\n\t/* Mark it poll in progress */\n\tdesc->istate |= IRQS_POLL_INPROGRESS;\n\tdo {\n\t\tif (handle_irq_event(desc) == IRQ_HANDLED)\n\t\t\tret = IRQ_HANDLED;\n\t\t/* Make sure that there is still a valid action */\n\t\taction = desc->action;\n\t} while ((desc->istate & IRQS_PENDING) && action);\n\tdesc->istate &= ~IRQS_POLL_INPROGRESS;\nout:\n\traw_spin_unlock(&desc->lock);\n\treturn ret == IRQ_HANDLED;\n}"
  },
  {
    "function_name": "irq_wait_for_poll",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/spurious.c",
    "lines": "36-56",
    "snippet": "bool irq_wait_for_poll(struct irq_desc *desc)\n\t__must_hold(&desc->lock)\n{\n\tif (WARN_ONCE(irq_poll_cpu == smp_processor_id(),\n\t\t      \"irq poll in progress on cpu %d for irq %d\\n\",\n\t\t      smp_processor_id(), desc->irq_data.irq))\n\t\treturn false;\n\n#ifdef CONFIG_SMP\n\tdo {\n\t\traw_spin_unlock(&desc->lock);\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\t\traw_spin_lock(&desc->lock);\n\t} while (irqd_irq_inprogress(&desc->irq_data));\n\t/* Might have been disabled in meantime */\n\treturn !irqd_irq_disabled(&desc->irq_data) && desc->action;\n#else\n\treturn false;\n#endif\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/timer.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>",
      "#include <linux/jiffies.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int irq_poll_cpu;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_irq_disabled",
          "args": [
            "&desc->irq_data"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_inprogress",
          "args": [
            "&desc->irq_data"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&desc->lock"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_irq_inprogress",
          "args": [
            "&desc->irq_data"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&desc->lock"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "irq_poll_cpu == smp_processor_id()",
            "\"irq poll in progress on cpu %d for irq %d\\n\"",
            "smp_processor_id()",
            "desc->irq_data.irq"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__must_hold",
          "args": [
            "&desc->lock"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/timer.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/jiffies.h>\n\nstatic int irq_poll_cpu;\n\nbool irq_wait_for_poll(struct irq_desc *desc)\n\t__must_hold(&desc->lock)\n{\n\tif (WARN_ONCE(irq_poll_cpu == smp_processor_id(),\n\t\t      \"irq poll in progress on cpu %d for irq %d\\n\",\n\t\t      smp_processor_id(), desc->irq_data.irq))\n\t\treturn false;\n\n#ifdef CONFIG_SMP\n\tdo {\n\t\traw_spin_unlock(&desc->lock);\n\t\twhile (irqd_irq_inprogress(&desc->irq_data))\n\t\t\tcpu_relax();\n\t\traw_spin_lock(&desc->lock);\n\t} while (irqd_irq_inprogress(&desc->irq_data));\n\t/* Might have been disabled in meantime */\n\treturn !irqd_irq_disabled(&desc->irq_data) && desc->action;\n#else\n\treturn false;\n#endif\n}"
  }
]