[
  {
    "function_name": "init_srcu_module_notifier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1459-1467",
    "snippet": "static __init int init_srcu_module_notifier(void)\n{\n\tint ret;\n\n\tret = register_module_notifier(&srcu_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register srcu module notifier\\n\");\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register srcu module notifier\\n\""
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&srcu_module_nb"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/module.c",
          "lines": "307-310",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel_read_file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buildid.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/module_signature.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel_read_file.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buildid.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/module_signature.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic __init int init_srcu_module_notifier(void)\n{\n\tint ret;\n\n\tret = register_module_notifier(&srcu_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register srcu module notifier\\n\");\n\treturn ret;\n}"
  },
  {
    "function_name": "srcu_module_notify",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1435-1452",
    "snippet": "static int srcu_module_notify(struct notifier_block *self,\n\t\t\t      unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = srcu_module_coming(mod);\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tsrcu_module_going(mod);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_module_going",
          "args": [
            "mod"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_module_going",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1425-1432",
          "snippet": "static void srcu_module_going(struct module *mod)\n{\n\tint i;\n\tstruct srcu_struct **sspp = mod->srcu_struct_ptrs;\n\n\tfor (i = 0; i < mod->num_srcu_structs; i++)\n\t\tcleanup_srcu_struct(*(sspp++));\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_module_going(struct module *mod)\n{\n\tint i;\n\tstruct srcu_struct **sspp = mod->srcu_struct_ptrs;\n\n\tfor (i = 0; i < mod->num_srcu_structs; i++)\n\t\tcleanup_srcu_struct(*(sspp++));\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_module_coming",
          "args": [
            "mod"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_module_coming",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1410-1422",
          "snippet": "static int srcu_module_coming(struct module *mod)\n{\n\tint i;\n\tstruct srcu_struct **sspp = mod->srcu_struct_ptrs;\n\tint ret;\n\n\tfor (i = 0; i < mod->num_srcu_structs; i++) {\n\t\tret = init_srcu_struct(*(sspp++));\n\t\tif (WARN_ON_ONCE(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic int srcu_module_coming(struct module *mod)\n{\n\tint i;\n\tstruct srcu_struct **sspp = mod->srcu_struct_ptrs;\n\tint ret;\n\n\tfor (i = 0; i < mod->num_srcu_structs; i++) {\n\t\tret = init_srcu_struct(*(sspp++));\n\t\tif (WARN_ON_ONCE(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic int srcu_module_notify(struct notifier_block *self,\n\t\t\t      unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = srcu_module_coming(mod);\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tsrcu_module_going(mod);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "srcu_module_going",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1425-1432",
    "snippet": "static void srcu_module_going(struct module *mod)\n{\n\tint i;\n\tstruct srcu_struct **sspp = mod->srcu_struct_ptrs;\n\n\tfor (i = 0; i < mod->num_srcu_structs; i++)\n\t\tcleanup_srcu_struct(*(sspp++));\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_srcu_struct",
          "args": [
            "*(sspp++)"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "367-392",
          "snippet": "void cleanup_srcu_struct(struct srcu_struct *ssp)\n{\n\tint cpu;\n\n\tif (WARN_ON(!srcu_get_delay(ssp)))\n\t\treturn; /* Just leak it! */\n\tif (WARN_ON(srcu_readers_active(ssp)))\n\t\treturn; /* Just leak it! */\n\tflush_delayed_work(&ssp->work);\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *sdp = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tdel_timer_sync(&sdp->delay_work);\n\t\tflush_work(&sdp->work);\n\t\tif (WARN_ON(rcu_segcblist_n_cbs(&sdp->srcu_cblist)))\n\t\t\treturn; /* Forgot srcu_barrier(), so just leak it! */\n\t}\n\tif (WARN_ON(rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||\n\t    WARN_ON(srcu_readers_active(ssp))) {\n\t\tpr_info(\"%s: Active srcu_struct %p state: %d\\n\",\n\t\t\t__func__, ssp, rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)));\n\t\treturn; /* Caller forgot to stop doing call_srcu()? */\n\t}\n\tfree_percpu(ssp->sda);\n\tssp->sda = NULL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid cleanup_srcu_struct(struct srcu_struct *ssp)\n{\n\tint cpu;\n\n\tif (WARN_ON(!srcu_get_delay(ssp)))\n\t\treturn; /* Just leak it! */\n\tif (WARN_ON(srcu_readers_active(ssp)))\n\t\treturn; /* Just leak it! */\n\tflush_delayed_work(&ssp->work);\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *sdp = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tdel_timer_sync(&sdp->delay_work);\n\t\tflush_work(&sdp->work);\n\t\tif (WARN_ON(rcu_segcblist_n_cbs(&sdp->srcu_cblist)))\n\t\t\treturn; /* Forgot srcu_barrier(), so just leak it! */\n\t}\n\tif (WARN_ON(rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||\n\t    WARN_ON(srcu_readers_active(ssp))) {\n\t\tpr_info(\"%s: Active srcu_struct %p state: %d\\n\",\n\t\t\t__func__, ssp, rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)));\n\t\treturn; /* Caller forgot to stop doing call_srcu()? */\n\t}\n\tfree_percpu(ssp->sda);\n\tssp->sda = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_module_going(struct module *mod)\n{\n\tint i;\n\tstruct srcu_struct **sspp = mod->srcu_struct_ptrs;\n\n\tfor (i = 0; i < mod->num_srcu_structs; i++)\n\t\tcleanup_srcu_struct(*(sspp++));\n}"
  },
  {
    "function_name": "srcu_module_coming",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1410-1422",
    "snippet": "static int srcu_module_coming(struct module *mod)\n{\n\tint i;\n\tstruct srcu_struct **sspp = mod->srcu_struct_ptrs;\n\tint ret;\n\n\tfor (i = 0; i < mod->num_srcu_structs; i++) {\n\t\tret = init_srcu_struct(*(sspp++));\n\t\tif (WARN_ON_ONCE(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ret"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_srcu_struct",
          "args": [
            "*(sspp++)"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "224-238",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic int srcu_module_coming(struct module *mod)\n{\n\tint i;\n\tstruct srcu_struct **sspp = mod->srcu_struct_ptrs;\n\tint ret;\n\n\tfor (i = 0; i < mod->num_srcu_structs; i++) {\n\t\tret = init_srcu_struct(*(sspp++));\n\t\tif (WARN_ON_ONCE(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "srcu_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1389-1405",
    "snippet": "void __init srcu_init(void)\n{\n\tstruct srcu_struct *ssp;\n\n\t/*\n\t * Once that is set, call_srcu() can follow the normal path and\n\t * queue delayed work. This must follow RCU workqueues creation\n\t * and timers initialization.\n\t */\n\tsrcu_init_done = true;\n\twhile (!list_empty(&srcu_boot_list)) {\n\t\tssp = list_first_entry(&srcu_boot_list, struct srcu_struct,\n\t\t\t\t      work.work.entry);\n\t\tlist_del_init(&ssp->work.work.entry);\n\t\tqueue_work(rcu_gp_wq, &ssp->work.work);\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(srcu_boot_list);",
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "rcu_gp_wq",
            "&ssp->work.work"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "93-113",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&ssp->work.work.entry"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&srcu_boot_list",
            "structsrcu_struct",
            "work.work.entry"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&srcu_boot_list"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(srcu_boot_list);\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid __init srcu_init(void)\n{\n\tstruct srcu_struct *ssp;\n\n\t/*\n\t * Once that is set, call_srcu() can follow the normal path and\n\t * queue delayed work. This must follow RCU workqueues creation\n\t * and timers initialization.\n\t */\n\tsrcu_init_done = true;\n\twhile (!list_empty(&srcu_boot_list)) {\n\t\tssp = list_first_entry(&srcu_boot_list, struct srcu_struct,\n\t\t\t\t      work.work.entry);\n\t\tlist_del_init(&ssp->work.work.entry);\n\t\tqueue_work(rcu_gp_wq, &ssp->work.work);\n\t}\n}"
  },
  {
    "function_name": "srcu_bootup_announce",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1380-1386",
    "snippet": "static int __init srcu_bootup_announce(void)\n{\n\tpr_info(\"Hierarchical SRCU implementation.\\n\");\n\tif (exp_holdoff != DEFAULT_SRCU_EXP_HOLDOFF)\n\t\tpr_info(\"\\tNon-default auto-expedite holdoff of %lu ns.\\n\", exp_holdoff);\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define DEFAULT_SRCU_EXP_HOLDOFF (25 * 1000)"
    ],
    "globals_used": [
      "static ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"\\tNon-default auto-expedite holdoff of %lu ns.\\n\"",
            "exp_holdoff"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Hierarchical SRCU implementation.\\n\""
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define DEFAULT_SRCU_EXP_HOLDOFF (25 * 1000)\n\nstatic ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;\n\nstatic int __init srcu_bootup_announce(void)\n{\n\tpr_info(\"Hierarchical SRCU implementation.\\n\");\n\tif (exp_holdoff != DEFAULT_SRCU_EXP_HOLDOFF)\n\t\tpr_info(\"\\tNon-default auto-expedite holdoff of %lu ns.\\n\", exp_holdoff);\n\treturn 0;\n}"
  },
  {
    "function_name": "srcu_torture_stats_print",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1340-1377",
    "snippet": "void srcu_torture_stats_print(struct srcu_struct *ssp, char *tt, char *tf)\n{\n\tint cpu;\n\tint idx;\n\tunsigned long s0 = 0, s1 = 0;\n\n\tidx = ssp->srcu_idx & 0x1;\n\tpr_alert(\"%s%s Tree SRCU g%ld per-CPU(idx=%d):\",\n\t\t tt, tf, rcu_seq_current(&ssp->srcu_gp_seq), idx);\n\tfor_each_possible_cpu(cpu) {\n\t\tunsigned long l0, l1;\n\t\tunsigned long u0, u1;\n\t\tlong c0, c1;\n\t\tstruct srcu_data *sdp;\n\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tu0 = data_race(sdp->srcu_unlock_count[!idx]);\n\t\tu1 = data_race(sdp->srcu_unlock_count[idx]);\n\n\t\t/*\n\t\t * Make sure that a lock is always counted if the corresponding\n\t\t * unlock is counted.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tl0 = data_race(sdp->srcu_lock_count[!idx]);\n\t\tl1 = data_race(sdp->srcu_lock_count[idx]);\n\n\t\tc0 = l0 - u0;\n\t\tc1 = l1 - u1;\n\t\tpr_cont(\" %d(%ld,%ld %c)\",\n\t\t\tcpu, c0, c1,\n\t\t\t\"C.\"[rcu_segcblist_empty(&sdp->srcu_cblist)]);\n\t\ts0 += c0;\n\t\ts1 += c1;\n\t}\n\tpr_cont(\" T(%ld,%ld)\\n\", s0, s1);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" T(%ld,%ld)\\n\"",
            "s0",
            "s1"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\" %d(%ld,%ld %c)\"",
            "cpu",
            "c0",
            "c1",
            "\"C.\"[rcu_segcblist_empty(&sdp->srcu_cblist)]"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_empty",
          "args": [
            "&sdp->srcu_cblist"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_race",
          "args": [
            "sdp->srcu_lock_count[idx]"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "test_data_race",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/kcsan_test.c",
          "lines": "998-1008",
          "snippet": "__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}",
          "includes": [
            "#include <trace/events/printk.h>",
            "#include <linux/types.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/torture.h>",
            "#include <linux/timer.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kcsan-checks.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <kunit/test.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline const struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/printk.h>\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <linux/torture.h>\n#include <linux/timer.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/seqlock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/jiffies.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <kunit/test.h>\n\nstatic __always_inline const struct;\n\n__no_kcsan\nstatic void test_data_race(struct kunit *test)\n{\n\tbool match_never = false;\n\n\tbegin_test_checks(test_kernel_data_race, test_kernel_data_race);\n\tdo {\n\t\tmatch_never = report_available();\n\t} while (!end_test_checks(match_never));\n\tKUNIT_EXPECT_FALSE(test, match_never);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ssp->sda",
            "cpu"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_alert",
          "args": [
            "\"%s%s Tree SRCU g%ld per-CPU(idx=%d):\"",
            "tt",
            "tf",
            "rcu_seq_current(&ssp->srcu_gp_seq)",
            "idx"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcu_torture_stats_print(struct srcu_struct *ssp, char *tt, char *tf)\n{\n\tint cpu;\n\tint idx;\n\tunsigned long s0 = 0, s1 = 0;\n\n\tidx = ssp->srcu_idx & 0x1;\n\tpr_alert(\"%s%s Tree SRCU g%ld per-CPU(idx=%d):\",\n\t\t tt, tf, rcu_seq_current(&ssp->srcu_gp_seq), idx);\n\tfor_each_possible_cpu(cpu) {\n\t\tunsigned long l0, l1;\n\t\tunsigned long u0, u1;\n\t\tlong c0, c1;\n\t\tstruct srcu_data *sdp;\n\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tu0 = data_race(sdp->srcu_unlock_count[!idx]);\n\t\tu1 = data_race(sdp->srcu_unlock_count[idx]);\n\n\t\t/*\n\t\t * Make sure that a lock is always counted if the corresponding\n\t\t * unlock is counted.\n\t\t */\n\t\tsmp_rmb();\n\n\t\tl0 = data_race(sdp->srcu_lock_count[!idx]);\n\t\tl1 = data_race(sdp->srcu_lock_count[idx]);\n\n\t\tc0 = l0 - u0;\n\t\tc1 = l1 - u1;\n\t\tpr_cont(\" %d(%ld,%ld %c)\",\n\t\t\tcpu, c0, c1,\n\t\t\t\"C.\"[rcu_segcblist_empty(&sdp->srcu_cblist)]);\n\t\ts0 += c0;\n\t\ts1 += c1;\n\t}\n\tpr_cont(\" T(%ld,%ld)\\n\", s0, s1);\n}"
  },
  {
    "function_name": "srcutorture_get_gp_data",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1329-1337",
    "snippet": "void srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *ssp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&ssp->srcu_gp_seq);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid srcutorture_get_gp_data(enum rcutorture_type test_type,\n\t\t\t     struct srcu_struct *ssp, int *flags,\n\t\t\t     unsigned long *gp_seq)\n{\n\tif (test_type != SRCU_FLAVOR)\n\t\treturn;\n\t*flags = 0;\n\t*gp_seq = rcu_seq_current(&ssp->srcu_gp_seq);\n}"
  },
  {
    "function_name": "process_srcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1319-1327",
    "snippet": "static void process_srcu(struct work_struct *work)\n{\n\tstruct srcu_struct *ssp;\n\n\tssp = container_of(work, struct srcu_struct, work.work);\n\n\tsrcu_advance_state(ssp);\n\tsrcu_reschedule(ssp, srcu_get_delay(ssp));\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_reschedule",
          "args": [
            "ssp",
            "srcu_get_delay(ssp)"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_reschedule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1296-1314",
          "snippet": "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(ssp);\n\tif (ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(ssp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(ssp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(ssp);\n\t}\n\tspin_unlock_irq_rcu_node(ssp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &ssp->work, delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(ssp);\n\tif (ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(ssp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(ssp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(ssp);\n\t}\n\tspin_unlock_irq_rcu_node(ssp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &ssp->work, delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_get_delay",
          "args": [
            "ssp"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_get_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "352-358",
          "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_advance_state",
          "args": [
            "ssp"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_advance_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1173-1233",
          "snippet": "static void srcu_advance_state(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tmutex_lock(&ssp->srcu_gp_mutex);\n\n\t/*\n\t * Because readers might be delayed for an extended period after\n\t * fetching ->srcu_idx for their index, at any point in time there\n\t * might well be readers using both idx=0 and idx=1.  We therefore\n\t * need to wait for readers to clear from both index values before\n\t * invoking a callback.\n\t *\n\t * The load-acquire ensures that we see the accesses performed\n\t * by the prior grace period.\n\t */\n\tidx = rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq)); /* ^^^ */\n\tif (idx == SRCU_STATE_IDLE) {\n\t\tspin_lock_irq_rcu_node(ssp);\n\t\tif (ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)) {\n\t\t\tWARN_ON_ONCE(rcu_seq_state(ssp->srcu_gp_seq));\n\t\t\tspin_unlock_irq_rcu_node(ssp);\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn;\n\t\t}\n\t\tidx = rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq));\n\t\tif (idx == SRCU_STATE_IDLE)\n\t\t\tsrcu_gp_start(ssp);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t\tif (idx != SRCU_STATE_IDLE) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* Someone else started the grace period. */\n\t\t}\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) == SRCU_STATE_SCAN1) {\n\t\tidx = 1 ^ (ssp->srcu_idx & 1);\n\t\tif (!try_check_zero(ssp, idx, 1)) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_flip(ssp);\n\t\tspin_lock_irq_rcu_node(ssp);\n\t\trcu_seq_set_state(&ssp->srcu_gp_seq, SRCU_STATE_SCAN2);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) == SRCU_STATE_SCAN2) {\n\n\t\t/*\n\t\t * SRCU read-side critical sections are normally short,\n\t\t * so check at least twice in quick succession after a flip.\n\t\t */\n\t\tidx = 1 ^ (ssp->srcu_idx & 1);\n\t\tif (!try_check_zero(ssp, idx, 2)) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_gp_end(ssp);  /* Releases ->srcu_gp_mutex. */\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_advance_state(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tmutex_lock(&ssp->srcu_gp_mutex);\n\n\t/*\n\t * Because readers might be delayed for an extended period after\n\t * fetching ->srcu_idx for their index, at any point in time there\n\t * might well be readers using both idx=0 and idx=1.  We therefore\n\t * need to wait for readers to clear from both index values before\n\t * invoking a callback.\n\t *\n\t * The load-acquire ensures that we see the accesses performed\n\t * by the prior grace period.\n\t */\n\tidx = rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq)); /* ^^^ */\n\tif (idx == SRCU_STATE_IDLE) {\n\t\tspin_lock_irq_rcu_node(ssp);\n\t\tif (ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)) {\n\t\t\tWARN_ON_ONCE(rcu_seq_state(ssp->srcu_gp_seq));\n\t\t\tspin_unlock_irq_rcu_node(ssp);\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn;\n\t\t}\n\t\tidx = rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq));\n\t\tif (idx == SRCU_STATE_IDLE)\n\t\t\tsrcu_gp_start(ssp);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t\tif (idx != SRCU_STATE_IDLE) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* Someone else started the grace period. */\n\t\t}\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) == SRCU_STATE_SCAN1) {\n\t\tidx = 1 ^ (ssp->srcu_idx & 1);\n\t\tif (!try_check_zero(ssp, idx, 1)) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_flip(ssp);\n\t\tspin_lock_irq_rcu_node(ssp);\n\t\trcu_seq_set_state(&ssp->srcu_gp_seq, SRCU_STATE_SCAN2);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) == SRCU_STATE_SCAN2) {\n\n\t\t/*\n\t\t * SRCU read-side critical sections are normally short,\n\t\t * so check at least twice in quick succession after a flip.\n\t\t */\n\t\tidx = 1 ^ (ssp->srcu_idx & 1);\n\t\tif (!try_check_zero(ssp, idx, 2)) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_gp_end(ssp);  /* Releases ->srcu_gp_mutex. */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsrcu_struct",
            "work.work"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void process_srcu(struct work_struct *work)\n{\n\tstruct srcu_struct *ssp;\n\n\tssp = container_of(work, struct srcu_struct, work.work);\n\n\tsrcu_advance_state(ssp);\n\tsrcu_reschedule(ssp, srcu_get_delay(ssp));\n}"
  },
  {
    "function_name": "srcu_reschedule",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1296-1314",
    "snippet": "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(ssp);\n\tif (ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(ssp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(ssp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(ssp);\n\t}\n\tspin_unlock_irq_rcu_node(ssp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &ssp->work, delay);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "rcu_gp_wq",
            "&ssp->work",
            "delay"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_delayed_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1092-1109",
          "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_gp_start",
          "args": [
            "ssp"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "435-452",
          "snippet": "static void srcu_gp_start(struct srcu_struct *ssp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(ssp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(ssp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\tspin_lock_rcu_node(sdp);  /* Interrupts already disabled. */\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tspin_unlock_rcu_node(sdp);  /* Interrupts remain disabled. */\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&ssp->srcu_gp_seq);\n\tstate = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_gp_start(struct srcu_struct *ssp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(ssp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(ssp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\tspin_lock_rcu_node(sdp);  /* Interrupts already disabled. */\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tspin_unlock_rcu_node(sdp);  /* Interrupts remain disabled. */\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&ssp->srcu_gp_seq);\n\tstate = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "ssp->srcu_gp_seq"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "39-42",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_seq_state(ssp->srcu_gp_seq)"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "ssp->srcu_gp_seq",
            "ssp->srcu_gp_seq_needed"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(ssp);\n\tif (ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(ssp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(ssp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(ssp);\n\t}\n\tspin_unlock_irq_rcu_node(ssp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &ssp->work, delay);\n}"
  },
  {
    "function_name": "srcu_invoke_callbacks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1241-1290",
    "snippet": "static void srcu_invoke_callbacks(struct work_struct *work)\n{\n\tlong len;\n\tbool more;\n\tstruct rcu_cblist ready_cbs;\n\tstruct rcu_head *rhp;\n\tstruct srcu_data *sdp;\n\tstruct srcu_struct *ssp;\n\n\tsdp = container_of(work, struct srcu_data, work);\n\n\tssp = sdp->ssp;\n\trcu_cblist_init(&ready_cbs);\n\tspin_lock_irq_rcu_node(sdp);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\tif (sdp->srcu_cblist_invoking ||\n\t    !rcu_segcblist_ready_cbs(&sdp->srcu_cblist)) {\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t\treturn;  /* Someone else on the job or nothing to do. */\n\t}\n\n\t/* We are on the job!  Extract and invoke ready callbacks. */\n\tsdp->srcu_cblist_invoking = true;\n\trcu_segcblist_extract_done_cbs(&sdp->srcu_cblist, &ready_cbs);\n\tlen = ready_cbs.len;\n\tspin_unlock_irq_rcu_node(sdp);\n\trhp = rcu_cblist_dequeue(&ready_cbs);\n\tfor (; rhp != NULL; rhp = rcu_cblist_dequeue(&ready_cbs)) {\n\t\tdebug_rcu_head_unqueue(rhp);\n\t\tlocal_bh_disable();\n\t\trhp->func(rhp);\n\t\tlocal_bh_enable();\n\t}\n\tWARN_ON_ONCE(ready_cbs.len);\n\n\t/*\n\t * Update counts, accelerate new callbacks, and if needed,\n\t * schedule another round of callback invocation.\n\t */\n\tspin_lock_irq_rcu_node(sdp);\n\trcu_segcblist_add_len(&sdp->srcu_cblist, -len);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tsdp->srcu_cblist_invoking = false;\n\tmore = rcu_segcblist_ready_cbs(&sdp->srcu_cblist);\n\tspin_unlock_irq_rcu_node(sdp);\n\tif (more)\n\t\tsrcu_schedule_cbs_sdp(sdp, 0);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_schedule_cbs_sdp",
          "args": [
            "sdp",
            "0"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_schedule_cbs_sdp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "477-480",
          "snippet": "static void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp, delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\n\nstatic void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp, delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_ready_cbs",
          "args": [
            "&sdp->srcu_cblist"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_ready_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "278-282",
          "snippet": "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       &rsclp->head != READ_ONCE(rsclp->tails[RCU_DONE_TAIL]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_accelerate",
          "args": [
            "&sdp->srcu_cblist",
            "rcu_seq_snap(&ssp->srcu_gp_seq)"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_accelerate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "537-598",
          "snippet": "bool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t *\n\t * Note that segment \"i\" (and any lower-numbered segments\n\t * containing older callbacks) will be unaffected, and their\n\t * grace-period numbers remain unchanged.  For example, if i ==\n\t * WAIT_TAIL, then neither WAIT_TAIL nor DONE_TAIL will be touched.\n\t * Instead, the CBs in NEXT_TAIL will be merged with those in\n\t * NEXT_READY_TAIL and the grace-period number of NEXT_READY_TAIL\n\t * would be updated.  NEXT_TAIL would then be empty.\n\t */\n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/* Accounting: everything below i is about to get merged into i. */\n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t *\n\t * Note that segment \"i\" (and any lower-numbered segments\n\t * containing older callbacks) will be unaffected, and their\n\t * grace-period numbers remain unchanged.  For example, if i ==\n\t * WAIT_TAIL, then neither WAIT_TAIL nor DONE_TAIL will be touched.\n\t * Instead, the CBs in NEXT_TAIL will be merged with those in\n\t * NEXT_READY_TAIL and the grace-period number of NEXT_READY_TAIL\n\t * would be updated.  NEXT_TAIL would then be empty.\n\t */\n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/* Accounting: everything below i is about to get merged into i. */\n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "87-94",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_add_len",
          "args": [
            "&sdp->srcu_cblist",
            "-len"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_add_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "210-221",
          "snippet": "void rcu_segcblist_add_len(struct rcu_segcblist *rsclp, long v)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\tsmp_mb__before_atomic(); // Read header comment above.\n\tatomic_long_add(v, &rsclp->len);\n\tsmp_mb__after_atomic();  // Read header comment above.\n#else\n\tsmp_mb(); // Read header comment above.\n\tWRITE_ONCE(rsclp->len, rsclp->len + v);\n\tsmp_mb(); // Read header comment above.\n#endif\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_add_len(struct rcu_segcblist *rsclp, long v)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\tsmp_mb__before_atomic(); // Read header comment above.\n\tatomic_long_add(v, &rsclp->len);\n\tsmp_mb__after_atomic();  // Read header comment above.\n#else\n\tsmp_mb(); // Read header comment above.\n\tWRITE_ONCE(rsclp->len, rsclp->len + v);\n\tsmp_mb(); // Read header comment above.\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ready_cbs.len"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_enable",
          "args": [],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "_local_bh_enable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/softirq.c",
          "lines": "353-357",
          "snippet": "void _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <asm/softirq_stack.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/local_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <asm/softirq_stack.h>\n#include <linux/wait_bit.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/local_lock.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid _local_bh_enable(void)\n{\n\tWARN_ON_ONCE(in_irq());\n\t__local_bh_enable(SOFTIRQ_DISABLE_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rhp->func",
          "args": [
            "rhp"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_bh_disable",
          "args": [],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "rhp"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "196-198",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_cblist_dequeue",
          "args": [
            "&ready_cbs"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_dequeue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "67-79",
          "snippet": "struct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp)\n{\n\tstruct rcu_head *rhp;\n\n\trhp = rclp->head;\n\tif (!rhp)\n\t\treturn NULL;\n\trclp->len--;\n\trclp->head = rhp->next;\n\tif (!rclp->head)\n\t\trclp->tail = &rclp->head;\n\treturn rhp;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nstruct rcu_head *rcu_cblist_dequeue(struct rcu_cblist *rclp)\n{\n\tstruct rcu_head *rhp;\n\n\trhp = rclp->head;\n\tif (!rhp)\n\t\treturn NULL;\n\trclp->len--;\n\trclp->head = rhp->next;\n\tif (!rclp->head)\n\t\trclp->tail = &rclp->head;\n\treturn rhp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_extract_done_cbs",
          "args": [
            "&sdp->srcu_cblist",
            "&ready_cbs"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_extract_done_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "385-401",
          "snippet": "void rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rcu_segcblist_ready_cbs(rsclp))\n\t\treturn; /* Nothing to do. */\n\trclp->len = rcu_segcblist_get_seglen(rsclp, RCU_DONE_TAIL);\n\t*rclp->tail = rsclp->head;\n\tWRITE_ONCE(rsclp->head, *rsclp->tails[RCU_DONE_TAIL]);\n\tWRITE_ONCE(*rsclp->tails[RCU_DONE_TAIL], NULL);\n\trclp->tail = rsclp->tails[RCU_DONE_TAIL];\n\tfor (i = RCU_CBLIST_NSEGS - 1; i >= RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] == rsclp->tails[RCU_DONE_TAIL])\n\t\t\tWRITE_ONCE(rsclp->tails[i], &rsclp->head);\n\trcu_segcblist_set_seglen(rsclp, RCU_DONE_TAIL, 0);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_extract_done_cbs(struct rcu_segcblist *rsclp,\n\t\t\t\t    struct rcu_cblist *rclp)\n{\n\tint i;\n\n\tif (!rcu_segcblist_ready_cbs(rsclp))\n\t\treturn; /* Nothing to do. */\n\trclp->len = rcu_segcblist_get_seglen(rsclp, RCU_DONE_TAIL);\n\t*rclp->tail = rsclp->head;\n\tWRITE_ONCE(rsclp->head, *rsclp->tails[RCU_DONE_TAIL]);\n\tWRITE_ONCE(*rsclp->tails[RCU_DONE_TAIL], NULL);\n\trclp->tail = rsclp->tails[RCU_DONE_TAIL];\n\tfor (i = RCU_CBLIST_NSEGS - 1; i >= RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] == rsclp->tails[RCU_DONE_TAIL])\n\t\t\tWRITE_ONCE(rsclp->tails[i], &rsclp->head);\n\trcu_segcblist_set_seglen(rsclp, RCU_DONE_TAIL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_advance",
          "args": [
            "&sdp->srcu_cblist",
            "rcu_seq_current(&ssp->srcu_gp_seq)"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_advance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "480-520",
          "snippet": "void rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\tWRITE_ONCE(rsclp->tails[RCU_DONE_TAIL], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, RCU_DONE_TAIL);\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[RCU_DONE_TAIL]);\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, j);\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\tWRITE_ONCE(rsclp->tails[RCU_DONE_TAIL], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, RCU_DONE_TAIL);\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[RCU_DONE_TAIL]);\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, j);\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_cblist_init",
          "args": [
            "&ready_cbs"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_cblist_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "18-23",
          "snippet": "void rcu_cblist_init(struct rcu_cblist *rclp)\n{\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n\trclp->len = 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_cblist_init(struct rcu_cblist *rclp)\n{\n\trclp->head = NULL;\n\trclp->tail = &rclp->head;\n\trclp->len = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsrcu_data",
            "work"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_invoke_callbacks(struct work_struct *work)\n{\n\tlong len;\n\tbool more;\n\tstruct rcu_cblist ready_cbs;\n\tstruct rcu_head *rhp;\n\tstruct srcu_data *sdp;\n\tstruct srcu_struct *ssp;\n\n\tsdp = container_of(work, struct srcu_data, work);\n\n\tssp = sdp->ssp;\n\trcu_cblist_init(&ready_cbs);\n\tspin_lock_irq_rcu_node(sdp);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\tif (sdp->srcu_cblist_invoking ||\n\t    !rcu_segcblist_ready_cbs(&sdp->srcu_cblist)) {\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t\treturn;  /* Someone else on the job or nothing to do. */\n\t}\n\n\t/* We are on the job!  Extract and invoke ready callbacks. */\n\tsdp->srcu_cblist_invoking = true;\n\trcu_segcblist_extract_done_cbs(&sdp->srcu_cblist, &ready_cbs);\n\tlen = ready_cbs.len;\n\tspin_unlock_irq_rcu_node(sdp);\n\trhp = rcu_cblist_dequeue(&ready_cbs);\n\tfor (; rhp != NULL; rhp = rcu_cblist_dequeue(&ready_cbs)) {\n\t\tdebug_rcu_head_unqueue(rhp);\n\t\tlocal_bh_disable();\n\t\trhp->func(rhp);\n\t\tlocal_bh_enable();\n\t}\n\tWARN_ON_ONCE(ready_cbs.len);\n\n\t/*\n\t * Update counts, accelerate new callbacks, and if needed,\n\t * schedule another round of callback invocation.\n\t */\n\tspin_lock_irq_rcu_node(sdp);\n\trcu_segcblist_add_len(&sdp->srcu_cblist, -len);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tsdp->srcu_cblist_invoking = false;\n\tmore = rcu_segcblist_ready_cbs(&sdp->srcu_cblist);\n\tspin_unlock_irq_rcu_node(sdp);\n\tif (more)\n\t\tsrcu_schedule_cbs_sdp(sdp, 0);\n}"
  },
  {
    "function_name": "srcu_advance_state",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1173-1233",
    "snippet": "static void srcu_advance_state(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tmutex_lock(&ssp->srcu_gp_mutex);\n\n\t/*\n\t * Because readers might be delayed for an extended period after\n\t * fetching ->srcu_idx for their index, at any point in time there\n\t * might well be readers using both idx=0 and idx=1.  We therefore\n\t * need to wait for readers to clear from both index values before\n\t * invoking a callback.\n\t *\n\t * The load-acquire ensures that we see the accesses performed\n\t * by the prior grace period.\n\t */\n\tidx = rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq)); /* ^^^ */\n\tif (idx == SRCU_STATE_IDLE) {\n\t\tspin_lock_irq_rcu_node(ssp);\n\t\tif (ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)) {\n\t\t\tWARN_ON_ONCE(rcu_seq_state(ssp->srcu_gp_seq));\n\t\t\tspin_unlock_irq_rcu_node(ssp);\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn;\n\t\t}\n\t\tidx = rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq));\n\t\tif (idx == SRCU_STATE_IDLE)\n\t\t\tsrcu_gp_start(ssp);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t\tif (idx != SRCU_STATE_IDLE) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* Someone else started the grace period. */\n\t\t}\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) == SRCU_STATE_SCAN1) {\n\t\tidx = 1 ^ (ssp->srcu_idx & 1);\n\t\tif (!try_check_zero(ssp, idx, 1)) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_flip(ssp);\n\t\tspin_lock_irq_rcu_node(ssp);\n\t\trcu_seq_set_state(&ssp->srcu_gp_seq, SRCU_STATE_SCAN2);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) == SRCU_STATE_SCAN2) {\n\n\t\t/*\n\t\t * SRCU read-side critical sections are normally short,\n\t\t * so check at least twice in quick succession after a flip.\n\t\t */\n\t\tidx = 1 ^ (ssp->srcu_idx & 1);\n\t\tif (!try_check_zero(ssp, idx, 2)) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_gp_end(ssp);  /* Releases ->srcu_gp_mutex. */\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_gp_end",
          "args": [
            "ssp"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "509-586",
          "snippet": "static void srcu_gp_end(struct srcu_struct *ssp)\n{\n\tunsigned long cbdelay;\n\tbool cbs;\n\tbool last_lvl;\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpseq;\n\tint idx;\n\tunsigned long mask;\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\n\t/* Prevent more than one additional grace period. */\n\tmutex_lock(&ssp->srcu_cb_mutex);\n\n\t/* End the current grace period. */\n\tspin_lock_irq_rcu_node(ssp);\n\tidx = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(idx != SRCU_STATE_SCAN2);\n\tcbdelay = srcu_get_delay(ssp);\n\tWRITE_ONCE(ssp->srcu_last_gp_end, ktime_get_mono_fast_ns());\n\trcu_seq_end(&ssp->srcu_gp_seq);\n\tgpseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, gpseq))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, gpseq);\n\tspin_unlock_irq_rcu_node(ssp);\n\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t/* A new grace period can start at this point.  But only one. */\n\n\t/* Initiate callback invocation as needed. */\n\tidx = rcu_seq_ctr(gpseq) % ARRAY_SIZE(snp->srcu_have_cbs);\n\tsrcu_for_each_node_breadth_first(ssp, snp) {\n\t\tspin_lock_irq_rcu_node(snp);\n\t\tcbs = false;\n\t\tlast_lvl = snp >= ssp->level[rcu_num_lvls - 1];\n\t\tif (last_lvl)\n\t\t\tcbs = snp->srcu_have_cbs[idx] == gpseq;\n\t\tsnp->srcu_have_cbs[idx] = gpseq;\n\t\trcu_seq_set_state(&snp->srcu_have_cbs[idx], 1);\n\t\tif (ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, gpseq))\n\t\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, gpseq);\n\t\tmask = snp->srcu_data_have_cbs[idx];\n\t\tsnp->srcu_data_have_cbs[idx] = 0;\n\t\tspin_unlock_irq_rcu_node(snp);\n\t\tif (cbs)\n\t\t\tsrcu_schedule_cbs_snp(ssp, snp, mask, cbdelay);\n\n\t\t/* Occasionally prevent srcu_data counter wrap. */\n\t\tif (!(gpseq & counter_wrap_check) && last_lvl)\n\t\t\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\t\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\t\t\tspin_lock_irqsave_rcu_node(sdp, flags);\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed = gpseq;\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed_exp + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed_exp = gpseq;\n\t\t\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\t\t}\n\t}\n\n\t/* Callback initiation done, allow grace periods after next. */\n\tmutex_unlock(&ssp->srcu_cb_mutex);\n\n\t/* Start a new grace period if needed. */\n\tspin_lock_irq_rcu_node(ssp);\n\tgpseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tif (!rcu_seq_state(gpseq) &&\n\t    ULONG_CMP_LT(gpseq, ssp->srcu_gp_seq_needed)) {\n\t\tsrcu_gp_start(ssp);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t\tsrcu_reschedule(ssp, 0);\n\t} else {\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong counter_wrap_check = (ULONG_MAX >> 2);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic ulong counter_wrap_check = (ULONG_MAX >> 2);\n\nstatic void srcu_gp_end(struct srcu_struct *ssp)\n{\n\tunsigned long cbdelay;\n\tbool cbs;\n\tbool last_lvl;\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpseq;\n\tint idx;\n\tunsigned long mask;\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\n\t/* Prevent more than one additional grace period. */\n\tmutex_lock(&ssp->srcu_cb_mutex);\n\n\t/* End the current grace period. */\n\tspin_lock_irq_rcu_node(ssp);\n\tidx = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(idx != SRCU_STATE_SCAN2);\n\tcbdelay = srcu_get_delay(ssp);\n\tWRITE_ONCE(ssp->srcu_last_gp_end, ktime_get_mono_fast_ns());\n\trcu_seq_end(&ssp->srcu_gp_seq);\n\tgpseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, gpseq))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, gpseq);\n\tspin_unlock_irq_rcu_node(ssp);\n\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t/* A new grace period can start at this point.  But only one. */\n\n\t/* Initiate callback invocation as needed. */\n\tidx = rcu_seq_ctr(gpseq) % ARRAY_SIZE(snp->srcu_have_cbs);\n\tsrcu_for_each_node_breadth_first(ssp, snp) {\n\t\tspin_lock_irq_rcu_node(snp);\n\t\tcbs = false;\n\t\tlast_lvl = snp >= ssp->level[rcu_num_lvls - 1];\n\t\tif (last_lvl)\n\t\t\tcbs = snp->srcu_have_cbs[idx] == gpseq;\n\t\tsnp->srcu_have_cbs[idx] = gpseq;\n\t\trcu_seq_set_state(&snp->srcu_have_cbs[idx], 1);\n\t\tif (ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, gpseq))\n\t\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, gpseq);\n\t\tmask = snp->srcu_data_have_cbs[idx];\n\t\tsnp->srcu_data_have_cbs[idx] = 0;\n\t\tspin_unlock_irq_rcu_node(snp);\n\t\tif (cbs)\n\t\t\tsrcu_schedule_cbs_snp(ssp, snp, mask, cbdelay);\n\n\t\t/* Occasionally prevent srcu_data counter wrap. */\n\t\tif (!(gpseq & counter_wrap_check) && last_lvl)\n\t\t\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\t\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\t\t\tspin_lock_irqsave_rcu_node(sdp, flags);\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed = gpseq;\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed_exp + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed_exp = gpseq;\n\t\t\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\t\t}\n\t}\n\n\t/* Callback initiation done, allow grace periods after next. */\n\tmutex_unlock(&ssp->srcu_cb_mutex);\n\n\t/* Start a new grace period if needed. */\n\tspin_lock_irq_rcu_node(ssp);\n\tgpseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tif (!rcu_seq_state(gpseq) &&\n\t    ULONG_CMP_LT(gpseq, ssp->srcu_gp_seq_needed)) {\n\t\tsrcu_gp_start(ssp);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t\tsrcu_reschedule(ssp, 0);\n\t} else {\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ssp->srcu_gp_mutex"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_check_zero",
          "args": [
            "ssp",
            "idx",
            "2"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "try_check_zero",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "695-704",
          "snippet": "static bool try_check_zero(struct srcu_struct *ssp, int idx, int trycount)\n{\n\tfor (;;) {\n\t\tif (srcu_readers_active_idx_check(ssp, idx))\n\t\t\treturn true;\n\t\tif (--trycount + !srcu_get_delay(ssp) <= 0)\n\t\t\treturn false;\n\t\tudelay(SRCU_RETRY_CHECK_DELAY);\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_RETRY_CHECK_DELAY\t\t5"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_RETRY_CHECK_DELAY\t\t5\n\nstatic bool try_check_zero(struct srcu_struct *ssp, int idx, int trycount)\n{\n\tfor (;;) {\n\t\tif (srcu_readers_active_idx_check(ssp, idx))\n\t\t\treturn true;\n\t\tif (--trycount + !srcu_get_delay(ssp) <= 0)\n\t\t\treturn false;\n\t\tudelay(SRCU_RETRY_CHECK_DELAY);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "READ_ONCE(ssp->srcu_gp_seq)"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "39-42",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_gp_seq"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_set_state",
          "args": [
            "&ssp->srcu_gp_seq",
            "SRCU_STATE_SCAN2"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "48-52",
          "snippet": "static inline void rcu_seq_set_state(unsigned long *sp, int newstate)\n{\n\tWARN_ON_ONCE(newstate & ~RCU_SEQ_STATE_MASK);\n\tWRITE_ONCE(*sp, (*sp & ~RCU_SEQ_STATE_MASK) + newstate);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline void rcu_seq_set_state(unsigned long *sp, int newstate)\n{\n\tWARN_ON_ONCE(newstate & ~RCU_SEQ_STATE_MASK);\n\tWRITE_ONCE(*sp, (*sp & ~RCU_SEQ_STATE_MASK) + newstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_flip",
          "args": [
            "ssp"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_flip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "711-733",
          "snippet": "static void srcu_flip(struct srcu_struct *ssp)\n{\n\t/*\n\t * Ensure that if this updater saw a given reader's increment\n\t * from __srcu_read_lock(), that reader was using an old value\n\t * of ->srcu_idx.  Also ensure that if a given reader sees the\n\t * new value of ->srcu_idx, this updater's earlier scans cannot\n\t * have seen that reader's increments (which is OK, because this\n\t * grace period need not wait on that reader).\n\t */\n\tsmp_mb(); /* E */  /* Pairs with B and C. */\n\n\tWRITE_ONCE(ssp->srcu_idx, ssp->srcu_idx + 1);\n\n\t/*\n\t * Ensure that if the updater misses an __srcu_read_unlock()\n\t * increment, that task's next __srcu_read_lock() will see the\n\t * above counter update.  Note that both this memory barrier\n\t * and the one in srcu_readers_active_idx_check() provide the\n\t * guarantee for __srcu_read_lock().\n\t */\n\tsmp_mb(); /* D */  /* Pairs with C. */\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_flip(struct srcu_struct *ssp)\n{\n\t/*\n\t * Ensure that if this updater saw a given reader's increment\n\t * from __srcu_read_lock(), that reader was using an old value\n\t * of ->srcu_idx.  Also ensure that if a given reader sees the\n\t * new value of ->srcu_idx, this updater's earlier scans cannot\n\t * have seen that reader's increments (which is OK, because this\n\t * grace period need not wait on that reader).\n\t */\n\tsmp_mb(); /* E */  /* Pairs with B and C. */\n\n\tWRITE_ONCE(ssp->srcu_idx, ssp->srcu_idx + 1);\n\n\t/*\n\t * Ensure that if the updater misses an __srcu_read_unlock()\n\t * increment, that task's next __srcu_read_lock() will see the\n\t * above counter update.  Note that both this memory barrier\n\t * and the one in srcu_readers_active_idx_check() provide the\n\t * guarantee for __srcu_read_lock().\n\t */\n\tsmp_mb(); /* D */  /* Pairs with C. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_gp_seq"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_gp_start",
          "args": [
            "ssp"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "435-452",
          "snippet": "static void srcu_gp_start(struct srcu_struct *ssp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(ssp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(ssp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\tspin_lock_rcu_node(sdp);  /* Interrupts already disabled. */\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tspin_unlock_rcu_node(sdp);  /* Interrupts remain disabled. */\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&ssp->srcu_gp_seq);\n\tstate = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_gp_start(struct srcu_struct *ssp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(ssp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(ssp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\tspin_lock_rcu_node(sdp);  /* Interrupts already disabled. */\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tspin_unlock_rcu_node(sdp);  /* Interrupts remain disabled. */\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&ssp->srcu_gp_seq);\n\tstate = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_gp_seq"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "rcu_seq_state(ssp->srcu_gp_seq)"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "ssp->srcu_gp_seq",
            "ssp->srcu_gp_seq_needed"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ssp->srcu_gp_mutex"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_advance_state(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tmutex_lock(&ssp->srcu_gp_mutex);\n\n\t/*\n\t * Because readers might be delayed for an extended period after\n\t * fetching ->srcu_idx for their index, at any point in time there\n\t * might well be readers using both idx=0 and idx=1.  We therefore\n\t * need to wait for readers to clear from both index values before\n\t * invoking a callback.\n\t *\n\t * The load-acquire ensures that we see the accesses performed\n\t * by the prior grace period.\n\t */\n\tidx = rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq)); /* ^^^ */\n\tif (idx == SRCU_STATE_IDLE) {\n\t\tspin_lock_irq_rcu_node(ssp);\n\t\tif (ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)) {\n\t\t\tWARN_ON_ONCE(rcu_seq_state(ssp->srcu_gp_seq));\n\t\t\tspin_unlock_irq_rcu_node(ssp);\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn;\n\t\t}\n\t\tidx = rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq));\n\t\tif (idx == SRCU_STATE_IDLE)\n\t\t\tsrcu_gp_start(ssp);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t\tif (idx != SRCU_STATE_IDLE) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* Someone else started the grace period. */\n\t\t}\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) == SRCU_STATE_SCAN1) {\n\t\tidx = 1 ^ (ssp->srcu_idx & 1);\n\t\tif (!try_check_zero(ssp, idx, 1)) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_flip(ssp);\n\t\tspin_lock_irq_rcu_node(ssp);\n\t\trcu_seq_set_state(&ssp->srcu_gp_seq, SRCU_STATE_SCAN2);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t}\n\n\tif (rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) == SRCU_STATE_SCAN2) {\n\n\t\t/*\n\t\t * SRCU read-side critical sections are normally short,\n\t\t * so check at least twice in quick succession after a flip.\n\t\t */\n\t\tidx = 1 ^ (ssp->srcu_idx & 1);\n\t\tif (!try_check_zero(ssp, idx, 2)) {\n\t\t\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t\t\treturn; /* readers present, retry later. */\n\t\t}\n\t\tsrcu_gp_end(ssp);  /* Releases ->srcu_gp_mutex. */\n\t}\n}"
  },
  {
    "function_name": "srcu_batches_completed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1162-1165",
    "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_idx"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}"
  },
  {
    "function_name": "srcu_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1104-1152",
    "snippet": "void srcu_barrier(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tstruct srcu_data *sdp;\n\tunsigned long s = rcu_seq_snap(&ssp->srcu_barrier_seq);\n\n\tcheck_init_srcu_struct(ssp);\n\tmutex_lock(&ssp->srcu_barrier_mutex);\n\tif (rcu_seq_done(&ssp->srcu_barrier_seq, s)) {\n\t\tsmp_mb(); /* Force ordering following return. */\n\t\tmutex_unlock(&ssp->srcu_barrier_mutex);\n\t\treturn; /* Someone else did our work for us. */\n\t}\n\trcu_seq_start(&ssp->srcu_barrier_seq);\n\tinit_completion(&ssp->srcu_barrier_completion);\n\n\t/* Initial count prevents reaching zero until all CBs are posted. */\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 1);\n\n\t/*\n\t * Each pass through this loop enqueues a callback, but only\n\t * on CPUs already having callbacks enqueued.  Note that if\n\t * a CPU already has callbacks enqueue, it must have already\n\t * registered the need for a future grace period, so all we\n\t * need do is enqueue a callback that will use the same\n\t * grace period as the last callback already in the queue.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tspin_lock_irq_rcu_node(sdp);\n\t\tatomic_inc(&ssp->srcu_barrier_cpu_cnt);\n\t\tsdp->srcu_barrier_head.func = srcu_barrier_cb;\n\t\tdebug_rcu_head_queue(&sdp->srcu_barrier_head);\n\t\tif (!rcu_segcblist_entrain(&sdp->srcu_cblist,\n\t\t\t\t\t   &sdp->srcu_barrier_head)) {\n\t\t\tdebug_rcu_head_unqueue(&sdp->srcu_barrier_head);\n\t\t\tatomic_dec(&ssp->srcu_barrier_cpu_cnt);\n\t\t}\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t}\n\n\t/* Remove the initial count, at which point reaching zero can happen. */\n\tif (atomic_dec_and_test(&ssp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&ssp->srcu_barrier_completion);\n\twait_for_completion(&ssp->srcu_barrier_completion);\n\n\trcu_seq_end(&ssp->srcu_barrier_seq);\n\tmutex_unlock(&ssp->srcu_barrier_mutex);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ssp->srcu_barrier_mutex"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_end",
          "args": [
            "&ssp->srcu_barrier_seq"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "69-74",
          "snippet": "static inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&ssp->srcu_barrier_completion"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&ssp->srcu_barrier_completion"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1162-1165",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ssp->srcu_barrier_cpu_cnt"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&ssp->srcu_barrier_cpu_cnt"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_unqueue",
          "args": [
            "&sdp->srcu_barrier_head"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_unqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "196-198",
          "snippet": "static inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void debug_rcu_head_unqueue(struct rcu_head *head)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_entrain",
          "args": [
            "&sdp->srcu_cblist",
            "&sdp->srcu_barrier_head"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_entrain",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "360-378",
          "snippet": "bool rcu_segcblist_entrain(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp)\n{\n\tint i;\n\n\tif (rcu_segcblist_n_cbs(rsclp) == 0)\n\t\treturn false;\n\trcu_segcblist_inc_len(rsclp);\n\tsmp_mb(); /* Ensure counts are updated before callback is entrained. */\n\trhp->next = NULL;\n\tfor (i = RCU_NEXT_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1])\n\t\t\tbreak;\n\trcu_segcblist_inc_seglen(rsclp, i);\n\tWRITE_ONCE(*rsclp->tails[i], rhp);\n\tfor (; i <= RCU_NEXT_TAIL; i++)\n\t\tWRITE_ONCE(rsclp->tails[i], &rhp->next);\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_entrain(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp)\n{\n\tint i;\n\n\tif (rcu_segcblist_n_cbs(rsclp) == 0)\n\t\treturn false;\n\trcu_segcblist_inc_len(rsclp);\n\tsmp_mb(); /* Ensure counts are updated before callback is entrained. */\n\trhp->next = NULL;\n\tfor (i = RCU_NEXT_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1])\n\t\t\tbreak;\n\trcu_segcblist_inc_seglen(rsclp, i);\n\tWRITE_ONCE(*rsclp->tails[i], rhp);\n\tfor (; i <= RCU_NEXT_TAIL; i++)\n\t\tWRITE_ONCE(rsclp->tails[i], &rhp->next);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_queue",
          "args": [
            "&sdp->srcu_barrier_head"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "191-194",
          "snippet": "static inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ssp->srcu_barrier_cpu_cnt"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ssp->sda",
            "cpu"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ssp->srcu_barrier_cpu_cnt",
            "1"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&ssp->srcu_barrier_completion"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_start",
          "args": [
            "&ssp->srcu_barrier_seq"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "55-60",
          "snippet": "static inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&ssp->srcu_barrier_seq",
            "s"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ssp->srcu_barrier_mutex"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_init_srcu_struct",
          "args": [
            "ssp"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "224-238",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&ssp->srcu_barrier_seq"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "87-94",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid srcu_barrier(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tstruct srcu_data *sdp;\n\tunsigned long s = rcu_seq_snap(&ssp->srcu_barrier_seq);\n\n\tcheck_init_srcu_struct(ssp);\n\tmutex_lock(&ssp->srcu_barrier_mutex);\n\tif (rcu_seq_done(&ssp->srcu_barrier_seq, s)) {\n\t\tsmp_mb(); /* Force ordering following return. */\n\t\tmutex_unlock(&ssp->srcu_barrier_mutex);\n\t\treturn; /* Someone else did our work for us. */\n\t}\n\trcu_seq_start(&ssp->srcu_barrier_seq);\n\tinit_completion(&ssp->srcu_barrier_completion);\n\n\t/* Initial count prevents reaching zero until all CBs are posted. */\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 1);\n\n\t/*\n\t * Each pass through this loop enqueues a callback, but only\n\t * on CPUs already having callbacks enqueued.  Note that if\n\t * a CPU already has callbacks enqueue, it must have already\n\t * registered the need for a future grace period, so all we\n\t * need do is enqueue a callback that will use the same\n\t * grace period as the last callback already in the queue.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tspin_lock_irq_rcu_node(sdp);\n\t\tatomic_inc(&ssp->srcu_barrier_cpu_cnt);\n\t\tsdp->srcu_barrier_head.func = srcu_barrier_cb;\n\t\tdebug_rcu_head_queue(&sdp->srcu_barrier_head);\n\t\tif (!rcu_segcblist_entrain(&sdp->srcu_cblist,\n\t\t\t\t\t   &sdp->srcu_barrier_head)) {\n\t\t\tdebug_rcu_head_unqueue(&sdp->srcu_barrier_head);\n\t\t\tatomic_dec(&ssp->srcu_barrier_cpu_cnt);\n\t\t}\n\t\tspin_unlock_irq_rcu_node(sdp);\n\t}\n\n\t/* Remove the initial count, at which point reaching zero can happen. */\n\tif (atomic_dec_and_test(&ssp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&ssp->srcu_barrier_completion);\n\twait_for_completion(&ssp->srcu_barrier_completion);\n\n\trcu_seq_end(&ssp->srcu_barrier_seq);\n\tmutex_unlock(&ssp->srcu_barrier_mutex);\n}"
  },
  {
    "function_name": "srcu_barrier_cb",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1089-1098",
    "snippet": "static void srcu_barrier_cb(struct rcu_head *rhp)\n{\n\tstruct srcu_data *sdp;\n\tstruct srcu_struct *ssp;\n\n\tsdp = container_of(rhp, struct srcu_data, srcu_barrier_head);\n\tssp = sdp->ssp;\n\tif (atomic_dec_and_test(&ssp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&ssp->srcu_barrier_completion);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&ssp->srcu_barrier_completion"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_batches_completed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1162-1165",
          "snippet": "unsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long srcu_batches_completed(struct srcu_struct *ssp)\n{\n\treturn READ_ONCE(ssp->srcu_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&ssp->srcu_barrier_cpu_cnt"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhp",
            "structsrcu_data",
            "srcu_barrier_head"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_barrier_cb(struct rcu_head *rhp)\n{\n\tstruct srcu_data *sdp;\n\tstruct srcu_struct *ssp;\n\n\tsdp = container_of(rhp, struct srcu_data, srcu_barrier_head);\n\tssp = sdp->ssp;\n\tif (atomic_dec_and_test(&ssp->srcu_barrier_cpu_cnt))\n\t\tcomplete(&ssp->srcu_barrier_completion);\n}"
  },
  {
    "function_name": "poll_state_synchronize_srcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1075-1083",
    "snippet": "bool poll_state_synchronize_srcu(struct srcu_struct *ssp, unsigned long cookie)\n{\n\tif (!rcu_seq_done(&ssp->srcu_gp_seq, cookie))\n\t\treturn false;\n\t// Ensure that the end of the SRCU grace period happens before\n\t// any subsequent code that the caller might execute.\n\tsmp_mb(); // ^^^\n\treturn true;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&ssp->srcu_gp_seq",
            "cookie"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nbool poll_state_synchronize_srcu(struct srcu_struct *ssp, unsigned long cookie)\n{\n\tif (!rcu_seq_done(&ssp->srcu_gp_seq, cookie))\n\t\treturn false;\n\t// Ensure that the end of the SRCU grace period happens before\n\t// any subsequent code that the caller might execute.\n\tsmp_mb(); // ^^^\n\treturn true;\n}"
  },
  {
    "function_name": "start_poll_synchronize_srcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1044-1047",
    "snippet": "unsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_gp_start_if_needed",
          "args": [
            "ssp",
            "NULL",
            "true"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_start_if_needed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "808-843",
          "snippet": "static unsigned long srcu_gp_start_if_needed(struct srcu_struct *ssp,\n\t\t\t\t\t     struct rcu_head *rhp, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(ssp);\n\tidx = srcu_read_lock(ssp);\n\tsdp = raw_cpu_ptr(ssp->sda);\n\tspin_lock_irqsave_rcu_node(sdp, flags);\n\tif (rhp)\n\t\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\ts = rcu_seq_snap(&ssp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(ssp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(ssp, sdp->mynode, s);\n\tsrcu_read_unlock(ssp, idx);\n\treturn s;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_gp_start_if_needed(struct srcu_struct *ssp,\n\t\t\t\t\t     struct rcu_head *rhp, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(ssp);\n\tidx = srcu_read_lock(ssp);\n\tsdp = raw_cpu_ptr(ssp->sda);\n\tspin_lock_irqsave_rcu_node(sdp, flags);\n\tif (rhp)\n\t\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\ts = rcu_seq_snap(&ssp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(ssp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(ssp, sdp->mynode, s);\n\tsrcu_read_unlock(ssp, idx);\n\treturn s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long start_poll_synchronize_srcu(struct srcu_struct *ssp)\n{\n\treturn srcu_gp_start_if_needed(ssp, NULL, true);\n}"
  },
  {
    "function_name": "get_state_synchronize_srcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1025-1031",
    "snippet": "unsigned long get_state_synchronize_srcu(struct srcu_struct *ssp)\n{\n\t// Any prior manipulation of SRCU-protected data must happen\n\t// before the load from ->srcu_gp_seq.\n\tsmp_mb();\n\treturn rcu_seq_snap(&ssp->srcu_gp_seq);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "87-94",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nunsigned long get_state_synchronize_srcu(struct srcu_struct *ssp)\n{\n\t// Any prior manipulation of SRCU-protected data must happen\n\t// before the load from ->srcu_gp_seq.\n\tsmp_mb();\n\treturn rcu_seq_snap(&ssp->srcu_gp_seq);\n}"
  },
  {
    "function_name": "synchronize_srcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "1006-1012",
    "snippet": "void synchronize_srcu(struct srcu_struct *ssp)\n{\n\tif (srcu_might_be_idle(ssp) || rcu_gp_is_expedited())\n\t\tsynchronize_srcu_expedited(ssp);\n\telse\n\t\t__synchronize_srcu(ssp, true);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synchronize_srcu",
          "args": [
            "ssp",
            "true"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "__synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "913-941",
          "snippet": "static void __synchronize_srcu(struct srcu_struct *ssp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lockdep_is_held(ssp) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(ssp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(ssp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void __synchronize_srcu(struct srcu_struct *ssp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lockdep_is_held(ssp) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(ssp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(ssp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_srcu_expedited",
          "args": [
            "ssp"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_srcu_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "953-956",
          "snippet": "void synchronize_srcu_expedited(struct srcu_struct *ssp)\n{\n\t__synchronize_srcu(ssp, rcu_gp_is_normal());\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu_expedited(struct srcu_struct *ssp)\n{\n\t__synchronize_srcu(ssp, rcu_gp_is_normal());\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_expedited",
          "args": [],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_expedited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "156-159",
          "snippet": "bool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_expedited(void)\n{\n\treturn rcu_expedited || atomic_read(&rcu_expedited_nesting);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_might_be_idle",
          "args": [
            "ssp"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_might_be_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "756-796",
          "snippet": "static bool srcu_might_be_idle(struct srcu_struct *ssp)\n{\n\tunsigned long curseq;\n\tunsigned long flags;\n\tstruct srcu_data *sdp;\n\tunsigned long t;\n\tunsigned long tlast;\n\n\tcheck_init_srcu_struct(ssp);\n\t/* If the local srcu_data structure has callbacks, not idle.  */\n\tsdp = raw_cpu_ptr(ssp->sda);\n\tspin_lock_irqsave_rcu_node(sdp, flags);\n\tif (rcu_segcblist_pend_cbs(&sdp->srcu_cblist)) {\n\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\treturn false; /* Callbacks already present, so not idle. */\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\n\t/*\n\t * No local callbacks, so probabilistically probe global state.\n\t * Exact information would require acquiring locks, which would\n\t * kill scalability, hence the probabilistic nature of the probe.\n\t */\n\n\t/* First, see if enough time has passed since the last GP. */\n\tt = ktime_get_mono_fast_ns();\n\ttlast = READ_ONCE(ssp->srcu_last_gp_end);\n\tif (exp_holdoff == 0 ||\n\t    time_in_range_open(t, tlast, tlast + exp_holdoff))\n\t\treturn false; /* Too soon after last GP. */\n\n\t/* Next, check for probable idleness. */\n\tcurseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tsmp_mb(); /* Order ->srcu_gp_seq with ->srcu_gp_seq_needed. */\n\tif (ULONG_CMP_LT(curseq, READ_ONCE(ssp->srcu_gp_seq_needed)))\n\t\treturn false; /* Grace period in progress, so not idle. */\n\tsmp_mb(); /* Order ->srcu_gp_seq with prior access. */\n\tif (curseq != rcu_seq_current(&ssp->srcu_gp_seq))\n\t\treturn false; /* GP # changed, so not idle. */\n\treturn true; /* With reasonable probability, idle! */\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;",
            "static void srcu_delay_timer(struct timer_list *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;\nstatic void srcu_delay_timer(struct timer_list *t);\n\nstatic bool srcu_might_be_idle(struct srcu_struct *ssp)\n{\n\tunsigned long curseq;\n\tunsigned long flags;\n\tstruct srcu_data *sdp;\n\tunsigned long t;\n\tunsigned long tlast;\n\n\tcheck_init_srcu_struct(ssp);\n\t/* If the local srcu_data structure has callbacks, not idle.  */\n\tsdp = raw_cpu_ptr(ssp->sda);\n\tspin_lock_irqsave_rcu_node(sdp, flags);\n\tif (rcu_segcblist_pend_cbs(&sdp->srcu_cblist)) {\n\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\treturn false; /* Callbacks already present, so not idle. */\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\n\t/*\n\t * No local callbacks, so probabilistically probe global state.\n\t * Exact information would require acquiring locks, which would\n\t * kill scalability, hence the probabilistic nature of the probe.\n\t */\n\n\t/* First, see if enough time has passed since the last GP. */\n\tt = ktime_get_mono_fast_ns();\n\ttlast = READ_ONCE(ssp->srcu_last_gp_end);\n\tif (exp_holdoff == 0 ||\n\t    time_in_range_open(t, tlast, tlast + exp_holdoff))\n\t\treturn false; /* Too soon after last GP. */\n\n\t/* Next, check for probable idleness. */\n\tcurseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tsmp_mb(); /* Order ->srcu_gp_seq with ->srcu_gp_seq_needed. */\n\tif (ULONG_CMP_LT(curseq, READ_ONCE(ssp->srcu_gp_seq_needed)))\n\t\treturn false; /* Grace period in progress, so not idle. */\n\tsmp_mb(); /* Order ->srcu_gp_seq with prior access. */\n\tif (curseq != rcu_seq_current(&ssp->srcu_gp_seq))\n\t\treturn false; /* GP # changed, so not idle. */\n\treturn true; /* With reasonable probability, idle! */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu(struct srcu_struct *ssp)\n{\n\tif (srcu_might_be_idle(ssp) || rcu_gp_is_expedited())\n\t\tsynchronize_srcu_expedited(ssp);\n\telse\n\t\t__synchronize_srcu(ssp, true);\n}"
  },
  {
    "function_name": "synchronize_srcu_expedited",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "953-956",
    "snippet": "void synchronize_srcu_expedited(struct srcu_struct *ssp)\n{\n\t__synchronize_srcu(ssp, rcu_gp_is_normal());\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__synchronize_srcu",
          "args": [
            "ssp",
            "rcu_gp_is_normal()"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "__synchronize_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "913-941",
          "snippet": "static void __synchronize_srcu(struct srcu_struct *ssp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lockdep_is_held(ssp) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(ssp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(ssp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void __synchronize_srcu(struct srcu_struct *ssp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lockdep_is_held(ssp) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(ssp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(ssp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_gp_is_normal",
          "args": [],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_gp_is_normal",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "140-144",
          "snippet": "bool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nbool rcu_gp_is_normal(void)\n{\n\treturn READ_ONCE(rcu_normal) &&\n\t       rcu_scheduler_active != RCU_SCHEDULER_INIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid synchronize_srcu_expedited(struct srcu_struct *ssp)\n{\n\t__synchronize_srcu(ssp, rcu_gp_is_normal());\n}"
  },
  {
    "function_name": "__synchronize_srcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "913-941",
    "snippet": "static void __synchronize_srcu(struct srcu_struct *ssp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lockdep_is_held(ssp) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(ssp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(ssp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_rcu_head_on_stack",
          "args": [
            "&rcu.head"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_rcu_head_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "455-458",
          "snippet": "void destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid destroy_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_free(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&rcu.completion"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/completion.c",
          "lines": "282-303",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\traw_spin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\traw_spin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__call_srcu",
          "args": [
            "ssp",
            "&rcu.head",
            "wakeme_after_rcu",
            "do_norm"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "__call_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "873-884",
          "snippet": "static void __call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t\t\trcu_callback_t func, bool do_norm)\n{\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\t(void)srcu_gp_start_if_needed(ssp, rhp, do_norm);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void __call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t\t\trcu_callback_t func, bool do_norm)\n{\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\t(void)srcu_gp_start_if_needed(ssp, rhp, do_norm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rcu_head_on_stack",
          "args": [
            "&rcu.head"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "init_rcu_head_on_stack",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "438-441",
          "snippet": "void init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid init_rcu_head_on_stack(struct rcu_head *head)\n{\n\tdebug_object_init_on_stack(head, &rcuhead_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&rcu.completion"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_init_srcu_struct",
          "args": [
            "ssp"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "224-238",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "lockdep_is_held(ssp) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map)",
            "\"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\""
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_sched_lock_map"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_lock_map"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_is_held",
          "args": [
            "&rcu_bh_lock_map"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "ssp"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void __synchronize_srcu(struct srcu_struct *ssp, bool do_norm)\n{\n\tstruct rcu_synchronize rcu;\n\n\tRCU_LOCKDEP_WARN(lockdep_is_held(ssp) ||\n\t\t\t lock_is_held(&rcu_bh_lock_map) ||\n\t\t\t lock_is_held(&rcu_lock_map) ||\n\t\t\t lock_is_held(&rcu_sched_lock_map),\n\t\t\t \"Illegal synchronize_srcu() in same-type SRCU (or in RCU) read-side critical section\");\n\n\tif (rcu_scheduler_active == RCU_SCHEDULER_INACTIVE)\n\t\treturn;\n\tmight_sleep();\n\tcheck_init_srcu_struct(ssp);\n\tinit_completion(&rcu.completion);\n\tinit_rcu_head_on_stack(&rcu.head);\n\t__call_srcu(ssp, &rcu.head, wakeme_after_rcu, do_norm);\n\twait_for_completion(&rcu.completion);\n\tdestroy_rcu_head_on_stack(&rcu.head);\n\n\t/*\n\t * Make sure that later code is ordered after the SRCU grace\n\t * period.  This pairs with the spin_lock_irq_rcu_node()\n\t * in srcu_invoke_callbacks().  Unlike Tree RCU, this is needed\n\t * because the current CPU might have been totally uninvolved with\n\t * (and thus unordered against) that grace period.\n\t */\n\tsmp_mb();\n}"
  },
  {
    "function_name": "call_srcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "903-907",
    "snippet": "void call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(ssp, rhp, func, true);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__call_srcu",
          "args": [
            "ssp",
            "rhp",
            "func",
            "true"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "__call_srcu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "873-884",
          "snippet": "static void __call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t\t\trcu_callback_t func, bool do_norm)\n{\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\t(void)srcu_gp_start_if_needed(ssp, rhp, do_norm);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void __call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t\t\trcu_callback_t func, bool do_norm)\n{\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\t(void)srcu_gp_start_if_needed(ssp, rhp, do_norm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(ssp, rhp, func, true);\n}"
  },
  {
    "function_name": "__call_srcu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "873-884",
    "snippet": "static void __call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t\t\trcu_callback_t func, bool do_norm)\n{\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\t(void)srcu_gp_start_if_needed(ssp, rhp, do_norm);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_gp_start_if_needed",
          "args": [
            "ssp",
            "rhp",
            "do_norm"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_start_if_needed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "808-843",
          "snippet": "static unsigned long srcu_gp_start_if_needed(struct srcu_struct *ssp,\n\t\t\t\t\t     struct rcu_head *rhp, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(ssp);\n\tidx = srcu_read_lock(ssp);\n\tsdp = raw_cpu_ptr(ssp->sda);\n\tspin_lock_irqsave_rcu_node(sdp, flags);\n\tif (rhp)\n\t\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\ts = rcu_seq_snap(&ssp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(ssp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(ssp, sdp->mynode, s);\n\tsrcu_read_unlock(ssp, idx);\n\treturn s;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_gp_start_if_needed(struct srcu_struct *ssp,\n\t\t\t\t\t     struct rcu_head *rhp, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(ssp);\n\tidx = srcu_read_lock(ssp);\n\tsdp = raw_cpu_ptr(ssp->sda);\n\tspin_lock_irqsave_rcu_node(sdp, flags);\n\tif (rhp)\n\t\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\ts = rcu_seq_snap(&ssp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(ssp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(ssp, sdp->mynode, s);\n\tsrcu_read_unlock(ssp, idx);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"call_srcu(): Leaked duplicate callback\\n\""
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "rhp->func",
            "srcu_leak_callback"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_rcu_head_queue",
          "args": [
            "rhp"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "debug_rcu_head_queue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "191-194",
          "snippet": "static inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline int debug_rcu_head_queue(struct rcu_head *head)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void __call_srcu(struct srcu_struct *ssp, struct rcu_head *rhp,\n\t\t\trcu_callback_t func, bool do_norm)\n{\n\tif (debug_rcu_head_queue(rhp)) {\n\t\t/* Probable double call_srcu(), so leak the callback. */\n\t\tWRITE_ONCE(rhp->func, srcu_leak_callback);\n\t\tWARN_ONCE(1, \"call_srcu(): Leaked duplicate callback\\n\");\n\t\treturn;\n\t}\n\trhp->func = func;\n\t(void)srcu_gp_start_if_needed(ssp, rhp, do_norm);\n}"
  },
  {
    "function_name": "srcu_gp_start_if_needed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "808-843",
    "snippet": "static unsigned long srcu_gp_start_if_needed(struct srcu_struct *ssp,\n\t\t\t\t\t     struct rcu_head *rhp, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(ssp);\n\tidx = srcu_read_lock(ssp);\n\tsdp = raw_cpu_ptr(ssp->sda);\n\tspin_lock_irqsave_rcu_node(sdp, flags);\n\tif (rhp)\n\t\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\ts = rcu_seq_snap(&ssp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(ssp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(ssp, sdp->mynode, s);\n\tsrcu_read_unlock(ssp, idx);\n\treturn s;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "ssp",
            "idx"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "416-420",
          "snippet": "void __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_funnel_exp_start",
          "args": [
            "ssp",
            "sdp->mynode",
            "s"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_funnel_exp_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "595-616",
          "snippet": "static void srcu_funnel_exp_start(struct srcu_struct *ssp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&ssp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, s))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, s);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_funnel_exp_start(struct srcu_struct *ssp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&ssp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, s))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, s);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_funnel_gp_start",
          "args": [
            "ssp",
            "sdp",
            "s",
            "do_norm"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_funnel_gp_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "628-688",
          "snippet": "static void srcu_funnel_gp_start(struct srcu_struct *ssp, struct srcu_data *sdp,\n\t\t\t\t unsigned long s, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx = rcu_seq_ctr(s) % ARRAY_SIZE(sdp->mynode->srcu_have_cbs);\n\tstruct srcu_node *snp = sdp->mynode;\n\tunsigned long snp_seq;\n\n\t/* Each pass through the loop does one level of the srcu_node tree. */\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&ssp->srcu_gp_seq, s) && snp != sdp->mynode)\n\t\t\treturn; /* GP already done and CBs recorded. */\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_have_cbs[idx], s)) {\n\t\t\tsnp_seq = snp->srcu_have_cbs[idx];\n\t\t\tif (snp == sdp->mynode && snp_seq == s)\n\t\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\tif (snp == sdp->mynode && snp_seq != s) {\n\t\t\t\tsrcu_schedule_cbs_sdp(sdp, do_norm\n\t\t\t\t\t\t\t   ? SRCU_INTERVAL\n\t\t\t\t\t\t\t   : 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!do_norm)\n\t\t\t\tsrcu_funnel_exp_start(ssp, snp, s);\n\t\t\treturn;\n\t\t}\n\t\tsnp->srcu_have_cbs[idx] = s;\n\t\tif (snp == sdp->mynode)\n\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\tif (!do_norm && ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, s))\n\t\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\n\t/* Top of tree, must ensure the grace period will be started. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed, s)) {\n\t\t/*\n\t\t * Record need for grace period s.  Pair with load\n\t\t * acquire setting up for initialization.\n\t\t */\n\t\tsmp_store_release(&ssp->srcu_gp_seq_needed, s); /*^^^*/\n\t}\n\tif (!do_norm && ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, s))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, s);\n\n\t/* If grace period not already done and none in progress, start it. */\n\tif (!rcu_seq_done(&ssp->srcu_gp_seq, s) &&\n\t    rcu_seq_state(ssp->srcu_gp_seq) == SRCU_STATE_IDLE) {\n\t\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\t\tsrcu_gp_start(ssp);\n\t\tif (likely(srcu_init_done))\n\t\t\tqueue_delayed_work(rcu_gp_wq, &ssp->work,\n\t\t\t\t\t   srcu_get_delay(ssp));\n\t\telse if (list_empty(&ssp->work.work.entry))\n\t\t\tlist_add(&ssp->work.work.entry, &srcu_boot_list);\n\t}\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [
            "static LIST_HEAD(srcu_boot_list);",
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic LIST_HEAD(srcu_boot_list);\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_funnel_gp_start(struct srcu_struct *ssp, struct srcu_data *sdp,\n\t\t\t\t unsigned long s, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx = rcu_seq_ctr(s) % ARRAY_SIZE(sdp->mynode->srcu_have_cbs);\n\tstruct srcu_node *snp = sdp->mynode;\n\tunsigned long snp_seq;\n\n\t/* Each pass through the loop does one level of the srcu_node tree. */\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&ssp->srcu_gp_seq, s) && snp != sdp->mynode)\n\t\t\treturn; /* GP already done and CBs recorded. */\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_have_cbs[idx], s)) {\n\t\t\tsnp_seq = snp->srcu_have_cbs[idx];\n\t\t\tif (snp == sdp->mynode && snp_seq == s)\n\t\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\tif (snp == sdp->mynode && snp_seq != s) {\n\t\t\t\tsrcu_schedule_cbs_sdp(sdp, do_norm\n\t\t\t\t\t\t\t   ? SRCU_INTERVAL\n\t\t\t\t\t\t\t   : 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!do_norm)\n\t\t\t\tsrcu_funnel_exp_start(ssp, snp, s);\n\t\t\treturn;\n\t\t}\n\t\tsnp->srcu_have_cbs[idx] = s;\n\t\tif (snp == sdp->mynode)\n\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\tif (!do_norm && ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, s))\n\t\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\n\t/* Top of tree, must ensure the grace period will be started. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed, s)) {\n\t\t/*\n\t\t * Record need for grace period s.  Pair with load\n\t\t * acquire setting up for initialization.\n\t\t */\n\t\tsmp_store_release(&ssp->srcu_gp_seq_needed, s); /*^^^*/\n\t}\n\tif (!do_norm && ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, s))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, s);\n\n\t/* If grace period not already done and none in progress, start it. */\n\tif (!rcu_seq_done(&ssp->srcu_gp_seq, s) &&\n\t    rcu_seq_state(ssp->srcu_gp_seq) == SRCU_STATE_IDLE) {\n\t\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\t\tsrcu_gp_start(ssp);\n\t\tif (likely(srcu_init_done))\n\t\t\tqueue_delayed_work(rcu_gp_wq, &ssp->work,\n\t\t\t\t\t   srcu_get_delay(ssp));\n\t\telse if (list_empty(&ssp->work.work.entry))\n\t\t\tlist_add(&ssp->work.work.entry, &srcu_boot_list);\n\t}\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "sdp",
            "flags"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "sdp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "sdp->srcu_gp_seq_needed",
            "s"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_accelerate",
          "args": [
            "&sdp->srcu_cblist",
            "s"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_accelerate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "537-598",
          "snippet": "bool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t *\n\t * Note that segment \"i\" (and any lower-numbered segments\n\t * containing older callbacks) will be unaffected, and their\n\t * grace-period numbers remain unchanged.  For example, if i ==\n\t * WAIT_TAIL, then neither WAIT_TAIL nor DONE_TAIL will be touched.\n\t * Instead, the CBs in NEXT_TAIL will be merged with those in\n\t * NEXT_READY_TAIL and the grace-period number of NEXT_READY_TAIL\n\t * would be updated.  NEXT_TAIL would then be empty.\n\t */\n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/* Accounting: everything below i is about to get merged into i. */\n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t *\n\t * Note that segment \"i\" (and any lower-numbered segments\n\t * containing older callbacks) will be unaffected, and their\n\t * grace-period numbers remain unchanged.  For example, if i ==\n\t * WAIT_TAIL, then neither WAIT_TAIL nor DONE_TAIL will be touched.\n\t * Instead, the CBs in NEXT_TAIL will be merged with those in\n\t * NEXT_READY_TAIL and the grace-period number of NEXT_READY_TAIL\n\t * would be updated.  NEXT_TAIL would then be empty.\n\t */\n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/* Accounting: everything below i is about to get merged into i. */\n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "87-94",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_advance",
          "args": [
            "&sdp->srcu_cblist",
            "rcu_seq_current(&ssp->srcu_gp_seq)"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_advance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "480-520",
          "snippet": "void rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\tWRITE_ONCE(rsclp->tails[RCU_DONE_TAIL], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, RCU_DONE_TAIL);\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[RCU_DONE_TAIL]);\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, j);\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\tWRITE_ONCE(rsclp->tails[RCU_DONE_TAIL], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, RCU_DONE_TAIL);\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[RCU_DONE_TAIL]);\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, j);\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_enqueue",
          "args": [
            "&sdp->srcu_cblist",
            "rhp"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_enqueue",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "340-348",
          "snippet": "void rcu_segcblist_enqueue(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp)\n{\n\trcu_segcblist_inc_len(rsclp);\n\trcu_segcblist_inc_seglen(rsclp, RCU_NEXT_TAIL);\n\trhp->next = NULL;\n\tWRITE_ONCE(*rsclp->tails[RCU_NEXT_TAIL], rhp);\n\tWRITE_ONCE(rsclp->tails[RCU_NEXT_TAIL], &rhp->next);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_enqueue(struct rcu_segcblist *rsclp,\n\t\t\t   struct rcu_head *rhp)\n{\n\trcu_segcblist_inc_len(rsclp);\n\trcu_segcblist_inc_seglen(rsclp, RCU_NEXT_TAIL);\n\trhp->next = NULL;\n\tWRITE_ONCE(*rsclp->tails[RCU_NEXT_TAIL], rhp);\n\tWRITE_ONCE(rsclp->tails[RCU_NEXT_TAIL], &rhp->next);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "sdp",
            "flags"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "ssp->sda"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "ssp"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "__srcu_read_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "400-408",
          "snippet": "int __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_init_srcu_struct",
          "args": [
            "ssp"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "224-238",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_gp_start_if_needed(struct srcu_struct *ssp,\n\t\t\t\t\t     struct rcu_head *rhp, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx;\n\tbool needexp = false;\n\tbool needgp = false;\n\tunsigned long s;\n\tstruct srcu_data *sdp;\n\n\tcheck_init_srcu_struct(ssp);\n\tidx = srcu_read_lock(ssp);\n\tsdp = raw_cpu_ptr(ssp->sda);\n\tspin_lock_irqsave_rcu_node(sdp, flags);\n\tif (rhp)\n\t\trcu_segcblist_enqueue(&sdp->srcu_cblist, rhp);\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\ts = rcu_seq_snap(&ssp->srcu_gp_seq);\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist, s);\n\tif (ULONG_CMP_LT(sdp->srcu_gp_seq_needed, s)) {\n\t\tsdp->srcu_gp_seq_needed = s;\n\t\tneedgp = true;\n\t}\n\tif (!do_norm && ULONG_CMP_LT(sdp->srcu_gp_seq_needed_exp, s)) {\n\t\tsdp->srcu_gp_seq_needed_exp = s;\n\t\tneedexp = true;\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\tif (needgp)\n\t\tsrcu_funnel_gp_start(ssp, sdp, s, do_norm);\n\telse if (needexp)\n\t\tsrcu_funnel_exp_start(ssp, sdp->mynode, s);\n\tsrcu_read_unlock(ssp, idx);\n\treturn s;\n}"
  },
  {
    "function_name": "srcu_leak_callback",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "801-803",
    "snippet": "static void srcu_leak_callback(struct rcu_head *rhp)\n{\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_leak_callback(struct rcu_head *rhp)\n{\n}"
  },
  {
    "function_name": "srcu_might_be_idle",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "756-796",
    "snippet": "static bool srcu_might_be_idle(struct srcu_struct *ssp)\n{\n\tunsigned long curseq;\n\tunsigned long flags;\n\tstruct srcu_data *sdp;\n\tunsigned long t;\n\tunsigned long tlast;\n\n\tcheck_init_srcu_struct(ssp);\n\t/* If the local srcu_data structure has callbacks, not idle.  */\n\tsdp = raw_cpu_ptr(ssp->sda);\n\tspin_lock_irqsave_rcu_node(sdp, flags);\n\tif (rcu_segcblist_pend_cbs(&sdp->srcu_cblist)) {\n\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\treturn false; /* Callbacks already present, so not idle. */\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\n\t/*\n\t * No local callbacks, so probabilistically probe global state.\n\t * Exact information would require acquiring locks, which would\n\t * kill scalability, hence the probabilistic nature of the probe.\n\t */\n\n\t/* First, see if enough time has passed since the last GP. */\n\tt = ktime_get_mono_fast_ns();\n\ttlast = READ_ONCE(ssp->srcu_last_gp_end);\n\tif (exp_holdoff == 0 ||\n\t    time_in_range_open(t, tlast, tlast + exp_holdoff))\n\t\treturn false; /* Too soon after last GP. */\n\n\t/* Next, check for probable idleness. */\n\tcurseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tsmp_mb(); /* Order ->srcu_gp_seq with ->srcu_gp_seq_needed. */\n\tif (ULONG_CMP_LT(curseq, READ_ONCE(ssp->srcu_gp_seq_needed)))\n\t\treturn false; /* Grace period in progress, so not idle. */\n\tsmp_mb(); /* Order ->srcu_gp_seq with prior access. */\n\tif (curseq != rcu_seq_current(&ssp->srcu_gp_seq))\n\t\treturn false; /* GP # changed, so not idle. */\n\treturn true; /* With reasonable probability, idle! */\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;",
      "static void srcu_delay_timer(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "curseq",
            "READ_ONCE(ssp->srcu_gp_seq_needed)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_gp_seq_needed"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_in_range_open",
          "args": [
            "t",
            "tlast",
            "tlast + exp_holdoff"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_last_gp_end"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "485-488",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "sdp",
            "flags"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "sdp",
            "flags"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_pend_cbs",
          "args": [
            "&sdp->srcu_cblist"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_pend_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "288-292",
          "snippet": "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp)\n{\n\treturn rcu_segcblist_is_enabled(rsclp) &&\n\t       !rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "sdp",
            "flags"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "ssp->sda"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_init_srcu_struct",
          "args": [
            "ssp"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "check_init_srcu_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "224-238",
          "snippet": "static void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic ulong exp_holdoff = DEFAULT_SRCU_EXP_HOLDOFF;\nstatic void srcu_delay_timer(struct timer_list *t);\n\nstatic bool srcu_might_be_idle(struct srcu_struct *ssp)\n{\n\tunsigned long curseq;\n\tunsigned long flags;\n\tstruct srcu_data *sdp;\n\tunsigned long t;\n\tunsigned long tlast;\n\n\tcheck_init_srcu_struct(ssp);\n\t/* If the local srcu_data structure has callbacks, not idle.  */\n\tsdp = raw_cpu_ptr(ssp->sda);\n\tspin_lock_irqsave_rcu_node(sdp, flags);\n\tif (rcu_segcblist_pend_cbs(&sdp->srcu_cblist)) {\n\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\treturn false; /* Callbacks already present, so not idle. */\n\t}\n\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\n\t/*\n\t * No local callbacks, so probabilistically probe global state.\n\t * Exact information would require acquiring locks, which would\n\t * kill scalability, hence the probabilistic nature of the probe.\n\t */\n\n\t/* First, see if enough time has passed since the last GP. */\n\tt = ktime_get_mono_fast_ns();\n\ttlast = READ_ONCE(ssp->srcu_last_gp_end);\n\tif (exp_holdoff == 0 ||\n\t    time_in_range_open(t, tlast, tlast + exp_holdoff))\n\t\treturn false; /* Too soon after last GP. */\n\n\t/* Next, check for probable idleness. */\n\tcurseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tsmp_mb(); /* Order ->srcu_gp_seq with ->srcu_gp_seq_needed. */\n\tif (ULONG_CMP_LT(curseq, READ_ONCE(ssp->srcu_gp_seq_needed)))\n\t\treturn false; /* Grace period in progress, so not idle. */\n\tsmp_mb(); /* Order ->srcu_gp_seq with prior access. */\n\tif (curseq != rcu_seq_current(&ssp->srcu_gp_seq))\n\t\treturn false; /* GP # changed, so not idle. */\n\treturn true; /* With reasonable probability, idle! */\n}"
  },
  {
    "function_name": "srcu_flip",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "711-733",
    "snippet": "static void srcu_flip(struct srcu_struct *ssp)\n{\n\t/*\n\t * Ensure that if this updater saw a given reader's increment\n\t * from __srcu_read_lock(), that reader was using an old value\n\t * of ->srcu_idx.  Also ensure that if a given reader sees the\n\t * new value of ->srcu_idx, this updater's earlier scans cannot\n\t * have seen that reader's increments (which is OK, because this\n\t * grace period need not wait on that reader).\n\t */\n\tsmp_mb(); /* E */  /* Pairs with B and C. */\n\n\tWRITE_ONCE(ssp->srcu_idx, ssp->srcu_idx + 1);\n\n\t/*\n\t * Ensure that if the updater misses an __srcu_read_unlock()\n\t * increment, that task's next __srcu_read_lock() will see the\n\t * above counter update.  Note that both this memory barrier\n\t * and the one in srcu_readers_active_idx_check() provide the\n\t * guarantee for __srcu_read_lock().\n\t */\n\tsmp_mb(); /* D */  /* Pairs with C. */\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ssp->srcu_idx",
            "ssp->srcu_idx + 1"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_flip(struct srcu_struct *ssp)\n{\n\t/*\n\t * Ensure that if this updater saw a given reader's increment\n\t * from __srcu_read_lock(), that reader was using an old value\n\t * of ->srcu_idx.  Also ensure that if a given reader sees the\n\t * new value of ->srcu_idx, this updater's earlier scans cannot\n\t * have seen that reader's increments (which is OK, because this\n\t * grace period need not wait on that reader).\n\t */\n\tsmp_mb(); /* E */  /* Pairs with B and C. */\n\n\tWRITE_ONCE(ssp->srcu_idx, ssp->srcu_idx + 1);\n\n\t/*\n\t * Ensure that if the updater misses an __srcu_read_unlock()\n\t * increment, that task's next __srcu_read_lock() will see the\n\t * above counter update.  Note that both this memory barrier\n\t * and the one in srcu_readers_active_idx_check() provide the\n\t * guarantee for __srcu_read_lock().\n\t */\n\tsmp_mb(); /* D */  /* Pairs with C. */\n}"
  },
  {
    "function_name": "try_check_zero",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "695-704",
    "snippet": "static bool try_check_zero(struct srcu_struct *ssp, int idx, int trycount)\n{\n\tfor (;;) {\n\t\tif (srcu_readers_active_idx_check(ssp, idx))\n\t\t\treturn true;\n\t\tif (--trycount + !srcu_get_delay(ssp) <= 0)\n\t\t\treturn false;\n\t\tudelay(SRCU_RETRY_CHECK_DELAY);\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define SRCU_RETRY_CHECK_DELAY\t\t5"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "SRCU_RETRY_CHECK_DELAY"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_get_delay",
          "args": [
            "ssp"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_get_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "352-358",
          "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_readers_active_idx_check",
          "args": [
            "ssp",
            "idx"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_readers_active_idx_check",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "278-319",
          "snippet": "static bool srcu_readers_active_idx_check(struct srcu_struct *ssp, int idx)\n{\n\tunsigned long unlocks;\n\n\tunlocks = srcu_readers_unlock_idx(ssp, idx);\n\n\t/*\n\t * Make sure that a lock is always counted if the corresponding\n\t * unlock is counted. Needs to be a smp_mb() as the read side may\n\t * contain a read from a variable that is written to before the\n\t * synchronize_srcu() in the write side. In this case smp_mb()s\n\t * A and B act like the store buffering pattern.\n\t *\n\t * This smp_mb() also pairs with smp_mb() C to prevent accesses\n\t * after the synchronize_srcu() from being executed before the\n\t * grace period ends.\n\t */\n\tsmp_mb(); /* A */\n\n\t/*\n\t * If the locks are the same as the unlocks, then there must have\n\t * been no readers on this index at some time in between. This does\n\t * not mean that there are no more readers, as one could have read\n\t * the current index but not have incremented the lock counter yet.\n\t *\n\t * So suppose that the updater is preempted here for so long\n\t * that more than ULONG_MAX non-nested readers come and go in\n\t * the meantime.  It turns out that this cannot result in overflow\n\t * because if a reader modifies its unlock count after we read it\n\t * above, then that reader's next load of ->srcu_idx is guaranteed\n\t * to get the new value, which will cause it to operate on the\n\t * other bank of counters, where it cannot contribute to the\n\t * overflow of these counters.  This means that there is a maximum\n\t * of 2*NR_CPUS increments, which cannot overflow given current\n\t * systems, especially not on 64-bit systems.\n\t *\n\t * OK, how about nesting?  This does impose a limit on nesting\n\t * of floor(ULONG_MAX/NR_CPUS/2), which should be sufficient,\n\t * especially on 64-bit systems.\n\t */\n\treturn srcu_readers_lock_idx(ssp, idx) == unlocks;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic bool srcu_readers_active_idx_check(struct srcu_struct *ssp, int idx)\n{\n\tunsigned long unlocks;\n\n\tunlocks = srcu_readers_unlock_idx(ssp, idx);\n\n\t/*\n\t * Make sure that a lock is always counted if the corresponding\n\t * unlock is counted. Needs to be a smp_mb() as the read side may\n\t * contain a read from a variable that is written to before the\n\t * synchronize_srcu() in the write side. In this case smp_mb()s\n\t * A and B act like the store buffering pattern.\n\t *\n\t * This smp_mb() also pairs with smp_mb() C to prevent accesses\n\t * after the synchronize_srcu() from being executed before the\n\t * grace period ends.\n\t */\n\tsmp_mb(); /* A */\n\n\t/*\n\t * If the locks are the same as the unlocks, then there must have\n\t * been no readers on this index at some time in between. This does\n\t * not mean that there are no more readers, as one could have read\n\t * the current index but not have incremented the lock counter yet.\n\t *\n\t * So suppose that the updater is preempted here for so long\n\t * that more than ULONG_MAX non-nested readers come and go in\n\t * the meantime.  It turns out that this cannot result in overflow\n\t * because if a reader modifies its unlock count after we read it\n\t * above, then that reader's next load of ->srcu_idx is guaranteed\n\t * to get the new value, which will cause it to operate on the\n\t * other bank of counters, where it cannot contribute to the\n\t * overflow of these counters.  This means that there is a maximum\n\t * of 2*NR_CPUS increments, which cannot overflow given current\n\t * systems, especially not on 64-bit systems.\n\t *\n\t * OK, how about nesting?  This does impose a limit on nesting\n\t * of floor(ULONG_MAX/NR_CPUS/2), which should be sufficient,\n\t * especially on 64-bit systems.\n\t */\n\treturn srcu_readers_lock_idx(ssp, idx) == unlocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_RETRY_CHECK_DELAY\t\t5\n\nstatic bool try_check_zero(struct srcu_struct *ssp, int idx, int trycount)\n{\n\tfor (;;) {\n\t\tif (srcu_readers_active_idx_check(ssp, idx))\n\t\t\treturn true;\n\t\tif (--trycount + !srcu_get_delay(ssp) <= 0)\n\t\t\treturn false;\n\t\tudelay(SRCU_RETRY_CHECK_DELAY);\n\t}\n}"
  },
  {
    "function_name": "srcu_funnel_gp_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "628-688",
    "snippet": "static void srcu_funnel_gp_start(struct srcu_struct *ssp, struct srcu_data *sdp,\n\t\t\t\t unsigned long s, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx = rcu_seq_ctr(s) % ARRAY_SIZE(sdp->mynode->srcu_have_cbs);\n\tstruct srcu_node *snp = sdp->mynode;\n\tunsigned long snp_seq;\n\n\t/* Each pass through the loop does one level of the srcu_node tree. */\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&ssp->srcu_gp_seq, s) && snp != sdp->mynode)\n\t\t\treturn; /* GP already done and CBs recorded. */\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_have_cbs[idx], s)) {\n\t\t\tsnp_seq = snp->srcu_have_cbs[idx];\n\t\t\tif (snp == sdp->mynode && snp_seq == s)\n\t\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\tif (snp == sdp->mynode && snp_seq != s) {\n\t\t\t\tsrcu_schedule_cbs_sdp(sdp, do_norm\n\t\t\t\t\t\t\t   ? SRCU_INTERVAL\n\t\t\t\t\t\t\t   : 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!do_norm)\n\t\t\t\tsrcu_funnel_exp_start(ssp, snp, s);\n\t\t\treturn;\n\t\t}\n\t\tsnp->srcu_have_cbs[idx] = s;\n\t\tif (snp == sdp->mynode)\n\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\tif (!do_norm && ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, s))\n\t\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\n\t/* Top of tree, must ensure the grace period will be started. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed, s)) {\n\t\t/*\n\t\t * Record need for grace period s.  Pair with load\n\t\t * acquire setting up for initialization.\n\t\t */\n\t\tsmp_store_release(&ssp->srcu_gp_seq_needed, s); /*^^^*/\n\t}\n\tif (!do_norm && ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, s))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, s);\n\n\t/* If grace period not already done and none in progress, start it. */\n\tif (!rcu_seq_done(&ssp->srcu_gp_seq, s) &&\n\t    rcu_seq_state(ssp->srcu_gp_seq) == SRCU_STATE_IDLE) {\n\t\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\t\tsrcu_gp_start(ssp);\n\t\tif (likely(srcu_init_done))\n\t\t\tqueue_delayed_work(rcu_gp_wq, &ssp->work,\n\t\t\t\t\t   srcu_get_delay(ssp));\n\t\telse if (list_empty(&ssp->work.work.entry))\n\t\t\tlist_add(&ssp->work.work.entry, &srcu_boot_list);\n\t}\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define SRCU_INTERVAL\t\t1"
    ],
    "globals_used": [
      "static LIST_HEAD(srcu_boot_list);",
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "ssp",
            "flags"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ssp->work.work.entry",
            "&srcu_boot_list"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_add_len",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "210-221",
          "snippet": "void rcu_segcblist_add_len(struct rcu_segcblist *rsclp, long v)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\tsmp_mb__before_atomic(); // Read header comment above.\n\tatomic_long_add(v, &rsclp->len);\n\tsmp_mb__after_atomic();  // Read header comment above.\n#else\n\tsmp_mb(); // Read header comment above.\n\tWRITE_ONCE(rsclp->len, rsclp->len + v);\n\tsmp_mb(); // Read header comment above.\n#endif\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_add_len(struct rcu_segcblist *rsclp, long v)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\tsmp_mb__before_atomic(); // Read header comment above.\n\tatomic_long_add(v, &rsclp->len);\n\tsmp_mb__after_atomic();  // Read header comment above.\n#else\n\tsmp_mb(); // Read header comment above.\n\tWRITE_ONCE(rsclp->len, rsclp->len + v);\n\tsmp_mb(); // Read header comment above.\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ssp->work.work.entry"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "41-44",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !READ_ONCE(rsclp->head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "rcu_gp_wq",
            "&ssp->work",
            "srcu_get_delay(ssp)"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_delayed_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "1092-1109",
          "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\traw_spin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\traw_spin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_get_delay",
          "args": [
            "ssp"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_get_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "352-358",
          "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "srcu_init_done"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_gp_start",
          "args": [
            "ssp"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "435-452",
          "snippet": "static void srcu_gp_start(struct srcu_struct *ssp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(ssp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(ssp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\tspin_lock_rcu_node(sdp);  /* Interrupts already disabled. */\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tspin_unlock_rcu_node(sdp);  /* Interrupts remain disabled. */\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&ssp->srcu_gp_seq);\n\tstate = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_gp_start(struct srcu_struct *ssp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(ssp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(ssp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\tspin_lock_rcu_node(sdp);  /* Interrupts already disabled. */\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tspin_unlock_rcu_node(sdp);  /* Interrupts remain disabled. */\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&ssp->srcu_gp_seq);\n\tstate = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "ssp->srcu_gp_seq",
            "ssp->srcu_gp_seq_needed"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "ssp->srcu_gp_seq"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "39-42",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&ssp->srcu_gp_seq",
            "s"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ssp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "ssp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&ssp->srcu_gp_seq_needed",
            "s"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "ssp->srcu_gp_seq_needed",
            "s"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "ssp",
            "flags"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "snp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "snp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_funnel_exp_start",
          "args": [
            "ssp",
            "snp",
            "s"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_funnel_exp_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "595-616",
          "snippet": "static void srcu_funnel_exp_start(struct srcu_struct *ssp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&ssp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, s))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, s);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_funnel_exp_start(struct srcu_struct *ssp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&ssp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, s))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, s);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_schedule_cbs_sdp",
          "args": [
            "sdp",
            "do_norm\n\t\t\t\t\t\t\t   ? SRCU_INTERVAL\n\t\t\t\t\t\t\t   : 0"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_schedule_cbs_sdp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "477-480",
          "snippet": "static void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp, delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\n\nstatic void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp, delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "snp->srcu_have_cbs[idx]",
            "s"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sdp->mynode->srcu_have_cbs"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "s"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "30-33",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic LIST_HEAD(srcu_boot_list);\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_funnel_gp_start(struct srcu_struct *ssp, struct srcu_data *sdp,\n\t\t\t\t unsigned long s, bool do_norm)\n{\n\tunsigned long flags;\n\tint idx = rcu_seq_ctr(s) % ARRAY_SIZE(sdp->mynode->srcu_have_cbs);\n\tstruct srcu_node *snp = sdp->mynode;\n\tunsigned long snp_seq;\n\n\t/* Each pass through the loop does one level of the srcu_node tree. */\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&ssp->srcu_gp_seq, s) && snp != sdp->mynode)\n\t\t\treturn; /* GP already done and CBs recorded. */\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_have_cbs[idx], s)) {\n\t\t\tsnp_seq = snp->srcu_have_cbs[idx];\n\t\t\tif (snp == sdp->mynode && snp_seq == s)\n\t\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\tif (snp == sdp->mynode && snp_seq != s) {\n\t\t\t\tsrcu_schedule_cbs_sdp(sdp, do_norm\n\t\t\t\t\t\t\t   ? SRCU_INTERVAL\n\t\t\t\t\t\t\t   : 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!do_norm)\n\t\t\t\tsrcu_funnel_exp_start(ssp, snp, s);\n\t\t\treturn;\n\t\t}\n\t\tsnp->srcu_have_cbs[idx] = s;\n\t\tif (snp == sdp->mynode)\n\t\t\tsnp->srcu_data_have_cbs[idx] |= sdp->grpmask;\n\t\tif (!do_norm && ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, s))\n\t\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\n\t/* Top of tree, must ensure the grace period will be started. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed, s)) {\n\t\t/*\n\t\t * Record need for grace period s.  Pair with load\n\t\t * acquire setting up for initialization.\n\t\t */\n\t\tsmp_store_release(&ssp->srcu_gp_seq_needed, s); /*^^^*/\n\t}\n\tif (!do_norm && ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, s))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, s);\n\n\t/* If grace period not already done and none in progress, start it. */\n\tif (!rcu_seq_done(&ssp->srcu_gp_seq, s) &&\n\t    rcu_seq_state(ssp->srcu_gp_seq) == SRCU_STATE_IDLE) {\n\t\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\t\tsrcu_gp_start(ssp);\n\t\tif (likely(srcu_init_done))\n\t\t\tqueue_delayed_work(rcu_gp_wq, &ssp->work,\n\t\t\t\t\t   srcu_get_delay(ssp));\n\t\telse if (list_empty(&ssp->work.work.entry))\n\t\t\tlist_add(&ssp->work.work.entry, &srcu_boot_list);\n\t}\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
  },
  {
    "function_name": "srcu_funnel_exp_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "595-616",
    "snippet": "static void srcu_funnel_exp_start(struct srcu_struct *ssp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&ssp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, s))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, s);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "ssp",
            "flags"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ssp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "ssp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "ssp",
            "flags"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "snp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "snp->srcu_gp_seq_needed_exp",
            "s"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "snp",
            "flags"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "READ_ONCE(snp->srcu_gp_seq_needed_exp)",
            "s"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "snp->srcu_gp_seq_needed_exp"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_done",
          "args": [
            "&ssp->srcu_gp_seq",
            "s"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_done",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "115-118",
          "snippet": "static inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline bool rcu_seq_done(unsigned long *sp, unsigned long s)\n{\n\treturn ULONG_CMP_GE(READ_ONCE(*sp), s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_funnel_exp_start(struct srcu_struct *ssp, struct srcu_node *snp,\n\t\t\t\t  unsigned long s)\n{\n\tunsigned long flags;\n\n\tfor (; snp != NULL; snp = snp->srcu_parent) {\n\t\tif (rcu_seq_done(&ssp->srcu_gp_seq, s) ||\n\t\t    ULONG_CMP_GE(READ_ONCE(snp->srcu_gp_seq_needed_exp), s))\n\t\t\treturn;\n\t\tspin_lock_irqsave_rcu_node(snp, flags);\n\t\tif (ULONG_CMP_GE(snp->srcu_gp_seq_needed_exp, s)) {\n\t\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t\t\treturn;\n\t\t}\n\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, s);\n\t\tspin_unlock_irqrestore_rcu_node(snp, flags);\n\t}\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, s))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, s);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
  },
  {
    "function_name": "srcu_gp_end",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "509-586",
    "snippet": "static void srcu_gp_end(struct srcu_struct *ssp)\n{\n\tunsigned long cbdelay;\n\tbool cbs;\n\tbool last_lvl;\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpseq;\n\tint idx;\n\tunsigned long mask;\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\n\t/* Prevent more than one additional grace period. */\n\tmutex_lock(&ssp->srcu_cb_mutex);\n\n\t/* End the current grace period. */\n\tspin_lock_irq_rcu_node(ssp);\n\tidx = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(idx != SRCU_STATE_SCAN2);\n\tcbdelay = srcu_get_delay(ssp);\n\tWRITE_ONCE(ssp->srcu_last_gp_end, ktime_get_mono_fast_ns());\n\trcu_seq_end(&ssp->srcu_gp_seq);\n\tgpseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, gpseq))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, gpseq);\n\tspin_unlock_irq_rcu_node(ssp);\n\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t/* A new grace period can start at this point.  But only one. */\n\n\t/* Initiate callback invocation as needed. */\n\tidx = rcu_seq_ctr(gpseq) % ARRAY_SIZE(snp->srcu_have_cbs);\n\tsrcu_for_each_node_breadth_first(ssp, snp) {\n\t\tspin_lock_irq_rcu_node(snp);\n\t\tcbs = false;\n\t\tlast_lvl = snp >= ssp->level[rcu_num_lvls - 1];\n\t\tif (last_lvl)\n\t\t\tcbs = snp->srcu_have_cbs[idx] == gpseq;\n\t\tsnp->srcu_have_cbs[idx] = gpseq;\n\t\trcu_seq_set_state(&snp->srcu_have_cbs[idx], 1);\n\t\tif (ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, gpseq))\n\t\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, gpseq);\n\t\tmask = snp->srcu_data_have_cbs[idx];\n\t\tsnp->srcu_data_have_cbs[idx] = 0;\n\t\tspin_unlock_irq_rcu_node(snp);\n\t\tif (cbs)\n\t\t\tsrcu_schedule_cbs_snp(ssp, snp, mask, cbdelay);\n\n\t\t/* Occasionally prevent srcu_data counter wrap. */\n\t\tif (!(gpseq & counter_wrap_check) && last_lvl)\n\t\t\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\t\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\t\t\tspin_lock_irqsave_rcu_node(sdp, flags);\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed = gpseq;\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed_exp + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed_exp = gpseq;\n\t\t\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\t\t}\n\t}\n\n\t/* Callback initiation done, allow grace periods after next. */\n\tmutex_unlock(&ssp->srcu_cb_mutex);\n\n\t/* Start a new grace period if needed. */\n\tspin_lock_irq_rcu_node(ssp);\n\tgpseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tif (!rcu_seq_state(gpseq) &&\n\t    ULONG_CMP_LT(gpseq, ssp->srcu_gp_seq_needed)) {\n\t\tsrcu_gp_start(ssp);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t\tsrcu_reschedule(ssp, 0);\n\t} else {\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static ulong counter_wrap_check = (ULONG_MAX >> 2);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_reschedule",
          "args": [
            "ssp",
            "0"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_reschedule",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "1296-1314",
          "snippet": "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(ssp);\n\tif (ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(ssp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(ssp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(ssp);\n\t}\n\tspin_unlock_irq_rcu_node(ssp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &ssp->work, delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay)\n{\n\tbool pushgp = true;\n\n\tspin_lock_irq_rcu_node(ssp);\n\tif (ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)) {\n\t\tif (!WARN_ON_ONCE(rcu_seq_state(ssp->srcu_gp_seq))) {\n\t\t\t/* All requests fulfilled, time to go idle. */\n\t\t\tpushgp = false;\n\t\t}\n\t} else if (!rcu_seq_state(ssp->srcu_gp_seq)) {\n\t\t/* Outstanding request and no GP.  Start one. */\n\t\tsrcu_gp_start(ssp);\n\t}\n\tspin_unlock_irq_rcu_node(ssp);\n\n\tif (pushgp)\n\t\tqueue_delayed_work(rcu_gp_wq, &ssp->work, delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_gp_start",
          "args": [
            "ssp"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_gp_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "435-452",
          "snippet": "static void srcu_gp_start(struct srcu_struct *ssp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(ssp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(ssp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\tspin_lock_rcu_node(sdp);  /* Interrupts already disabled. */\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tspin_unlock_rcu_node(sdp);  /* Interrupts remain disabled. */\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&ssp->srcu_gp_seq);\n\tstate = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_gp_start(struct srcu_struct *ssp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(ssp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(ssp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\tspin_lock_rcu_node(sdp);  /* Interrupts already disabled. */\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tspin_unlock_rcu_node(sdp);  /* Interrupts remain disabled. */\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&ssp->srcu_gp_seq);\n\tstate = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "gpseq",
            "ssp->srcu_gp_seq_needed"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "gpseq"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "39-42",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ssp->srcu_cb_mutex"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "__rt_mutex_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "1350-1356",
          "snippet": "static __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "sdp",
            "flags"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "gpseq",
            "sdp->srcu_gp_seq_needed_exp + 100"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "gpseq",
            "sdp->srcu_gp_seq_needed + 100"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "sdp",
            "flags"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ssp->sda",
            "cpu"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_schedule_cbs_snp",
          "args": [
            "ssp",
            "snp",
            "mask",
            "cbdelay"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_schedule_cbs_snp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "488-498",
          "snippet": "static void srcu_schedule_cbs_snp(struct srcu_struct *ssp, struct srcu_node *snp,\n\t\t\t\t  unsigned long mask, unsigned long delay)\n{\n\tint cpu;\n\n\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\tif (!(mask & (1 << (cpu - snp->grplo))))\n\t\t\tcontinue;\n\t\tsrcu_schedule_cbs_sdp(per_cpu_ptr(ssp->sda, cpu), delay);\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\n\nstatic void srcu_schedule_cbs_snp(struct srcu_struct *ssp, struct srcu_node *snp,\n\t\t\t\t  unsigned long mask, unsigned long delay)\n{\n\tint cpu;\n\n\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\tif (!(mask & (1 << (cpu - snp->grplo))))\n\t\t\tcontinue;\n\t\tsrcu_schedule_cbs_sdp(per_cpu_ptr(ssp->sda, cpu), delay);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "snp"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "snp->srcu_gp_seq_needed_exp",
            "gpseq"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "snp->srcu_gp_seq_needed_exp",
            "gpseq"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_set_state",
          "args": [
            "&snp->srcu_have_cbs[idx]",
            "1"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_set_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "48-52",
          "snippet": "static inline void rcu_seq_set_state(unsigned long *sp, int newstate)\n{\n\tWARN_ON_ONCE(newstate & ~RCU_SEQ_STATE_MASK);\n\tWRITE_ONCE(*sp, (*sp & ~RCU_SEQ_STATE_MASK) + newstate);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline void rcu_seq_set_state(unsigned long *sp, int newstate)\n{\n\tWARN_ON_ONCE(newstate & ~RCU_SEQ_STATE_MASK);\n\tWRITE_ONCE(*sp, (*sp & ~RCU_SEQ_STATE_MASK) + newstate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "snp"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_for_each_node_breadth_first",
          "args": [
            "ssp",
            "snp"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "snp->srcu_have_cbs"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_ctr",
          "args": [
            "gpseq"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_ctr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "30-33",
          "snippet": "static inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_CTR_SHIFT\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_CTR_SHIFT\t2\n\nstatic inline unsigned long rcu_seq_ctr(unsigned long s)\n{\n\treturn s >> RCU_SEQ_CTR_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ssp->srcu_gp_seq_needed_exp",
            "gpseq"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "ssp->srcu_gp_seq_needed_exp",
            "gpseq"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_end",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "69-74",
          "snippet": "static inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_end(unsigned long *sp)\n{\n\tsmp_mb(); /* Ensure update-side operation before counter increment. */\n\tWARN_ON_ONCE(!rcu_seq_state(*sp));\n\tWRITE_ONCE(*sp, rcu_seq_endval(sp));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ssp->srcu_last_gp_end",
            "ktime_get_mono_fast_ns()"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "485-488",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_get_delay",
          "args": [
            "ssp"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_get_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "352-358",
          "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "idx != SRCU_STATE_SCAN2"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq_rcu_node",
          "args": [
            "ssp"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ssp->srcu_cb_mutex"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "mutex_lock_io",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex_api.c",
          "lines": "580-586",
          "snippet": "void __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}",
          "includes": [
            "#include \"rtmutex.c\"",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex.c\"\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched mutex_lock_io(struct mutex *lock)\n{\n\tint token = io_schedule_prepare();\n\n\t__mutex_lock_common(lock, TASK_UNINTERRUPTIBLE, 0, NULL, _RET_IP_);\n\tio_schedule_finish(token);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic ulong counter_wrap_check = (ULONG_MAX >> 2);\n\nstatic void srcu_gp_end(struct srcu_struct *ssp)\n{\n\tunsigned long cbdelay;\n\tbool cbs;\n\tbool last_lvl;\n\tint cpu;\n\tunsigned long flags;\n\tunsigned long gpseq;\n\tint idx;\n\tunsigned long mask;\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\n\t/* Prevent more than one additional grace period. */\n\tmutex_lock(&ssp->srcu_cb_mutex);\n\n\t/* End the current grace period. */\n\tspin_lock_irq_rcu_node(ssp);\n\tidx = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(idx != SRCU_STATE_SCAN2);\n\tcbdelay = srcu_get_delay(ssp);\n\tWRITE_ONCE(ssp->srcu_last_gp_end, ktime_get_mono_fast_ns());\n\trcu_seq_end(&ssp->srcu_gp_seq);\n\tgpseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tif (ULONG_CMP_LT(ssp->srcu_gp_seq_needed_exp, gpseq))\n\t\tWRITE_ONCE(ssp->srcu_gp_seq_needed_exp, gpseq);\n\tspin_unlock_irq_rcu_node(ssp);\n\tmutex_unlock(&ssp->srcu_gp_mutex);\n\t/* A new grace period can start at this point.  But only one. */\n\n\t/* Initiate callback invocation as needed. */\n\tidx = rcu_seq_ctr(gpseq) % ARRAY_SIZE(snp->srcu_have_cbs);\n\tsrcu_for_each_node_breadth_first(ssp, snp) {\n\t\tspin_lock_irq_rcu_node(snp);\n\t\tcbs = false;\n\t\tlast_lvl = snp >= ssp->level[rcu_num_lvls - 1];\n\t\tif (last_lvl)\n\t\t\tcbs = snp->srcu_have_cbs[idx] == gpseq;\n\t\tsnp->srcu_have_cbs[idx] = gpseq;\n\t\trcu_seq_set_state(&snp->srcu_have_cbs[idx], 1);\n\t\tif (ULONG_CMP_LT(snp->srcu_gp_seq_needed_exp, gpseq))\n\t\t\tWRITE_ONCE(snp->srcu_gp_seq_needed_exp, gpseq);\n\t\tmask = snp->srcu_data_have_cbs[idx];\n\t\tsnp->srcu_data_have_cbs[idx] = 0;\n\t\tspin_unlock_irq_rcu_node(snp);\n\t\tif (cbs)\n\t\t\tsrcu_schedule_cbs_snp(ssp, snp, mask, cbdelay);\n\n\t\t/* Occasionally prevent srcu_data counter wrap. */\n\t\tif (!(gpseq & counter_wrap_check) && last_lvl)\n\t\t\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\t\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\t\t\tspin_lock_irqsave_rcu_node(sdp, flags);\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed = gpseq;\n\t\t\t\tif (ULONG_CMP_GE(gpseq,\n\t\t\t\t\t\t sdp->srcu_gp_seq_needed_exp + 100))\n\t\t\t\t\tsdp->srcu_gp_seq_needed_exp = gpseq;\n\t\t\t\tspin_unlock_irqrestore_rcu_node(sdp, flags);\n\t\t\t}\n\t}\n\n\t/* Callback initiation done, allow grace periods after next. */\n\tmutex_unlock(&ssp->srcu_cb_mutex);\n\n\t/* Start a new grace period if needed. */\n\tspin_lock_irq_rcu_node(ssp);\n\tgpseq = rcu_seq_current(&ssp->srcu_gp_seq);\n\tif (!rcu_seq_state(gpseq) &&\n\t    ULONG_CMP_LT(gpseq, ssp->srcu_gp_seq_needed)) {\n\t\tsrcu_gp_start(ssp);\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t\tsrcu_reschedule(ssp, 0);\n\t} else {\n\t\tspin_unlock_irq_rcu_node(ssp);\n\t}\n}"
  },
  {
    "function_name": "srcu_schedule_cbs_snp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "488-498",
    "snippet": "static void srcu_schedule_cbs_snp(struct srcu_struct *ssp, struct srcu_node *snp,\n\t\t\t\t  unsigned long mask, unsigned long delay)\n{\n\tint cpu;\n\n\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\tif (!(mask & (1 << (cpu - snp->grplo))))\n\t\t\tcontinue;\n\t\tsrcu_schedule_cbs_sdp(per_cpu_ptr(ssp->sda, cpu), delay);\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_schedule_cbs_sdp",
          "args": [
            "per_cpu_ptr(ssp->sda, cpu)",
            "delay"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_schedule_cbs_sdp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "477-480",
          "snippet": "static void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp, delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\n\nstatic void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp, delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ssp->sda",
            "cpu"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\n\nstatic void srcu_schedule_cbs_snp(struct srcu_struct *ssp, struct srcu_node *snp,\n\t\t\t\t  unsigned long mask, unsigned long delay)\n{\n\tint cpu;\n\n\tfor (cpu = snp->grplo; cpu <= snp->grphi; cpu++) {\n\t\tif (!(mask & (1 << (cpu - snp->grplo))))\n\t\t\tcontinue;\n\t\tsrcu_schedule_cbs_sdp(per_cpu_ptr(ssp->sda, cpu), delay);\n\t}\n}"
  },
  {
    "function_name": "srcu_schedule_cbs_sdp",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "477-480",
    "snippet": "static void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp, delay);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_queue_delayed_work_on",
          "args": [
            "sdp",
            "delay"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_queue_delayed_work_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "462-471",
          "snippet": "static void srcu_queue_delayed_work_on(struct srcu_data *sdp,\n\t\t\t\t       unsigned long delay)\n{\n\tif (!delay) {\n\t\tqueue_work_on(sdp->cpu, rcu_gp_wq, &sdp->work);\n\t\treturn;\n\t}\n\n\ttimer_reduce(&sdp->delay_work, jiffies + delay);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_queue_delayed_work_on(struct srcu_data *sdp,\n\t\t\t\t       unsigned long delay)\n{\n\tif (!delay) {\n\t\tqueue_work_on(sdp->cpu, rcu_gp_wq, &sdp->work);\n\t\treturn;\n\t}\n\n\ttimer_reduce(&sdp->delay_work, jiffies + delay);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\n\nstatic void srcu_schedule_cbs_sdp(struct srcu_data *sdp, unsigned long delay)\n{\n\tsrcu_queue_delayed_work_on(sdp, delay);\n}"
  },
  {
    "function_name": "srcu_queue_delayed_work_on",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "462-471",
    "snippet": "static void srcu_queue_delayed_work_on(struct srcu_data *sdp,\n\t\t\t\t       unsigned long delay)\n{\n\tif (!delay) {\n\t\tqueue_work_on(sdp->cpu, rcu_gp_wq, &sdp->work);\n\t\treturn;\n\t}\n\n\ttimer_reduce(&sdp->delay_work, jiffies + delay);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_reduce",
          "args": [
            "&sdp->delay_work",
            "jiffies + delay"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "timer_reduce",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1121-1124",
          "snippet": "int timer_reduce(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, MOD_TIMER_REDUCE);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define MOD_TIMER_REDUCE\t\t0x02"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_REDUCE\t\t0x02\n\nint timer_reduce(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, MOD_TIMER_REDUCE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "sdp->cpu",
            "rcu_gp_wq",
            "&sdp->work"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1553-1568",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void srcu_reschedule(struct srcu_struct *ssp, unsigned long delay);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void srcu_queue_delayed_work_on(struct srcu_data *sdp,\n\t\t\t\t       unsigned long delay)\n{\n\tif (!delay) {\n\t\tqueue_work_on(sdp->cpu, rcu_gp_wq, &sdp->work);\n\t\treturn;\n\t}\n\n\ttimer_reduce(&sdp->delay_work, jiffies + delay);\n}"
  },
  {
    "function_name": "srcu_delay_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "455-460",
    "snippet": "static void srcu_delay_timer(struct timer_list *t)\n{\n\tstruct srcu_data *sdp = container_of(t, struct srcu_data, delay_work);\n\n\tqueue_work_on(sdp->cpu, rcu_gp_wq, &sdp->work);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);",
      "static void srcu_delay_timer(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work_on",
          "args": [
            "sdp->cpu",
            "rcu_gp_wq",
            "&sdp->work"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "queue_work_on",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "1553-1568",
          "snippet": "bool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool queue_work_on(int cpu, struct workqueue_struct *wq,\n\t\t   struct work_struct *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\n\tif (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) {\n\t\t__queue_work(cpu, wq, work);\n\t\tret = true;\n\t}\n\n\tlocal_irq_restore(flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "t",
            "structsrcu_data",
            "delay_work"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\nstatic void srcu_delay_timer(struct timer_list *t);\n\nstatic void srcu_delay_timer(struct timer_list *t)\n{\n\tstruct srcu_data *sdp = container_of(t, struct srcu_data, delay_work);\n\n\tqueue_work_on(sdp->cpu, rcu_gp_wq, &sdp->work);\n}"
  },
  {
    "function_name": "srcu_gp_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "435-452",
    "snippet": "static void srcu_gp_start(struct srcu_struct *ssp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(ssp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(ssp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\tspin_lock_rcu_node(sdp);  /* Interrupts already disabled. */\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tspin_unlock_rcu_node(sdp);  /* Interrupts remain disabled. */\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&ssp->srcu_gp_seq);\n\tstate = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "state != SRCU_STATE_SCAN1"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "ssp->srcu_gp_seq"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "39-42",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_start",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "55-60",
          "snippet": "static inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_seq_start(unsigned long *sp)\n{\n\tWRITE_ONCE(*sp, *sp + 1);\n\tsmp_mb(); /* Ensure update-side operation after counter increment. */\n\tWARN_ON_ONCE(rcu_seq_state(*sp) != 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_accelerate",
          "args": [
            "&sdp->srcu_cblist",
            "rcu_seq_snap(&ssp->srcu_gp_seq)"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_accelerate",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "537-598",
          "snippet": "bool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t *\n\t * Note that segment \"i\" (and any lower-numbered segments\n\t * containing older callbacks) will be unaffected, and their\n\t * grace-period numbers remain unchanged.  For example, if i ==\n\t * WAIT_TAIL, then neither WAIT_TAIL nor DONE_TAIL will be touched.\n\t * Instead, the CBs in NEXT_TAIL will be merged with those in\n\t * NEXT_READY_TAIL and the grace-period number of NEXT_READY_TAIL\n\t * would be updated.  NEXT_TAIL would then be empty.\n\t */\n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/* Accounting: everything below i is about to get merged into i. */\n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nbool rcu_segcblist_accelerate(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn false;\n\n\t/*\n\t * Find the segment preceding the oldest segment of callbacks\n\t * whose ->gp_seq[] completion is at or after that passed in via\n\t * \"seq\", skipping any empty segments.  This oldest segment, along\n\t * with any later segments, can be merged in with any newly arrived\n\t * callbacks in the RCU_NEXT_TAIL segment, and assigned \"seq\"\n\t * as their ->gp_seq[] grace-period completion sequence number.\n\t */\n\tfor (i = RCU_NEXT_READY_TAIL; i > RCU_DONE_TAIL; i--)\n\t\tif (rsclp->tails[i] != rsclp->tails[i - 1] &&\n\t\t    ULONG_CMP_LT(rsclp->gp_seq[i], seq))\n\t\t\tbreak;\n\n\t/*\n\t * If all the segments contain callbacks that correspond to\n\t * earlier grace-period sequence numbers than \"seq\", leave.\n\t * Assuming that the rcu_segcblist structure has enough\n\t * segments in its arrays, this can only happen if some of\n\t * the non-done segments contain callbacks that really are\n\t * ready to invoke.  This situation will get straightened\n\t * out by the next call to rcu_segcblist_advance().\n\t *\n\t * Also advance to the oldest segment of callbacks whose\n\t * ->gp_seq[] completion is at or after that passed in via \"seq\",\n\t * skipping any empty segments.\n\t *\n\t * Note that segment \"i\" (and any lower-numbered segments\n\t * containing older callbacks) will be unaffected, and their\n\t * grace-period numbers remain unchanged.  For example, if i ==\n\t * WAIT_TAIL, then neither WAIT_TAIL nor DONE_TAIL will be touched.\n\t * Instead, the CBs in NEXT_TAIL will be merged with those in\n\t * NEXT_READY_TAIL and the grace-period number of NEXT_READY_TAIL\n\t * would be updated.  NEXT_TAIL would then be empty.\n\t */\n\tif (rcu_segcblist_restempty(rsclp, i) || ++i >= RCU_NEXT_TAIL)\n\t\treturn false;\n\n\t/* Accounting: everything below i is about to get merged into i. */\n\tfor (j = i + 1; j <= RCU_NEXT_TAIL; j++)\n\t\trcu_segcblist_move_seglen(rsclp, j, i);\n\n\t/*\n\t * Merge all later callbacks, including newly arrived callbacks,\n\t * into the segment located by the for-loop above.  Assign \"seq\"\n\t * as the ->gp_seq[] value in order to correctly handle the case\n\t * where there were no pending callbacks in the rcu_segcblist\n\t * structure other than in the RCU_NEXT_TAIL segment.\n\t */\n\tfor (; i < RCU_NEXT_TAIL; i++) {\n\t\tWRITE_ONCE(rsclp->tails[i], rsclp->tails[RCU_NEXT_TAIL]);\n\t\trsclp->gp_seq[i] = seq;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_snap",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_snap",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "87-94",
          "snippet": "static inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline unsigned long rcu_seq_snap(unsigned long *sp)\n{\n\tunsigned long s;\n\n\ts = (READ_ONCE(*sp) + 2 * RCU_SEQ_STATE_MASK + 1) & ~RCU_SEQ_STATE_MASK;\n\tsmp_mb(); /* Above access must not bleed into critical section. */\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_advance",
          "args": [
            "&sdp->srcu_cblist",
            "rcu_seq_current(&ssp->srcu_gp_seq)"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_advance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "480-520",
          "snippet": "void rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\tWRITE_ONCE(rsclp->tails[RCU_DONE_TAIL], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, RCU_DONE_TAIL);\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[RCU_DONE_TAIL]);\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, j);\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_advance(struct rcu_segcblist *rsclp, unsigned long seq)\n{\n\tint i, j;\n\n\tWARN_ON_ONCE(!rcu_segcblist_is_enabled(rsclp));\n\tif (rcu_segcblist_restempty(rsclp, RCU_DONE_TAIL))\n\t\treturn;\n\n\t/*\n\t * Find all callbacks whose ->gp_seq numbers indicate that they\n\t * are ready to invoke, and put them into the RCU_DONE_TAIL segment.\n\t */\n\tfor (i = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++) {\n\t\tif (ULONG_CMP_LT(seq, rsclp->gp_seq[i]))\n\t\t\tbreak;\n\t\tWRITE_ONCE(rsclp->tails[RCU_DONE_TAIL], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, RCU_DONE_TAIL);\n\t}\n\n\t/* If no callbacks moved, nothing more need be done. */\n\tif (i == RCU_WAIT_TAIL)\n\t\treturn;\n\n\t/* Clean up tail pointers that might have been misordered above. */\n\tfor (j = RCU_WAIT_TAIL; j < i; j++)\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[RCU_DONE_TAIL]);\n\n\t/*\n\t * Callbacks moved, so clean up the misordered ->tails[] pointers\n\t * that now point into the middle of the list of ready-to-invoke\n\t * callbacks.  The overall effect is to copy down the later pointers\n\t * into the gap that was created by the now-ready segments.\n\t */\n\tfor (j = RCU_WAIT_TAIL; i < RCU_NEXT_TAIL; i++, j++) {\n\t\tif (rsclp->tails[j] == rsclp->tails[RCU_NEXT_TAIL])\n\t\t\tbreak;  /* No more callbacks. */\n\t\tWRITE_ONCE(rsclp->tails[j], rsclp->tails[i]);\n\t\trcu_segcblist_move_seglen(rsclp, i, j);\n\t\trsclp->gp_seq[j] = rsclp->gp_seq[i];\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_seq_current",
          "args": [
            "&ssp->srcu_gp_seq"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "97-100",
          "snippet": "static inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline unsigned long rcu_seq_current(unsigned long *sp)\n{\n\treturn READ_ONCE(*sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_rcu_node",
          "args": [
            "sdp"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULONG_CMP_GE",
          "args": [
            "ssp->srcu_gp_seq",
            "ssp->srcu_gp_seq_needed"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&ACCESS_PRIVATE(ssp, lock)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "ssp",
            "lock"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "ssp->sda"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_gp_start(struct srcu_struct *ssp)\n{\n\tstruct srcu_data *sdp = this_cpu_ptr(ssp->sda);\n\tint state;\n\n\tlockdep_assert_held(&ACCESS_PRIVATE(ssp, lock));\n\tWARN_ON_ONCE(ULONG_CMP_GE(ssp->srcu_gp_seq, ssp->srcu_gp_seq_needed));\n\tspin_lock_rcu_node(sdp);  /* Interrupts already disabled. */\n\trcu_segcblist_advance(&sdp->srcu_cblist,\n\t\t\t      rcu_seq_current(&ssp->srcu_gp_seq));\n\t(void)rcu_segcblist_accelerate(&sdp->srcu_cblist,\n\t\t\t\t       rcu_seq_snap(&ssp->srcu_gp_seq));\n\tspin_unlock_rcu_node(sdp);  /* Interrupts remain disabled. */\n\tsmp_mb(); /* Order prior store to ->srcu_gp_seq_needed vs. GP start. */\n\trcu_seq_start(&ssp->srcu_gp_seq);\n\tstate = rcu_seq_state(ssp->srcu_gp_seq);\n\tWARN_ON_ONCE(state != SRCU_STATE_SCAN1);\n}"
  },
  {
    "function_name": "__srcu_read_unlock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "416-420",
    "snippet": "void __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "ssp->sda->srcu_unlock_count[idx]"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid __srcu_read_unlock(struct srcu_struct *ssp, int idx)\n{\n\tsmp_mb(); /* C */  /* Avoid leaking the critical section. */\n\tthis_cpu_inc(ssp->sda->srcu_unlock_count[idx]);\n}"
  },
  {
    "function_name": "__srcu_read_lock",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "400-408",
    "snippet": "int __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "ssp->sda->srcu_lock_count[idx]"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_idx"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint __srcu_read_lock(struct srcu_struct *ssp)\n{\n\tint idx;\n\n\tidx = READ_ONCE(ssp->srcu_idx) & 0x1;\n\tthis_cpu_inc(ssp->sda->srcu_lock_count[idx]);\n\tsmp_mb(); /* B */  /* Avoid leaking the critical section. */\n\treturn idx;\n}"
  },
  {
    "function_name": "cleanup_srcu_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "367-392",
    "snippet": "void cleanup_srcu_struct(struct srcu_struct *ssp)\n{\n\tint cpu;\n\n\tif (WARN_ON(!srcu_get_delay(ssp)))\n\t\treturn; /* Just leak it! */\n\tif (WARN_ON(srcu_readers_active(ssp)))\n\t\treturn; /* Just leak it! */\n\tflush_delayed_work(&ssp->work);\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *sdp = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tdel_timer_sync(&sdp->delay_work);\n\t\tflush_work(&sdp->work);\n\t\tif (WARN_ON(rcu_segcblist_n_cbs(&sdp->srcu_cblist)))\n\t\t\treturn; /* Forgot srcu_barrier(), so just leak it! */\n\t}\n\tif (WARN_ON(rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||\n\t    WARN_ON(srcu_readers_active(ssp))) {\n\t\tpr_info(\"%s: Active srcu_struct %p state: %d\\n\",\n\t\t\t__func__, ssp, rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)));\n\t\treturn; /* Caller forgot to stop doing call_srcu()? */\n\t}\n\tfree_percpu(ssp->sda);\n\tssp->sda = NULL;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "ssp->sda"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "21-29",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s: Active srcu_struct %p state: %d\\n\"",
            "__func__",
            "ssp",
            "rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq))"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "READ_ONCE(ssp->srcu_gp_seq)"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "39-42",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_gp_seq"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "srcu_readers_active(ssp)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_readers_active",
          "args": [
            "ssp"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_readers_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "330-344",
          "snippet": "static bool srcu_readers_active(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[0]);\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[1]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[0]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[1]);\n\t}\n\treturn sum;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic bool srcu_readers_active(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[0]);\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[1]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[0]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[1]);\n\t}\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) != SRCU_STATE_IDLE"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_gp_seq"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rcu_segcblist_n_cbs(&sdp->srcu_cblist)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_n_cbs",
          "args": [
            "&sdp->srcu_cblist"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_n_cbs",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "47-54",
          "snippet": "static inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "long rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nlong rcu_segcblist_n_segment_cbs(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_inc_len(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline long rcu_segcblist_n_cbs(struct rcu_segcblist *rsclp)\n{\n#ifdef CONFIG_RCU_NOCB_CPU\n\treturn atomic_long_read(&rsclp->len);\n#else\n\treturn READ_ONCE(rsclp->len);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&sdp->work"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3112-3115",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&sdp->delay_work"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer.c",
          "lines": "1352-1391",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/random.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/random.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n\tint ret;\n\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\n\t/*\n\t * Must be able to sleep on PREEMPT_RT because of the slowpath in\n\t * del_timer_wait_running().\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT_RT) && !(timer->flags & TIMER_IRQSAFE))\n\t\tlockdep_assert_preemption_enabled();\n\n\tdo {\n\t\tret = try_to_del_timer_sync(timer);\n\n\t\tif (unlikely(ret < 0)) {\n\t\t\tdel_timer_wait_running(timer);\n\t\t\tcpu_relax();\n\t\t}\n\t} while (ret < 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ssp->sda",
            "cpu"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_delayed_work",
          "args": [
            "&ssp->work"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "flush_delayed_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/workqueue.c",
          "lines": "3232-3239",
          "snippet": "bool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/kvm_para.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/kvm_para.h>\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "srcu_readers_active(ssp)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!srcu_get_delay(ssp)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_get_delay",
          "args": [
            "ssp"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_get_delay",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "352-358",
          "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define SRCU_INTERVAL\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nvoid cleanup_srcu_struct(struct srcu_struct *ssp)\n{\n\tint cpu;\n\n\tif (WARN_ON(!srcu_get_delay(ssp)))\n\t\treturn; /* Just leak it! */\n\tif (WARN_ON(srcu_readers_active(ssp)))\n\t\treturn; /* Just leak it! */\n\tflush_delayed_work(&ssp->work);\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *sdp = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tdel_timer_sync(&sdp->delay_work);\n\t\tflush_work(&sdp->work);\n\t\tif (WARN_ON(rcu_segcblist_n_cbs(&sdp->srcu_cblist)))\n\t\t\treturn; /* Forgot srcu_barrier(), so just leak it! */\n\t}\n\tif (WARN_ON(rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)) != SRCU_STATE_IDLE) ||\n\t    WARN_ON(srcu_readers_active(ssp))) {\n\t\tpr_info(\"%s: Active srcu_struct %p state: %d\\n\",\n\t\t\t__func__, ssp, rcu_seq_state(READ_ONCE(ssp->srcu_gp_seq)));\n\t\treturn; /* Caller forgot to stop doing call_srcu()? */\n\t}\n\tfree_percpu(ssp->sda);\n\tssp->sda = NULL;\n}"
  },
  {
    "function_name": "srcu_get_delay",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "352-358",
    "snippet": "static unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define SRCU_INTERVAL\t\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ULONG_CMP_LT",
          "args": [
            "READ_ONCE(ssp->srcu_gp_seq)",
            "READ_ONCE(ssp->srcu_gp_seq_needed_exp)"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_gp_seq_needed_exp"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ssp->srcu_gp_seq"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\n#define SRCU_INTERVAL\t\t1\n\nstatic unsigned long srcu_get_delay(struct srcu_struct *ssp)\n{\n\tif (ULONG_CMP_LT(READ_ONCE(ssp->srcu_gp_seq),\n\t\t\t READ_ONCE(ssp->srcu_gp_seq_needed_exp)))\n\t\treturn 0;\n\treturn SRCU_INTERVAL;\n}"
  },
  {
    "function_name": "srcu_readers_active",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "330-344",
    "snippet": "static bool srcu_readers_active(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[0]);\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[1]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[0]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[1]);\n\t}\n\treturn sum;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_unlock_count[1]"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_unlock_count[0]"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_lock_count[1]"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_lock_count[0]"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ssp->sda",
            "cpu"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic bool srcu_readers_active(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[0]);\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[1]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[0]);\n\t\tsum -= READ_ONCE(cpuc->srcu_unlock_count[1]);\n\t}\n\treturn sum;\n}"
  },
  {
    "function_name": "srcu_readers_active_idx_check",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "278-319",
    "snippet": "static bool srcu_readers_active_idx_check(struct srcu_struct *ssp, int idx)\n{\n\tunsigned long unlocks;\n\n\tunlocks = srcu_readers_unlock_idx(ssp, idx);\n\n\t/*\n\t * Make sure that a lock is always counted if the corresponding\n\t * unlock is counted. Needs to be a smp_mb() as the read side may\n\t * contain a read from a variable that is written to before the\n\t * synchronize_srcu() in the write side. In this case smp_mb()s\n\t * A and B act like the store buffering pattern.\n\t *\n\t * This smp_mb() also pairs with smp_mb() C to prevent accesses\n\t * after the synchronize_srcu() from being executed before the\n\t * grace period ends.\n\t */\n\tsmp_mb(); /* A */\n\n\t/*\n\t * If the locks are the same as the unlocks, then there must have\n\t * been no readers on this index at some time in between. This does\n\t * not mean that there are no more readers, as one could have read\n\t * the current index but not have incremented the lock counter yet.\n\t *\n\t * So suppose that the updater is preempted here for so long\n\t * that more than ULONG_MAX non-nested readers come and go in\n\t * the meantime.  It turns out that this cannot result in overflow\n\t * because if a reader modifies its unlock count after we read it\n\t * above, then that reader's next load of ->srcu_idx is guaranteed\n\t * to get the new value, which will cause it to operate on the\n\t * other bank of counters, where it cannot contribute to the\n\t * overflow of these counters.  This means that there is a maximum\n\t * of 2*NR_CPUS increments, which cannot overflow given current\n\t * systems, especially not on 64-bit systems.\n\t *\n\t * OK, how about nesting?  This does impose a limit on nesting\n\t * of floor(ULONG_MAX/NR_CPUS/2), which should be sufficient,\n\t * especially on 64-bit systems.\n\t */\n\treturn srcu_readers_lock_idx(ssp, idx) == unlocks;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_readers_lock_idx",
          "args": [
            "ssp",
            "idx"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_readers_lock_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "244-255",
          "snippet": "static unsigned long srcu_readers_lock_idx(struct srcu_struct *ssp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[idx]);\n\t}\n\treturn sum;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_readers_lock_idx(struct srcu_struct *ssp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[idx]);\n\t}\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_readers_unlock_idx",
          "args": [
            "ssp",
            "idx"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "srcu_readers_unlock_idx",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "261-272",
          "snippet": "static unsigned long srcu_readers_unlock_idx(struct srcu_struct *ssp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_unlock_count[idx]);\n\t}\n\treturn sum;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_readers_unlock_idx(struct srcu_struct *ssp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_unlock_count[idx]);\n\t}\n\treturn sum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic bool srcu_readers_active_idx_check(struct srcu_struct *ssp, int idx)\n{\n\tunsigned long unlocks;\n\n\tunlocks = srcu_readers_unlock_idx(ssp, idx);\n\n\t/*\n\t * Make sure that a lock is always counted if the corresponding\n\t * unlock is counted. Needs to be a smp_mb() as the read side may\n\t * contain a read from a variable that is written to before the\n\t * synchronize_srcu() in the write side. In this case smp_mb()s\n\t * A and B act like the store buffering pattern.\n\t *\n\t * This smp_mb() also pairs with smp_mb() C to prevent accesses\n\t * after the synchronize_srcu() from being executed before the\n\t * grace period ends.\n\t */\n\tsmp_mb(); /* A */\n\n\t/*\n\t * If the locks are the same as the unlocks, then there must have\n\t * been no readers on this index at some time in between. This does\n\t * not mean that there are no more readers, as one could have read\n\t * the current index but not have incremented the lock counter yet.\n\t *\n\t * So suppose that the updater is preempted here for so long\n\t * that more than ULONG_MAX non-nested readers come and go in\n\t * the meantime.  It turns out that this cannot result in overflow\n\t * because if a reader modifies its unlock count after we read it\n\t * above, then that reader's next load of ->srcu_idx is guaranteed\n\t * to get the new value, which will cause it to operate on the\n\t * other bank of counters, where it cannot contribute to the\n\t * overflow of these counters.  This means that there is a maximum\n\t * of 2*NR_CPUS increments, which cannot overflow given current\n\t * systems, especially not on 64-bit systems.\n\t *\n\t * OK, how about nesting?  This does impose a limit on nesting\n\t * of floor(ULONG_MAX/NR_CPUS/2), which should be sufficient,\n\t * especially on 64-bit systems.\n\t */\n\treturn srcu_readers_lock_idx(ssp, idx) == unlocks;\n}"
  },
  {
    "function_name": "srcu_readers_unlock_idx",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "261-272",
    "snippet": "static unsigned long srcu_readers_unlock_idx(struct srcu_struct *ssp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_unlock_count[idx]);\n\t}\n\treturn sum;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_unlock_count[idx]"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ssp->sda",
            "cpu"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_readers_unlock_idx(struct srcu_struct *ssp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_unlock_count[idx]);\n\t}\n\treturn sum;\n}"
  },
  {
    "function_name": "srcu_readers_lock_idx",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "244-255",
    "snippet": "static unsigned long srcu_readers_lock_idx(struct srcu_struct *ssp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[idx]);\n\t}\n\treturn sum;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "cpuc->srcu_lock_count[idx]"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ssp->sda",
            "cpu"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic unsigned long srcu_readers_lock_idx(struct srcu_struct *ssp, int idx)\n{\n\tint cpu;\n\tunsigned long sum = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct srcu_data *cpuc = per_cpu_ptr(ssp->sda, cpu);\n\n\t\tsum += READ_ONCE(cpuc->srcu_lock_count[idx]);\n\t}\n\treturn sum;\n}"
  },
  {
    "function_name": "check_init_srcu_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "224-238",
    "snippet": "static void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "ssp",
            "flags"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_srcu_struct_fields",
          "args": [
            "ssp",
            "true"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "init_srcu_struct_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "163-182",
          "snippet": "static int init_srcu_struct_fields(struct srcu_struct *ssp, bool is_static)\n{\n\tmutex_init(&ssp->srcu_cb_mutex);\n\tmutex_init(&ssp->srcu_gp_mutex);\n\tssp->srcu_idx = 0;\n\tssp->srcu_gp_seq = 0;\n\tssp->srcu_barrier_seq = 0;\n\tmutex_init(&ssp->srcu_barrier_mutex);\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&ssp->work, process_srcu);\n\tif (!is_static)\n\t\tssp->sda = alloc_percpu(struct srcu_data);\n\tif (!ssp->sda)\n\t\treturn -ENOMEM;\n\tinit_srcu_struct_nodes(ssp);\n\tssp->srcu_gp_seq_needed_exp = 0;\n\tssp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&ssp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic int init_srcu_struct_fields(struct srcu_struct *ssp, bool is_static)\n{\n\tmutex_init(&ssp->srcu_cb_mutex);\n\tmutex_init(&ssp->srcu_gp_mutex);\n\tssp->srcu_idx = 0;\n\tssp->srcu_gp_seq = 0;\n\tssp->srcu_barrier_seq = 0;\n\tmutex_init(&ssp->srcu_barrier_mutex);\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&ssp->work, process_srcu);\n\tif (!is_static)\n\t\tssp->sda = alloc_percpu(struct srcu_data);\n\tif (!ssp->sda)\n\t\treturn -ENOMEM;\n\tinit_srcu_struct_nodes(ssp);\n\tssp->srcu_gp_seq_needed_exp = 0;\n\tssp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&ssp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore_rcu_node",
          "args": [
            "ssp",
            "flags"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_seq_state",
          "args": [
            "ssp->srcu_gp_seq_needed"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_seq_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "39-42",
          "snippet": "static inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [
            "#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\n#define RCU_SEQ_STATE_MASK\t((1 << RCU_SEQ_CTR_SHIFT) - 1)\n\nstatic inline int rcu_seq_state(unsigned long s)\n{\n\treturn s & RCU_SEQ_STATE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_rcu_node",
          "args": [
            "ssp",
            "flags"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&ssp->srcu_gp_seq_needed"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void check_init_srcu_struct(struct srcu_struct *ssp)\n{\n\tunsigned long flags;\n\n\t/* The smp_load_acquire() pairs with the smp_store_release(). */\n\tif (!rcu_seq_state(smp_load_acquire(&ssp->srcu_gp_seq_needed))) /*^^^*/\n\t\treturn; /* Already initialized. */\n\tspin_lock_irqsave_rcu_node(ssp, flags);\n\tif (!rcu_seq_state(ssp->srcu_gp_seq_needed)) {\n\t\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n\t\treturn;\n\t}\n\tinit_srcu_struct_fields(ssp, true);\n\tspin_unlock_irqrestore_rcu_node(ssp, flags);\n}"
  },
  {
    "function_name": "init_srcu_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "207-211",
    "snippet": "int init_srcu_struct(struct srcu_struct *ssp)\n{\n\tspin_lock_init(&ACCESS_PRIVATE(ssp, lock));\n\treturn init_srcu_struct_fields(ssp, false);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_srcu_struct_fields",
          "args": [
            "ssp",
            "false"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "init_srcu_struct_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "163-182",
          "snippet": "static int init_srcu_struct_fields(struct srcu_struct *ssp, bool is_static)\n{\n\tmutex_init(&ssp->srcu_cb_mutex);\n\tmutex_init(&ssp->srcu_gp_mutex);\n\tssp->srcu_idx = 0;\n\tssp->srcu_gp_seq = 0;\n\tssp->srcu_barrier_seq = 0;\n\tmutex_init(&ssp->srcu_barrier_mutex);\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&ssp->work, process_srcu);\n\tif (!is_static)\n\t\tssp->sda = alloc_percpu(struct srcu_data);\n\tif (!ssp->sda)\n\t\treturn -ENOMEM;\n\tinit_srcu_struct_nodes(ssp);\n\tssp->srcu_gp_seq_needed_exp = 0;\n\tssp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&ssp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic int init_srcu_struct_fields(struct srcu_struct *ssp, bool is_static)\n{\n\tmutex_init(&ssp->srcu_cb_mutex);\n\tmutex_init(&ssp->srcu_gp_mutex);\n\tssp->srcu_idx = 0;\n\tssp->srcu_gp_seq = 0;\n\tssp->srcu_barrier_seq = 0;\n\tmutex_init(&ssp->srcu_barrier_mutex);\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&ssp->work, process_srcu);\n\tif (!is_static)\n\t\tssp->sda = alloc_percpu(struct srcu_data);\n\tif (!ssp->sda)\n\t\treturn -ENOMEM;\n\tinit_srcu_struct_nodes(ssp);\n\tssp->srcu_gp_seq_needed_exp = 0;\n\tssp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&ssp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ACCESS_PRIVATE(ssp, lock)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "ssp",
            "lock"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nint init_srcu_struct(struct srcu_struct *ssp)\n{\n\tspin_lock_init(&ACCESS_PRIVATE(ssp, lock));\n\treturn init_srcu_struct_fields(ssp, false);\n}"
  },
  {
    "function_name": "__init_srcu_struct",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "186-194",
    "snippet": "int __init_srcu_struct(struct srcu_struct *ssp, const char *name,\n\t\t       struct lock_class_key *key)\n{\n\t/* Don't re-initialize a lock while it is held. */\n\tdebug_check_no_locks_freed((void *)ssp, sizeof(*ssp));\n\tlockdep_init_map(&ssp->dep_map, name, key, 0);\n\tspin_lock_init(&ACCESS_PRIVATE(ssp, lock));\n\treturn init_srcu_struct_fields(ssp, false);\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_delay_timer(struct timer_list *t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_srcu_struct_fields",
          "args": [
            "ssp",
            "false"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "init_srcu_struct_fields",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "163-182",
          "snippet": "static int init_srcu_struct_fields(struct srcu_struct *ssp, bool is_static)\n{\n\tmutex_init(&ssp->srcu_cb_mutex);\n\tmutex_init(&ssp->srcu_gp_mutex);\n\tssp->srcu_idx = 0;\n\tssp->srcu_gp_seq = 0;\n\tssp->srcu_barrier_seq = 0;\n\tmutex_init(&ssp->srcu_barrier_mutex);\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&ssp->work, process_srcu);\n\tif (!is_static)\n\t\tssp->sda = alloc_percpu(struct srcu_data);\n\tif (!ssp->sda)\n\t\treturn -ENOMEM;\n\tinit_srcu_struct_nodes(ssp);\n\tssp->srcu_gp_seq_needed_exp = 0;\n\tssp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&ssp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn 0;\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic int init_srcu_struct_fields(struct srcu_struct *ssp, bool is_static)\n{\n\tmutex_init(&ssp->srcu_cb_mutex);\n\tmutex_init(&ssp->srcu_gp_mutex);\n\tssp->srcu_idx = 0;\n\tssp->srcu_gp_seq = 0;\n\tssp->srcu_barrier_seq = 0;\n\tmutex_init(&ssp->srcu_barrier_mutex);\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&ssp->work, process_srcu);\n\tif (!is_static)\n\t\tssp->sda = alloc_percpu(struct srcu_data);\n\tif (!ssp->sda)\n\t\treturn -ENOMEM;\n\tinit_srcu_struct_nodes(ssp);\n\tssp->srcu_gp_seq_needed_exp = 0;\n\tssp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&ssp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ACCESS_PRIVATE(ssp, lock)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "ssp",
            "lock"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&ssp->dep_map",
            "name",
            "key",
            "0"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)ssp",
            "sizeof(*ssp)"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/lockdep.c",
          "lines": "6405-6427",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinstr struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/lockdep.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/bitmap.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic noinstr struct;\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_delay_timer(struct timer_list *t);\n\nint __init_srcu_struct(struct srcu_struct *ssp, const char *name,\n\t\t       struct lock_class_key *key)\n{\n\t/* Don't re-initialize a lock while it is held. */\n\tdebug_check_no_locks_freed((void *)ssp, sizeof(*ssp));\n\tlockdep_init_map(&ssp->dep_map, name, key, 0);\n\tspin_lock_init(&ACCESS_PRIVATE(ssp, lock));\n\treturn init_srcu_struct_fields(ssp, false);\n}"
  },
  {
    "function_name": "init_srcu_struct_fields",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "163-182",
    "snippet": "static int init_srcu_struct_fields(struct srcu_struct *ssp, bool is_static)\n{\n\tmutex_init(&ssp->srcu_cb_mutex);\n\tmutex_init(&ssp->srcu_gp_mutex);\n\tssp->srcu_idx = 0;\n\tssp->srcu_gp_seq = 0;\n\tssp->srcu_barrier_seq = 0;\n\tmutex_init(&ssp->srcu_barrier_mutex);\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&ssp->work, process_srcu);\n\tif (!is_static)\n\t\tssp->sda = alloc_percpu(struct srcu_data);\n\tif (!ssp->sda)\n\t\treturn -ENOMEM;\n\tinit_srcu_struct_nodes(ssp);\n\tssp->srcu_gp_seq_needed_exp = 0;\n\tssp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&ssp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn 0;\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&ssp->srcu_gp_seq_needed",
            "0"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "485-488",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_srcu_struct_nodes",
          "args": [
            "ssp"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "init_srcu_struct_nodes",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
          "lines": "83-155",
          "snippet": "static void init_srcu_struct_nodes(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tint i;\n\tint level = 0;\n\tint levelspread[RCU_NUM_LVLS];\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\tstruct srcu_node *snp_first;\n\n\t/* Initialize geometry if it has not already been initialized. */\n\trcu_init_geometry();\n\n\t/* Work out the overall tree geometry. */\n\tssp->level[0] = &ssp->node[0];\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\tssp->level[i] = ssp->level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Each pass through this loop initializes one srcu_node structure. */\n\tsrcu_for_each_node_breadth_first(ssp, snp) {\n\t\tspin_lock_init(&ACCESS_PRIVATE(snp, lock));\n\t\tWARN_ON_ONCE(ARRAY_SIZE(snp->srcu_have_cbs) !=\n\t\t\t     ARRAY_SIZE(snp->srcu_data_have_cbs));\n\t\tfor (i = 0; i < ARRAY_SIZE(snp->srcu_have_cbs); i++) {\n\t\t\tsnp->srcu_have_cbs[i] = 0;\n\t\t\tsnp->srcu_data_have_cbs[i] = 0;\n\t\t}\n\t\tsnp->srcu_gp_seq_needed_exp = 0;\n\t\tsnp->grplo = -1;\n\t\tsnp->grphi = -1;\n\t\tif (snp == &ssp->node[0]) {\n\t\t\t/* Root node, special case. */\n\t\t\tsnp->srcu_parent = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Non-root node. */\n\t\tif (snp == ssp->level[level + 1])\n\t\t\tlevel++;\n\t\tsnp->srcu_parent = ssp->level[level - 1] +\n\t\t\t\t   (snp - ssp->level[level]) /\n\t\t\t\t   levelspread[level - 1];\n\t}\n\n\t/*\n\t * Initialize the per-CPU srcu_data array, which feeds into the\n\t * leaves of the srcu_node tree.\n\t */\n\tWARN_ON_ONCE(ARRAY_SIZE(sdp->srcu_lock_count) !=\n\t\t     ARRAY_SIZE(sdp->srcu_unlock_count));\n\tlevel = rcu_num_lvls - 1;\n\tsnp_first = ssp->level[level];\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tspin_lock_init(&ACCESS_PRIVATE(sdp, lock));\n\t\trcu_segcblist_init(&sdp->srcu_cblist);\n\t\tsdp->srcu_cblist_invoking = false;\n\t\tsdp->srcu_gp_seq_needed = ssp->srcu_gp_seq;\n\t\tsdp->srcu_gp_seq_needed_exp = ssp->srcu_gp_seq;\n\t\tsdp->mynode = &snp_first[cpu / levelspread[level]];\n\t\tfor (snp = sdp->mynode; snp != NULL; snp = snp->srcu_parent) {\n\t\t\tif (snp->grplo < 0)\n\t\t\t\tsnp->grplo = cpu;\n\t\t\tsnp->grphi = cpu;\n\t\t}\n\t\tsdp->cpu = cpu;\n\t\tINIT_WORK(&sdp->work, srcu_invoke_callbacks);\n\t\ttimer_setup(&sdp->delay_work, srcu_delay_timer, 0);\n\t\tsdp->ssp = ssp;\n\t\tsdp->grpmask = 1 << (cpu - sdp->mynode->grplo);\n\t}\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void srcu_invoke_callbacks(struct work_struct *work);",
            "static void process_srcu(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void init_srcu_struct_nodes(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tint i;\n\tint level = 0;\n\tint levelspread[RCU_NUM_LVLS];\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\tstruct srcu_node *snp_first;\n\n\t/* Initialize geometry if it has not already been initialized. */\n\trcu_init_geometry();\n\n\t/* Work out the overall tree geometry. */\n\tssp->level[0] = &ssp->node[0];\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\tssp->level[i] = ssp->level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Each pass through this loop initializes one srcu_node structure. */\n\tsrcu_for_each_node_breadth_first(ssp, snp) {\n\t\tspin_lock_init(&ACCESS_PRIVATE(snp, lock));\n\t\tWARN_ON_ONCE(ARRAY_SIZE(snp->srcu_have_cbs) !=\n\t\t\t     ARRAY_SIZE(snp->srcu_data_have_cbs));\n\t\tfor (i = 0; i < ARRAY_SIZE(snp->srcu_have_cbs); i++) {\n\t\t\tsnp->srcu_have_cbs[i] = 0;\n\t\t\tsnp->srcu_data_have_cbs[i] = 0;\n\t\t}\n\t\tsnp->srcu_gp_seq_needed_exp = 0;\n\t\tsnp->grplo = -1;\n\t\tsnp->grphi = -1;\n\t\tif (snp == &ssp->node[0]) {\n\t\t\t/* Root node, special case. */\n\t\t\tsnp->srcu_parent = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Non-root node. */\n\t\tif (snp == ssp->level[level + 1])\n\t\t\tlevel++;\n\t\tsnp->srcu_parent = ssp->level[level - 1] +\n\t\t\t\t   (snp - ssp->level[level]) /\n\t\t\t\t   levelspread[level - 1];\n\t}\n\n\t/*\n\t * Initialize the per-CPU srcu_data array, which feeds into the\n\t * leaves of the srcu_node tree.\n\t */\n\tWARN_ON_ONCE(ARRAY_SIZE(sdp->srcu_lock_count) !=\n\t\t     ARRAY_SIZE(sdp->srcu_unlock_count));\n\tlevel = rcu_num_lvls - 1;\n\tsnp_first = ssp->level[level];\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tspin_lock_init(&ACCESS_PRIVATE(sdp, lock));\n\t\trcu_segcblist_init(&sdp->srcu_cblist);\n\t\tsdp->srcu_cblist_invoking = false;\n\t\tsdp->srcu_gp_seq_needed = ssp->srcu_gp_seq;\n\t\tsdp->srcu_gp_seq_needed_exp = ssp->srcu_gp_seq;\n\t\tsdp->mynode = &snp_first[cpu / levelspread[level]];\n\t\tfor (snp = sdp->mynode; snp != NULL; snp = snp->srcu_parent) {\n\t\t\tif (snp->grplo < 0)\n\t\t\t\tsnp->grplo = cpu;\n\t\t\tsnp->grphi = cpu;\n\t\t}\n\t\tsdp->cpu = cpu;\n\t\tINIT_WORK(&sdp->work, srcu_invoke_callbacks);\n\t\ttimer_setup(&sdp->delay_work, srcu_delay_timer, 0);\n\t\tsdp->ssp = ssp;\n\t\tsdp->grpmask = 1 << (cpu - sdp->mynode->grplo);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "structsrcu_data"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/arraymap.c",
          "lines": "31-48",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <linux/rcupdate_trace.h>\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = bpf_map_alloc_percpu(&array->map, array->elem_size, 8,\n\t\t\t\t\t   GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&ssp->work",
            "process_srcu"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ssp->srcu_barrier_cpu_cnt",
            "0"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ssp->srcu_barrier_mutex"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "1700-1708",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic int init_srcu_struct_fields(struct srcu_struct *ssp, bool is_static)\n{\n\tmutex_init(&ssp->srcu_cb_mutex);\n\tmutex_init(&ssp->srcu_gp_mutex);\n\tssp->srcu_idx = 0;\n\tssp->srcu_gp_seq = 0;\n\tssp->srcu_barrier_seq = 0;\n\tmutex_init(&ssp->srcu_barrier_mutex);\n\tatomic_set(&ssp->srcu_barrier_cpu_cnt, 0);\n\tINIT_DELAYED_WORK(&ssp->work, process_srcu);\n\tif (!is_static)\n\t\tssp->sda = alloc_percpu(struct srcu_data);\n\tif (!ssp->sda)\n\t\treturn -ENOMEM;\n\tinit_srcu_struct_nodes(ssp);\n\tssp->srcu_gp_seq_needed_exp = 0;\n\tssp->srcu_last_gp_end = ktime_get_mono_fast_ns();\n\tsmp_store_release(&ssp->srcu_gp_seq_needed, 0); /* Init done. */\n\treturn 0;\n}"
  },
  {
    "function_name": "init_srcu_struct_nodes",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/srcutree.c",
    "lines": "83-155",
    "snippet": "static void init_srcu_struct_nodes(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tint i;\n\tint level = 0;\n\tint levelspread[RCU_NUM_LVLS];\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\tstruct srcu_node *snp_first;\n\n\t/* Initialize geometry if it has not already been initialized. */\n\trcu_init_geometry();\n\n\t/* Work out the overall tree geometry. */\n\tssp->level[0] = &ssp->node[0];\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\tssp->level[i] = ssp->level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Each pass through this loop initializes one srcu_node structure. */\n\tsrcu_for_each_node_breadth_first(ssp, snp) {\n\t\tspin_lock_init(&ACCESS_PRIVATE(snp, lock));\n\t\tWARN_ON_ONCE(ARRAY_SIZE(snp->srcu_have_cbs) !=\n\t\t\t     ARRAY_SIZE(snp->srcu_data_have_cbs));\n\t\tfor (i = 0; i < ARRAY_SIZE(snp->srcu_have_cbs); i++) {\n\t\t\tsnp->srcu_have_cbs[i] = 0;\n\t\t\tsnp->srcu_data_have_cbs[i] = 0;\n\t\t}\n\t\tsnp->srcu_gp_seq_needed_exp = 0;\n\t\tsnp->grplo = -1;\n\t\tsnp->grphi = -1;\n\t\tif (snp == &ssp->node[0]) {\n\t\t\t/* Root node, special case. */\n\t\t\tsnp->srcu_parent = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Non-root node. */\n\t\tif (snp == ssp->level[level + 1])\n\t\t\tlevel++;\n\t\tsnp->srcu_parent = ssp->level[level - 1] +\n\t\t\t\t   (snp - ssp->level[level]) /\n\t\t\t\t   levelspread[level - 1];\n\t}\n\n\t/*\n\t * Initialize the per-CPU srcu_data array, which feeds into the\n\t * leaves of the srcu_node tree.\n\t */\n\tWARN_ON_ONCE(ARRAY_SIZE(sdp->srcu_lock_count) !=\n\t\t     ARRAY_SIZE(sdp->srcu_unlock_count));\n\tlevel = rcu_num_lvls - 1;\n\tsnp_first = ssp->level[level];\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tspin_lock_init(&ACCESS_PRIVATE(sdp, lock));\n\t\trcu_segcblist_init(&sdp->srcu_cblist);\n\t\tsdp->srcu_cblist_invoking = false;\n\t\tsdp->srcu_gp_seq_needed = ssp->srcu_gp_seq;\n\t\tsdp->srcu_gp_seq_needed_exp = ssp->srcu_gp_seq;\n\t\tsdp->mynode = &snp_first[cpu / levelspread[level]];\n\t\tfor (snp = sdp->mynode; snp != NULL; snp = snp->srcu_parent) {\n\t\t\tif (snp->grplo < 0)\n\t\t\t\tsnp->grplo = cpu;\n\t\t\tsnp->grphi = cpu;\n\t\t}\n\t\tsdp->cpu = cpu;\n\t\tINIT_WORK(&sdp->work, srcu_invoke_callbacks);\n\t\ttimer_setup(&sdp->delay_work, srcu_delay_timer, 0);\n\t\tsdp->ssp = ssp;\n\t\tsdp->grpmask = 1 << (cpu - sdp->mynode->grplo);\n\t}\n}",
    "includes": [
      "#include \"rcu_segcblist.h\"",
      "#include \"rcu.h\"",
      "#include <linux/srcu.h>",
      "#include <linux/module.h>",
      "#include <linux/delay.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/rcupdate_wait.h>",
      "#include <linux/preempt.h>",
      "#include <linux/percpu.h>",
      "#include <linux/mutex.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void srcu_invoke_callbacks(struct work_struct *work);",
      "static void process_srcu(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "&sdp->delay_work",
            "srcu_delay_timer",
            "0"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&sdp->work",
            "srcu_invoke_callbacks"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_segcblist_init",
          "args": [
            "&sdp->srcu_cblist"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_init",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu_segcblist.c",
          "lines": "237-250",
          "snippet": "void rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++) {\n\t\trsclp->tails[i] = &rsclp->head;\n\t\trcu_segcblist_set_seglen(rsclp, i, 0);\n\t}\n\trcu_segcblist_set_len(rsclp, 0);\n\trcu_segcblist_set_flags(rsclp, SEGCBLIST_ENABLED);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/cpu.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp)\n{\n\tint i;\n\n\tBUILD_BUG_ON(RCU_NEXT_TAIL + 1 != ARRAY_SIZE(rsclp->gp_seq));\n\tBUILD_BUG_ON(ARRAY_SIZE(rsclp->tails) != ARRAY_SIZE(rsclp->gp_seq));\n\trsclp->head = NULL;\n\tfor (i = 0; i < RCU_CBLIST_NSEGS; i++) {\n\t\trsclp->tails[i] = &rsclp->head;\n\t\trcu_segcblist_set_seglen(rsclp, i, 0);\n\t}\n\trcu_segcblist_set_len(rsclp, 0);\n\trcu_segcblist_set_flags(rsclp, SEGCBLIST_ENABLED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ACCESS_PRIVATE(sdp, lock)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "sdp",
            "lock"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "ssp->sda",
            "cpu"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ARRAY_SIZE(sdp->srcu_lock_count) !=\n\t\t     ARRAY_SIZE(sdp->srcu_unlock_count)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sdp->srcu_unlock_count"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sdp->srcu_lock_count"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "snp->srcu_have_cbs"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "ARRAY_SIZE(snp->srcu_have_cbs) !=\n\t\t\t     ARRAY_SIZE(snp->srcu_data_have_cbs)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "snp->srcu_data_have_cbs"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "snp->srcu_have_cbs"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ACCESS_PRIVATE(snp, lock)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_PRIVATE",
          "args": [
            "snp",
            "lock"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_for_each_node_breadth_first",
          "args": [
            "ssp",
            "snp"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_init_levelspread",
          "args": [
            "levelspread",
            "num_rcu_lvl"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_levelspread",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/rcu.h",
          "lines": "288-309",
          "snippet": "static inline void rcu_init_levelspread(int *levelspread, const int *levelcnt)\n{\n\tint i;\n\n\tfor (i = 0; i < RCU_NUM_LVLS; i++)\n\t\tlevelspread[i] = INT_MIN;\n\tif (rcu_fanout_exact) {\n\t\tlevelspread[rcu_num_lvls - 1] = rcu_fanout_leaf;\n\t\tfor (i = rcu_num_lvls - 2; i >= 0; i--)\n\t\t\tlevelspread[i] = RCU_FANOUT;\n\t} else {\n\t\tint ccur;\n\t\tint cprv;\n\n\t\tcprv = nr_cpu_ids;\n\t\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\t\tccur = levelcnt[i];\n\t\t\tlevelspread[i] = (cprv + ccur - 1) / ccur;\n\t\t\tcprv = ccur;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/rcu_node_tree.h>",
            "#include <trace/events/rcu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_node_tree.h>\n#include <trace/events/rcu.h>\n\nstatic inline void rcu_init_levelspread(int *levelspread, const int *levelcnt)\n{\n\tint i;\n\n\tfor (i = 0; i < RCU_NUM_LVLS; i++)\n\t\tlevelspread[i] = INT_MIN;\n\tif (rcu_fanout_exact) {\n\t\tlevelspread[rcu_num_lvls - 1] = rcu_fanout_leaf;\n\t\tfor (i = rcu_num_lvls - 2; i >= 0; i--)\n\t\t\tlevelspread[i] = RCU_FANOUT;\n\t} else {\n\t\tint ccur;\n\t\tint cprv;\n\n\t\tcprv = nr_cpu_ids;\n\t\tfor (i = rcu_num_lvls - 1; i >= 0; i--) {\n\t\t\tccur = levelcnt[i];\n\t\t\tlevelspread[i] = (cprv + ccur - 1) / ccur;\n\t\t\tcprv = ccur;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_init_geometry",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_init_geometry",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "4592-4679",
          "snippet": "void rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tstatic unsigned long old_nr_cpu_ids;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\tstatic bool initialized;\n\n\tif (initialized) {\n\t\t/*\n\t\t * Warn if setup_nr_cpu_ids() had not yet been invoked,\n\t\t * unless nr_cpus_ids == NR_CPUS, in which case who cares?\n\t\t */\n\t\tWARN_ON_ONCE(old_nr_cpu_ids != nr_cpu_ids);\n\t\treturn;\n\t}\n\n\told_nr_cpu_ids = nr_cpu_ids;\n\tinitialized = true;\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int rcu_fanout_leaf = RCU_FANOUT_LEAF;",
            "int rcu_num_lvls",
            "int num_rcu_lvl[] = NUM_RCU_LVL_INIT;",
            "int rcu_num_nodes",
            "static ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;",
            "static ulong jiffies_till_next_fqs = ULONG_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int rcu_fanout_leaf = RCU_FANOUT_LEAF;\nint rcu_num_lvls;\nint num_rcu_lvl[] = NUM_RCU_LVL_INIT;\nint rcu_num_nodes;\nstatic ulong jiffies_till_first_fqs = IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD) ? 0 : ULONG_MAX;\nstatic ulong jiffies_till_next_fqs = ULONG_MAX;\n\nvoid rcu_init_geometry(void)\n{\n\tulong d;\n\tint i;\n\tstatic unsigned long old_nr_cpu_ids;\n\tint rcu_capacity[RCU_NUM_LVLS];\n\tstatic bool initialized;\n\n\tif (initialized) {\n\t\t/*\n\t\t * Warn if setup_nr_cpu_ids() had not yet been invoked,\n\t\t * unless nr_cpus_ids == NR_CPUS, in which case who cares?\n\t\t */\n\t\tWARN_ON_ONCE(old_nr_cpu_ids != nr_cpu_ids);\n\t\treturn;\n\t}\n\n\told_nr_cpu_ids = nr_cpu_ids;\n\tinitialized = true;\n\n\t/*\n\t * Initialize any unspecified boot parameters.\n\t * The default values of jiffies_till_first_fqs and\n\t * jiffies_till_next_fqs are set to the RCU_JIFFIES_TILL_FORCE_QS\n\t * value, which is a function of HZ, then adding one for each\n\t * RCU_JIFFIES_FQS_DIV CPUs that might be on the system.\n\t */\n\td = RCU_JIFFIES_TILL_FORCE_QS + nr_cpu_ids / RCU_JIFFIES_FQS_DIV;\n\tif (jiffies_till_first_fqs == ULONG_MAX)\n\t\tjiffies_till_first_fqs = d;\n\tif (jiffies_till_next_fqs == ULONG_MAX)\n\t\tjiffies_till_next_fqs = d;\n\tadjust_jiffies_till_sched_qs();\n\n\t/* If the compile-time values are accurate, just leave. */\n\tif (rcu_fanout_leaf == RCU_FANOUT_LEAF &&\n\t    nr_cpu_ids == NR_CPUS)\n\t\treturn;\n\tpr_info(\"Adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%u\\n\",\n\t\trcu_fanout_leaf, nr_cpu_ids);\n\n\t/*\n\t * The boot-time rcu_fanout_leaf parameter must be at least two\n\t * and cannot exceed the number of bits in the rcu_node masks.\n\t * Complain and fall back to the compile-time values if this\n\t * limit is exceeded.\n\t */\n\tif (rcu_fanout_leaf < 2 ||\n\t    rcu_fanout_leaf > sizeof(unsigned long) * 8) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/*\n\t * Compute number of nodes that can be handled an rcu_node tree\n\t * with the given number of levels.\n\t */\n\trcu_capacity[0] = rcu_fanout_leaf;\n\tfor (i = 1; i < RCU_NUM_LVLS; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * RCU_FANOUT;\n\n\t/*\n\t * The tree must be able to accommodate the configured number of CPUs.\n\t * If this limit is exceeded, fall back to the compile-time values.\n\t */\n\tif (nr_cpu_ids > rcu_capacity[RCU_NUM_LVLS - 1]) {\n\t\trcu_fanout_leaf = RCU_FANOUT_LEAF;\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t/* Calculate the number of levels in the tree. */\n\tfor (i = 0; nr_cpu_ids > rcu_capacity[i]; i++) {\n\t}\n\trcu_num_lvls = i + 1;\n\n\t/* Calculate the number of rcu_nodes at each level of the tree. */\n\tfor (i = 0; i < rcu_num_lvls; i++) {\n\t\tint cap = rcu_capacity[(rcu_num_lvls - 1) - i];\n\t\tnum_rcu_lvl[i] = DIV_ROUND_UP(nr_cpu_ids, cap);\n\t}\n\n\t/* Calculate the total number of rcu_node structures. */\n\trcu_num_nodes = 0;\n\tfor (i = 0; i < rcu_num_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nstatic void srcu_invoke_callbacks(struct work_struct *work);\nstatic void process_srcu(struct work_struct *work);\n\nstatic void init_srcu_struct_nodes(struct srcu_struct *ssp)\n{\n\tint cpu;\n\tint i;\n\tint level = 0;\n\tint levelspread[RCU_NUM_LVLS];\n\tstruct srcu_data *sdp;\n\tstruct srcu_node *snp;\n\tstruct srcu_node *snp_first;\n\n\t/* Initialize geometry if it has not already been initialized. */\n\trcu_init_geometry();\n\n\t/* Work out the overall tree geometry. */\n\tssp->level[0] = &ssp->node[0];\n\tfor (i = 1; i < rcu_num_lvls; i++)\n\t\tssp->level[i] = ssp->level[i - 1] + num_rcu_lvl[i - 1];\n\trcu_init_levelspread(levelspread, num_rcu_lvl);\n\n\t/* Each pass through this loop initializes one srcu_node structure. */\n\tsrcu_for_each_node_breadth_first(ssp, snp) {\n\t\tspin_lock_init(&ACCESS_PRIVATE(snp, lock));\n\t\tWARN_ON_ONCE(ARRAY_SIZE(snp->srcu_have_cbs) !=\n\t\t\t     ARRAY_SIZE(snp->srcu_data_have_cbs));\n\t\tfor (i = 0; i < ARRAY_SIZE(snp->srcu_have_cbs); i++) {\n\t\t\tsnp->srcu_have_cbs[i] = 0;\n\t\t\tsnp->srcu_data_have_cbs[i] = 0;\n\t\t}\n\t\tsnp->srcu_gp_seq_needed_exp = 0;\n\t\tsnp->grplo = -1;\n\t\tsnp->grphi = -1;\n\t\tif (snp == &ssp->node[0]) {\n\t\t\t/* Root node, special case. */\n\t\t\tsnp->srcu_parent = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Non-root node. */\n\t\tif (snp == ssp->level[level + 1])\n\t\t\tlevel++;\n\t\tsnp->srcu_parent = ssp->level[level - 1] +\n\t\t\t\t   (snp - ssp->level[level]) /\n\t\t\t\t   levelspread[level - 1];\n\t}\n\n\t/*\n\t * Initialize the per-CPU srcu_data array, which feeds into the\n\t * leaves of the srcu_node tree.\n\t */\n\tWARN_ON_ONCE(ARRAY_SIZE(sdp->srcu_lock_count) !=\n\t\t     ARRAY_SIZE(sdp->srcu_unlock_count));\n\tlevel = rcu_num_lvls - 1;\n\tsnp_first = ssp->level[level];\n\tfor_each_possible_cpu(cpu) {\n\t\tsdp = per_cpu_ptr(ssp->sda, cpu);\n\t\tspin_lock_init(&ACCESS_PRIVATE(sdp, lock));\n\t\trcu_segcblist_init(&sdp->srcu_cblist);\n\t\tsdp->srcu_cblist_invoking = false;\n\t\tsdp->srcu_gp_seq_needed = ssp->srcu_gp_seq;\n\t\tsdp->srcu_gp_seq_needed_exp = ssp->srcu_gp_seq;\n\t\tsdp->mynode = &snp_first[cpu / levelspread[level]];\n\t\tfor (snp = sdp->mynode; snp != NULL; snp = snp->srcu_parent) {\n\t\t\tif (snp->grplo < 0)\n\t\t\t\tsnp->grplo = cpu;\n\t\t\tsnp->grphi = cpu;\n\t\t}\n\t\tsdp->cpu = cpu;\n\t\tINIT_WORK(&sdp->work, srcu_invoke_callbacks);\n\t\ttimer_setup(&sdp->delay_work, srcu_delay_timer, 0);\n\t\tsdp->ssp = ssp;\n\t\tsdp->grpmask = 1 << (cpu - sdp->mynode->grplo);\n\t}\n}"
  }
]