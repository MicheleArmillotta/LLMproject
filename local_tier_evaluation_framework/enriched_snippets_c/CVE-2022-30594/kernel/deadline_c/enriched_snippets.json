[
  {
    "function_name": "print_dl_stats",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "3033-3036",
    "snippet": "void print_dl_stats(struct seq_file *m, int cpu)\n{\n\tprint_dl_rq(m, cpu, &cpu_rq(cpu)->dl);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_dl_rq",
          "args": [
            "m",
            "cpu",
            "&cpu_rq(cpu)->dl"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "print_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/debug.c",
          "lines": "693-714",
          "snippet": "void print_dl_rq(struct seq_file *m, int cpu, struct dl_rq *dl_rq)\n{\n\tstruct dl_bw *dl_bw;\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"dl_rq[%d]:\\n\", cpu);\n\n#define PU(x) \\\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", #x, (unsigned long)(dl_rq->x))\n\n\tPU(dl_nr_running);\n#ifdef CONFIG_SMP\n\tPU(dl_nr_migratory);\n\tdl_bw = &cpu_rq(cpu)->rd->dl_bw;\n#else\n\tdl_bw = &dl_rq->dl_bw;\n#endif\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->bw\", dl_bw->bw);\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->total_bw\", dl_bw->total_bw);\n\n#undef PU\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid print_dl_rq(struct seq_file *m, int cpu, struct dl_rq *dl_rq)\n{\n\tstruct dl_bw *dl_bw;\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"dl_rq[%d]:\\n\", cpu);\n\n#define PU(x) \\\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", #x, (unsigned long)(dl_rq->x))\n\n\tPU(dl_nr_running);\n#ifdef CONFIG_SMP\n\tPU(dl_nr_migratory);\n\tdl_bw = &cpu_rq(cpu)->rd->dl_bw;\n#else\n\tdl_bw = &dl_rq->dl_bw;\n#endif\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->bw\", dl_bw->bw);\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->total_bw\", dl_bw->total_bw);\n\n#undef PU\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 3035
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nvoid print_dl_stats(struct seq_file *m, int cpu)\n{\n\tprint_dl_rq(m, cpu, &cpu_rq(cpu)->dl);\n}"
  },
  {
    "function_name": "dl_cpu_busy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "3014-3029",
    "snippet": "bool dl_cpu_busy(unsigned int cpu)\n{\n\tunsigned long flags, cap;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcap = dl_bw_capacity(cpu);\n\toverflow = __dl_overflow(dl_b, cap, 0, 0);\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn overflow;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 3026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_overflow",
          "args": [
            "dl_b",
            "cap",
            "0",
            "0"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_overflow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "320-325",
          "snippet": "static inline bool __dl_overflow(struct dl_bw *dl_b, unsigned long cap,\n\t\t\t\t u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       cap_scale(dl_b->bw, cap) < dl_b->total_bw - old_bw + new_bw;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void __dl_update(struct dl_bw *dl_b, s64 bw);",
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void __dl_update(struct dl_bw *dl_b, s64 bw);\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline bool __dl_overflow(struct dl_bw *dl_b, unsigned long cap,\n\t\t\t\t u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       cap_scale(dl_b->bw, cap) < dl_b->total_bw - old_bw + new_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_capacity",
          "args": [
            "cpu"
          ],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_capacity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "144-147",
          "snippet": "static inline unsigned long dl_bw_capacity(int i)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline unsigned long dl_bw_capacity(int i)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpu"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "134-137",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nbool dl_cpu_busy(unsigned int cpu)\n{\n\tunsigned long flags, cap;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcap = dl_bw_capacity(cpu);\n\toverflow = __dl_overflow(dl_b, cap, 0, 0);\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn overflow;\n}"
  },
  {
    "function_name": "dl_cpuset_cpumask_can_shrink",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2993-3012",
    "snippet": "int dl_cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t\t const struct cpumask *trial)\n{\n\tint ret = 1, trial_cpus;\n\tstruct dl_bw *cur_dl_b;\n\tunsigned long flags;\n\n\trcu_read_lock_sched();\n\tcur_dl_b = dl_bw_of(cpumask_any(cur));\n\ttrial_cpus = cpumask_weight(trial);\n\n\traw_spin_lock_irqsave(&cur_dl_b->lock, flags);\n\tif (cur_dl_b->bw != -1 &&\n\t    cur_dl_b->bw * trial_cpus < cur_dl_b->total_bw)\n\t\tret = 0;\n\traw_spin_unlock_irqrestore(&cur_dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cur_dl_b->lock",
            "flags"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cur_dl_b->lock",
            "flags"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "trial"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpumask_any(cur)"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "134-137",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any",
          "args": [
            "cur"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nint dl_cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t\t const struct cpumask *trial)\n{\n\tint ret = 1, trial_cpus;\n\tstruct dl_bw *cur_dl_b;\n\tunsigned long flags;\n\n\trcu_read_lock_sched();\n\tcur_dl_b = dl_bw_of(cpumask_any(cur));\n\ttrial_cpus = cpumask_weight(trial);\n\n\traw_spin_lock_irqsave(&cur_dl_b->lock, flags);\n\tif (cur_dl_b->bw != -1 &&\n\t    cur_dl_b->bw * trial_cpus < cur_dl_b->total_bw)\n\t\tret = 0;\n\traw_spin_unlock_irqrestore(&cur_dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dl_task_can_attach",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2958-2991",
    "snippet": "int dl_task_can_attach(struct task_struct *p, const struct cpumask *cs_cpus_allowed)\n{\n\tunsigned long flags, cap;\n\tunsigned int dest_cpu;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\tint ret;\n\n\tdest_cpu = cpumask_any_and(cpu_active_mask, cs_cpus_allowed);\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(dest_cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcap = dl_bw_capacity(dest_cpu);\n\toverflow = __dl_overflow(dl_b, cap, 0, p->dl.dl_bw);\n\tif (overflow) {\n\t\tret = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * We reserve space for this task in the destination\n\t\t * root_domain, as we can't fail after this point.\n\t\t * We will free resources in the source root_domain\n\t\t * later on (see set_cpus_allowed_dl()).\n\t\t */\n\t\tint cpus = dl_bw_cpus(dest_cpu);\n\n\t\t__dl_add(dl_b, p->dl.dl_bw, cpus);\n\t\tret = 0;\n\t}\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2987
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_add",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "cpus"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "313-318",
          "snippet": "static inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "dest_cpu"
          ],
          "line": 2982
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "139-142",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_overflow",
          "args": [
            "dl_b",
            "cap",
            "0",
            "p->dl.dl_bw"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_overflow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "320-325",
          "snippet": "static inline bool __dl_overflow(struct dl_bw *dl_b, unsigned long cap,\n\t\t\t\t u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       cap_scale(dl_b->bw, cap) < dl_b->total_bw - old_bw + new_bw;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void __dl_update(struct dl_bw *dl_b, s64 bw);",
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void __dl_update(struct dl_bw *dl_b, s64 bw);\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline bool __dl_overflow(struct dl_bw *dl_b, unsigned long cap,\n\t\t\t\t u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       cap_scale(dl_b->bw, cap) < dl_b->total_bw - old_bw + new_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_capacity",
          "args": [
            "dest_cpu"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_capacity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "144-147",
          "snippet": "static inline unsigned long dl_bw_capacity(int i)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline unsigned long dl_bw_capacity(int i)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "dest_cpu"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "134-137",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "cpu_active_mask",
            "cs_cpus_allowed"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nint dl_task_can_attach(struct task_struct *p, const struct cpumask *cs_cpus_allowed)\n{\n\tunsigned long flags, cap;\n\tunsigned int dest_cpu;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\tint ret;\n\n\tdest_cpu = cpumask_any_and(cpu_active_mask, cs_cpus_allowed);\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(dest_cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcap = dl_bw_capacity(dest_cpu);\n\toverflow = __dl_overflow(dl_b, cap, 0, p->dl.dl_bw);\n\tif (overflow) {\n\t\tret = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * We reserve space for this task in the destination\n\t\t * root_domain, as we can't fail after this point.\n\t\t * We will free resources in the source root_domain\n\t\t * later on (see set_cpus_allowed_dl()).\n\t\t */\n\t\tint cpus = dl_bw_cpus(dest_cpu);\n\n\t\t__dl_add(dl_b, p->dl.dl_bw, cpus);\n\t\tret = 0;\n\t}\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dl_param_changed",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2944-2955",
    "snippet": "bool dl_param_changed(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tif (dl_se->dl_runtime != attr->sched_runtime ||\n\t    dl_se->dl_deadline != attr->sched_deadline ||\n\t    dl_se->dl_period != attr->sched_period ||\n\t    dl_se->flags != (attr->sched_flags & SCHED_DL_FLAGS))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nbool dl_param_changed(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tif (dl_se->dl_runtime != attr->sched_runtime ||\n\t    dl_se->dl_deadline != attr->sched_deadline ||\n\t    dl_se->dl_period != attr->sched_period ||\n\t    dl_se->flags != (attr->sched_flags & SCHED_DL_FLAGS))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "__dl_clear_params",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2923-2942",
    "snippet": "void __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n\n#ifdef CONFIG_RT_MUTEXES\n\tdl_se->pi_se\t\t\t= dl_se;\n#endif\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nvoid __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n\n#ifdef CONFIG_RT_MUTEXES\n\tdl_se->pi_se\t\t\t= dl_se;\n#endif\n}"
  },
  {
    "function_name": "__checkparam_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2875-2918",
    "snippet": "bool __checkparam_dl(const struct sched_attr *attr)\n{\n\tu64 period, max, min;\n\n\t/* special dl tasks don't actually use any parameter */\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn true;\n\n\t/* deadline != 0 */\n\tif (attr->sched_deadline == 0)\n\t\treturn false;\n\n\t/*\n\t * Since we truncate DL_SCALE bits, make sure we're at least\n\t * that big.\n\t */\n\tif (attr->sched_runtime < (1ULL << DL_SCALE))\n\t\treturn false;\n\n\t/*\n\t * Since we use the MSB for wrap-around and sign issues, make\n\t * sure it's not set (mind that period can be equal to zero).\n\t */\n\tif (attr->sched_deadline & (1ULL << 63) ||\n\t    attr->sched_period & (1ULL << 63))\n\t\treturn false;\n\n\tperiod = attr->sched_period;\n\tif (!period)\n\t\tperiod = attr->sched_deadline;\n\n\t/* runtime <= deadline <= period (if period != 0) */\n\tif (period < attr->sched_deadline ||\n\t    attr->sched_deadline < attr->sched_runtime)\n\t\treturn false;\n\n\tmax = (u64)READ_ONCE(sysctl_sched_dl_period_max) * NSEC_PER_USEC;\n\tmin = (u64)READ_ONCE(sysctl_sched_dl_period_min) * NSEC_PER_USEC;\n\n\tif (period < min || period > max)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};",
      "unsigned int sysctl_sched_dl_period_max = 1 << 22;",
      "unsigned int sysctl_sched_dl_period_min = 100;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sysctl_sched_dl_period_min"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sysctl_sched_dl_period_max"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\nunsigned int sysctl_sched_dl_period_max = 1 << 22;\nunsigned int sysctl_sched_dl_period_min = 100;\n\nbool __checkparam_dl(const struct sched_attr *attr)\n{\n\tu64 period, max, min;\n\n\t/* special dl tasks don't actually use any parameter */\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn true;\n\n\t/* deadline != 0 */\n\tif (attr->sched_deadline == 0)\n\t\treturn false;\n\n\t/*\n\t * Since we truncate DL_SCALE bits, make sure we're at least\n\t * that big.\n\t */\n\tif (attr->sched_runtime < (1ULL << DL_SCALE))\n\t\treturn false;\n\n\t/*\n\t * Since we use the MSB for wrap-around and sign issues, make\n\t * sure it's not set (mind that period can be equal to zero).\n\t */\n\tif (attr->sched_deadline & (1ULL << 63) ||\n\t    attr->sched_period & (1ULL << 63))\n\t\treturn false;\n\n\tperiod = attr->sched_period;\n\tif (!period)\n\t\tperiod = attr->sched_deadline;\n\n\t/* runtime <= deadline <= period (if period != 0) */\n\tif (period < attr->sched_deadline ||\n\t    attr->sched_deadline < attr->sched_runtime)\n\t\treturn false;\n\n\tmax = (u64)READ_ONCE(sysctl_sched_dl_period_max) * NSEC_PER_USEC;\n\tmin = (u64)READ_ONCE(sysctl_sched_dl_period_min) * NSEC_PER_USEC;\n\n\tif (period < min || period > max)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "__getparam_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2845-2855",
    "snippet": "void __getparam_dl(struct task_struct *p, struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tattr->sched_priority = p->rt_priority;\n\tattr->sched_runtime = dl_se->dl_runtime;\n\tattr->sched_deadline = dl_se->dl_deadline;\n\tattr->sched_period = dl_se->dl_period;\n\tattr->sched_flags &= ~SCHED_DL_FLAGS;\n\tattr->sched_flags |= dl_se->flags;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nvoid __getparam_dl(struct task_struct *p, struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tattr->sched_priority = p->rt_priority;\n\tattr->sched_runtime = dl_se->dl_runtime;\n\tattr->sched_deadline = dl_se->dl_deadline;\n\tattr->sched_period = dl_se->dl_period;\n\tattr->sched_flags &= ~SCHED_DL_FLAGS;\n\tattr->sched_flags |= dl_se->flags;\n}"
  },
  {
    "function_name": "__setparam_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2833-2843",
    "snippet": "void __setparam_dl(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime = attr->sched_runtime;\n\tdl_se->dl_deadline = attr->sched_deadline;\n\tdl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;\n\tdl_se->flags = attr->sched_flags & SCHED_DL_FLAGS;\n\tdl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);\n\tdl_se->dl_density = to_ratio(dl_se->dl_deadline, dl_se->dl_runtime);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "dl_se->dl_deadline",
            "dl_se->dl_runtime"
          ],
          "line": 2842
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4468-4482",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nvoid __setparam_dl(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime = attr->sched_runtime;\n\tdl_se->dl_deadline = attr->sched_deadline;\n\tdl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;\n\tdl_se->flags = attr->sched_flags & SCHED_DL_FLAGS;\n\tdl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);\n\tdl_se->dl_density = to_ratio(dl_se->dl_deadline, dl_se->dl_runtime);\n}"
  },
  {
    "function_name": "sched_dl_overflow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2767-2823",
    "snippet": "int sched_dl_overflow(struct task_struct *p, int policy,\n\t\t      const struct sched_attr *attr)\n{\n\tu64 period = attr->sched_period ?: attr->sched_deadline;\n\tu64 runtime = attr->sched_runtime;\n\tu64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0;\n\tint cpus, err = -1, cpu = task_cpu(p);\n\tstruct dl_bw *dl_b = dl_bw_of(cpu);\n\tunsigned long cap;\n\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn 0;\n\n\t/* !deadline task may carry old deadline bandwidth */\n\tif (new_bw == p->dl.dl_bw && task_has_dl_policy(p))\n\t\treturn 0;\n\n\t/*\n\t * Either if a task, enters, leave, or stays -deadline but changes\n\t * its parameters, we may need to update accordingly the total\n\t * allocated bandwidth of the container.\n\t */\n\traw_spin_lock(&dl_b->lock);\n\tcpus = dl_bw_cpus(cpu);\n\tcap = dl_bw_capacity(cpu);\n\n\tif (dl_policy(policy) && !task_has_dl_policy(p) &&\n\t    !__dl_overflow(dl_b, cap, 0, new_bw)) {\n\t\tif (hrtimer_active(&p->dl.inactive_timer))\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\terr = 0;\n\t} else if (dl_policy(policy) && task_has_dl_policy(p) &&\n\t\t   !__dl_overflow(dl_b, cap, p->dl.dl_bw, new_bw)) {\n\t\t/*\n\t\t * XXX this is slightly incorrect: when the task\n\t\t * utilization decreases, we should delay the total\n\t\t * utilization change until the task's 0-lag point.\n\t\t * But this would require to set the task's \"inactive\n\t\t * timer\" when the task is not inactive.\n\t\t */\n\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\tdl_change_utilization(p, new_bw);\n\t\terr = 0;\n\t} else if (!dl_policy(policy) && task_has_dl_policy(p)) {\n\t\t/*\n\t\t * Do not decrease the total deadline utilization here,\n\t\t * switched_from_dl() will take care to do it at the correct\n\t\t * (0-lag) time.\n\t\t */\n\t\terr = 0;\n\t}\n\traw_spin_unlock(&dl_b->lock);\n\n\treturn err;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_has_dl_policy",
          "args": [
            "p"
          ],
          "line": 2812
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_dl_policy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "195-198",
          "snippet": "static inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_change_utilization",
          "args": [
            "p",
            "new_bw"
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "dl_change_utilization",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "233-258",
          "snippet": "static void dl_change_utilization(struct task_struct *p, u64 new_bw)\n{\n\tstruct rq *rq;\n\n\tBUG_ON(p->dl.flags & SCHED_FLAG_SUGOV);\n\n\tif (task_on_rq_queued(p))\n\t\treturn;\n\n\trq = task_rq(p);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\t__sub_rq_bw(p->dl.dl_bw, &rq->dl);\n\t__add_rq_bw(new_bw, &rq->dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void dl_change_utilization(struct task_struct *p, u64 new_bw)\n{\n\tstruct rq *rq;\n\n\tBUG_ON(p->dl.flags & SCHED_FLAG_SUGOV);\n\n\tif (task_on_rq_queued(p))\n\t\treturn;\n\n\trq = task_rq(p);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\t__sub_rq_bw(p->dl.dl_bw, &rq->dl);\n\t__add_rq_bw(new_bw, &rq->dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_add",
          "args": [
            "dl_b",
            "new_bw",
            "cpus"
          ],
          "line": 2809
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "313-318",
          "snippet": "static inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_sub",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "cpus"
          ],
          "line": 2808
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_sub",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "306-311",
          "snippet": "static inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_overflow",
          "args": [
            "dl_b",
            "cap",
            "p->dl.dl_bw",
            "new_bw"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_overflow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "320-325",
          "snippet": "static inline bool __dl_overflow(struct dl_bw *dl_b, unsigned long cap,\n\t\t\t\t u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       cap_scale(dl_b->bw, cap) < dl_b->total_bw - old_bw + new_bw;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void __dl_update(struct dl_bw *dl_b, s64 bw);",
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void __dl_update(struct dl_bw *dl_b, s64 bw);\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline bool __dl_overflow(struct dl_bw *dl_b, unsigned long cap,\n\t\t\t\t u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       cap_scale(dl_b->bw, cap) < dl_b->total_bw - old_bw + new_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "&p->dl.inactive_timer"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1604-1621",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_capacity",
          "args": [
            "cpu"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_capacity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "144-147",
          "snippet": "static inline unsigned long dl_bw_capacity(int i)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline unsigned long dl_bw_capacity(int i)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "cpu"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "139-142",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpu"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "134-137",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "period",
            "runtime"
          ],
          "line": 2772
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4468-4482",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nint sched_dl_overflow(struct task_struct *p, int policy,\n\t\t      const struct sched_attr *attr)\n{\n\tu64 period = attr->sched_period ?: attr->sched_deadline;\n\tu64 runtime = attr->sched_runtime;\n\tu64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0;\n\tint cpus, err = -1, cpu = task_cpu(p);\n\tstruct dl_bw *dl_b = dl_bw_of(cpu);\n\tunsigned long cap;\n\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn 0;\n\n\t/* !deadline task may carry old deadline bandwidth */\n\tif (new_bw == p->dl.dl_bw && task_has_dl_policy(p))\n\t\treturn 0;\n\n\t/*\n\t * Either if a task, enters, leave, or stays -deadline but changes\n\t * its parameters, we may need to update accordingly the total\n\t * allocated bandwidth of the container.\n\t */\n\traw_spin_lock(&dl_b->lock);\n\tcpus = dl_bw_cpus(cpu);\n\tcap = dl_bw_capacity(cpu);\n\n\tif (dl_policy(policy) && !task_has_dl_policy(p) &&\n\t    !__dl_overflow(dl_b, cap, 0, new_bw)) {\n\t\tif (hrtimer_active(&p->dl.inactive_timer))\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\terr = 0;\n\t} else if (dl_policy(policy) && task_has_dl_policy(p) &&\n\t\t   !__dl_overflow(dl_b, cap, p->dl.dl_bw, new_bw)) {\n\t\t/*\n\t\t * XXX this is slightly incorrect: when the task\n\t\t * utilization decreases, we should delay the total\n\t\t * utilization change until the task's 0-lag point.\n\t\t * But this would require to set the task's \"inactive\n\t\t * timer\" when the task is not inactive.\n\t\t */\n\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\tdl_change_utilization(p, new_bw);\n\t\terr = 0;\n\t} else if (!dl_policy(policy) && task_has_dl_policy(p)) {\n\t\t/*\n\t\t * Do not decrease the total deadline utilization here,\n\t\t * switched_from_dl() will take care to do it at the correct\n\t\t * (0-lag) time.\n\t\t */\n\t\terr = 0;\n\t}\n\traw_spin_unlock(&dl_b->lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "sched_dl_do_global",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2726-2757",
    "snippet": "void sched_dl_do_global(void)\n{\n\tu64 new_bw = -1;\n\tu64 gen = ++dl_generation;\n\tstruct dl_bw *dl_b;\n\tint cpu;\n\tunsigned long flags;\n\n\tdef_dl_bandwidth.dl_period = global_rt_period();\n\tdef_dl_bandwidth.dl_runtime = global_rt_runtime();\n\n\tif (global_rt_runtime() != RUNTIME_INF)\n\t\tnew_bw = to_ratio(global_rt_period(), global_rt_runtime());\n\n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\n\t\tif (dl_bw_visited(cpu, gen)) {\n\t\t\trcu_read_unlock_sched();\n\t\t\tcontinue;\n\t\t}\n\n\t\tdl_b = dl_bw_of(cpu);\n\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tdl_b->bw = new_bw;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\n\t\trcu_read_unlock_sched();\n\t\tinit_dl_rq_bw_ratio(&cpu_rq(cpu)->dl);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct dl_bandwidth def_dl_bandwidth;",
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};",
      "static u64 dl_generation;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_dl_rq_bw_ratio",
          "args": [
            "&cpu_rq(cpu)->dl"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_rq_bw_ratio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2713-2724",
          "snippet": "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpu"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "134-137",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 2744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_bw_visited",
          "args": [
            "cpu",
            "gen"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_visited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "149-152",
          "snippet": "static inline bool dl_bw_visited(int cpu, u64 gen)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool dl_bw_visited(int cpu, u64 gen)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "global_rt_period()",
            "global_rt_runtime()"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4468-4482",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_runtime",
          "args": [],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_runtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2022-2028",
          "snippet": "static inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RUNTIME_INF\t\t((u64)~0ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RUNTIME_INF\t\t((u64)~0ULL)\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_period",
          "args": [],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_period",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2017-2020",
          "snippet": "static inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstruct dl_bandwidth def_dl_bandwidth;\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\nstatic u64 dl_generation;\n\nvoid sched_dl_do_global(void)\n{\n\tu64 new_bw = -1;\n\tu64 gen = ++dl_generation;\n\tstruct dl_bw *dl_b;\n\tint cpu;\n\tunsigned long flags;\n\n\tdef_dl_bandwidth.dl_period = global_rt_period();\n\tdef_dl_bandwidth.dl_runtime = global_rt_runtime();\n\n\tif (global_rt_runtime() != RUNTIME_INF)\n\t\tnew_bw = to_ratio(global_rt_period(), global_rt_runtime());\n\n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\n\t\tif (dl_bw_visited(cpu, gen)) {\n\t\t\trcu_read_unlock_sched();\n\t\t\tcontinue;\n\t\t}\n\n\t\tdl_b = dl_bw_of(cpu);\n\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tdl_b->bw = new_bw;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\n\t\trcu_read_unlock_sched();\n\t\tinit_dl_rq_bw_ratio(&cpu_rq(cpu)->dl);\n\t}\n}"
  },
  {
    "function_name": "init_dl_rq_bw_ratio",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2713-2724",
    "snippet": "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "global_rt_period()",
            "global_rt_runtime()"
          ],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4468-4482",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_runtime",
          "args": [],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_runtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2022-2028",
          "snippet": "static inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RUNTIME_INF\t\t((u64)~0ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RUNTIME_INF\t\t((u64)~0ULL)\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_period",
          "args": [],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_period",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2017-2020",
          "snippet": "static inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}"
  },
  {
    "function_name": "sched_dl_global_validate",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2674-2711",
    "snippet": "int sched_dl_global_validate(void)\n{\n\tu64 runtime = global_rt_runtime();\n\tu64 period = global_rt_period();\n\tu64 new_bw = to_ratio(period, runtime);\n\tu64 gen = ++dl_generation;\n\tstruct dl_bw *dl_b;\n\tint cpu, cpus, ret = 0;\n\tunsigned long flags;\n\n\t/*\n\t * Here we want to check the bandwidth not being set to some\n\t * value smaller than the currently allocated bandwidth in\n\t * any of the root_domains.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\n\t\tif (dl_bw_visited(cpu, gen))\n\t\t\tgoto next;\n\n\t\tdl_b = dl_bw_of(cpu);\n\t\tcpus = dl_bw_cpus(cpu);\n\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tif (new_bw * cpus < dl_b->total_bw)\n\t\t\tret = -EBUSY;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\nnext:\n\t\trcu_read_unlock_sched();\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static u64 dl_generation;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2701
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "cpu"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "139-142",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpu"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "134-137",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_visited",
          "args": [
            "cpu",
            "gen"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_visited",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "149-152",
          "snippet": "static inline bool dl_bw_visited(int cpu, u64 gen)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool dl_bw_visited(int cpu, u64 gen)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "period",
            "runtime"
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4468-4482",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_period",
          "args": [],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_period",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2017-2020",
          "snippet": "static inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_runtime",
          "args": [],
          "line": 2676
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_runtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2022-2028",
          "snippet": "static inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RUNTIME_INF\t\t((u64)~0ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RUNTIME_INF\t\t((u64)~0ULL)\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic u64 dl_generation;\n\nint sched_dl_global_validate(void)\n{\n\tu64 runtime = global_rt_runtime();\n\tu64 period = global_rt_period();\n\tu64 new_bw = to_ratio(period, runtime);\n\tu64 gen = ++dl_generation;\n\tstruct dl_bw *dl_b;\n\tint cpu, cpus, ret = 0;\n\tunsigned long flags;\n\n\t/*\n\t * Here we want to check the bandwidth not being set to some\n\t * value smaller than the currently allocated bandwidth in\n\t * any of the root_domains.\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\n\t\tif (dl_bw_visited(cpu, gen))\n\t\t\tgoto next;\n\n\t\tdl_b = dl_bw_of(cpu);\n\t\tcpus = dl_bw_cpus(cpu);\n\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tif (new_bw * cpus < dl_b->total_bw)\n\t\t\tret = -EBUSY;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\nnext:\n\t\trcu_read_unlock_sched();\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "prio_changed_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2605-2635",
    "snippet": "static void prio_changed_dl(struct rq *rq, struct task_struct *p,\n\t\t\t    int oldprio)\n{\n\tif (task_on_rq_queued(p) || task_current(rq, p)) {\n#ifdef CONFIG_SMP\n\t\t/*\n\t\t * This might be too much, but unfortunately\n\t\t * we don't have the old deadline value, and\n\t\t * we can't argue if the task is increasing\n\t\t * or lowering its prio, so...\n\t\t */\n\t\tif (!rq->dl.overloaded)\n\t\t\tdeadline_queue_pull_task(rq);\n\n\t\t/*\n\t\t * If we now have a earlier deadline task than p,\n\t\t * then reschedule, provided p is still on this\n\t\t * runqueue.\n\t\t */\n\t\tif (dl_time_before(rq->dl.earliest_dl.curr, p->dl.deadline))\n\t\t\tresched_curr(rq);\n#else\n\t\t/*\n\t\t * Again, we don't know if p has a earlier\n\t\t * or later deadline, so let's blindly set a\n\t\t * (maybe not needed) rescheduling point.\n\t\t */\n\t\tresched_curr(rq);\n#endif /* CONFIG_SMP */\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "976-998",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "rq->dl.earliest_dl.curr",
            "p->dl.deadline"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deadline_queue_pull_task",
          "args": [
            "rq"
          ],
          "line": 2617
        },
        "resolved": true,
        "details": {
          "function_name": "deadline_queue_pull_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "699-701",
          "snippet": "static inline void deadline_queue_pull_task(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_pull_task(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2030-2033",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2044-2047",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void prio_changed_dl(struct rq *rq, struct task_struct *p,\n\t\t\t    int oldprio)\n{\n\tif (task_on_rq_queued(p) || task_current(rq, p)) {\n#ifdef CONFIG_SMP\n\t\t/*\n\t\t * This might be too much, but unfortunately\n\t\t * we don't have the old deadline value, and\n\t\t * we can't argue if the task is increasing\n\t\t * or lowering its prio, so...\n\t\t */\n\t\tif (!rq->dl.overloaded)\n\t\t\tdeadline_queue_pull_task(rq);\n\n\t\t/*\n\t\t * If we now have a earlier deadline task than p,\n\t\t * then reschedule, provided p is still on this\n\t\t * runqueue.\n\t\t */\n\t\tif (dl_time_before(rq->dl.earliest_dl.curr, p->dl.deadline))\n\t\t\tresched_curr(rq);\n#else\n\t\t/*\n\t\t * Again, we don't know if p has a earlier\n\t\t * or later deadline, so let's blindly set a\n\t\t * (maybe not needed) rescheduling point.\n\t\t */\n\t\tresched_curr(rq);\n#endif /* CONFIG_SMP */\n\t}\n}"
  },
  {
    "function_name": "switched_to_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2575-2599",
    "snippet": "static void switched_to_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\tput_task_struct(p);\n\n\t/* If p is not queued we will update its parameters at next wakeup. */\n\tif (!task_on_rq_queued(p)) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\n\t\treturn;\n\t}\n\n\tif (rq->curr != p) {\n#ifdef CONFIG_SMP\n\t\tif (p->nr_cpus_allowed > 1 && rq->dl.overloaded)\n\t\t\tdeadline_queue_push_tasks(rq);\n#endif\n\t\tif (dl_task(rq->curr))\n\t\t\tcheck_preempt_curr_dl(rq, p, 0);\n\t\telse\n\t\t\tresched_curr(rq);\n\t} else {\n\t\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_dl_rq_load_avg",
          "args": [
            "rq_clock_pelt(rq)",
            "rq",
            "0"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_rq_load_avg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "171-175",
          "snippet": "static inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock_pelt",
          "args": [
            "rq"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "976-998",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_preempt_curr_dl",
          "args": [
            "rq",
            "p",
            "0"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_curr_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1880-1897",
          "snippet": "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "rq->curr"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deadline_queue_push_tasks",
          "args": [
            "rq"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "deadline_queue_push_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "695-697",
          "snippet": "static inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "add_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "205-210",
          "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2044-2047",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&p->dl.inactive_timer"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "823-826",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void switched_to_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\tput_task_struct(p);\n\n\t/* If p is not queued we will update its parameters at next wakeup. */\n\tif (!task_on_rq_queued(p)) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\n\t\treturn;\n\t}\n\n\tif (rq->curr != p) {\n#ifdef CONFIG_SMP\n\t\tif (p->nr_cpus_allowed > 1 && rq->dl.overloaded)\n\t\t\tdeadline_queue_push_tasks(rq);\n#endif\n\t\tif (dl_task(rq->curr))\n\t\t\tcheck_preempt_curr_dl(rq, p, 0);\n\t\telse\n\t\t\tresched_curr(rq);\n\t} else {\n\t\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);\n\t}\n}"
  },
  {
    "function_name": "switched_from_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2527-2569",
    "snippet": "static void switched_from_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * task_non_contending() can start the \"inactive timer\" (if the 0-lag\n\t * time is in the future). If the task switches back to dl before\n\t * the \"inactive timer\" fires, it can continue to consume its current\n\t * runtime using its current deadline. If it stays outside of\n\t * SCHED_DEADLINE until the 0-lag time passes, inactive_task_timer()\n\t * will reset the task parameters.\n\t */\n\tif (task_on_rq_queued(p) && p->dl.dl_runtime)\n\t\ttask_non_contending(p);\n\n\tif (!task_on_rq_queued(p)) {\n\t\t/*\n\t\t * Inactive timer is armed. However, p is leaving DEADLINE and\n\t\t * might migrate away from this rq while continuing to run on\n\t\t * some other class. We need to remove its contribution from\n\t\t * this rq running_bw now, or sub_rq_bw (below) will complain.\n\t\t */\n\t\tif (p->dl.dl_non_contending)\n\t\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * We cannot use inactive_task_timer() to invoke sub_running_bw()\n\t * at the 0-lag time, because the task could have been migrated\n\t * while SCHED_OTHER in the meanwhile.\n\t */\n\tif (p->dl.dl_non_contending)\n\t\tp->dl.dl_non_contending = 0;\n\n\t/*\n\t * Since this might be the only -deadline task on the rq,\n\t * this is the right place to try to pull some other one\n\t * from an overloaded CPU, if any.\n\t */\n\tif (!task_on_rq_queued(p) || rq->dl.dl_nr_running)\n\t\treturn;\n\n\tdeadline_queue_pull_task(rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deadline_queue_pull_task",
          "args": [
            "rq"
          ],
          "line": 2568
        },
        "resolved": true,
        "details": {
          "function_name": "deadline_queue_pull_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "699-701",
          "snippet": "static inline void deadline_queue_pull_task(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_pull_task(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2044-2047",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "212-217",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "226-231",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_non_contending",
          "args": [
            "p"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "task_non_contending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "314-368",
          "snippet": "static void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif ((zerolag_time < 0) || hrtimer_active(&dl_se->inactive_timer)) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (READ_ONCE(p->__state) == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL_HARD);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif ((zerolag_time < 0) || hrtimer_active(&dl_se->inactive_timer)) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (READ_ONCE(p->__state) == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL_HARD);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void switched_from_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * task_non_contending() can start the \"inactive timer\" (if the 0-lag\n\t * time is in the future). If the task switches back to dl before\n\t * the \"inactive timer\" fires, it can continue to consume its current\n\t * runtime using its current deadline. If it stays outside of\n\t * SCHED_DEADLINE until the 0-lag time passes, inactive_task_timer()\n\t * will reset the task parameters.\n\t */\n\tif (task_on_rq_queued(p) && p->dl.dl_runtime)\n\t\ttask_non_contending(p);\n\n\tif (!task_on_rq_queued(p)) {\n\t\t/*\n\t\t * Inactive timer is armed. However, p is leaving DEADLINE and\n\t\t * might migrate away from this rq while continuing to run on\n\t\t * some other class. We need to remove its contribution from\n\t\t * this rq running_bw now, or sub_rq_bw (below) will complain.\n\t\t */\n\t\tif (p->dl.dl_non_contending)\n\t\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * We cannot use inactive_task_timer() to invoke sub_running_bw()\n\t * at the 0-lag time, because the task could have been migrated\n\t * while SCHED_OTHER in the meanwhile.\n\t */\n\tif (p->dl.dl_non_contending)\n\t\tp->dl.dl_non_contending = 0;\n\n\t/*\n\t * Since this might be the only -deadline task on the rq,\n\t * this is the right place to try to pull some other one\n\t * from an overloaded CPU, if any.\n\t */\n\tif (!task_on_rq_queued(p) || rq->dl.dl_nr_running)\n\t\treturn;\n\n\tdeadline_queue_pull_task(rq);\n}"
  },
  {
    "function_name": "dl_clear_root_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2516-2523",
    "snippet": "void dl_clear_root_domain(struct root_domain *rd)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rd->dl_bw.lock, flags);\n\trd->dl_bw.total_bw = 0;\n\traw_spin_unlock_irqrestore(&rd->dl_bw.lock, flags);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&rd->dl_bw.lock",
            "flags"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&rd->dl_bw.lock",
            "flags"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid dl_clear_root_domain(struct root_domain *rd)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rd->dl_bw.lock, flags);\n\trd->dl_bw.total_bw = 0;\n\traw_spin_unlock_irqrestore(&rd->dl_bw.lock, flags);\n}"
  },
  {
    "function_name": "dl_add_task_root_domain",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2492-2514",
    "snippet": "void dl_add_task_root_domain(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tstruct dl_bw *dl_b;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\tif (!dl_task(p)) {\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf.flags);\n\t\treturn;\n\t}\n\n\trq = __task_rq_lock(p, &rf);\n\n\tdl_b = &rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\n\t__dl_add(dl_b, p->dl.dl_bw, cpumask_weight(rq->rd->span));\n\n\traw_spin_unlock(&dl_b->lock);\n\n\ttask_rq_unlock(rq, p, &rf);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1586-1594",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_add",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "cpumask_weight(rq->rd->span)"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "313-318",
          "snippet": "static inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "rq->rd->span"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "__task_rq_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "558-577",
          "snippet": "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tlockdep_assert_held(&p->pi_lock);\n\n\tfor (;;) {\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&p->pi_lock",
            "rf.flags"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&p->pi_lock",
            "rf.flags"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nvoid dl_add_task_root_domain(struct task_struct *p)\n{\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\tstruct dl_bw *dl_b;\n\n\traw_spin_lock_irqsave(&p->pi_lock, rf.flags);\n\tif (!dl_task(p)) {\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf.flags);\n\t\treturn;\n\t}\n\n\trq = __task_rq_lock(p, &rf);\n\n\tdl_b = &rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\n\t__dl_add(dl_b, p->dl.dl_bw, cpumask_weight(rq->rd->span));\n\n\traw_spin_unlock(&dl_b->lock);\n\n\ttask_rq_unlock(rq, p, &rf);\n}"
  },
  {
    "function_name": "init_sched_dl_class",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2483-2490",
    "snippet": "void __init init_sched_dl_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask_dl, i),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(i));\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid __init init_sched_dl_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask_dl, i),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(i));\n}"
  },
  {
    "function_name": "rq_offline_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2474-2481",
    "snippet": "static void rq_offline_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_clear_overload(rq);\n\n\tcpudl_clear(&rq->rd->cpudl, rq->cpu);\n\tcpudl_clear_freecpu(&rq->rd->cpudl, rq->cpu);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpudl_clear_freecpu",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_clear_freecpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "255-258",
          "snippet": "void cpudl_clear_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_clear_cpu(cpu, cp->free_cpus);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_clear_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_clear_cpu(cpu, cp->free_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_clear_overload",
          "args": [
            "rq"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "dl_clear_overload",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "478-485",
          "snippet": "static inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void rq_offline_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_clear_overload(rq);\n\n\tcpudl_clear(&rq->rd->cpudl, rq->cpu);\n\tcpudl_clear_freecpu(&rq->rd->cpudl, rq->cpu);\n}"
  },
  {
    "function_name": "rq_online_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2463-2471",
    "snippet": "static void rq_online_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_set_overload(rq);\n\n\tcpudl_set_freecpu(&rq->rd->cpudl, rq->cpu);\n\tif (rq->dl.dl_nr_running > 0)\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, rq->dl.earliest_dl.curr);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpudl_set",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu",
            "rq->dl.earliest_dl.curr"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "214-238",
          "snippet": "void cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpudl_set_freecpu",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu"
          ],
          "line": 2468
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_set_freecpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "245-248",
          "snippet": "void cpudl_set_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_set_cpu(cpu, cp->free_cpus);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_set_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_set_cpu(cpu, cp->free_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_set_overload",
          "args": [
            "rq"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "dl_set_overload",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "462-476",
          "snippet": "static inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void rq_online_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_set_overload(rq);\n\n\tcpudl_set_freecpu(&rq->rd->cpudl, rq->cpu);\n\tif (rq->dl.dl_nr_running > 0)\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, rq->dl.earliest_dl.curr);\n}"
  },
  {
    "function_name": "set_cpus_allowed_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2428-2460",
    "snippet": "static void set_cpus_allowed_dl(struct task_struct *p,\n\t\t\t\tconst struct cpumask *new_mask,\n\t\t\t\tu32 flags)\n{\n\tstruct root_domain *src_rd;\n\tstruct rq *rq;\n\n\tBUG_ON(!dl_task(p));\n\n\trq = task_rq(p);\n\tsrc_rd = rq->rd;\n\t/*\n\t * Migrating a SCHED_DEADLINE task between exclusive\n\t * cpusets (different root_domains) entails a bandwidth\n\t * update. We already made space for us in the destination\n\t * domain (see cpuset_can_attach()).\n\t */\n\tif (!cpumask_intersects(src_rd->span, new_mask)) {\n\t\tstruct dl_bw *src_dl_b;\n\n\t\tsrc_dl_b = dl_bw_of(cpu_of(rq));\n\t\t/*\n\t\t * We now free resources of the root_domain we are migrating\n\t\t * off. In the worst case, sched_setattr() may temporary fail\n\t\t * until we complete the update.\n\t\t */\n\t\traw_spin_lock(&src_dl_b->lock);\n\t\t__dl_sub(src_dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\traw_spin_unlock(&src_dl_b->lock);\n\t}\n\n\tset_cpus_allowed_common(p, new_mask, flags);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpus_allowed_common",
          "args": [
            "p",
            "new_mask",
            "flags"
          ],
          "line": 2459
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_common",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2476-2485",
          "snippet": "void set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask, u32 flags)\n{\n\tif (flags & (SCA_MIGRATE_ENABLE | SCA_MIGRATE_DISABLE)) {\n\t\tp->cpus_ptr = new_mask;\n\t\treturn;\n\t}\n\n\tcpumask_copy(&p->cpus_mask, new_mask);\n\tp->nr_cpus_allowed = cpumask_weight(new_mask);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask, u32 flags)\n{\n\tif (flags & (SCA_MIGRATE_ENABLE | SCA_MIGRATE_DISABLE)) {\n\t\tp->cpus_ptr = new_mask;\n\t\treturn;\n\t}\n\n\tcpumask_copy(&p->cpus_mask, new_mask);\n\tp->nr_cpus_allowed = cpumask_weight(new_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&src_dl_b->lock"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_sub",
          "args": [
            "src_dl_b",
            "p->dl.dl_bw",
            "dl_bw_cpus(task_cpu(p))"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_sub",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "306-311",
          "snippet": "static inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "task_cpu(p)"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "139-142",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 2455
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&src_dl_b->lock"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpu_of(rq)"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "134-137",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1137-1144",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "src_rd->span",
            "new_mask"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "is_task_rq_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5634-5637",
          "snippet": "static inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dl_task(p)"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void set_cpus_allowed_dl(struct task_struct *p,\n\t\t\t\tconst struct cpumask *new_mask,\n\t\t\t\tu32 flags)\n{\n\tstruct root_domain *src_rd;\n\tstruct rq *rq;\n\n\tBUG_ON(!dl_task(p));\n\n\trq = task_rq(p);\n\tsrc_rd = rq->rd;\n\t/*\n\t * Migrating a SCHED_DEADLINE task between exclusive\n\t * cpusets (different root_domains) entails a bandwidth\n\t * update. We already made space for us in the destination\n\t * domain (see cpuset_can_attach()).\n\t */\n\tif (!cpumask_intersects(src_rd->span, new_mask)) {\n\t\tstruct dl_bw *src_dl_b;\n\n\t\tsrc_dl_b = dl_bw_of(cpu_of(rq));\n\t\t/*\n\t\t * We now free resources of the root_domain we are migrating\n\t\t * off. In the worst case, sched_setattr() may temporary fail\n\t\t * until we complete the update.\n\t\t */\n\t\traw_spin_lock(&src_dl_b->lock);\n\t\t__dl_sub(src_dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\traw_spin_unlock(&src_dl_b->lock);\n\t}\n\n\tset_cpus_allowed_common(p, new_mask, flags);\n}"
  },
  {
    "function_name": "task_woken_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2416-2426",
    "snippet": "static void task_woken_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (!task_running(rq, p) &&\n\t    !test_tsk_need_resched(rq->curr) &&\n\t    p->nr_cpus_allowed > 1 &&\n\t    dl_task(rq->curr) &&\n\t    (rq->curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &rq->curr->dl))) {\n\t\tpush_dl_tasks(rq);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_dl_tasks",
          "args": [
            "rq"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "push_dl_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2313-2318",
          "snippet": "static void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_preempt",
          "args": [
            "&p->dl",
            "&rq->curr->dl"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_preempt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "243-248",
          "snippet": "static inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "rq->curr"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_tsk_need_resched",
          "args": [
            "rq->curr"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "p"
          ],
          "line": 2418
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2035-2042",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void task_woken_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (!task_running(rq, p) &&\n\t    !test_tsk_need_resched(rq->curr) &&\n\t    p->nr_cpus_allowed > 1 &&\n\t    dl_task(rq->curr) &&\n\t    (rq->curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &rq->curr->dl))) {\n\t\tpush_dl_tasks(rq);\n\t}\n}"
  },
  {
    "function_name": "pull_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2320-2410",
    "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "this_rq"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "976-998",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_rq_lock",
          "args": [
            "this_rq"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_rq_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1333-1339",
          "snippet": "static inline unsigned long _raw_spin_rq_lock_irqsave(struct rq *rq)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\traw_spin_rq_lock(rq);\n\treturn flags;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline unsigned long _raw_spin_rq_lock_irqsave(struct rq *rq)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\traw_spin_rq_lock(rq);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stop_one_cpu_nowait",
          "args": [
            "src_rq->cpu",
            "push_cpu_stop",
            "push_task",
            "&src_rq->push_work"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "stop_one_cpu_nowait",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/stop_machine.c",
          "lines": "384-389",
          "snippet": "bool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,\n\t\t\tstruct cpu_stop_work *work_buf)\n{\n\t*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, .caller = _RET_IP_, };\n\treturn cpu_stop_queue_work(cpu, work_buf);\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n#include <linux/compiler.h>\n\nbool stop_one_cpu_nowait(unsigned int cpu, cpu_stop_fn_t fn, void *arg,\n\t\t\tstruct cpu_stop_work *work_buf)\n{\n\t*work_buf = (struct cpu_stop_work){ .fn = fn, .arg = arg, .caller = _RET_IP_, };\n\treturn cpu_stop_queue_work(cpu, work_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_rq_unlock",
          "args": [
            "this_rq"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "raw_spin_rq_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "531-534",
          "snippet": "void raw_spin_rq_unlock(struct rq *rq)\n{\n\traw_spin_unlock(rq_lockp(rq));\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid raw_spin_rq_unlock(struct rq *rq)\n{\n\traw_spin_unlock(rq_lockp(rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_unlock_balance",
          "args": [
            "this_rq",
            "src_rq"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "double_unlock_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2597-2603",
          "snippet": "static inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\tif (__rq_lockp(this_rq) != __rq_lockp(busiest))\n\t\traw_spin_rq_unlock(busiest);\n\tlock_set_subclass(&__rq_lockp(this_rq)->dep_map, 0, _RET_IP_);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\tif (__rq_lockp(this_rq) != __rq_lockp(busiest))\n\t\traw_spin_rq_unlock(busiest);\n\tlock_set_subclass(&__rq_lockp(this_rq)->dep_map, 0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "activate_task",
          "args": [
            "this_rq",
            "p",
            "0"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2040-2045",
          "snippet": "void deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tp->on_rq = (flags & DEQUEUE_SLEEP) ? 0 : TASK_ON_RQ_MIGRATING;\n\n\tdequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tp->on_rq = (flags & DEQUEUE_SLEEP) ? 0 : TASK_ON_RQ_MIGRATING;\n\n\tdequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_cpu",
          "args": [
            "p",
            "this_cpu"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "set_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3026-3079",
          "snippet": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tunsigned int state = READ_ONCE(p->__state);\n\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(state != TASK_RUNNING && state != TASK_WAKING && !p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(__rq_lockp(task_rq(p)))));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n\n\tWARN_ON_ONCE(is_migration_disabled(p));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tunsigned int state = READ_ONCE(p->__state);\n\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(state != TASK_RUNNING && state != TASK_WAKING && !p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(__rq_lockp(task_rq(p)))));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n\n\tWARN_ON_ONCE(is_migration_disabled(p));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_push_task",
          "args": [
            "src_rq"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "get_push_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2268-2285",
          "snippet": "static inline struct task_struct *get_push_task(struct rq *rq)\n{\n\tstruct task_struct *p = rq->curr;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->push_busy)\n\t\treturn NULL;\n\n\tif (p->nr_cpus_allowed == 1)\n\t\treturn NULL;\n\n\tif (p->migration_disabled)\n\t\treturn NULL;\n\n\trq->push_busy = true;\n\treturn get_task_struct(p);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline struct task_struct *get_push_task(struct rq *rq)\n{\n\tstruct task_struct *p = rq->curr;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->push_busy)\n\t\treturn NULL;\n\n\tif (p->nr_cpus_allowed == 1)\n\t\treturn NULL;\n\n\tif (p->migration_disabled)\n\t\treturn NULL;\n\n\trq->push_busy = true;\n\treturn get_task_struct(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_migration_disabled",
          "args": [
            "p"
          ],
          "line": 2385
        },
        "resolved": true,
        "details": {
          "function_name": "is_migration_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1148-1155",
          "snippet": "static inline bool is_migration_disabled(struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->migration_disabled;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline bool is_migration_disabled(struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->migration_disabled;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "p->dl.deadline",
            "src_rq->curr->dl.deadline"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!task_on_rq_queued(p)"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2044-2047",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "p == src_rq->curr"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "p->dl.deadline",
            "this_rq->dl.earliest_dl.curr"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "p->dl.deadline",
            "dmin"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pick_earliest_pushable_dl_task",
          "args": [
            "src_rq",
            "this_cpu"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "pick_earliest_pushable_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2035-2055",
          "snippet": "static struct task_struct *pick_earliest_pushable_dl_task(struct rq *rq, int cpu)\n{\n\tstruct rb_node *next_node = rq->dl.pushable_dl_tasks_root.rb_leftmost;\n\tstruct task_struct *p = NULL;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\nnext_node:\n\tif (next_node) {\n\t\tp = rb_entry(next_node, struct task_struct, pushable_dl_tasks);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tnext_node = rb_next(next_node);\n\t\tgoto next_node;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct task_struct *pick_earliest_pushable_dl_task(struct rq *rq, int cpu)\n{\n\tstruct rb_node *next_node = rq->dl.pushable_dl_tasks_root.rb_leftmost;\n\tstruct task_struct *p = NULL;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\nnext_node:\n\tif (next_node) {\n\t\tp = rb_entry(next_node, struct task_struct, pushable_dl_tasks);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tnext_node = rb_next(next_node);\n\t\tgoto next_node;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_lock_balance",
          "args": [
            "this_rq",
            "src_rq"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "double_lock_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2590-2595",
          "snippet": "static inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tlockdep_assert_irqs_disabled();\n\n\treturn _double_lock_balance(this_rq, busiest);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tlockdep_assert_irqs_disabled();\n\n\treturn _double_lock_balance(this_rq, busiest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "this_rq->dl.earliest_dl.curr",
            "src_rq->dl.earliest_dl.next"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "this_rq->rd->dlo_mask"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!dl_overloaded(this_rq)"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_overloaded",
          "args": [
            "this_rq"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "dl_overloaded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "457-460",
          "snippet": "static inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
  },
  {
    "function_name": "push_dl_tasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2313-2318",
    "snippet": "static void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_dl_task",
          "args": [
            "rq"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "push_dl_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2313-2318",
          "snippet": "static void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}"
  },
  {
    "function_name": "push_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2229-2311",
    "snippet": "static int push_dl_task(struct rq *rq)\n{\n\tstruct task_struct *next_task;\n\tstruct rq *later_rq;\n\tint ret = 0;\n\n\tif (!rq->dl.overloaded)\n\t\treturn 0;\n\n\tnext_task = pick_next_pushable_dl_task(rq);\n\tif (!next_task)\n\t\treturn 0;\n\nretry:\n\tif (is_migration_disabled(next_task))\n\t\treturn 0;\n\n\tif (WARN_ON(next_task == rq->curr))\n\t\treturn 0;\n\n\t/*\n\t * If next_task preempts rq->curr, and rq->curr\n\t * can move away, it makes sense to just reschedule\n\t * without going further in pushing next_task.\n\t */\n\tif (dl_task(rq->curr) &&\n\t    dl_time_before(next_task->dl.deadline, rq->curr->dl.deadline) &&\n\t    rq->curr->nr_cpus_allowed > 1) {\n\t\tresched_curr(rq);\n\t\treturn 0;\n\t}\n\n\t/* We might release rq lock */\n\tget_task_struct(next_task);\n\n\t/* Will lock the rq it'll find */\n\tlater_rq = find_lock_later_rq(next_task, rq);\n\tif (!later_rq) {\n\t\tstruct task_struct *task;\n\n\t\t/*\n\t\t * We must check all this again, since\n\t\t * find_lock_later_rq releases rq->lock and it is\n\t\t * then possible that next_task has migrated.\n\t\t */\n\t\ttask = pick_next_pushable_dl_task(rq);\n\t\tif (task == next_task) {\n\t\t\t/*\n\t\t\t * The task is still there. We don't try\n\t\t\t * again, some other CPU will pull it when ready.\n\t\t\t */\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!task)\n\t\t\t/* No more tasks */\n\t\t\tgoto out;\n\n\t\tput_task_struct(next_task);\n\t\tnext_task = task;\n\t\tgoto retry;\n\t}\n\n\tdeactivate_task(rq, next_task, 0);\n\tset_task_cpu(next_task, later_rq->cpu);\n\n\t/*\n\t * Update the later_rq clock here, because the clock is used\n\t * by the cpufreq_update_util() inside __add_running_bw().\n\t */\n\tupdate_rq_clock(later_rq);\n\tactivate_task(later_rq, next_task, ENQUEUE_NOCLOCK);\n\tret = 1;\n\n\tresched_curr(later_rq);\n\n\tdouble_unlock_balance(rq, later_rq);\n\nout:\n\tput_task_struct(next_task);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "next_task"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_unlock_balance",
          "args": [
            "rq",
            "later_rq"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "double_unlock_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2597-2603",
          "snippet": "static inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\tif (__rq_lockp(this_rq) != __rq_lockp(busiest))\n\t\traw_spin_rq_unlock(busiest);\n\tlock_set_subclass(&__rq_lockp(this_rq)->dep_map, 0, _RET_IP_);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\tif (__rq_lockp(this_rq) != __rq_lockp(busiest))\n\t\traw_spin_rq_unlock(busiest);\n\tlock_set_subclass(&__rq_lockp(this_rq)->dep_map, 0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "later_rq"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "976-998",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "activate_task",
          "args": [
            "later_rq",
            "next_task",
            "ENQUEUE_NOCLOCK"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "2040-2045",
          "snippet": "void deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tp->on_rq = (flags & DEQUEUE_SLEEP) ? 0 : TASK_ON_RQ_MIGRATING;\n\n\tdequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tp->on_rq = (flags & DEQUEUE_SLEEP) ? 0 : TASK_ON_RQ_MIGRATING;\n\n\tdequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "later_rq"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "679-699",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_cpu",
          "args": [
            "next_task",
            "later_rq->cpu"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "set_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3026-3079",
          "snippet": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tunsigned int state = READ_ONCE(p->__state);\n\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(state != TASK_RUNNING && state != TASK_WAKING && !p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(__rq_lockp(task_rq(p)))));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n\n\tWARN_ON_ONCE(is_migration_disabled(p));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tunsigned int state = READ_ONCE(p->__state);\n\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(state != TASK_RUNNING && state != TASK_WAKING && !p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(__rq_lockp(task_rq(p)))));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n\n\tWARN_ON_ONCE(is_migration_disabled(p));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pick_next_pushable_dl_task",
          "args": [
            "rq"
          ],
          "line": 2274
        },
        "resolved": true,
        "details": {
          "function_name": "pick_next_pushable_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2204-2222",
          "snippet": "static struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\n\tp = rb_entry(rq->dl.pushable_dl_tasks_root.rb_leftmost,\n\t\t     struct task_struct, pushable_dl_tasks);\n\n\tBUG_ON(rq->cpu != task_cpu(p));\n\tBUG_ON(task_current(rq, p));\n\tBUG_ON(p->nr_cpus_allowed <= 1);\n\n\tBUG_ON(!task_on_rq_queued(p));\n\tBUG_ON(!dl_task(p));\n\n\treturn p;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\n\tp = rb_entry(rq->dl.pushable_dl_tasks_root.rb_leftmost,\n\t\t     struct task_struct, pushable_dl_tasks);\n\n\tBUG_ON(rq->cpu != task_cpu(p));\n\tBUG_ON(task_current(rq, p));\n\tBUG_ON(p->nr_cpus_allowed <= 1);\n\n\tBUG_ON(!task_on_rq_queued(p));\n\tBUG_ON(!dl_task(p));\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lock_later_rq",
          "args": [
            "next_task",
            "rq"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_later_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2147-2202",
          "snippet": "static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define DL_MAX_TRIES 3"
          ],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\n#define DL_MAX_TRIES 3\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "next_task"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "next_task->dl.deadline",
            "rq->curr->dl.deadline"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "rq->curr"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "next_task == rq->curr"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_migration_disabled",
          "args": [
            "next_task"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "is_migration_disabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1148-1155",
          "snippet": "static inline bool is_migration_disabled(struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->migration_disabled;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline bool is_migration_disabled(struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->migration_disabled;\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic int push_dl_task(struct rq *rq)\n{\n\tstruct task_struct *next_task;\n\tstruct rq *later_rq;\n\tint ret = 0;\n\n\tif (!rq->dl.overloaded)\n\t\treturn 0;\n\n\tnext_task = pick_next_pushable_dl_task(rq);\n\tif (!next_task)\n\t\treturn 0;\n\nretry:\n\tif (is_migration_disabled(next_task))\n\t\treturn 0;\n\n\tif (WARN_ON(next_task == rq->curr))\n\t\treturn 0;\n\n\t/*\n\t * If next_task preempts rq->curr, and rq->curr\n\t * can move away, it makes sense to just reschedule\n\t * without going further in pushing next_task.\n\t */\n\tif (dl_task(rq->curr) &&\n\t    dl_time_before(next_task->dl.deadline, rq->curr->dl.deadline) &&\n\t    rq->curr->nr_cpus_allowed > 1) {\n\t\tresched_curr(rq);\n\t\treturn 0;\n\t}\n\n\t/* We might release rq lock */\n\tget_task_struct(next_task);\n\n\t/* Will lock the rq it'll find */\n\tlater_rq = find_lock_later_rq(next_task, rq);\n\tif (!later_rq) {\n\t\tstruct task_struct *task;\n\n\t\t/*\n\t\t * We must check all this again, since\n\t\t * find_lock_later_rq releases rq->lock and it is\n\t\t * then possible that next_task has migrated.\n\t\t */\n\t\ttask = pick_next_pushable_dl_task(rq);\n\t\tif (task == next_task) {\n\t\t\t/*\n\t\t\t * The task is still there. We don't try\n\t\t\t * again, some other CPU will pull it when ready.\n\t\t\t */\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!task)\n\t\t\t/* No more tasks */\n\t\t\tgoto out;\n\n\t\tput_task_struct(next_task);\n\t\tnext_task = task;\n\t\tgoto retry;\n\t}\n\n\tdeactivate_task(rq, next_task, 0);\n\tset_task_cpu(next_task, later_rq->cpu);\n\n\t/*\n\t * Update the later_rq clock here, because the clock is used\n\t * by the cpufreq_update_util() inside __add_running_bw().\n\t */\n\tupdate_rq_clock(later_rq);\n\tactivate_task(later_rq, next_task, ENQUEUE_NOCLOCK);\n\tret = 1;\n\n\tresched_curr(later_rq);\n\n\tdouble_unlock_balance(rq, later_rq);\n\nout:\n\tput_task_struct(next_task);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pick_next_pushable_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2204-2222",
    "snippet": "static struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\n\tp = rb_entry(rq->dl.pushable_dl_tasks_root.rb_leftmost,\n\t\t     struct task_struct, pushable_dl_tasks);\n\n\tBUG_ON(rq->cpu != task_cpu(p));\n\tBUG_ON(task_current(rq, p));\n\tBUG_ON(p->nr_cpus_allowed <= 1);\n\n\tBUG_ON(!task_on_rq_queued(p));\n\tBUG_ON(!dl_task(p));\n\n\treturn p;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dl_task(p)"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!task_on_rq_queued(p)"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2044-2047",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p->nr_cpus_allowed <= 1"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "task_current(rq, p)"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2030-2033",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rq->cpu != task_cpu(p)"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rq->dl.pushable_dl_tasks_root.rb_leftmost",
            "structtask_struct",
            "pushable_dl_tasks"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_pushable_dl_tasks",
          "args": [
            "rq"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "has_pushable_dl_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "561-564",
          "snippet": "static inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\n\tp = rb_entry(rq->dl.pushable_dl_tasks_root.rb_leftmost,\n\t\t     struct task_struct, pushable_dl_tasks);\n\n\tBUG_ON(rq->cpu != task_cpu(p));\n\tBUG_ON(task_current(rq, p));\n\tBUG_ON(p->nr_cpus_allowed <= 1);\n\n\tBUG_ON(!task_on_rq_queued(p));\n\tBUG_ON(!dl_task(p));\n\n\treturn p;\n}"
  },
  {
    "function_name": "find_lock_later_rq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2147-2202",
    "snippet": "static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define DL_MAX_TRIES 3"
    ],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "double_unlock_balance",
          "args": [
            "rq",
            "later_rq"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "double_unlock_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2597-2603",
          "snippet": "static inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\tif (__rq_lockp(this_rq) != __rq_lockp(busiest))\n\t\traw_spin_rq_unlock(busiest);\n\tlock_set_subclass(&__rq_lockp(this_rq)->dep_map, 0, _RET_IP_);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\tif (__rq_lockp(this_rq) != __rq_lockp(busiest))\n\t\traw_spin_rq_unlock(busiest);\n\tlock_set_subclass(&__rq_lockp(this_rq)->dep_map, 0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "task->dl.deadline",
            "later_rq->dl.earliest_dl.curr"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task)"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "task"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2044-2047",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "task"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "task"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2035-2042",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "later_rq->cpu",
            "&task->cpus_mask"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "task"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "is_task_rq_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5634-5637",
          "snippet": "static inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_lock_balance",
          "args": [
            "rq",
            "later_rq"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "double_lock_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2590-2595",
          "snippet": "static inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tlockdep_assert_irqs_disabled();\n\n\treturn _double_lock_balance(this_rq, busiest);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tlockdep_assert_irqs_disabled();\n\n\treturn _double_lock_balance(this_rq, busiest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "task->dl.deadline",
            "later_rq->dl.earliest_dl.curr"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_later_rq",
          "args": [
            "task"
          ],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "find_later_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2059-2144",
          "snippet": "static int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_any_and_distribute(later_mask,\n\t\t\t\t\t\t\t      sched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any_distribute(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_any_and_distribute(later_mask,\n\t\t\t\t\t\t\t      sched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any_distribute(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\n#define DL_MAX_TRIES 3\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}"
  },
  {
    "function_name": "find_later_rq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2059-2144",
    "snippet": "static int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_any_and_distribute(later_mask,\n\t\t\t\t\t\t\t      sched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any_distribute(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_any_distribute",
          "args": [
            "later_mask"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any_and_distribute",
          "args": [
            "later_mask",
            "sched_domain_span(sd)"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "this_cpu",
            "sched_domain_span(sd)"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_domain",
          "args": [
            "cpu",
            "sd"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "this_cpu",
            "later_mask"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "later_mask"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpudl_find",
          "args": [
            "&task_rq(task)->rd->cpudl",
            "task",
            "later_mask"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_find",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "117-163",
          "snippet": "int cpudl_find(struct cpudl *cp, struct task_struct *p,\n\t       struct cpumask *later_mask)\n{\n\tconst struct sched_dl_entity *dl_se = &p->dl;\n\n\tif (later_mask &&\n\t    cpumask_and(later_mask, cp->free_cpus, &p->cpus_mask)) {\n\t\tunsigned long cap, max_cap = 0;\n\t\tint cpu, max_cpu = -1;\n\n\t\tif (!static_branch_unlikely(&sched_asym_cpucapacity))\n\t\t\treturn 1;\n\n\t\t/* Ensure the capacity of the CPUs fits the task. */\n\t\tfor_each_cpu(cpu, later_mask) {\n\t\t\tif (!dl_task_fits_capacity(p, cpu)) {\n\t\t\t\tcpumask_clear_cpu(cpu, later_mask);\n\n\t\t\t\tcap = capacity_orig_of(cpu);\n\n\t\t\t\tif (cap > max_cap ||\n\t\t\t\t    (cpu == task_cpu(p) && cap == max_cap)) {\n\t\t\t\t\tmax_cap = cap;\n\t\t\t\t\tmax_cpu = cpu;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cpumask_empty(later_mask))\n\t\t\tcpumask_set_cpu(max_cpu, later_mask);\n\n\t\treturn 1;\n\t} else {\n\t\tint best_cpu = cpudl_maximum(cp);\n\n\t\tWARN_ON(best_cpu != -1 && !cpu_present(best_cpu));\n\n\t\tif (cpumask_test_cpu(best_cpu, &p->cpus_mask) &&\n\t\t    dl_time_before(dl_se->deadline, cp->elements[0].dl)) {\n\t\t\tif (later_mask)\n\t\t\t\tcpumask_set_cpu(best_cpu, later_mask);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint cpudl_find(struct cpudl *cp, struct task_struct *p,\n\t       struct cpumask *later_mask)\n{\n\tconst struct sched_dl_entity *dl_se = &p->dl;\n\n\tif (later_mask &&\n\t    cpumask_and(later_mask, cp->free_cpus, &p->cpus_mask)) {\n\t\tunsigned long cap, max_cap = 0;\n\t\tint cpu, max_cpu = -1;\n\n\t\tif (!static_branch_unlikely(&sched_asym_cpucapacity))\n\t\t\treturn 1;\n\n\t\t/* Ensure the capacity of the CPUs fits the task. */\n\t\tfor_each_cpu(cpu, later_mask) {\n\t\t\tif (!dl_task_fits_capacity(p, cpu)) {\n\t\t\t\tcpumask_clear_cpu(cpu, later_mask);\n\n\t\t\t\tcap = capacity_orig_of(cpu);\n\n\t\t\t\tif (cap > max_cap ||\n\t\t\t\t    (cpu == task_cpu(p) && cap == max_cap)) {\n\t\t\t\t\tmax_cap = cap;\n\t\t\t\t\tmax_cpu = cpu;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cpumask_empty(later_mask))\n\t\t\tcpumask_set_cpu(max_cpu, later_mask);\n\n\t\treturn 1;\n\t} else {\n\t\tint best_cpu = cpudl_maximum(cp);\n\n\t\tWARN_ON(best_cpu != -1 && !cpu_present(best_cpu));\n\n\t\tif (cpumask_test_cpu(best_cpu, &p->cpus_mask) &&\n\t\t    dl_time_before(dl_se->deadline, cp->elements[0].dl)) {\n\t\t\tif (later_mask)\n\t\t\t\tcpumask_set_cpu(best_cpu, later_mask);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "task"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "is_task_rq_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5634-5637",
          "snippet": "static inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!later_mask"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "task"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_cpumask_var_ptr",
          "args": [
            "local_cpu_mask_dl"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_any_and_distribute(later_mask,\n\t\t\t\t\t\t\t      sched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any_distribute(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}"
  },
  {
    "function_name": "pick_earliest_pushable_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2035-2055",
    "snippet": "static struct task_struct *pick_earliest_pushable_dl_task(struct rq *rq, int cpu)\n{\n\tstruct rb_node *next_node = rq->dl.pushable_dl_tasks_root.rb_leftmost;\n\tstruct task_struct *p = NULL;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\nnext_node:\n\tif (next_node) {\n\t\tp = rb_entry(next_node, struct task_struct, pushable_dl_tasks);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tnext_node = rb_next(next_node);\n\t\tgoto next_node;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "next_node"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "prb_next_seq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk_ringbuffer.c",
          "lines": "2006-2015",
          "snippet": "u64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}",
          "includes": [
            "#include \"printk_ringbuffer.h\"",
            "#include <linux/bug.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"printk_ringbuffer.h\"\n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/irqflags.h>\n#include <linux/kernel.h>\n\nu64 prb_next_seq(struct printk_ringbuffer *rb)\n{\n\tu64 seq = 0;\n\n\t/* Search forward from the oldest descriptor. */\n\twhile (_prb_read_valid(rb, &seq, NULL, NULL))\n\t\tseq++;\n\n\treturn seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pick_dl_task",
          "args": [
            "rq",
            "p",
            "cpu"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "pick_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2023-2029",
          "snippet": "static int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_running(rq, p) &&\n\t    cpumask_test_cpu(cpu, &p->cpus_mask))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_running(rq, p) &&\n\t    cpumask_test_cpu(cpu, &p->cpus_mask))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next_node",
            "structtask_struct",
            "pushable_dl_tasks"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_pushable_dl_tasks",
          "args": [
            "rq"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "has_pushable_dl_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "561-564",
          "snippet": "static inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct task_struct *pick_earliest_pushable_dl_task(struct rq *rq, int cpu)\n{\n\tstruct rb_node *next_node = rq->dl.pushable_dl_tasks_root.rb_leftmost;\n\tstruct task_struct *p = NULL;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\nnext_node:\n\tif (next_node) {\n\t\tp = rb_entry(next_node, struct task_struct, pushable_dl_tasks);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tnext_node = rb_next(next_node);\n\t\tgoto next_node;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pick_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2023-2029",
    "snippet": "static int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_running(rq, p) &&\n\t    cpumask_test_cpu(cpu, &p->cpus_mask))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&p->cpus_mask"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "p"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2035-2042",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_running(rq, p) &&\n\t    cpumask_test_cpu(cpu, &p->cpus_mask))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "task_fork_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "2010-2016",
    "snippet": "static void task_fork_dl(struct task_struct *p)\n{\n\t/*\n\t * SCHED_DEADLINE tasks cannot fork and this is achieved through\n\t * sched_fork()\n\t */\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void task_fork_dl(struct task_struct *p)\n{\n\t/*\n\t * SCHED_DEADLINE tasks cannot fork and this is achieved through\n\t * sched_fork()\n\t */\n}"
  },
  {
    "function_name": "task_tick_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1995-2008",
    "snippet": "static void task_tick_dl(struct rq *rq, struct task_struct *p, int queued)\n{\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 1);\n\t/*\n\t * Even when we have runtime, update_curr_dl() might have resulted in us\n\t * not being the leftmost task anymore. In that case NEED_RESCHED will\n\t * be set and schedule() will start a new hrtick for the next task.\n\t */\n\tif (hrtick_enabled_dl(rq) && queued && p->dl.runtime > 0 &&\n\t    is_leftmost(p, &rq->dl))\n\t\tstart_hrtick_dl(rq, p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_hrtick_dl",
          "args": [
            "rq",
            "p"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "start_hrtick_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1905-1907",
          "snippet": "static void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_leftmost",
          "args": [
            "p",
            "&rq->dl"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "is_leftmost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "407-412",
          "snippet": "static inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtick_enabled_dl",
          "args": [
            "rq"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "hrtick_enabled_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2466-2469",
          "snippet": "static inline int hrtick_enabled_dl(struct rq *rq)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int hrtick_enabled_dl(struct rq *rq)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dl_rq_load_avg",
          "args": [
            "rq_clock_pelt(rq)",
            "rq",
            "1"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_rq_load_avg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "171-175",
          "snippet": "static inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock_pelt",
          "args": [
            "rq"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "update_curr_dl",
          "args": [
            "rq"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "update_curr_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1241-1344",
          "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void task_tick_dl(struct rq *rq, struct task_struct *p, int queued)\n{\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 1);\n\t/*\n\t * Even when we have runtime, update_curr_dl() might have resulted in us\n\t * not being the leftmost task anymore. In that case NEED_RESCHED will\n\t * be set and schedule() will start a new hrtick for the next task.\n\t */\n\tif (hrtick_enabled_dl(rq) && queued && p->dl.runtime > 0 &&\n\t    is_leftmost(p, &rq->dl))\n\t\tstart_hrtick_dl(rq, p);\n}"
  },
  {
    "function_name": "put_prev_task_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1972-1985",
    "snippet": "static void put_prev_task_dl(struct rq *rq, struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tif (on_dl_rq(&p->dl))\n\t\tupdate_stats_wait_start_dl(dl_rq, dl_se);\n\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 1);\n\tif (on_dl_rq(&p->dl) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enqueue_pushable_dl_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_pushable_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "666-669",
          "snippet": "static inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_dl_rq",
          "args": [
            "&p->dl"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "on_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "41-44",
          "snippet": "static inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dl_rq_load_avg",
          "args": [
            "rq_clock_pelt(rq)",
            "rq",
            "1"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_rq_load_avg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "171-175",
          "snippet": "static inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock_pelt",
          "args": [
            "rq"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "update_curr_dl",
          "args": [
            "rq"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "update_curr_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1241-1344",
          "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_stats_wait_start_dl",
          "args": [
            "dl_rq",
            "dl_se"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "update_stats_wait_start_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1483-1493",
          "snippet": "static inline void\nupdate_stats_wait_start_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_start(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void\nupdate_stats_wait_start_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_start(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void put_prev_task_dl(struct rq *rq, struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tif (on_dl_rq(&p->dl))\n\t\tupdate_stats_wait_start_dl(dl_rq, dl_se);\n\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 1);\n\tif (on_dl_rq(&p->dl) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}"
  },
  {
    "function_name": "pick_next_task_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1961-1970",
    "snippet": "static struct task_struct *pick_next_task_dl(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tp = pick_task_dl(rq);\n\tif (p)\n\t\tset_next_task_dl(rq, p, true);\n\n\treturn p;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_next_task_dl",
          "args": [
            "rq",
            "p",
            "true"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "set_next_task_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1910-1932",
          "snippet": "static void set_next_task_dl(struct rq *rq, struct task_struct *p, bool first)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tp->se.exec_start = rq_clock_task(rq);\n\tif (on_dl_rq(&p->dl))\n\t\tupdate_stats_wait_end_dl(dl_rq, dl_se);\n\n\t/* You can't push away the running task */\n\tdequeue_pushable_dl_task(rq, p);\n\n\tif (!first)\n\t\treturn;\n\n\tif (hrtick_enabled_dl(rq))\n\t\tstart_hrtick_dl(rq, p);\n\n\tif (rq->curr->sched_class != &dl_sched_class)\n\t\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);\n\n\tdeadline_queue_push_tasks(rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void set_next_task_dl(struct rq *rq, struct task_struct *p, bool first)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tp->se.exec_start = rq_clock_task(rq);\n\tif (on_dl_rq(&p->dl))\n\t\tupdate_stats_wait_end_dl(dl_rq, dl_se);\n\n\t/* You can't push away the running task */\n\tdequeue_pushable_dl_task(rq, p);\n\n\tif (!first)\n\t\treturn;\n\n\tif (hrtick_enabled_dl(rq))\n\t\tstart_hrtick_dl(rq, p);\n\n\tif (rq->curr->sched_class != &dl_sched_class)\n\t\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);\n\n\tdeadline_queue_push_tasks(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pick_task_dl",
          "args": [
            "rq"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "pick_task_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1945-1959",
          "snippet": "static struct task_struct *pick_task_dl(struct rq *rq)\n{\n\tstruct sched_dl_entity *dl_se;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct task_struct *p;\n\n\tif (!sched_dl_runnable(rq))\n\t\treturn NULL;\n\n\tdl_se = pick_next_dl_entity(rq, dl_rq);\n\tBUG_ON(!dl_se);\n\tp = dl_task_of(dl_se);\n\n\treturn p;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct task_struct *pick_task_dl(struct rq *rq)\n{\n\tstruct sched_dl_entity *dl_se;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct task_struct *p;\n\n\tif (!sched_dl_runnable(rq))\n\t\treturn NULL;\n\n\tdl_se = pick_next_dl_entity(rq, dl_rq);\n\tBUG_ON(!dl_se);\n\tp = dl_task_of(dl_se);\n\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic struct task_struct *pick_next_task_dl(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tp = pick_task_dl(rq);\n\tif (p)\n\t\tset_next_task_dl(rq, p, true);\n\n\treturn p;\n}"
  },
  {
    "function_name": "pick_task_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1945-1959",
    "snippet": "static struct task_struct *pick_task_dl(struct rq *rq)\n{\n\tstruct sched_dl_entity *dl_se;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct task_struct *p;\n\n\tif (!sched_dl_runnable(rq))\n\t\treturn NULL;\n\n\tdl_se = pick_next_dl_entity(rq, dl_rq);\n\tBUG_ON(!dl_se);\n\tp = dl_task_of(dl_se);\n\n\treturn p;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dl_se"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pick_next_dl_entity",
          "args": [
            "rq",
            "dl_rq"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "pick_next_dl_entity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1934-1943",
          "snippet": "static struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,\n\t\t\t\t\t\t   struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&dl_rq->root);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_dl_entity, rb_node);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,\n\t\t\t\t\t\t   struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&dl_rq->root);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_dl_entity, rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_dl_runnable",
          "args": [
            "rq"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "sched_dl_runnable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2237-2240",
          "snippet": "static inline bool sched_dl_runnable(struct rq *rq)\n{\n\treturn rq->dl.dl_nr_running > 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline bool sched_dl_runnable(struct rq *rq)\n{\n\treturn rq->dl.dl_nr_running > 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct task_struct *pick_task_dl(struct rq *rq)\n{\n\tstruct sched_dl_entity *dl_se;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct task_struct *p;\n\n\tif (!sched_dl_runnable(rq))\n\t\treturn NULL;\n\n\tdl_se = pick_next_dl_entity(rq, dl_rq);\n\tBUG_ON(!dl_se);\n\tp = dl_task_of(dl_se);\n\n\treturn p;\n}"
  },
  {
    "function_name": "pick_next_dl_entity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1934-1943",
    "snippet": "static struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,\n\t\t\t\t\t\t   struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&dl_rq->root);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_dl_entity, rb_node);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "left",
            "structsched_dl_entity",
            "rb_node"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first_cached",
          "args": [
            "&dl_rq->root"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,\n\t\t\t\t\t\t   struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&dl_rq->root);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_dl_entity, rb_node);\n}"
  },
  {
    "function_name": "set_next_task_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1910-1932",
    "snippet": "static void set_next_task_dl(struct rq *rq, struct task_struct *p, bool first)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tp->se.exec_start = rq_clock_task(rq);\n\tif (on_dl_rq(&p->dl))\n\t\tupdate_stats_wait_end_dl(dl_rq, dl_se);\n\n\t/* You can't push away the running task */\n\tdequeue_pushable_dl_task(rq, p);\n\n\tif (!first)\n\t\treturn;\n\n\tif (hrtick_enabled_dl(rq))\n\t\tstart_hrtick_dl(rq, p);\n\n\tif (rq->curr->sched_class != &dl_sched_class)\n\t\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);\n\n\tdeadline_queue_push_tasks(rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deadline_queue_push_tasks",
          "args": [
            "rq"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "deadline_queue_push_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "695-697",
          "snippet": "static inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dl_rq_load_avg",
          "args": [
            "rq_clock_pelt(rq)",
            "rq",
            "0"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_rq_load_avg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "171-175",
          "snippet": "static inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock_pelt",
          "args": [
            "rq"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "start_hrtick_dl",
          "args": [
            "rq",
            "p"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "start_hrtick_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1905-1907",
          "snippet": "static void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtick_enabled_dl",
          "args": [
            "rq"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "hrtick_enabled_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2466-2469",
          "snippet": "static inline int hrtick_enabled_dl(struct rq *rq)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int hrtick_enabled_dl(struct rq *rq)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_pushable_dl_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_pushable_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "671-674",
          "snippet": "static inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_stats_wait_end_dl",
          "args": [
            "dl_rq",
            "dl_se"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "update_stats_wait_end_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1495-1505",
          "snippet": "static inline void\nupdate_stats_wait_end_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_end(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void\nupdate_stats_wait_end_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_end(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_dl_rq",
          "args": [
            "&p->dl"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "on_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "41-44",
          "snippet": "static inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock_task",
          "args": [
            "rq"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1470-1476",
          "snippet": "static inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_rq_held(rq);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_rq_held(rq);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void set_next_task_dl(struct rq *rq, struct task_struct *p, bool first)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tp->se.exec_start = rq_clock_task(rq);\n\tif (on_dl_rq(&p->dl))\n\t\tupdate_stats_wait_end_dl(dl_rq, dl_se);\n\n\t/* You can't push away the running task */\n\tdequeue_pushable_dl_task(rq, p);\n\n\tif (!first)\n\t\treturn;\n\n\tif (hrtick_enabled_dl(rq))\n\t\tstart_hrtick_dl(rq, p);\n\n\tif (rq->curr->sched_class != &dl_sched_class)\n\t\tupdate_dl_rq_load_avg(rq_clock_pelt(rq), rq, 0);\n\n\tdeadline_queue_push_tasks(rq);\n}"
  },
  {
    "function_name": "start_hrtick_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1905-1907",
    "snippet": "static void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}"
  },
  {
    "function_name": "start_hrtick_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1900-1903",
    "snippet": "static void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n\thrtick_start(rq, p->dl.runtime);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtick_start",
          "args": [
            "rq",
            "p->dl.runtime"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "hrtick_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "783-792",
          "snippet": "void hrtick_start(struct rq *rq, u64 delay)\n{\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense. Rely on vruntime for fairness.\n\t */\n\tdelay = max_t(u64, delay, 10000LL);\n\thrtimer_start(&rq->hrtick_timer, ns_to_ktime(delay),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid hrtick_start(struct rq *rq, u64 delay)\n{\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense. Rely on vruntime for fairness.\n\t */\n\tdelay = max_t(u64, delay, 10000LL);\n\thrtimer_start(&rq->hrtick_timer, ns_to_ktime(delay),\n\t\t      HRTIMER_MODE_REL_PINNED_HARD);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n\thrtick_start(rq, p->dl.runtime);\n}"
  },
  {
    "function_name": "check_preempt_curr_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1880-1897",
    "snippet": "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_preempt_equal_dl",
          "args": [
            "rq",
            "p"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_equal_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1837-1856",
          "snippet": "static void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * Current can't be migrated, useless to reschedule,\n\t * let's hope p can move out.\n\t */\n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    !cpudl_find(&rq->rd->cpudl, rq->curr, NULL))\n\t\treturn;\n\n\t/*\n\t * p is migratable, so let's not schedule it and\n\t * see if it is pushed or pulled somewhere else.\n\t */\n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, NULL))\n\t\treturn;\n\n\tresched_curr(rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * Current can't be migrated, useless to reschedule,\n\t * let's hope p can move out.\n\t */\n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    !cpudl_find(&rq->rd->cpudl, rq->curr, NULL))\n\t\treturn;\n\n\t/*\n\t * p is migratable, so let's not schedule it and\n\t * see if it is pushed or pulled somewhere else.\n\t */\n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, NULL))\n\t\treturn;\n\n\tresched_curr(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_tsk_need_resched",
          "args": [
            "rq->curr"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "976-998",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_preempt",
          "args": [
            "&p->dl",
            "&rq->curr->dl"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_preempt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "243-248",
          "snippet": "static inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}"
  },
  {
    "function_name": "balance_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1858-1873",
    "snippet": "static int balance_dl(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n{\n\tif (!on_dl_rq(&p->dl) && need_pull_dl_task(rq, p)) {\n\t\t/*\n\t\t * This is OK, because current is on_cpu, which avoids it being\n\t\t * picked for load-balance and preemption/IRQs are still\n\t\t * disabled avoiding further scheduler activity on it and we've\n\t\t * not yet started the picking loop.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tpull_dl_task(rq);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\treturn sched_stop_runnable(rq) || sched_dl_runnable(rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_dl_runnable",
          "args": [
            "rq"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "sched_dl_runnable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2237-2240",
          "snippet": "static inline bool sched_dl_runnable(struct rq *rq)\n{\n\treturn rq->dl.dl_nr_running > 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline bool sched_dl_runnable(struct rq *rq)\n{\n\treturn rq->dl.dl_nr_running > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_stop_runnable",
          "args": [
            "rq"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "sched_stop_runnable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2232-2235",
          "snippet": "static inline bool sched_stop_runnable(struct rq *rq)\n{\n\treturn rq->stop && task_on_rq_queued(rq->stop);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline bool sched_stop_runnable(struct rq *rq)\n{\n\treturn rq->stop && task_on_rq_queued(rq->stop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_repin_lock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "rq_repin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1560-1570",
          "snippet": "static inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(__rq_lockp(rq), rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(__rq_lockp(rq), rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pull_dl_task",
          "args": [
            "rq"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unpin_lock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unpin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1550-1558",
          "snippet": "static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(__rq_lockp(rq), rf->cookie);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_UPDATED\t\t0x04",
            "#define RQCF_ACT_SKIP\t\t0x02"
          ],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_UPDATED\t\t0x04\n#define RQCF_ACT_SKIP\t\t0x02\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(__rq_lockp(rq), rf->cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_pull_dl_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "need_pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "686-689",
          "snippet": "static inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_dl_rq",
          "args": [
            "&p->dl"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "on_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "41-44",
          "snippet": "static inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic int balance_dl(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n{\n\tif (!on_dl_rq(&p->dl) && need_pull_dl_task(rq, p)) {\n\t\t/*\n\t\t * This is OK, because current is on_cpu, which avoids it being\n\t\t * picked for load-balance and preemption/IRQs are still\n\t\t * disabled avoiding further scheduler activity on it and we've\n\t\t * not yet started the picking loop.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tpull_dl_task(rq);\n\t\trq_repin_lock(rq, rf);\n\t}\n\n\treturn sched_stop_runnable(rq) || sched_dl_runnable(rq);\n}"
  },
  {
    "function_name": "check_preempt_equal_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1837-1856",
    "snippet": "static void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * Current can't be migrated, useless to reschedule,\n\t * let's hope p can move out.\n\t */\n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    !cpudl_find(&rq->rd->cpudl, rq->curr, NULL))\n\t\treturn;\n\n\t/*\n\t * p is migratable, so let's not schedule it and\n\t * see if it is pushed or pulled somewhere else.\n\t */\n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, NULL))\n\t\treturn;\n\n\tresched_curr(rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "976-998",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpudl_find",
          "args": [
            "&rq->rd->cpudl",
            "p",
            "NULL"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_find",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "117-163",
          "snippet": "int cpudl_find(struct cpudl *cp, struct task_struct *p,\n\t       struct cpumask *later_mask)\n{\n\tconst struct sched_dl_entity *dl_se = &p->dl;\n\n\tif (later_mask &&\n\t    cpumask_and(later_mask, cp->free_cpus, &p->cpus_mask)) {\n\t\tunsigned long cap, max_cap = 0;\n\t\tint cpu, max_cpu = -1;\n\n\t\tif (!static_branch_unlikely(&sched_asym_cpucapacity))\n\t\t\treturn 1;\n\n\t\t/* Ensure the capacity of the CPUs fits the task. */\n\t\tfor_each_cpu(cpu, later_mask) {\n\t\t\tif (!dl_task_fits_capacity(p, cpu)) {\n\t\t\t\tcpumask_clear_cpu(cpu, later_mask);\n\n\t\t\t\tcap = capacity_orig_of(cpu);\n\n\t\t\t\tif (cap > max_cap ||\n\t\t\t\t    (cpu == task_cpu(p) && cap == max_cap)) {\n\t\t\t\t\tmax_cap = cap;\n\t\t\t\t\tmax_cpu = cpu;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cpumask_empty(later_mask))\n\t\t\tcpumask_set_cpu(max_cpu, later_mask);\n\n\t\treturn 1;\n\t} else {\n\t\tint best_cpu = cpudl_maximum(cp);\n\n\t\tWARN_ON(best_cpu != -1 && !cpu_present(best_cpu));\n\n\t\tif (cpumask_test_cpu(best_cpu, &p->cpus_mask) &&\n\t\t    dl_time_before(dl_se->deadline, cp->elements[0].dl)) {\n\t\t\tif (later_mask)\n\t\t\t\tcpumask_set_cpu(best_cpu, later_mask);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint cpudl_find(struct cpudl *cp, struct task_struct *p,\n\t       struct cpumask *later_mask)\n{\n\tconst struct sched_dl_entity *dl_se = &p->dl;\n\n\tif (later_mask &&\n\t    cpumask_and(later_mask, cp->free_cpus, &p->cpus_mask)) {\n\t\tunsigned long cap, max_cap = 0;\n\t\tint cpu, max_cpu = -1;\n\n\t\tif (!static_branch_unlikely(&sched_asym_cpucapacity))\n\t\t\treturn 1;\n\n\t\t/* Ensure the capacity of the CPUs fits the task. */\n\t\tfor_each_cpu(cpu, later_mask) {\n\t\t\tif (!dl_task_fits_capacity(p, cpu)) {\n\t\t\t\tcpumask_clear_cpu(cpu, later_mask);\n\n\t\t\t\tcap = capacity_orig_of(cpu);\n\n\t\t\t\tif (cap > max_cap ||\n\t\t\t\t    (cpu == task_cpu(p) && cap == max_cap)) {\n\t\t\t\t\tmax_cap = cap;\n\t\t\t\t\tmax_cpu = cpu;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cpumask_empty(later_mask))\n\t\t\tcpumask_set_cpu(max_cpu, later_mask);\n\n\t\treturn 1;\n\t} else {\n\t\tint best_cpu = cpudl_maximum(cp);\n\n\t\tWARN_ON(best_cpu != -1 && !cpu_present(best_cpu));\n\n\t\tif (cpumask_test_cpu(best_cpu, &p->cpus_mask) &&\n\t\t    dl_time_before(dl_se->deadline, cp->elements[0].dl)) {\n\t\t\tif (later_mask)\n\t\t\t\tcpumask_set_cpu(best_cpu, later_mask);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * Current can't be migrated, useless to reschedule,\n\t * let's hope p can move out.\n\t */\n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    !cpudl_find(&rq->rd->cpudl, rq->curr, NULL))\n\t\treturn;\n\n\t/*\n\t * p is migratable, so let's not schedule it and\n\t * see if it is pushed or pulled somewhere else.\n\t */\n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, NULL))\n\t\treturn;\n\n\tresched_curr(rq);\n}"
  },
  {
    "function_name": "migrate_task_rq_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1805-1835",
    "snippet": "static void migrate_task_rq_dl(struct task_struct *p, int new_cpu __maybe_unused)\n{\n\tstruct rq *rq;\n\n\tif (READ_ONCE(p->__state) != TASK_WAKING)\n\t\treturn;\n\n\trq = task_rq(p);\n\t/*\n\t * Since p->state == TASK_WAKING, set_task_cpu() has been called\n\t * from try_to_wake_up(). Hence, p->pi_lock is locked, but\n\t * rq->lock is not... So, lock it\n\t */\n\traw_spin_rq_lock(rq);\n\tif (p->dl.dl_non_contending) {\n\t\tupdate_rq_clock(rq);\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\tsub_rq_bw(&p->dl, &rq->dl);\n\traw_spin_rq_unlock(rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_rq_unlock",
          "args": [
            "rq"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "raw_spin_rq_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "531-534",
          "snippet": "void raw_spin_rq_unlock(struct rq *rq)\n{\n\traw_spin_unlock(rq_lockp(rq));\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid raw_spin_rq_unlock(struct rq *rq)\n{\n\traw_spin_unlock(rq_lockp(rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "212-217",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&p->dl.inactive_timer"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "823-826",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "226-231",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "679-699",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_rq_lock",
          "args": [
            "rq"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_rq_lock_irqsave",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1333-1339",
          "snippet": "static inline unsigned long _raw_spin_rq_lock_irqsave(struct rq *rq)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\traw_spin_rq_lock(rq);\n\treturn flags;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline unsigned long _raw_spin_rq_lock_irqsave(struct rq *rq)\n{\n\tunsigned long flags;\n\tlocal_irq_save(flags);\n\traw_spin_rq_lock(rq);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "is_task_rq_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5634-5637",
          "snippet": "static inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->__state"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void migrate_task_rq_dl(struct task_struct *p, int new_cpu __maybe_unused)\n{\n\tstruct rq *rq;\n\n\tif (READ_ONCE(p->__state) != TASK_WAKING)\n\t\treturn;\n\n\trq = task_rq(p);\n\t/*\n\t * Since p->state == TASK_WAKING, set_task_cpu() has been called\n\t * from try_to_wake_up(). Hence, p->pi_lock is locked, but\n\t * rq->lock is not... So, lock it\n\t */\n\traw_spin_rq_lock(rq);\n\tif (p->dl.dl_non_contending) {\n\t\tupdate_rq_clock(rq);\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\tsub_rq_bw(&p->dl, &rq->dl);\n\traw_spin_rq_unlock(rq);\n}"
  },
  {
    "function_name": "select_task_rq_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1754-1803",
    "snippet": "static int\nselect_task_rq_dl(struct task_struct *p, int cpu, int flags)\n{\n\tstruct task_struct *curr;\n\tbool select_rq;\n\tstruct rq *rq;\n\n\tif (!(flags & WF_TTWU))\n\t\tgoto out;\n\n\trq = cpu_rq(cpu);\n\n\trcu_read_lock();\n\tcurr = READ_ONCE(rq->curr); /* unlocked access */\n\n\t/*\n\t * If we are dealing with a -deadline task, we must\n\t * decide where to wake it up.\n\t * If it has a later deadline and the current task\n\t * on this rq can't move (provided the waking task\n\t * can!) we prefer to send it somewhere else. On the\n\t * other hand, if it has a shorter deadline, we\n\t * try to make it stay here, it might be important.\n\t */\n\tselect_rq = unlikely(dl_task(curr)) &&\n\t\t    (curr->nr_cpus_allowed < 2 ||\n\t\t     !dl_entity_preempt(&p->dl, &curr->dl)) &&\n\t\t    p->nr_cpus_allowed > 1;\n\n\t/*\n\t * Take the capacity of the CPU into account to\n\t * ensure it fits the requirement of the task.\n\t */\n\tif (static_branch_unlikely(&sched_asym_cpucapacity))\n\t\tselect_rq |= !dl_task_fits_capacity(p, cpu);\n\n\tif (select_rq) {\n\t\tint target = find_later_rq(p);\n\n\t\tif (target != -1 &&\n\t\t\t\t(dl_time_before(p->dl.deadline,\n\t\t\t\t\tcpu_rq(target)->dl.earliest_dl.curr) ||\n\t\t\t\t(cpu_rq(target)->dl.dl_nr_running == 0)))\n\t\t\tcpu = target;\n\t}\n\trcu_read_unlock();\n\nout:\n\treturn cpu;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_unlock_strict",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_plugin.h",
          "lines": "815-824",
          "snippet": "void rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n\nvoid rcu_read_unlock_strict(void)\n{\n\tstruct rcu_data *rdp;\n\n\tif (irqs_disabled() || preempt_count() || !rcu_state.gp_kthread)\n\t\treturn;\n\trdp = this_cpu_ptr(&rcu_data);\n\trcu_report_qs_rdp(rdp);\n\tudelay(rcu_unlock_delay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "target"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "p->dl.deadline",
            "cpu_rq(target)->dl.earliest_dl.curr"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_later_rq",
          "args": [
            "p"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "find_later_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2059-2144",
          "snippet": "static int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_any_and_distribute(later_mask,\n\t\t\t\t\t\t\t      sched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any_distribute(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_any_and_distribute(later_mask,\n\t\t\t\t\t\t\t      sched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any_distribute(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_fits_capacity",
          "args": [
            "p",
            "cpu"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_fits_capacity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "335-340",
          "snippet": "static inline bool dl_task_fits_capacity(struct task_struct *p, int cpu)\n{\n\tunsigned long cap = arch_scale_cpu_capacity(cpu);\n\n\treturn cap_scale(p->dl.dl_deadline, cap) >= p->dl.dl_runtime;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline bool dl_task_fits_capacity(struct task_struct *p, int cpu)\n{\n\tunsigned long cap = arch_scale_cpu_capacity(cpu);\n\n\treturn cap_scale(p->dl.dl_deadline, cap) >= p->dl.dl_runtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sched_asym_cpucapacity"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_entity_preempt",
          "args": [
            "&p->dl",
            "&curr->dl"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_preempt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "243-248",
          "snippet": "static inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dl_task(curr)"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "curr"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rq->curr"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_any_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "340-351",
          "snippet": "int rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_any_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\tif (lock_is_held(&rcu_lock_map) ||\n\t    lock_is_held(&rcu_bh_lock_map) ||\n\t    lock_is_held(&rcu_sched_lock_map))\n\t\treturn 1;\n\treturn !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic int\nselect_task_rq_dl(struct task_struct *p, int cpu, int flags)\n{\n\tstruct task_struct *curr;\n\tbool select_rq;\n\tstruct rq *rq;\n\n\tif (!(flags & WF_TTWU))\n\t\tgoto out;\n\n\trq = cpu_rq(cpu);\n\n\trcu_read_lock();\n\tcurr = READ_ONCE(rq->curr); /* unlocked access */\n\n\t/*\n\t * If we are dealing with a -deadline task, we must\n\t * decide where to wake it up.\n\t * If it has a later deadline and the current task\n\t * on this rq can't move (provided the waking task\n\t * can!) we prefer to send it somewhere else. On the\n\t * other hand, if it has a shorter deadline, we\n\t * try to make it stay here, it might be important.\n\t */\n\tselect_rq = unlikely(dl_task(curr)) &&\n\t\t    (curr->nr_cpus_allowed < 2 ||\n\t\t     !dl_entity_preempt(&p->dl, &curr->dl)) &&\n\t\t    p->nr_cpus_allowed > 1;\n\n\t/*\n\t * Take the capacity of the CPU into account to\n\t * ensure it fits the requirement of the task.\n\t */\n\tif (static_branch_unlikely(&sched_asym_cpucapacity))\n\t\tselect_rq |= !dl_task_fits_capacity(p, cpu);\n\n\tif (select_rq) {\n\t\tint target = find_later_rq(p);\n\n\t\tif (target != -1 &&\n\t\t\t\t(dl_time_before(p->dl.deadline,\n\t\t\t\t\tcpu_rq(target)->dl.earliest_dl.curr) ||\n\t\t\t\t(cpu_rq(target)->dl.dl_nr_running == 0)))\n\t\t\tcpu = target;\n\t}\n\trcu_read_unlock();\n\nout:\n\treturn cpu;\n}"
  },
  {
    "function_name": "yield_task_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1730-1748",
    "snippet": "static void yield_task_dl(struct rq *rq)\n{\n\t/*\n\t * We make the task go to sleep until its current deadline by\n\t * forcing its runtime to zero. This way, update_curr_dl() stops\n\t * it and the bandwidth timer will wake it up and will give it\n\t * new scheduling parameters (thanks to dl_yielded=1).\n\t */\n\trq->curr->dl.dl_yielded = 1;\n\n\tupdate_rq_clock(rq);\n\tupdate_curr_dl(rq);\n\t/*\n\t * Tell update_rq_clock() that we've just updated,\n\t * so we don't do microscopic update in schedule()\n\t * and double the fastpath cost.\n\t */\n\trq_clock_skip_update(rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_clock_skip_update",
          "args": [
            "rq"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_skip_update",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1496-1500",
          "snippet": "static inline void rq_clock_skip_update(struct rq *rq)\n{\n\tlockdep_assert_rq_held(rq);\n\trq->clock_update_flags |= RQCF_REQ_SKIP;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_REQ_SKIP\t\t0x01"
          ],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_REQ_SKIP\t\t0x01\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_clock_skip_update(struct rq *rq)\n{\n\tlockdep_assert_rq_held(rq);\n\trq->clock_update_flags |= RQCF_REQ_SKIP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_curr_dl",
          "args": [
            "rq"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "update_curr_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1241-1344",
          "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "679-699",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void yield_task_dl(struct rq *rq)\n{\n\t/*\n\t * We make the task go to sleep until its current deadline by\n\t * forcing its runtime to zero. This way, update_curr_dl() stops\n\t * it and the bandwidth timer will wake it up and will give it\n\t * new scheduling parameters (thanks to dl_yielded=1).\n\t */\n\trq->curr->dl.dl_yielded = 1;\n\n\tupdate_rq_clock(rq);\n\tupdate_curr_dl(rq);\n\t/*\n\t * Tell update_rq_clock() that we've just updated,\n\t * so we don't do microscopic update in schedule()\n\t * and double the fastpath cost.\n\t */\n\trq_clock_skip_update(rq);\n}"
  },
  {
    "function_name": "dequeue_task_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1697-1718",
    "snippet": "static void dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_curr_dl(rq);\n\t__dequeue_task_dl(rq, p, flags);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & DEQUEUE_SAVE) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * This check allows to start the inactive timer (or to immediately\n\t * decrease the active utilization, if needed) in two cases:\n\t * when the task blocks and when it is terminating\n\t * (p->state == TASK_DEAD). We can handle the two cases in the same\n\t * way, because from GRUB's point of view the same thing is happening\n\t * (the task moves from \"active contending\" to \"active non contending\"\n\t * or \"inactive\")\n\t */\n\tif (flags & DEQUEUE_SLEEP)\n\t\ttask_non_contending(p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_non_contending",
          "args": [
            "p"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "task_non_contending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "314-368",
          "snippet": "static void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif ((zerolag_time < 0) || hrtimer_active(&dl_se->inactive_timer)) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (READ_ONCE(p->__state) == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL_HARD);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif ((zerolag_time < 0) || hrtimer_active(&dl_se->inactive_timer)) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (READ_ONCE(p->__state) == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL_HARD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "212-217",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "226-231",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dequeue_task_dl",
          "args": [
            "rq",
            "p",
            "flags"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "__dequeue_task_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1690-1695",
          "snippet": "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_stats_dequeue_dl(&rq->dl, &p->dl, flags);\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_stats_dequeue_dl(&rq->dl, &p->dl, flags);\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_curr_dl",
          "args": [
            "rq"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "update_curr_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1241-1344",
          "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_curr_dl(rq);\n\t__dequeue_task_dl(rq, p, flags);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & DEQUEUE_SAVE) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * This check allows to start the inactive timer (or to immediately\n\t * decrease the active utilization, if needed) in two cases:\n\t * when the task blocks and when it is terminating\n\t * (p->state == TASK_DEAD). We can handle the two cases in the same\n\t * way, because from GRUB's point of view the same thing is happening\n\t * (the task moves from \"active contending\" to \"active non contending\"\n\t * or \"inactive\")\n\t */\n\tif (flags & DEQUEUE_SLEEP)\n\t\ttask_non_contending(p);\n}"
  },
  {
    "function_name": "__dequeue_task_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1690-1695",
    "snippet": "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_stats_dequeue_dl(&rq->dl, &p->dl, flags);\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dequeue_pushable_dl_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_pushable_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "671-674",
          "snippet": "static inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_dl_entity",
          "args": [
            "&p->dl"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_dl_entity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1604-1607",
          "snippet": "static void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_stats_dequeue_dl",
          "args": [
            "&rq->dl",
            "&p->dl",
            "flags"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "update_stats_dequeue_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1530-1551",
          "snippet": "static inline void\nupdate_stats_dequeue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,\n\t\t\tint flags)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tif ((flags & DEQUEUE_SLEEP)) {\n\t\tunsigned int state;\n\n\t\tstate = READ_ONCE(p->__state);\n\t\tif (state & TASK_INTERRUPTIBLE)\n\t\t\t__schedstat_set(p->stats.sleep_start,\n\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));\n\n\t\tif (state & TASK_UNINTERRUPTIBLE)\n\t\t\t__schedstat_set(p->stats.block_start,\n\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nupdate_stats_dequeue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,\n\t\t\tint flags)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tif ((flags & DEQUEUE_SLEEP)) {\n\t\tunsigned int state;\n\n\t\tstate = READ_ONCE(p->__state);\n\t\tif (state & TASK_INTERRUPTIBLE)\n\t\t\t__schedstat_set(p->stats.sleep_start,\n\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));\n\n\t\tif (state & TASK_UNINTERRUPTIBLE)\n\t\t\t__schedstat_set(p->stats.block_start,\n\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_stats_dequeue_dl(&rq->dl, &p->dl, flags);\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}"
  },
  {
    "function_name": "enqueue_task_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1609-1688",
    "snippet": "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (is_dl_boosted(&p->dl)) {\n\t\t/*\n\t\t * Because of delays in the detection of the overrun of a\n\t\t * thread's runtime, it might be the case that a thread\n\t\t * goes to sleep in a rt mutex with negative runtime. As\n\t\t * a consequence, the thread will be throttled.\n\t\t *\n\t\t * While waiting for the mutex, this thread can also be\n\t\t * boosted via PI, resulting in a thread that is throttled\n\t\t * and boosted at the same time.\n\t\t *\n\t\t * In this case, the boost overrides the throttle.\n\t\t */\n\t\tif (p->dl.dl_throttled) {\n\t\t\t/*\n\t\t\t * The replenish timer needs to be canceled. No\n\t\t\t * problem if it fires concurrently: boosted threads\n\t\t\t * are ignored in dl_task_timer().\n\t\t\t */\n\t\t\thrtimer_try_to_cancel(&p->dl.dl_timer);\n\t\t\tp->dl.dl_throttled = 0;\n\t\t}\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task that is going\n\t\t * to be deboosted, but exceeds its runtime while doing so. No point in\n\t\t * replenishing it, as it's going to return back to its original\n\t\t * scheduling class after this. If it has been throttled, we need to\n\t\t * clear the flag, otherwise the task may wake up as throttled after\n\t\t * being boosted again with no means to replenish the runtime and clear\n\t\t * the throttle.\n\t\t */\n\t\tp->dl.dl_throttled = 0;\n\t\tBUG_ON(!is_dl_boosted(&p->dl) || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tcheck_schedstat_required();\n\tupdate_stats_wait_start_dl(dl_rq_of_se(&p->dl), &p->dl);\n\n\tenqueue_dl_entity(&p->dl, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enqueue_pushable_dl_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_pushable_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "666-669",
          "snippet": "static inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2030-2033",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_dl_entity",
          "args": [
            "&p->dl",
            "flags"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_dl_entity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1578-1602",
          "snippet": "static void\nenqueue_dl_entity(struct sched_dl_entity *dl_se, int flags)\n{\n\tBUG_ON(on_dl_rq(dl_se));\n\n\tupdate_stats_enqueue_dl(dl_rq_of_se(dl_se), dl_se, flags);\n\n\t/*\n\t * If this is a wakeup or a new instance, the scheduling\n\t * parameters of the task might need updating. Otherwise,\n\t * we want a replenishment of its runtime.\n\t */\n\tif (flags & ENQUEUE_WAKEUP) {\n\t\ttask_contending(dl_se, flags);\n\t\tupdate_dl_entity(dl_se);\n\t} else if (flags & ENQUEUE_REPLENISH) {\n\t\treplenish_dl_entity(dl_se);\n\t} else if ((flags & ENQUEUE_RESTORE) &&\n\t\t  dl_time_before(dl_se->deadline,\n\t\t\t\t rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se))))) {\n\t\tsetup_new_dl_entity(dl_se);\n\t}\n\n\t__enqueue_dl_entity(dl_se);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void\nenqueue_dl_entity(struct sched_dl_entity *dl_se, int flags)\n{\n\tBUG_ON(on_dl_rq(dl_se));\n\n\tupdate_stats_enqueue_dl(dl_rq_of_se(dl_se), dl_se, flags);\n\n\t/*\n\t * If this is a wakeup or a new instance, the scheduling\n\t * parameters of the task might need updating. Otherwise,\n\t * we want a replenishment of its runtime.\n\t */\n\tif (flags & ENQUEUE_WAKEUP) {\n\t\ttask_contending(dl_se, flags);\n\t\tupdate_dl_entity(dl_se);\n\t} else if (flags & ENQUEUE_REPLENISH) {\n\t\treplenish_dl_entity(dl_se);\n\t} else if ((flags & ENQUEUE_RESTORE) &&\n\t\t  dl_time_before(dl_se->deadline,\n\t\t\t\t rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se))))) {\n\t\tsetup_new_dl_entity(dl_se);\n\t}\n\n\t__enqueue_dl_entity(dl_se);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_stats_wait_start_dl",
          "args": [
            "dl_rq_of_se(&p->dl)",
            "&p->dl"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "update_stats_wait_start_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1483-1493",
          "snippet": "static inline void\nupdate_stats_wait_start_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_start(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void\nupdate_stats_wait_start_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_start(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "&p->dl"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_schedstat_required",
          "args": [],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "check_schedstat_required",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.h",
          "lines": "53-66",
          "snippet": "static inline void\ncheck_schedstat_required(void)\n{\n\tif (schedstat_enabled())\n\t\treturn;\n\n\t/* Force schedstat enabled if a dependent tracepoint is active */\n\tif (trace_sched_stat_wait_enabled()    ||\n\t    trace_sched_stat_sleep_enabled()   ||\n\t    trace_sched_stat_iowait_enabled()  ||\n\t    trace_sched_stat_blocked_enabled() ||\n\t    trace_sched_stat_runtime_enabled())\n\t\tprintk_deferred_once(\"Scheduler tracepoints stat_sleep, stat_iowait, stat_blocked and stat_runtime require the kernel parameter schedstats=enable or kernel.sched_schedstats=1\\n\");\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\ncheck_schedstat_required(void)\n{\n\tif (schedstat_enabled())\n\t\treturn;\n\n\t/* Force schedstat enabled if a dependent tracepoint is active */\n\tif (trace_sched_stat_wait_enabled()    ||\n\t    trace_sched_stat_sleep_enabled()   ||\n\t    trace_sched_stat_iowait_enabled()  ||\n\t    trace_sched_stat_blocked_enabled() ||\n\t    trace_sched_stat_runtime_enabled())\n\t\tprintk_deferred_once(\"Scheduler tracepoints stat_sleep, stat_iowait, stat_blocked and stat_runtime require the kernel parameter schedstats=enable or kernel.sched_schedstats=1\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_contending",
          "args": [
            "&p->dl",
            "flags"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "task_contending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "370-405",
          "snippet": "static void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "add_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "219-224",
          "snippet": "static inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "add_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "205-210",
          "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_check_constrained_dl",
          "args": [
            "&p->dl"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "dl_check_constrained_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1173-1186",
          "snippet": "static inline void dl_check_constrained_dl(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq_of_se(dl_se));\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t    dl_time_before(rq_clock(rq), dl_next_period(dl_se))) {\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(p)))\n\t\t\treturn;\n\t\tdl_se->dl_throttled = 1;\n\t\tif (dl_se->runtime > 0)\n\t\t\tdl_se->runtime = 0;\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_check_constrained_dl(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq_of_se(dl_se));\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t    dl_time_before(rq_clock(rq), dl_next_period(dl_se))) {\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(p)))\n\t\t\treturn;\n\t\tdl_se->dl_throttled = 1;\n\t\tif (dl_se->runtime > 0)\n\t\t\tdl_se->runtime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_is_implicit",
          "args": [
            "&p->dl"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "dl_is_implicit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "912-915",
          "snippet": "static inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!is_dl_boosted(&p->dl) || flags != ENQUEUE_REPLENISH"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dl_boosted",
          "args": [
            "&p->dl"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "is_dl_boosted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "62-65",
          "snippet": "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "p->normal_prio"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&p->dl.dl_timer"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "823-826",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (is_dl_boosted(&p->dl)) {\n\t\t/*\n\t\t * Because of delays in the detection of the overrun of a\n\t\t * thread's runtime, it might be the case that a thread\n\t\t * goes to sleep in a rt mutex with negative runtime. As\n\t\t * a consequence, the thread will be throttled.\n\t\t *\n\t\t * While waiting for the mutex, this thread can also be\n\t\t * boosted via PI, resulting in a thread that is throttled\n\t\t * and boosted at the same time.\n\t\t *\n\t\t * In this case, the boost overrides the throttle.\n\t\t */\n\t\tif (p->dl.dl_throttled) {\n\t\t\t/*\n\t\t\t * The replenish timer needs to be canceled. No\n\t\t\t * problem if it fires concurrently: boosted threads\n\t\t\t * are ignored in dl_task_timer().\n\t\t\t */\n\t\t\thrtimer_try_to_cancel(&p->dl.dl_timer);\n\t\t\tp->dl.dl_throttled = 0;\n\t\t}\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task that is going\n\t\t * to be deboosted, but exceeds its runtime while doing so. No point in\n\t\t * replenishing it, as it's going to return back to its original\n\t\t * scheduling class after this. If it has been throttled, we need to\n\t\t * clear the flag, otherwise the task may wake up as throttled after\n\t\t * being boosted again with no means to replenish the runtime and clear\n\t\t * the throttle.\n\t\t */\n\t\tp->dl.dl_throttled = 0;\n\t\tBUG_ON(!is_dl_boosted(&p->dl) || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tcheck_schedstat_required();\n\tupdate_stats_wait_start_dl(dl_rq_of_se(&p->dl), &p->dl);\n\n\tenqueue_dl_entity(&p->dl, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}"
  },
  {
    "function_name": "dequeue_dl_entity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1604-1607",
    "snippet": "static void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dequeue_dl_entity",
          "args": [
            "dl_se"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "__dequeue_dl_entity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1564-1576",
          "snippet": "static void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (RB_EMPTY_NODE(&dl_se->rb_node))\n\t\treturn;\n\n\trb_erase_cached(&dl_se->rb_node, &dl_rq->root);\n\n\tRB_CLEAR_NODE(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (RB_EMPTY_NODE(&dl_se->rb_node))\n\t\treturn;\n\n\trb_erase_cached(&dl_se->rb_node, &dl_rq->root);\n\n\tRB_CLEAR_NODE(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}"
  },
  {
    "function_name": "enqueue_dl_entity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1578-1602",
    "snippet": "static void\nenqueue_dl_entity(struct sched_dl_entity *dl_se, int flags)\n{\n\tBUG_ON(on_dl_rq(dl_se));\n\n\tupdate_stats_enqueue_dl(dl_rq_of_se(dl_se), dl_se, flags);\n\n\t/*\n\t * If this is a wakeup or a new instance, the scheduling\n\t * parameters of the task might need updating. Otherwise,\n\t * we want a replenishment of its runtime.\n\t */\n\tif (flags & ENQUEUE_WAKEUP) {\n\t\ttask_contending(dl_se, flags);\n\t\tupdate_dl_entity(dl_se);\n\t} else if (flags & ENQUEUE_REPLENISH) {\n\t\treplenish_dl_entity(dl_se);\n\t} else if ((flags & ENQUEUE_RESTORE) &&\n\t\t  dl_time_before(dl_se->deadline,\n\t\t\t\t rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se))))) {\n\t\tsetup_new_dl_entity(dl_se);\n\t}\n\n\t__enqueue_dl_entity(dl_se);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__enqueue_dl_entity",
          "args": [
            "dl_se"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "__enqueue_dl_entity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1553-1562",
          "snippet": "static void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tBUG_ON(!RB_EMPTY_NODE(&dl_se->rb_node));\n\n\trb_add_cached(&dl_se->rb_node, &dl_rq->root, __dl_less);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tBUG_ON(!RB_EMPTY_NODE(&dl_se->rb_node));\n\n\trb_add_cached(&dl_se->rb_node, &dl_rq->root, __dl_less);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_new_dl_entity",
          "args": [
            "dl_se"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "setup_new_dl_entity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "720-743",
          "snippet": "static inline void setup_new_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tWARN_ON(is_dl_boosted(dl_se));\n\tWARN_ON(dl_time_before(rq_clock(rq), dl_se->deadline));\n\n\t/*\n\t * We are racing with the deadline timer. So, do nothing because\n\t * the deadline timer handler will take care of properly recharging\n\t * the runtime and postponing the deadline\n\t */\n\tif (dl_se->dl_throttled)\n\t\treturn;\n\n\t/*\n\t * We use the regular wall clock time to set deadlines in the\n\t * future; in fact, we must consider execution overheads (time\n\t * spent on hardirq context, etc.).\n\t */\n\tdl_se->deadline = rq_clock(rq) + dl_se->dl_deadline;\n\tdl_se->runtime = dl_se->dl_runtime;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void setup_new_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tWARN_ON(is_dl_boosted(dl_se));\n\tWARN_ON(dl_time_before(rq_clock(rq), dl_se->deadline));\n\n\t/*\n\t * We are racing with the deadline timer. So, do nothing because\n\t * the deadline timer handler will take care of properly recharging\n\t * the runtime and postponing the deadline\n\t */\n\tif (dl_se->dl_throttled)\n\t\treturn;\n\n\t/*\n\t * We use the regular wall clock time to set deadlines in the\n\t * future; in fact, we must consider execution overheads (time\n\t * spent on hardirq context, etc.).\n\t */\n\tdl_se->deadline = rq_clock(rq) + dl_se->dl_deadline;\n\tdl_se->runtime = dl_se->dl_runtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se)))"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq_of_dl_rq(dl_rq_of_se(dl_se))"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq_of_se(dl_se)"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "replenish_dl_entity",
          "args": [
            "dl_se"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "replenish_dl_entity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "763-812",
          "snippet": "static void replenish_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_of(dl_se)->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_of(dl_se)->dl_period;\n\t\tdl_se->runtime += pi_of(dl_se)->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void replenish_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_of(dl_se)->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_of(dl_se)->dl_period;\n\t\tdl_se->runtime += pi_of(dl_se)->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dl_entity",
          "args": [
            "dl_se"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_entity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "947-965",
          "snippet": "static void update_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, rq_clock(rq))) {\n\n\t\tif (unlikely(!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !is_dl_boosted(dl_se))) {\n\t\t\tupdate_dl_revised_wakeup(dl_se, rq);\n\t\t\treturn;\n\t\t}\n\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void update_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, rq_clock(rq))) {\n\n\t\tif (unlikely(!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !is_dl_boosted(dl_se))) {\n\t\t\tupdate_dl_revised_wakeup(dl_se, rq);\n\t\t\treturn;\n\t\t}\n\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_contending",
          "args": [
            "dl_se",
            "flags"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "task_contending",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "370-405",
          "snippet": "static void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_stats_enqueue_dl",
          "args": [
            "dl_rq_of_se(dl_se)",
            "dl_se",
            "flags"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "update_stats_enqueue_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1519-1528",
          "snippet": "static inline void\nupdate_stats_enqueue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,\n\t\t\tint flags)\n{\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tif (flags & ENQUEUE_WAKEUP)\n\t\tupdate_stats_enqueue_sleeper_dl(dl_rq, dl_se);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nupdate_stats_enqueue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,\n\t\t\tint flags)\n{\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tif (flags & ENQUEUE_WAKEUP)\n\t\tupdate_stats_enqueue_sleeper_dl(dl_rq, dl_se);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "on_dl_rq(dl_se)"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_dl_rq",
          "args": [
            "dl_se"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "on_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "41-44",
          "snippet": "static inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void\nenqueue_dl_entity(struct sched_dl_entity *dl_se, int flags)\n{\n\tBUG_ON(on_dl_rq(dl_se));\n\n\tupdate_stats_enqueue_dl(dl_rq_of_se(dl_se), dl_se, flags);\n\n\t/*\n\t * If this is a wakeup or a new instance, the scheduling\n\t * parameters of the task might need updating. Otherwise,\n\t * we want a replenishment of its runtime.\n\t */\n\tif (flags & ENQUEUE_WAKEUP) {\n\t\ttask_contending(dl_se, flags);\n\t\tupdate_dl_entity(dl_se);\n\t} else if (flags & ENQUEUE_REPLENISH) {\n\t\treplenish_dl_entity(dl_se);\n\t} else if ((flags & ENQUEUE_RESTORE) &&\n\t\t  dl_time_before(dl_se->deadline,\n\t\t\t\t rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se))))) {\n\t\tsetup_new_dl_entity(dl_se);\n\t}\n\n\t__enqueue_dl_entity(dl_se);\n}"
  },
  {
    "function_name": "__dequeue_dl_entity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1564-1576",
    "snippet": "static void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (RB_EMPTY_NODE(&dl_se->rb_node))\n\t\treturn;\n\n\trb_erase_cached(&dl_se->rb_node, &dl_rq->root);\n\n\tRB_CLEAR_NODE(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_dl_tasks",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "dec_dl_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1455-1467",
          "snippet": "static inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\tWARN_ON(!dl_prio(prio));\n\tWARN_ON(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\tWARN_ON(!dl_prio(prio));\n\tWARN_ON(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&dl_se->rb_node"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase_cached",
          "args": [
            "&dl_se->rb_node",
            "&dl_rq->root"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&dl_se->rb_node"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (RB_EMPTY_NODE(&dl_se->rb_node))\n\t\treturn;\n\n\trb_erase_cached(&dl_se->rb_node, &dl_rq->root);\n\n\tRB_CLEAR_NODE(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}"
  },
  {
    "function_name": "__enqueue_dl_entity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1553-1562",
    "snippet": "static void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tBUG_ON(!RB_EMPTY_NODE(&dl_se->rb_node));\n\n\trb_add_cached(&dl_se->rb_node, &dl_rq->root, __dl_less);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_dl_tasks",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "inc_dl_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1441-1453",
          "snippet": "static inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\tWARN_ON(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\tWARN_ON(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_add_cached",
          "args": [
            "&dl_se->rb_node",
            "&dl_rq->root",
            "__dl_less"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!RB_EMPTY_NODE(&dl_se->rb_node)"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&dl_se->rb_node"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tBUG_ON(!RB_EMPTY_NODE(&dl_se->rb_node));\n\n\trb_add_cached(&dl_se->rb_node, &dl_rq->root, __dl_less);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}"
  },
  {
    "function_name": "update_stats_dequeue_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1530-1551",
    "snippet": "static inline void\nupdate_stats_dequeue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,\n\t\t\tint flags)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tif ((flags & DEQUEUE_SLEEP)) {\n\t\tunsigned int state;\n\n\t\tstate = READ_ONCE(p->__state);\n\t\tif (state & TASK_INTERRUPTIBLE)\n\t\t\t__schedstat_set(p->stats.sleep_start,\n\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));\n\n\t\tif (state & TASK_UNINTERRUPTIBLE)\n\t\t\t__schedstat_set(p->stats.block_start,\n\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__schedstat_set",
          "args": [
            "p->stats.block_start",
            "rq_clock(rq_of_dl_rq(dl_rq))"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq_of_dl_rq(dl_rq)"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__schedstat_set",
          "args": [
            "p->stats.sleep_start",
            "rq_clock(rq_of_dl_rq(dl_rq))"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->__state"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4325-4331",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nupdate_stats_dequeue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,\n\t\t\tint flags)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tif ((flags & DEQUEUE_SLEEP)) {\n\t\tunsigned int state;\n\n\t\tstate = READ_ONCE(p->__state);\n\t\tif (state & TASK_INTERRUPTIBLE)\n\t\t\t__schedstat_set(p->stats.sleep_start,\n\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));\n\n\t\tif (state & TASK_UNINTERRUPTIBLE)\n\t\t\t__schedstat_set(p->stats.block_start,\n\t\t\t\t\trq_clock(rq_of_dl_rq(dl_rq)));\n\t}\n}"
  },
  {
    "function_name": "update_stats_enqueue_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1519-1528",
    "snippet": "static inline void\nupdate_stats_enqueue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,\n\t\t\tint flags)\n{\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tif (flags & ENQUEUE_WAKEUP)\n\t\tupdate_stats_enqueue_sleeper_dl(dl_rq, dl_se);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_stats_enqueue_sleeper_dl",
          "args": [
            "dl_rq",
            "dl_se"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "update_stats_enqueue_sleeper_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1507-1517",
          "snippet": "static inline void\nupdate_stats_enqueue_sleeper_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_enqueue_sleeper(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void\nupdate_stats_enqueue_sleeper_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_enqueue_sleeper(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4325-4331",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\nupdate_stats_enqueue_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se,\n\t\t\tint flags)\n{\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tif (flags & ENQUEUE_WAKEUP)\n\t\tupdate_stats_enqueue_sleeper_dl(dl_rq, dl_se);\n}"
  },
  {
    "function_name": "update_stats_enqueue_sleeper_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1507-1517",
    "snippet": "static inline void\nupdate_stats_enqueue_sleeper_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_enqueue_sleeper(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_stats_enqueue_sleeper",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "dl_task_of(dl_se)",
            "stats"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "__update_stats_enqueue_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
          "lines": "48-109",
          "snippet": "void __update_stats_enqueue_sleeper(struct rq *rq, struct task_struct *p,\n\t\t\t\t    struct sched_statistics *stats)\n{\n\tu64 sleep_start, block_start;\n\n\tsleep_start = schedstat_val(stats->sleep_start);\n\tblock_start = schedstat_val(stats->block_start);\n\n\tif (sleep_start) {\n\t\tu64 delta = rq_clock(rq) - sleep_start;\n\n\t\tif ((s64)delta < 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta > schedstat_val(stats->sleep_max)))\n\t\t\t__schedstat_set(stats->sleep_max, delta);\n\n\t\t__schedstat_set(stats->sleep_start, 0);\n\t\t__schedstat_add(stats->sum_sleep_runtime, delta);\n\n\t\tif (p) {\n\t\t\taccount_scheduler_latency(p, delta >> 10, 1);\n\t\t\ttrace_sched_stat_sleep(p, delta);\n\t\t}\n\t}\n\n\tif (block_start) {\n\t\tu64 delta = rq_clock(rq) - block_start;\n\n\t\tif ((s64)delta < 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta > schedstat_val(stats->block_max)))\n\t\t\t__schedstat_set(stats->block_max, delta);\n\n\t\t__schedstat_set(stats->block_start, 0);\n\t\t__schedstat_add(stats->sum_sleep_runtime, delta);\n\t\t__schedstat_add(stats->sum_block_runtime, delta);\n\n\t\tif (p) {\n\t\t\tif (p->in_iowait) {\n\t\t\t\t__schedstat_add(stats->iowait_sum, delta);\n\t\t\t\t__schedstat_inc(stats->iowait_count);\n\t\t\t\ttrace_sched_stat_iowait(p, delta);\n\t\t\t}\n\n\t\t\ttrace_sched_stat_blocked(p, delta);\n\n\t\t\t/*\n\t\t\t * Blocking time is in units of nanosecs, so shift by\n\t\t\t * 20 to get a milliseconds-range estimation of the\n\t\t\t * amount of time that the task spent sleeping:\n\t\t\t */\n\t\t\tif (unlikely(prof_on == SLEEP_PROFILING)) {\n\t\t\t\tprofile_hits(SLEEP_PROFILING,\n\t\t\t\t\t     (void *)get_wchan(p),\n\t\t\t\t\t     delta >> 20);\n\t\t\t}\n\t\t\taccount_scheduler_latency(p, delta >> 10, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __update_stats_enqueue_sleeper(struct rq *rq, struct task_struct *p,\n\t\t\t\t    struct sched_statistics *stats)\n{\n\tu64 sleep_start, block_start;\n\n\tsleep_start = schedstat_val(stats->sleep_start);\n\tblock_start = schedstat_val(stats->block_start);\n\n\tif (sleep_start) {\n\t\tu64 delta = rq_clock(rq) - sleep_start;\n\n\t\tif ((s64)delta < 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta > schedstat_val(stats->sleep_max)))\n\t\t\t__schedstat_set(stats->sleep_max, delta);\n\n\t\t__schedstat_set(stats->sleep_start, 0);\n\t\t__schedstat_add(stats->sum_sleep_runtime, delta);\n\n\t\tif (p) {\n\t\t\taccount_scheduler_latency(p, delta >> 10, 1);\n\t\t\ttrace_sched_stat_sleep(p, delta);\n\t\t}\n\t}\n\n\tif (block_start) {\n\t\tu64 delta = rq_clock(rq) - block_start;\n\n\t\tif ((s64)delta < 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta > schedstat_val(stats->block_max)))\n\t\t\t__schedstat_set(stats->block_max, delta);\n\n\t\t__schedstat_set(stats->block_start, 0);\n\t\t__schedstat_add(stats->sum_sleep_runtime, delta);\n\t\t__schedstat_add(stats->sum_block_runtime, delta);\n\n\t\tif (p) {\n\t\t\tif (p->in_iowait) {\n\t\t\t\t__schedstat_add(stats->iowait_sum, delta);\n\t\t\t\t__schedstat_inc(stats->iowait_count);\n\t\t\t\ttrace_sched_stat_iowait(p, delta);\n\t\t\t}\n\n\t\t\ttrace_sched_stat_blocked(p, delta);\n\n\t\t\t/*\n\t\t\t * Blocking time is in units of nanosecs, so shift by\n\t\t\t * 20 to get a milliseconds-range estimation of the\n\t\t\t * amount of time that the task spent sleeping:\n\t\t\t */\n\t\t\tif (unlikely(prof_on == SLEEP_PROFILING)) {\n\t\t\t\tprofile_hits(SLEEP_PROFILING,\n\t\t\t\t\t     (void *)get_wchan(p),\n\t\t\t\t\t     delta >> 20);\n\t\t\t}\n\t\t\taccount_scheduler_latency(p, delta >> 10, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__schedstats_from_dl_se",
          "args": [
            "dl_se"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "__schedstats_from_dl_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1477-1481",
          "snippet": "static inline struct sched_statistics *\n__schedstats_from_dl_se(struct sched_dl_entity *dl_se)\n{\n\treturn &dl_task_of(dl_se)->stats;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct sched_statistics *\n__schedstats_from_dl_se(struct sched_dl_entity *dl_se)\n{\n\treturn &dl_task_of(dl_se)->stats;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4325-4331",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void\nupdate_stats_enqueue_sleeper_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_enqueue_sleeper(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}"
  },
  {
    "function_name": "update_stats_wait_end_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1495-1505",
    "snippet": "static inline void\nupdate_stats_wait_end_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_end(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_stats_wait_end",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "dl_task_of(dl_se)",
            "stats"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "__update_stats_wait_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
          "lines": "21-46",
          "snippet": "void __update_stats_wait_end(struct rq *rq, struct task_struct *p,\n\t\t\t     struct sched_statistics *stats)\n{\n\tu64 delta = rq_clock(rq) - schedstat_val(stats->wait_start);\n\n\tif (p) {\n\t\tif (task_on_rq_migrating(p)) {\n\t\t\t/*\n\t\t\t * Preserve migrating task's wait time so wait_start\n\t\t\t * time stamp can be adjusted to accumulate wait time\n\t\t\t * prior to migration.\n\t\t\t */\n\t\t\t__schedstat_set(stats->wait_start, delta);\n\n\t\t\treturn;\n\t\t}\n\n\t\ttrace_sched_stat_wait(p, delta);\n\t}\n\n\t__schedstat_set(stats->wait_max,\n\t\t\tmax(schedstat_val(stats->wait_max), delta));\n\t__schedstat_inc(stats->wait_count);\n\t__schedstat_add(stats->wait_sum, delta);\n\t__schedstat_set(stats->wait_start, 0);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __update_stats_wait_end(struct rq *rq, struct task_struct *p,\n\t\t\t     struct sched_statistics *stats)\n{\n\tu64 delta = rq_clock(rq) - schedstat_val(stats->wait_start);\n\n\tif (p) {\n\t\tif (task_on_rq_migrating(p)) {\n\t\t\t/*\n\t\t\t * Preserve migrating task's wait time so wait_start\n\t\t\t * time stamp can be adjusted to accumulate wait time\n\t\t\t * prior to migration.\n\t\t\t */\n\t\t\t__schedstat_set(stats->wait_start, delta);\n\n\t\t\treturn;\n\t\t}\n\n\t\ttrace_sched_stat_wait(p, delta);\n\t}\n\n\t__schedstat_set(stats->wait_max,\n\t\t\tmax(schedstat_val(stats->wait_max), delta));\n\t__schedstat_inc(stats->wait_count);\n\t__schedstat_add(stats->wait_sum, delta);\n\t__schedstat_set(stats->wait_start, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__schedstats_from_dl_se",
          "args": [
            "dl_se"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "__schedstats_from_dl_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1477-1481",
          "snippet": "static inline struct sched_statistics *\n__schedstats_from_dl_se(struct sched_dl_entity *dl_se)\n{\n\treturn &dl_task_of(dl_se)->stats;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct sched_statistics *\n__schedstats_from_dl_se(struct sched_dl_entity *dl_se)\n{\n\treturn &dl_task_of(dl_se)->stats;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4325-4331",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void\nupdate_stats_wait_end_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_end(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}"
  },
  {
    "function_name": "update_stats_wait_start_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1483-1493",
    "snippet": "static inline void\nupdate_stats_wait_start_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_start(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_stats_wait_start",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "dl_task_of(dl_se)",
            "stats"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "__update_stats_wait_start",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/stats.c",
          "lines": "7-19",
          "snippet": "void __update_stats_wait_start(struct rq *rq, struct task_struct *p,\n\t\t\t       struct sched_statistics *stats)\n{\n\tu64 wait_start, prev_wait_start;\n\n\twait_start = rq_clock(rq);\n\tprev_wait_start = schedstat_val(stats->wait_start);\n\n\tif (p && likely(wait_start > prev_wait_start))\n\t\twait_start -= prev_wait_start;\n\n\t__schedstat_set(stats->wait_start, wait_start);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid __update_stats_wait_start(struct rq *rq, struct task_struct *p,\n\t\t\t       struct sched_statistics *stats)\n{\n\tu64 wait_start, prev_wait_start;\n\n\twait_start = rq_clock(rq);\n\tprev_wait_start = schedstat_val(stats->wait_start);\n\n\tif (p && likely(wait_start > prev_wait_start))\n\t\twait_start -= prev_wait_start;\n\n\t__schedstat_set(stats->wait_start, wait_start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__schedstats_from_dl_se",
          "args": [
            "dl_se"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "__schedstats_from_dl_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1477-1481",
          "snippet": "static inline struct sched_statistics *\n__schedstats_from_dl_se(struct sched_dl_entity *dl_se)\n{\n\treturn &dl_task_of(dl_se)->stats;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct sched_statistics *\n__schedstats_from_dl_se(struct sched_dl_entity *dl_se)\n{\n\treturn &dl_task_of(dl_se)->stats;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedstat_enabled",
          "args": [],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "force_schedstat_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4325-4331",
          "snippet": "void force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nvoid force_schedstat_enabled(void)\n{\n\tif (!schedstat_enabled()) {\n\t\tpr_info(\"kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\\n\");\n\t\tstatic_branch_enable(&sched_schedstats);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void\nupdate_stats_wait_start_dl(struct dl_rq *dl_rq, struct sched_dl_entity *dl_se)\n{\n\tstruct sched_statistics *stats;\n\n\tif (!schedstat_enabled())\n\t\treturn;\n\n\tstats = __schedstats_from_dl_se(dl_se);\n\t__update_stats_wait_start(rq_of_dl_rq(dl_rq), dl_task_of(dl_se), stats);\n}"
  },
  {
    "function_name": "__schedstats_from_dl_se",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1477-1481",
    "snippet": "static inline struct sched_statistics *\n__schedstats_from_dl_se(struct sched_dl_entity *dl_se)\n{\n\treturn &dl_task_of(dl_se)->stats;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct sched_statistics *\n__schedstats_from_dl_se(struct sched_dl_entity *dl_se)\n{\n\treturn &dl_task_of(dl_se)->stats;\n}"
  },
  {
    "function_name": "__dl_less",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1472-1475",
    "snippet": "static inline bool __dl_less(struct rb_node *a, const struct rb_node *b)\n{\n\treturn dl_time_before(__node_2_dle(a)->deadline, __node_2_dle(b)->deadline);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "__node_2_dle(a)->deadline",
            "__node_2_dle(b)->deadline"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__node_2_dle",
          "args": [
            "b"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__node_2_dle",
          "args": [
            "a"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool __dl_less(struct rb_node *a, const struct rb_node *b)\n{\n\treturn dl_time_before(__node_2_dle(a)->deadline, __node_2_dle(b)->deadline);\n}"
  },
  {
    "function_name": "dec_dl_tasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1455-1467",
    "snippet": "static inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\tWARN_ON(!dl_prio(prio));\n\tWARN_ON(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_dl_migration",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "dec_dl_migration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "681-684",
          "snippet": "static inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_dl_deadline",
          "args": [
            "dl_rq",
            "dl_se->deadline"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "dec_dl_deadline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1437-1437",
          "snippet": "static inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}"
        }
      },
      {
        "call_info": {
          "callee": "sub_nr_running",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "1"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "sub_nr_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2394-2403",
          "snippet": "static inline void sub_nr_running(struct rq *rq, unsigned count)\n{\n\trq->nr_running -= count;\n\tif (trace_sched_update_nr_running_tp_enabled()) {\n\t\tcall_trace_sched_update_nr_running(rq, -count);\n\t}\n\n\t/* Check if we still need preemption */\n\tsched_update_tick_dependency(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void call_trace_sched_update_nr_running(struct rq *rq, int count);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void call_trace_sched_update_nr_running(struct rq *rq, int count);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void sub_nr_running(struct rq *rq, unsigned count)\n{\n\trq->nr_running -= count;\n\tif (trace_sched_update_nr_running_tp_enabled()) {\n\t\tcall_trace_sched_update_nr_running(rq, -count);\n\t}\n\n\t/* Check if we still need preemption */\n\tsched_update_tick_dependency(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dl_rq->dl_nr_running"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dl_prio(prio)"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "prio"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\tWARN_ON(!dl_prio(prio));\n\tWARN_ON(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}"
  },
  {
    "function_name": "inc_dl_tasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1441-1453",
    "snippet": "static inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\tWARN_ON(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_dl_migration",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "inc_dl_migration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "676-679",
          "snippet": "static inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_dl_deadline",
          "args": [
            "dl_rq",
            "deadline"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "inc_dl_deadline",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1436-1436",
          "snippet": "static inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}"
        }
      },
      {
        "call_info": {
          "callee": "add_nr_running",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "1"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "add_nr_running",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2375-2392",
          "snippet": "static inline void add_nr_running(struct rq *rq, unsigned count)\n{\n\tunsigned prev_nr = rq->nr_running;\n\n\trq->nr_running = prev_nr + count;\n\tif (trace_sched_update_nr_running_tp_enabled()) {\n\t\tcall_trace_sched_update_nr_running(rq, count);\n\t}\n\n#ifdef CONFIG_SMP\n\tif (prev_nr < 2 && rq->nr_running >= 2) {\n\t\tif (!READ_ONCE(rq->rd->overload))\n\t\t\tWRITE_ONCE(rq->rd->overload, 1);\n\t}\n#endif\n\n\tsched_update_tick_dependency(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void call_trace_sched_update_nr_running(struct rq *rq, int count);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void call_trace_sched_update_nr_running(struct rq *rq, int count);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void add_nr_running(struct rq *rq, unsigned count)\n{\n\tunsigned prev_nr = rq->nr_running;\n\n\trq->nr_running = prev_nr + count;\n\tif (trace_sched_update_nr_running_tp_enabled()) {\n\t\tcall_trace_sched_update_nr_running(rq, count);\n\t}\n\n#ifdef CONFIG_SMP\n\tif (prev_nr < 2 && rq->nr_running >= 2) {\n\t\tif (!READ_ONCE(rq->rd->overload))\n\t\t\tWRITE_ONCE(rq->rd->overload, 1);\n\t}\n#endif\n\n\tsched_update_tick_dependency(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dl_prio(prio)"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "prio"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\tWARN_ON(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}"
  },
  {
    "function_name": "dec_dl_deadline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1437-1437",
    "snippet": "static inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}"
  },
  {
    "function_name": "inc_dl_deadline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1436-1436",
    "snippet": "static inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}"
  },
  {
    "function_name": "dec_dl_deadline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1411-1432",
    "snippet": "static void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\t/*\n\t * Since we may have removed our earliest (and/or next earliest)\n\t * task we must recompute them.\n\t */\n\tif (!dl_rq->dl_nr_running) {\n\t\tdl_rq->earliest_dl.curr = 0;\n\t\tdl_rq->earliest_dl.next = 0;\n\t\tcpudl_clear(&rq->rd->cpudl, rq->cpu);\n\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, rq->rt.highest_prio.curr);\n\t} else {\n\t\tstruct rb_node *leftmost = dl_rq->root.rb_leftmost;\n\t\tstruct sched_dl_entity *entry;\n\n\t\tentry = rb_entry(leftmost, struct sched_dl_entity, rb_node);\n\t\tdl_rq->earliest_dl.curr = entry->deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, entry->deadline);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpudl_set",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu",
            "entry->deadline"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "214-238",
          "snippet": "void cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "leftmost",
            "structsched_dl_entity",
            "rb_node"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpupri_set",
          "args": [
            "&rq->rd->cpupri",
            "rq->cpu",
            "rq->rt.highest_prio.curr"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "cpupri_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpupri.c",
          "lines": "210-270",
          "snippet": "void cpupri_set(struct cpupri *cp, int cpu, int newpri)\n{\n\tint *currpri = &cp->cpu_to_pri[cpu];\n\tint oldpri = *currpri;\n\tint do_mb = 0;\n\n\tnewpri = convert_prio(newpri);\n\n\tBUG_ON(newpri >= CPUPRI_NR_PRIORITIES);\n\n\tif (newpri == oldpri)\n\t\treturn;\n\n\t/*\n\t * If the CPU was currently mapped to a different value, we\n\t * need to map it to the new value then remove the old value.\n\t * Note, we must add the new value first, otherwise we risk the\n\t * cpu being missed by the priority loop in cpupri_find.\n\t */\n\tif (likely(newpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\n\n\t\tcpumask_set_cpu(cpu, vec->mask);\n\t\t/*\n\t\t * When adding a new vector, we update the mask first,\n\t\t * do a write memory barrier, and then update the count, to\n\t\t * make sure the vector is visible when count is set.\n\t\t */\n\t\tsmp_mb__before_atomic();\n\t\tatomic_inc(&(vec)->count);\n\t\tdo_mb = 1;\n\t}\n\tif (likely(oldpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[oldpri];\n\n\t\t/*\n\t\t * Because the order of modification of the vec->count\n\t\t * is important, we must make sure that the update\n\t\t * of the new prio is seen before we decrement the\n\t\t * old prio. This makes sure that the loop sees\n\t\t * one or the other when we raise the priority of\n\t\t * the run queue. We don't care about when we lower the\n\t\t * priority, as that will trigger an rt pull anyway.\n\t\t *\n\t\t * We only need to do a memory barrier if we updated\n\t\t * the new priority vec.\n\t\t */\n\t\tif (do_mb)\n\t\t\tsmp_mb__after_atomic();\n\n\t\t/*\n\t\t * When removing from the vector, we decrement the counter first\n\t\t * do a memory barrier and then clear the mask.\n\t\t */\n\t\tatomic_dec(&(vec)->count);\n\t\tsmp_mb__after_atomic();\n\t\tcpumask_clear_cpu(cpu, vec->mask);\n\t}\n\n\t*currpri = newpri;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpupri_set(struct cpupri *cp, int cpu, int newpri)\n{\n\tint *currpri = &cp->cpu_to_pri[cpu];\n\tint oldpri = *currpri;\n\tint do_mb = 0;\n\n\tnewpri = convert_prio(newpri);\n\n\tBUG_ON(newpri >= CPUPRI_NR_PRIORITIES);\n\n\tif (newpri == oldpri)\n\t\treturn;\n\n\t/*\n\t * If the CPU was currently mapped to a different value, we\n\t * need to map it to the new value then remove the old value.\n\t * Note, we must add the new value first, otherwise we risk the\n\t * cpu being missed by the priority loop in cpupri_find.\n\t */\n\tif (likely(newpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\n\n\t\tcpumask_set_cpu(cpu, vec->mask);\n\t\t/*\n\t\t * When adding a new vector, we update the mask first,\n\t\t * do a write memory barrier, and then update the count, to\n\t\t * make sure the vector is visible when count is set.\n\t\t */\n\t\tsmp_mb__before_atomic();\n\t\tatomic_inc(&(vec)->count);\n\t\tdo_mb = 1;\n\t}\n\tif (likely(oldpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[oldpri];\n\n\t\t/*\n\t\t * Because the order of modification of the vec->count\n\t\t * is important, we must make sure that the update\n\t\t * of the new prio is seen before we decrement the\n\t\t * old prio. This makes sure that the loop sees\n\t\t * one or the other when we raise the priority of\n\t\t * the run queue. We don't care about when we lower the\n\t\t * priority, as that will trigger an rt pull anyway.\n\t\t *\n\t\t * We only need to do a memory barrier if we updated\n\t\t * the new priority vec.\n\t\t */\n\t\tif (do_mb)\n\t\t\tsmp_mb__after_atomic();\n\n\t\t/*\n\t\t * When removing from the vector, we decrement the counter first\n\t\t * do a memory barrier and then clear the mask.\n\t\t */\n\t\tatomic_dec(&(vec)->count);\n\t\tsmp_mb__after_atomic();\n\t\tcpumask_clear_cpu(cpu, vec->mask);\n\t}\n\n\t*currpri = newpri;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpudl_clear",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_clear_freecpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "255-258",
          "snippet": "void cpudl_clear_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_clear_cpu(cpu, cp->free_cpus);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_clear_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_clear_cpu(cpu, cp->free_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\t/*\n\t * Since we may have removed our earliest (and/or next earliest)\n\t * task we must recompute them.\n\t */\n\tif (!dl_rq->dl_nr_running) {\n\t\tdl_rq->earliest_dl.curr = 0;\n\t\tdl_rq->earliest_dl.next = 0;\n\t\tcpudl_clear(&rq->rd->cpudl, rq->cpu);\n\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, rq->rt.highest_prio.curr);\n\t} else {\n\t\tstruct rb_node *leftmost = dl_rq->root.rb_leftmost;\n\t\tstruct sched_dl_entity *entry;\n\n\t\tentry = rb_entry(leftmost, struct sched_dl_entity, rb_node);\n\t\tdl_rq->earliest_dl.curr = entry->deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, entry->deadline);\n\t}\n}"
  },
  {
    "function_name": "inc_dl_deadline",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1398-1409",
    "snippet": "static void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_rq->earliest_dl.curr == 0 ||\n\t    dl_time_before(deadline, dl_rq->earliest_dl.curr)) {\n\t\tif (dl_rq->earliest_dl.curr == 0)\n\t\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, CPUPRI_HIGHER);\n\t\tdl_rq->earliest_dl.curr = deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, deadline);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpudl_set",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu",
            "deadline"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpudeadline.c",
          "lines": "214-238",
          "snippet": "void cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpupri_set",
          "args": [
            "&rq->rd->cpupri",
            "rq->cpu",
            "CPUPRI_HIGHER"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "cpupri_set",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/cpupri.c",
          "lines": "210-270",
          "snippet": "void cpupri_set(struct cpupri *cp, int cpu, int newpri)\n{\n\tint *currpri = &cp->cpu_to_pri[cpu];\n\tint oldpri = *currpri;\n\tint do_mb = 0;\n\n\tnewpri = convert_prio(newpri);\n\n\tBUG_ON(newpri >= CPUPRI_NR_PRIORITIES);\n\n\tif (newpri == oldpri)\n\t\treturn;\n\n\t/*\n\t * If the CPU was currently mapped to a different value, we\n\t * need to map it to the new value then remove the old value.\n\t * Note, we must add the new value first, otherwise we risk the\n\t * cpu being missed by the priority loop in cpupri_find.\n\t */\n\tif (likely(newpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\n\n\t\tcpumask_set_cpu(cpu, vec->mask);\n\t\t/*\n\t\t * When adding a new vector, we update the mask first,\n\t\t * do a write memory barrier, and then update the count, to\n\t\t * make sure the vector is visible when count is set.\n\t\t */\n\t\tsmp_mb__before_atomic();\n\t\tatomic_inc(&(vec)->count);\n\t\tdo_mb = 1;\n\t}\n\tif (likely(oldpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[oldpri];\n\n\t\t/*\n\t\t * Because the order of modification of the vec->count\n\t\t * is important, we must make sure that the update\n\t\t * of the new prio is seen before we decrement the\n\t\t * old prio. This makes sure that the loop sees\n\t\t * one or the other when we raise the priority of\n\t\t * the run queue. We don't care about when we lower the\n\t\t * priority, as that will trigger an rt pull anyway.\n\t\t *\n\t\t * We only need to do a memory barrier if we updated\n\t\t * the new priority vec.\n\t\t */\n\t\tif (do_mb)\n\t\t\tsmp_mb__after_atomic();\n\n\t\t/*\n\t\t * When removing from the vector, we decrement the counter first\n\t\t * do a memory barrier and then clear the mask.\n\t\t */\n\t\tatomic_dec(&(vec)->count);\n\t\tsmp_mb__after_atomic();\n\t\tcpumask_clear_cpu(cpu, vec->mask);\n\t}\n\n\t*currpri = newpri;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpupri_set(struct cpupri *cp, int cpu, int newpri)\n{\n\tint *currpri = &cp->cpu_to_pri[cpu];\n\tint oldpri = *currpri;\n\tint do_mb = 0;\n\n\tnewpri = convert_prio(newpri);\n\n\tBUG_ON(newpri >= CPUPRI_NR_PRIORITIES);\n\n\tif (newpri == oldpri)\n\t\treturn;\n\n\t/*\n\t * If the CPU was currently mapped to a different value, we\n\t * need to map it to the new value then remove the old value.\n\t * Note, we must add the new value first, otherwise we risk the\n\t * cpu being missed by the priority loop in cpupri_find.\n\t */\n\tif (likely(newpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\n\n\t\tcpumask_set_cpu(cpu, vec->mask);\n\t\t/*\n\t\t * When adding a new vector, we update the mask first,\n\t\t * do a write memory barrier, and then update the count, to\n\t\t * make sure the vector is visible when count is set.\n\t\t */\n\t\tsmp_mb__before_atomic();\n\t\tatomic_inc(&(vec)->count);\n\t\tdo_mb = 1;\n\t}\n\tif (likely(oldpri != CPUPRI_INVALID)) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[oldpri];\n\n\t\t/*\n\t\t * Because the order of modification of the vec->count\n\t\t * is important, we must make sure that the update\n\t\t * of the new prio is seen before we decrement the\n\t\t * old prio. This makes sure that the loop sees\n\t\t * one or the other when we raise the priority of\n\t\t * the run queue. We don't care about when we lower the\n\t\t * priority, as that will trigger an rt pull anyway.\n\t\t *\n\t\t * We only need to do a memory barrier if we updated\n\t\t * the new priority vec.\n\t\t */\n\t\tif (do_mb)\n\t\t\tsmp_mb__after_atomic();\n\n\t\t/*\n\t\t * When removing from the vector, we decrement the counter first\n\t\t * do a memory barrier and then clear the mask.\n\t\t */\n\t\tatomic_dec(&(vec)->count);\n\t\tsmp_mb__after_atomic();\n\t\tcpumask_clear_cpu(cpu, vec->mask);\n\t}\n\n\t*currpri = newpri;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "deadline",
            "dl_rq->earliest_dl.curr"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_rq->earliest_dl.curr == 0 ||\n\t    dl_time_before(deadline, dl_rq->earliest_dl.curr)) {\n\t\tif (dl_rq->earliest_dl.curr == 0)\n\t\t\tcpupri_set(&rq->rd->cpupri, rq->cpu, CPUPRI_HIGHER);\n\t\tdl_rq->earliest_dl.curr = deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, deadline);\n\t}\n}"
  },
  {
    "function_name": "init_dl_inactive_task_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1388-1394",
    "snippet": "void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\ttimer->function = inactive_task_timer;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL_HARD"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_inactive_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\ttimer->function = inactive_task_timer;\n}"
  },
  {
    "function_name": "inactive_task_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1346-1386",
    "snippet": "static enum hrtimer_restart inactive_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     inactive_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {\n\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\tif (READ_ONCE(p->__state) == TASK_DEAD && dl_se->dl_non_contending) {\n\t\t\tsub_running_bw(&p->dl, dl_rq_of_se(&p->dl));\n\t\t\tsub_rq_bw(&p->dl, dl_rq_of_se(&p->dl));\n\t\t\tdl_se->dl_non_contending = 0;\n\t\t}\n\n\t\traw_spin_lock(&dl_b->lock);\n\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\traw_spin_unlock(&dl_b->lock);\n\t\t__dl_clear_params(p);\n\n\t\tgoto unlock;\n\t}\n\tif (dl_se->dl_non_contending == 0)\n\t\tgoto unlock;\n\n\tsub_running_bw(dl_se, &rq->dl);\n\tdl_se->dl_non_contending = 0;\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\tput_task_struct(p);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1586-1594",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "dl_se",
            "&rq->dl"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "226-231",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_clear_params",
          "args": [
            "p"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_clear_params",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2923-2942",
          "snippet": "void __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n\n#ifdef CONFIG_RT_MUTEXES\n\tdl_se->pi_se\t\t\t= dl_se;\n#endif\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nvoid __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n\n#ifdef CONFIG_RT_MUTEXES\n\tdl_se->pi_se\t\t\t= dl_se;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_sub",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "dl_bw_cpus(task_cpu(p))"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_sub",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "306-311",
          "snippet": "static inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "task_cpu(p)"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "139-142",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "dl_rq_of_se(&p->dl)"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "212-217",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "&p->dl"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->__state"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "task_cpu(p)"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "134-137",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->__state"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "679-699",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_tick",
          "args": [],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_tick_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "406-421",
          "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "582-619",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structsched_dl_entity",
            "inactive_timer"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic enum hrtimer_restart inactive_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     inactive_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {\n\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\tif (READ_ONCE(p->__state) == TASK_DEAD && dl_se->dl_non_contending) {\n\t\t\tsub_running_bw(&p->dl, dl_rq_of_se(&p->dl));\n\t\t\tsub_rq_bw(&p->dl, dl_rq_of_se(&p->dl));\n\t\t\tdl_se->dl_non_contending = 0;\n\t\t}\n\n\t\traw_spin_lock(&dl_b->lock);\n\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\traw_spin_unlock(&dl_b->lock);\n\t\t__dl_clear_params(p);\n\n\t\tgoto unlock;\n\t}\n\tif (dl_se->dl_non_contending == 0)\n\t\tgoto unlock;\n\n\tsub_running_bw(dl_se, &rq->dl);\n\tdl_se->dl_non_contending = 0;\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\tput_task_struct(p);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "update_curr_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1241-1344",
    "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rt_rq->rt_runtime_lock"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_rt_bandwidth_account",
          "args": [
            "rt_rq"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "sched_rt_bandwidth_account",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/rt.c",
          "lines": "680-686",
          "snippet": "bool sched_rt_bandwidth_account(struct rt_rq *rt_rq)\n{\n\tstruct rt_bandwidth *rt_b = sched_rt_bandwidth(rt_rq);\n\n\treturn (hrtimer_active(&rt_b->rt_period_timer) ||\n\t\trt_rq->rt_time < rt_b->rt_runtime);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_top_rt_rq(struct rt_rq *rt_rq);",
            "static void dequeue_top_rt_rq(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_top_rt_rq(struct rt_rq *rt_rq);\nstatic void dequeue_top_rt_rq(struct rt_rq *rt_rq);\n\nbool sched_rt_bandwidth_account(struct rt_rq *rt_rq)\n{\n\tstruct rt_bandwidth *rt_b = sched_rt_bandwidth(rt_rq);\n\n\treturn (hrtimer_active(&rt_b->rt_period_timer) ||\n\t\trt_rq->rt_time < rt_b->rt_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rt_rq->rt_runtime_lock"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_bandwidth_enabled",
          "args": [],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "rt_bandwidth_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "630-633",
          "snippet": "static inline int rt_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int rt_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "976-998",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_leftmost",
          "args": [
            "curr",
            "&rq->dl"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "is_leftmost",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "407-412",
          "snippet": "static inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task_dl",
          "args": [
            "rq",
            "curr",
            "ENQUEUE_REPLENISH"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1609-1688",
          "snippet": "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (is_dl_boosted(&p->dl)) {\n\t\t/*\n\t\t * Because of delays in the detection of the overrun of a\n\t\t * thread's runtime, it might be the case that a thread\n\t\t * goes to sleep in a rt mutex with negative runtime. As\n\t\t * a consequence, the thread will be throttled.\n\t\t *\n\t\t * While waiting for the mutex, this thread can also be\n\t\t * boosted via PI, resulting in a thread that is throttled\n\t\t * and boosted at the same time.\n\t\t *\n\t\t * In this case, the boost overrides the throttle.\n\t\t */\n\t\tif (p->dl.dl_throttled) {\n\t\t\t/*\n\t\t\t * The replenish timer needs to be canceled. No\n\t\t\t * problem if it fires concurrently: boosted threads\n\t\t\t * are ignored in dl_task_timer().\n\t\t\t */\n\t\t\thrtimer_try_to_cancel(&p->dl.dl_timer);\n\t\t\tp->dl.dl_throttled = 0;\n\t\t}\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task that is going\n\t\t * to be deboosted, but exceeds its runtime while doing so. No point in\n\t\t * replenishing it, as it's going to return back to its original\n\t\t * scheduling class after this. If it has been throttled, we need to\n\t\t * clear the flag, otherwise the task may wake up as throttled after\n\t\t * being boosted again with no means to replenish the runtime and clear\n\t\t * the throttle.\n\t\t */\n\t\tp->dl.dl_throttled = 0;\n\t\tBUG_ON(!is_dl_boosted(&p->dl) || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tcheck_schedstat_required();\n\tupdate_stats_wait_start_dl(dl_rq_of_se(&p->dl), &p->dl);\n\n\tenqueue_dl_entity(&p->dl, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (is_dl_boosted(&p->dl)) {\n\t\t/*\n\t\t * Because of delays in the detection of the overrun of a\n\t\t * thread's runtime, it might be the case that a thread\n\t\t * goes to sleep in a rt mutex with negative runtime. As\n\t\t * a consequence, the thread will be throttled.\n\t\t *\n\t\t * While waiting for the mutex, this thread can also be\n\t\t * boosted via PI, resulting in a thread that is throttled\n\t\t * and boosted at the same time.\n\t\t *\n\t\t * In this case, the boost overrides the throttle.\n\t\t */\n\t\tif (p->dl.dl_throttled) {\n\t\t\t/*\n\t\t\t * The replenish timer needs to be canceled. No\n\t\t\t * problem if it fires concurrently: boosted threads\n\t\t\t * are ignored in dl_task_timer().\n\t\t\t */\n\t\t\thrtimer_try_to_cancel(&p->dl.dl_timer);\n\t\t\tp->dl.dl_throttled = 0;\n\t\t}\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task that is going\n\t\t * to be deboosted, but exceeds its runtime while doing so. No point in\n\t\t * replenishing it, as it's going to return back to its original\n\t\t * scheduling class after this. If it has been throttled, we need to\n\t\t * clear the flag, otherwise the task may wake up as throttled after\n\t\t * being boosted again with no means to replenish the runtime and clear\n\t\t * the throttle.\n\t\t */\n\t\tp->dl.dl_throttled = 0;\n\t\tBUG_ON(!is_dl_boosted(&p->dl) || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tcheck_schedstat_required();\n\tupdate_stats_wait_start_dl(dl_rq_of_se(&p->dl), &p->dl);\n\n\tenqueue_dl_entity(&p->dl, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_dl_boosted(dl_se) || !start_dl_timer(curr)"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_dl_timer",
          "args": [
            "curr"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "start_dl_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "982-1025",
          "snippet": "static int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS_HARD);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS_HARD);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dl_boosted",
          "args": [
            "dl_se"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "is_dl_boosted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "62-65",
          "snippet": "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dequeue_task_dl",
          "args": [
            "rq",
            "curr",
            "0"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "__dequeue_task_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1690-1695",
          "snippet": "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_stats_dequeue_dl(&rq->dl, &p->dl, flags);\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_stats_dequeue_dl(&rq->dl, &p->dl, flags);\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_runtime_exceeded",
          "args": [
            "dl_se"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "dl_runtime_exceeded",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1188-1192",
          "snippet": "static\nint dl_runtime_exceeded(struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic\nint dl_runtime_exceeded(struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_scale",
          "args": [
            "scaled_delta_exec",
            "scale_cpu"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_scale",
          "args": [
            "delta_exec",
            "scale_freq"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_scale_cpu_capacity",
          "args": [
            "cpu"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_scale_freq_capacity",
          "args": [
            "cpu"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "arch_scale_freq_capacity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2496-2500",
          "snippet": "static __always_inline\nunsigned long arch_scale_freq_capacity(int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic __always_inline\nunsigned long arch_scale_freq_capacity(int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grub_reclaim",
          "args": [
            "delta_exec",
            "rq",
            "&curr->dl"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "grub_reclaim",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1215-1235",
          "snippet": "static u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\tu64 u_inact = rq->dl.this_bw - rq->dl.running_bw; /* Utot - Uact */\n\tu64 u_act;\n\tu64 u_act_min = (dl_se->dl_bw * rq->dl.bw_ratio) >> RATIO_SHIFT;\n\n\t/*\n\t * Instead of computing max{u * bw_ratio, (1 - u_inact - u_extra)},\n\t * we compare u_inact + rq->dl.extra_bw with\n\t * 1 - (u * rq->dl.bw_ratio >> RATIO_SHIFT), because\n\t * u_inact + rq->dl.extra_bw can be larger than\n\t * 1 * (so, 1 - u_inact - rq->dl.extra_bw would be negative\n\t * leading to wrong results)\n\t */\n\tif (u_inact + rq->dl.extra_bw > BW_UNIT - u_act_min)\n\t\tu_act = u_act_min;\n\telse\n\t\tu_act = BW_UNIT - u_inact - rq->dl.extra_bw;\n\n\treturn (delta * u_act) >> BW_SHIFT;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\tu64 u_inact = rq->dl.this_bw - rq->dl.running_bw; /* Utot - Uact */\n\tu64 u_act;\n\tu64 u_act_min = (dl_se->dl_bw * rq->dl.bw_ratio) >> RATIO_SHIFT;\n\n\t/*\n\t * Instead of computing max{u * bw_ratio, (1 - u_inact - u_extra)},\n\t * we compare u_inact + rq->dl.extra_bw with\n\t * 1 - (u * rq->dl.bw_ratio >> RATIO_SHIFT), because\n\t * u_inact + rq->dl.extra_bw can be larger than\n\t * 1 * (so, 1 - u_inact - rq->dl.extra_bw would be negative\n\t * leading to wrong results)\n\t */\n\tif (u_inact + rq->dl.extra_bw > BW_UNIT - u_act_min)\n\t\tu_act = u_act_min;\n\telse\n\t\tu_act = BW_UNIT - u_inact - rq->dl.extra_bw;\n\n\treturn (delta * u_act) >> BW_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dl_se->flags & SCHED_FLAG_RECLAIM"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "231-238",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_account_cputime",
          "args": [
            "curr",
            "delta_exec"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_account_cputime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/cgroup/rstat.c",
          "lines": "365-373",
          "snippet": "void __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\trstatc->bstat.cputime.sum_exec_runtime += delta_exec;\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\tunsigned long flags;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp, &flags);\n\trstatc->bstat.cputime.sum_exec_runtime += delta_exec;\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_group_exec_runtime",
          "args": [
            "curr",
            "delta_exec"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_stat_runtime",
          "args": [
            "curr",
            "delta_exec",
            "0"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_set",
          "args": [
            "curr->stats.exec_max",
            "max(curr->stats.exec_max, delta_exec)"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "curr->stats.exec_max",
            "delta_exec"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "254-257",
          "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dl_se->dl_yielded"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(s64)delta_exec <= 0"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock_task",
          "args": [
            "rq"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1470-1476",
          "snippet": "static inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_rq_held(rq);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_rq_held(rq);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_dl_rq",
          "args": [
            "dl_se"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "on_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "41-44",
          "snippet": "static inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "curr"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1137-1144",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->stats.exec_max,\n\t\t      max(curr->stats.exec_max, delta_exec));\n\n\ttrace_sched_stat_runtime(curr, delta_exec, 0);\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
  },
  {
    "function_name": "grub_reclaim",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1215-1235",
    "snippet": "static u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\tu64 u_inact = rq->dl.this_bw - rq->dl.running_bw; /* Utot - Uact */\n\tu64 u_act;\n\tu64 u_act_min = (dl_se->dl_bw * rq->dl.bw_ratio) >> RATIO_SHIFT;\n\n\t/*\n\t * Instead of computing max{u * bw_ratio, (1 - u_inact - u_extra)},\n\t * we compare u_inact + rq->dl.extra_bw with\n\t * 1 - (u * rq->dl.bw_ratio >> RATIO_SHIFT), because\n\t * u_inact + rq->dl.extra_bw can be larger than\n\t * 1 * (so, 1 - u_inact - rq->dl.extra_bw would be negative\n\t * leading to wrong results)\n\t */\n\tif (u_inact + rq->dl.extra_bw > BW_UNIT - u_act_min)\n\t\tu_act = u_act_min;\n\telse\n\t\tu_act = BW_UNIT - u_inact - rq->dl.extra_bw;\n\n\treturn (delta * u_act) >> BW_SHIFT;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\tu64 u_inact = rq->dl.this_bw - rq->dl.running_bw; /* Utot - Uact */\n\tu64 u_act;\n\tu64 u_act_min = (dl_se->dl_bw * rq->dl.bw_ratio) >> RATIO_SHIFT;\n\n\t/*\n\t * Instead of computing max{u * bw_ratio, (1 - u_inact - u_extra)},\n\t * we compare u_inact + rq->dl.extra_bw with\n\t * 1 - (u * rq->dl.bw_ratio >> RATIO_SHIFT), because\n\t * u_inact + rq->dl.extra_bw can be larger than\n\t * 1 * (so, 1 - u_inact - rq->dl.extra_bw would be negative\n\t * leading to wrong results)\n\t */\n\tif (u_inact + rq->dl.extra_bw > BW_UNIT - u_act_min)\n\t\tu_act = u_act_min;\n\telse\n\t\tu_act = BW_UNIT - u_inact - rq->dl.extra_bw;\n\n\treturn (delta * u_act) >> BW_SHIFT;\n}"
  },
  {
    "function_name": "dl_runtime_exceeded",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1188-1192",
    "snippet": "static\nint dl_runtime_exceeded(struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic\nint dl_runtime_exceeded(struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}"
  },
  {
    "function_name": "dl_check_constrained_dl",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1173-1186",
    "snippet": "static inline void dl_check_constrained_dl(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq_of_se(dl_se));\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t    dl_time_before(rq_clock(rq), dl_next_period(dl_se))) {\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(p)))\n\t\t\treturn;\n\t\tdl_se->dl_throttled = 1;\n\t\tif (dl_se->runtime > 0)\n\t\t\tdl_se->runtime = 0;\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_dl_boosted(dl_se) || !start_dl_timer(p)"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_dl_timer",
          "args": [
            "p"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "start_dl_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "982-1025",
          "snippet": "static int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS_HARD);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS_HARD);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dl_boosted",
          "args": [
            "dl_se"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "is_dl_boosted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "62-65",
          "snippet": "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "rq_clock(rq)",
            "dl_next_period(dl_se)"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_next_period",
          "args": [
            "dl_se"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "dl_next_period",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "967-970",
          "snippet": "static inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq)"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq_of_se(dl_se)"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_check_constrained_dl(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq_of_se(dl_se));\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t    dl_time_before(rq_clock(rq), dl_next_period(dl_se))) {\n\t\tif (unlikely(is_dl_boosted(dl_se) || !start_dl_timer(p)))\n\t\t\treturn;\n\t\tdl_se->dl_throttled = 1;\n\t\tif (dl_se->runtime > 0)\n\t\t\tdl_se->runtime = 0;\n\t}\n}"
  },
  {
    "function_name": "init_dl_task_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1147-1153",
    "snippet": "void init_dl_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\ttimer->function = dl_task_timer;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL_HARD"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init_sleeper",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "2007-2013",
          "snippet": "void hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, clockid_t clock_id,\n\t\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(&sl->timer, clock_id, mode);\n\t__hrtimer_init_sleeper(sl, clock_id, mode);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_HARD);\n\ttimer->function = dl_task_timer;\n}"
  },
  {
    "function_name": "dl_task_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "1040-1145",
    "snippet": "static enum hrtimer_restart dl_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     dl_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\t/*\n\t * The task might have changed its scheduling policy to something\n\t * different than SCHED_DEADLINE (through switched_from_dl()).\n\t */\n\tif (!dl_task(p))\n\t\tgoto unlock;\n\n\t/*\n\t * The task might have been boosted by someone else and might be in the\n\t * boosting/deboosting path, its not throttled.\n\t */\n\tif (is_dl_boosted(dl_se))\n\t\tgoto unlock;\n\n\t/*\n\t * Spurious timer due to start_dl_timer() race; or we already received\n\t * a replenishment from rt_mutex_setprio().\n\t */\n\tif (!dl_se->dl_throttled)\n\t\tgoto unlock;\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * If the throttle happened during sched-out; like:\n\t *\n\t *   schedule()\n\t *     deactivate_task()\n\t *       dequeue_task_dl()\n\t *         update_curr_dl()\n\t *           start_dl_timer()\n\t *         __dequeue_task_dl()\n\t *     prev->on_rq = 0;\n\t *\n\t * We can be both throttled and !queued. Replenish the counter\n\t * but do not enqueue -- wait for our wakeup to do that.\n\t */\n\tif (!task_on_rq_queued(p)) {\n\t\treplenish_dl_entity(dl_se);\n\t\tgoto unlock;\n\t}\n\n#ifdef CONFIG_SMP\n\tif (unlikely(!rq->online)) {\n\t\t/*\n\t\t * If the runqueue is no longer available, migrate the\n\t\t * task elsewhere. This necessarily changes rq.\n\t\t */\n\t\tlockdep_unpin_lock(__rq_lockp(rq), rf.cookie);\n\t\trq = dl_task_offline_migration(rq, p);\n\t\trf.cookie = lockdep_pin_lock(__rq_lockp(rq));\n\t\tupdate_rq_clock(rq);\n\n\t\t/*\n\t\t * Now that the task has been migrated to the new RQ and we\n\t\t * have that locked, proceed as normal and enqueue the task\n\t\t * there.\n\t\t */\n\t}\n#endif\n\n\tenqueue_task_dl(rq, p, ENQUEUE_REPLENISH);\n\tif (dl_task(rq->curr))\n\t\tcheck_preempt_curr_dl(rq, p, 0);\n\telse\n\t\tresched_curr(rq);\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Queueing this task back might have overloaded rq, check if we need\n\t * to kick someone away.\n\t */\n\tif (has_pushable_dl_tasks(rq)) {\n\t\t/*\n\t\t * Nothing relies on rq->lock after this, so its safe to drop\n\t\t * rq->lock.\n\t\t */\n\t\trq_unpin_lock(rq, &rf);\n\t\tpush_dl_task(rq);\n\t\trq_repin_lock(rq, &rf);\n\t}\n#endif\n\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\n\t/*\n\t * This can free the task_struct, including this hrtimer, do not touch\n\t * anything related to that after this.\n\t */\n\tput_task_struct(p);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1586-1594",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void post_init_entity_util_avg(struct task_struct *p);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void post_init_entity_util_avg(struct task_struct *p);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_rq_unlock(rq);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_repin_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "rq_repin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1560-1570",
          "snippet": "static inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(__rq_lockp(rq), rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(__rq_lockp(rq), rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_dl_task",
          "args": [
            "rq"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "push_dl_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2313-2318",
          "snippet": "static void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unpin_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unpin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1550-1558",
          "snippet": "static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(__rq_lockp(rq), rf->cookie);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_UPDATED\t\t0x04",
            "#define RQCF_ACT_SKIP\t\t0x02"
          ],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_UPDATED\t\t0x04\n#define RQCF_ACT_SKIP\t\t0x02\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(__rq_lockp(rq), rf->cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_pushable_dl_tasks",
          "args": [
            "rq"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "has_pushable_dl_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "561-564",
          "snippet": "static inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "976-998",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_preempt_curr_dl",
          "args": [
            "rq",
            "p",
            "0"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_curr_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1880-1897",
          "snippet": "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "rq->curr"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task_dl",
          "args": [
            "rq",
            "p",
            "ENQUEUE_REPLENISH"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task_dl",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "1609-1688",
          "snippet": "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (is_dl_boosted(&p->dl)) {\n\t\t/*\n\t\t * Because of delays in the detection of the overrun of a\n\t\t * thread's runtime, it might be the case that a thread\n\t\t * goes to sleep in a rt mutex with negative runtime. As\n\t\t * a consequence, the thread will be throttled.\n\t\t *\n\t\t * While waiting for the mutex, this thread can also be\n\t\t * boosted via PI, resulting in a thread that is throttled\n\t\t * and boosted at the same time.\n\t\t *\n\t\t * In this case, the boost overrides the throttle.\n\t\t */\n\t\tif (p->dl.dl_throttled) {\n\t\t\t/*\n\t\t\t * The replenish timer needs to be canceled. No\n\t\t\t * problem if it fires concurrently: boosted threads\n\t\t\t * are ignored in dl_task_timer().\n\t\t\t */\n\t\t\thrtimer_try_to_cancel(&p->dl.dl_timer);\n\t\t\tp->dl.dl_throttled = 0;\n\t\t}\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task that is going\n\t\t * to be deboosted, but exceeds its runtime while doing so. No point in\n\t\t * replenishing it, as it's going to return back to its original\n\t\t * scheduling class after this. If it has been throttled, we need to\n\t\t * clear the flag, otherwise the task may wake up as throttled after\n\t\t * being boosted again with no means to replenish the runtime and clear\n\t\t * the throttle.\n\t\t */\n\t\tp->dl.dl_throttled = 0;\n\t\tBUG_ON(!is_dl_boosted(&p->dl) || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tcheck_schedstat_required();\n\tupdate_stats_wait_start_dl(dl_rq_of_se(&p->dl), &p->dl);\n\n\tenqueue_dl_entity(&p->dl, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (is_dl_boosted(&p->dl)) {\n\t\t/*\n\t\t * Because of delays in the detection of the overrun of a\n\t\t * thread's runtime, it might be the case that a thread\n\t\t * goes to sleep in a rt mutex with negative runtime. As\n\t\t * a consequence, the thread will be throttled.\n\t\t *\n\t\t * While waiting for the mutex, this thread can also be\n\t\t * boosted via PI, resulting in a thread that is throttled\n\t\t * and boosted at the same time.\n\t\t *\n\t\t * In this case, the boost overrides the throttle.\n\t\t */\n\t\tif (p->dl.dl_throttled) {\n\t\t\t/*\n\t\t\t * The replenish timer needs to be canceled. No\n\t\t\t * problem if it fires concurrently: boosted threads\n\t\t\t * are ignored in dl_task_timer().\n\t\t\t */\n\t\t\thrtimer_try_to_cancel(&p->dl.dl_timer);\n\t\t\tp->dl.dl_throttled = 0;\n\t\t}\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task that is going\n\t\t * to be deboosted, but exceeds its runtime while doing so. No point in\n\t\t * replenishing it, as it's going to return back to its original\n\t\t * scheduling class after this. If it has been throttled, we need to\n\t\t * clear the flag, otherwise the task may wake up as throttled after\n\t\t * being boosted again with no means to replenish the runtime and clear\n\t\t * the throttle.\n\t\t */\n\t\tp->dl.dl_throttled = 0;\n\t\tBUG_ON(!is_dl_boosted(&p->dl) || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tcheck_schedstat_required();\n\tupdate_stats_wait_start_dl(dl_rq_of_se(&p->dl), &p->dl);\n\n\tenqueue_dl_entity(&p->dl, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "679-699",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_pin_lock",
          "args": [
            "__rq_lockp(rq)"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rq_lockp",
          "args": [
            "rq"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "__rq_lockp",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1280-1283",
          "snippet": "static inline raw_spinlock_t *__rq_lockp(struct rq *rq)\n{\n\treturn &rq->__lock;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline raw_spinlock_t *__rq_lockp(struct rq *rq)\n{\n\treturn &rq->__lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_offline_migration",
          "args": [
            "rq",
            "p"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_offline_migration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "594-662",
          "snippet": "static struct rq *dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = NULL;\n\tstruct dl_bw *dl_b;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t/*\n\t\t * If we cannot preempt any rq, fall back to pick any\n\t\t * online CPU:\n\t\t */\n\t\tcpu = cpumask_any_and(cpu_active_mask, p->cpus_ptr);\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t/*\n\t\t\t * Failed to find any suitable CPU.\n\t\t\t * The task will never come back!\n\t\t\t */\n\t\t\tBUG_ON(dl_bandwidth_enabled());\n\n\t\t\t/*\n\t\t\t * If admission control is disabled we\n\t\t\t * try a little harder to let the task\n\t\t\t * run.\n\t\t\t */\n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tif (p->dl.dl_non_contending || p->dl.dl_throttled) {\n\t\t/*\n\t\t * Inactive timer is armed (or callback is running, but\n\t\t * waiting for us to release rq locks). In any case, when it\n\t\t * will fire (or continue), it will see running_bw of this\n\t\t * task migrated to later_rq (and correctly handle it).\n\t\t */\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\n\t\tadd_rq_bw(&p->dl, &later_rq->dl);\n\t\tadd_running_bw(&p->dl, &later_rq->dl);\n\t} else {\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\tadd_rq_bw(&p->dl, &later_rq->dl);\n\t}\n\n\t/*\n\t * And we finally need to fixup root_domain(s) bandwidth accounting,\n\t * since p is still hanging out in the old (now moved to default) root\n\t * domain.\n\t */\n\tdl_b = &rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\t__dl_sub(dl_b, p->dl.dl_bw, cpumask_weight(rq->rd->span));\n\traw_spin_unlock(&dl_b->lock);\n\n\tdl_b = &later_rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\t__dl_add(dl_b, p->dl.dl_bw, cpumask_weight(later_rq->rd->span));\n\traw_spin_unlock(&dl_b->lock);\n\n\tset_task_cpu(p, later_rq->cpu);\n\tdouble_unlock_balance(later_rq, rq);\n\n\treturn later_rq;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct rq *dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = NULL;\n\tstruct dl_bw *dl_b;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t/*\n\t\t * If we cannot preempt any rq, fall back to pick any\n\t\t * online CPU:\n\t\t */\n\t\tcpu = cpumask_any_and(cpu_active_mask, p->cpus_ptr);\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t/*\n\t\t\t * Failed to find any suitable CPU.\n\t\t\t * The task will never come back!\n\t\t\t */\n\t\t\tBUG_ON(dl_bandwidth_enabled());\n\n\t\t\t/*\n\t\t\t * If admission control is disabled we\n\t\t\t * try a little harder to let the task\n\t\t\t * run.\n\t\t\t */\n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tif (p->dl.dl_non_contending || p->dl.dl_throttled) {\n\t\t/*\n\t\t * Inactive timer is armed (or callback is running, but\n\t\t * waiting for us to release rq locks). In any case, when it\n\t\t * will fire (or continue), it will see running_bw of this\n\t\t * task migrated to later_rq (and correctly handle it).\n\t\t */\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\n\t\tadd_rq_bw(&p->dl, &later_rq->dl);\n\t\tadd_running_bw(&p->dl, &later_rq->dl);\n\t} else {\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\tadd_rq_bw(&p->dl, &later_rq->dl);\n\t}\n\n\t/*\n\t * And we finally need to fixup root_domain(s) bandwidth accounting,\n\t * since p is still hanging out in the old (now moved to default) root\n\t * domain.\n\t */\n\tdl_b = &rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\t__dl_sub(dl_b, p->dl.dl_bw, cpumask_weight(rq->rd->span));\n\traw_spin_unlock(&dl_b->lock);\n\n\tdl_b = &later_rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\t__dl_add(dl_b, p->dl.dl_bw, cpumask_weight(later_rq->rd->span));\n\traw_spin_unlock(&dl_b->lock);\n\n\tset_task_cpu(p, later_rq->cpu);\n\tdouble_unlock_balance(later_rq, rq);\n\n\treturn later_rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_unpin_lock",
          "args": [
            "__rq_lockp(rq)",
            "rf.cookie"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rq->online"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replenish_dl_entity",
          "args": [
            "dl_se"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "replenish_dl_entity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "763-812",
          "snippet": "static void replenish_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_of(dl_se)->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_of(dl_se)->dl_period;\n\t\tdl_se->runtime += pi_of(dl_se)->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void replenish_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_of(dl_se)->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_of(dl_se)->dl_period;\n\t\tdl_se->runtime += pi_of(dl_se)->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2044-2047",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_tick",
          "args": [],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_tick_stable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/clock.c",
          "lines": "406-421",
          "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dl_boosted",
          "args": [
            "dl_se"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "is_dl_boosted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "62-65",
          "snippet": "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "582-619",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_rq_lock(rq);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock(), the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock(), the address\n\t\t * dependency headed by '[L] rq = task_rq()' and the acquire\n\t\t * will pair with the WMB to ensure we then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_rq_unlock(rq);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structsched_dl_entity",
            "dl_timer"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic enum hrtimer_restart dl_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     dl_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\t/*\n\t * The task might have changed its scheduling policy to something\n\t * different than SCHED_DEADLINE (through switched_from_dl()).\n\t */\n\tif (!dl_task(p))\n\t\tgoto unlock;\n\n\t/*\n\t * The task might have been boosted by someone else and might be in the\n\t * boosting/deboosting path, its not throttled.\n\t */\n\tif (is_dl_boosted(dl_se))\n\t\tgoto unlock;\n\n\t/*\n\t * Spurious timer due to start_dl_timer() race; or we already received\n\t * a replenishment from rt_mutex_setprio().\n\t */\n\tif (!dl_se->dl_throttled)\n\t\tgoto unlock;\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * If the throttle happened during sched-out; like:\n\t *\n\t *   schedule()\n\t *     deactivate_task()\n\t *       dequeue_task_dl()\n\t *         update_curr_dl()\n\t *           start_dl_timer()\n\t *         __dequeue_task_dl()\n\t *     prev->on_rq = 0;\n\t *\n\t * We can be both throttled and !queued. Replenish the counter\n\t * but do not enqueue -- wait for our wakeup to do that.\n\t */\n\tif (!task_on_rq_queued(p)) {\n\t\treplenish_dl_entity(dl_se);\n\t\tgoto unlock;\n\t}\n\n#ifdef CONFIG_SMP\n\tif (unlikely(!rq->online)) {\n\t\t/*\n\t\t * If the runqueue is no longer available, migrate the\n\t\t * task elsewhere. This necessarily changes rq.\n\t\t */\n\t\tlockdep_unpin_lock(__rq_lockp(rq), rf.cookie);\n\t\trq = dl_task_offline_migration(rq, p);\n\t\trf.cookie = lockdep_pin_lock(__rq_lockp(rq));\n\t\tupdate_rq_clock(rq);\n\n\t\t/*\n\t\t * Now that the task has been migrated to the new RQ and we\n\t\t * have that locked, proceed as normal and enqueue the task\n\t\t * there.\n\t\t */\n\t}\n#endif\n\n\tenqueue_task_dl(rq, p, ENQUEUE_REPLENISH);\n\tif (dl_task(rq->curr))\n\t\tcheck_preempt_curr_dl(rq, p, 0);\n\telse\n\t\tresched_curr(rq);\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Queueing this task back might have overloaded rq, check if we need\n\t * to kick someone away.\n\t */\n\tif (has_pushable_dl_tasks(rq)) {\n\t\t/*\n\t\t * Nothing relies on rq->lock after this, so its safe to drop\n\t\t * rq->lock.\n\t\t */\n\t\trq_unpin_lock(rq, &rf);\n\t\tpush_dl_task(rq);\n\t\trq_repin_lock(rq, &rf);\n\t}\n#endif\n\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\n\t/*\n\t * This can free the task_struct, including this hrtimer, do not touch\n\t * anything related to that after this.\n\t */\n\tput_task_struct(p);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "start_dl_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "982-1025",
    "snippet": "static int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS_HARD);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "timer",
            "act",
            "HRTIMER_MODE_ABS_HARD"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_is_queued",
          "args": [
            "timer"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_us_delta",
          "args": [
            "act",
            "now"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "act",
            "delta"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "now"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cb_get_time",
          "args": [
            "timer"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "dl_next_period(dl_se)"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_next_period",
          "args": [
            "dl_se"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "dl_next_period",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "967-970",
          "snippet": "static inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_rq_held",
          "args": [
            "rq"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_rq_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1307-1310",
          "snippet": "static inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "is_task_rq_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5634-5637",
          "snippet": "static inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_rq_held(rq);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS_HARD);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "dl_next_period",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "967-970",
    "snippet": "static inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}"
  },
  {
    "function_name": "update_dl_entity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "947-965",
    "snippet": "static void update_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, rq_clock(rq))) {\n\n\t\tif (unlikely(!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !is_dl_boosted(dl_se))) {\n\t\t\tupdate_dl_revised_wakeup(dl_se, rq);\n\t\t\treturn;\n\t\t}\n\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pi_of",
          "args": [
            "dl_se"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "pi_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "57-60",
          "snippet": "static inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "update_dl_revised_wakeup",
          "args": [
            "dl_se",
            "rq"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_revised_wakeup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "885-899",
          "snippet": "static void\nupdate_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)\n{\n\tu64 laxity = dl_se->deadline - rq_clock(rq);\n\n\t/*\n\t * If the task has deadline < period, and the deadline is in the past,\n\t * it should already be throttled before this check.\n\t *\n\t * See update_dl_entity() comments for further details.\n\t */\n\tWARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));\n\n\tdl_se->runtime = (dl_se->dl_density * laxity) >> BW_SHIFT;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void\nupdate_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)\n{\n\tu64 laxity = dl_se->deadline - rq_clock(rq);\n\n\t/*\n\t * If the task has deadline < period, and the deadline is in the past,\n\t * it should already be throttled before this check.\n\t *\n\t * See update_dl_entity() comments for further details.\n\t */\n\tWARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));\n\n\tdl_se->runtime = (dl_se->dl_density * laxity) >> BW_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !is_dl_boosted(dl_se)"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dl_boosted",
          "args": [
            "dl_se"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "is_dl_boosted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "62-65",
          "snippet": "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq)"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_is_implicit",
          "args": [
            "dl_se"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "dl_is_implicit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "912-915",
          "snippet": "static inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_overflow",
          "args": [
            "dl_se",
            "rq_clock(rq)"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_overflow",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "838-865",
          "snippet": "static bool dl_entity_overflow(struct sched_dl_entity *dl_se, u64 t)\n{\n\tu64 left, right;\n\n\t/*\n\t * left and right are the two sides of the equation above,\n\t * after a bit of shuffling to use multiplications instead\n\t * of divisions.\n\t *\n\t * Note that none of the time values involved in the two\n\t * multiplications are absolute: dl_deadline and dl_runtime\n\t * are the relative deadline and the maximum runtime of each\n\t * instance, runtime is the runtime left for the last instance\n\t * and (deadline - t), since t is rq->clock, is the time left\n\t * to the (absolute) deadline. Even if overflowing the u64 type\n\t * is very unlikely to occur in both cases, here we scale down\n\t * as we want to avoid that risk at all. Scaling down by 10\n\t * means that we reduce granularity to 1us. We are fine with it,\n\t * since this is only a true/false check and, anyway, thinking\n\t * of anything below microseconds resolution is actually fiction\n\t * (but still we want to give the user that illusion >;).\n\t */\n\tleft = (pi_of(dl_se)->dl_deadline >> DL_SCALE) * (dl_se->runtime >> DL_SCALE);\n\tright = ((dl_se->deadline - t) >> DL_SCALE) *\n\t\t(pi_of(dl_se)->dl_runtime >> DL_SCALE);\n\n\treturn dl_time_before(right, left);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool dl_entity_overflow(struct sched_dl_entity *dl_se, u64 t)\n{\n\tu64 left, right;\n\n\t/*\n\t * left and right are the two sides of the equation above,\n\t * after a bit of shuffling to use multiplications instead\n\t * of divisions.\n\t *\n\t * Note that none of the time values involved in the two\n\t * multiplications are absolute: dl_deadline and dl_runtime\n\t * are the relative deadline and the maximum runtime of each\n\t * instance, runtime is the runtime left for the last instance\n\t * and (deadline - t), since t is rq->clock, is the time left\n\t * to the (absolute) deadline. Even if overflowing the u64 type\n\t * is very unlikely to occur in both cases, here we scale down\n\t * as we want to avoid that risk at all. Scaling down by 10\n\t * means that we reduce granularity to 1us. We are fine with it,\n\t * since this is only a true/false check and, anyway, thinking\n\t * of anything below microseconds resolution is actually fiction\n\t * (but still we want to give the user that illusion >;).\n\t */\n\tleft = (pi_of(dl_se)->dl_deadline >> DL_SCALE) * (dl_se->runtime >> DL_SCALE);\n\tright = ((dl_se->deadline - t) >> DL_SCALE) *\n\t\t(pi_of(dl_se)->dl_runtime >> DL_SCALE);\n\n\treturn dl_time_before(right, left);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq)"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void update_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, rq_clock(rq))) {\n\n\t\tif (unlikely(!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !is_dl_boosted(dl_se))) {\n\t\t\tupdate_dl_revised_wakeup(dl_se, rq);\n\t\t\treturn;\n\t\t}\n\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n}"
  },
  {
    "function_name": "dl_is_implicit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "912-915",
    "snippet": "static inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}"
  },
  {
    "function_name": "update_dl_revised_wakeup",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "885-899",
    "snippet": "static void\nupdate_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)\n{\n\tu64 laxity = dl_se->deadline - rq_clock(rq);\n\n\t/*\n\t * If the task has deadline < period, and the deadline is in the past,\n\t * it should already be throttled before this check.\n\t *\n\t * See update_dl_entity() comments for further details.\n\t */\n\tWARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));\n\n\tdl_se->runtime = (dl_se->dl_density * laxity) >> BW_SHIFT;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "dl_time_before(dl_se->deadline, rq_clock(rq))"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq)"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void\nupdate_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)\n{\n\tu64 laxity = dl_se->deadline - rq_clock(rq);\n\n\t/*\n\t * If the task has deadline < period, and the deadline is in the past,\n\t * it should already be throttled before this check.\n\t *\n\t * See update_dl_entity() comments for further details.\n\t */\n\tWARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));\n\n\tdl_se->runtime = (dl_se->dl_density * laxity) >> BW_SHIFT;\n}"
  },
  {
    "function_name": "dl_entity_overflow",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "838-865",
    "snippet": "static bool dl_entity_overflow(struct sched_dl_entity *dl_se, u64 t)\n{\n\tu64 left, right;\n\n\t/*\n\t * left and right are the two sides of the equation above,\n\t * after a bit of shuffling to use multiplications instead\n\t * of divisions.\n\t *\n\t * Note that none of the time values involved in the two\n\t * multiplications are absolute: dl_deadline and dl_runtime\n\t * are the relative deadline and the maximum runtime of each\n\t * instance, runtime is the runtime left for the last instance\n\t * and (deadline - t), since t is rq->clock, is the time left\n\t * to the (absolute) deadline. Even if overflowing the u64 type\n\t * is very unlikely to occur in both cases, here we scale down\n\t * as we want to avoid that risk at all. Scaling down by 10\n\t * means that we reduce granularity to 1us. We are fine with it,\n\t * since this is only a true/false check and, anyway, thinking\n\t * of anything below microseconds resolution is actually fiction\n\t * (but still we want to give the user that illusion >;).\n\t */\n\tleft = (pi_of(dl_se)->dl_deadline >> DL_SCALE) * (dl_se->runtime >> DL_SCALE);\n\tright = ((dl_se->deadline - t) >> DL_SCALE) *\n\t\t(pi_of(dl_se)->dl_runtime >> DL_SCALE);\n\n\treturn dl_time_before(right, left);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "right",
            "left"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pi_of",
          "args": [
            "dl_se"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "pi_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "57-60",
          "snippet": "static inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool dl_entity_overflow(struct sched_dl_entity *dl_se, u64 t)\n{\n\tu64 left, right;\n\n\t/*\n\t * left and right are the two sides of the equation above,\n\t * after a bit of shuffling to use multiplications instead\n\t * of divisions.\n\t *\n\t * Note that none of the time values involved in the two\n\t * multiplications are absolute: dl_deadline and dl_runtime\n\t * are the relative deadline and the maximum runtime of each\n\t * instance, runtime is the runtime left for the last instance\n\t * and (deadline - t), since t is rq->clock, is the time left\n\t * to the (absolute) deadline. Even if overflowing the u64 type\n\t * is very unlikely to occur in both cases, here we scale down\n\t * as we want to avoid that risk at all. Scaling down by 10\n\t * means that we reduce granularity to 1us. We are fine with it,\n\t * since this is only a true/false check and, anyway, thinking\n\t * of anything below microseconds resolution is actually fiction\n\t * (but still we want to give the user that illusion >;).\n\t */\n\tleft = (pi_of(dl_se)->dl_deadline >> DL_SCALE) * (dl_se->runtime >> DL_SCALE);\n\tright = ((dl_se->deadline - t) >> DL_SCALE) *\n\t\t(pi_of(dl_se)->dl_runtime >> DL_SCALE);\n\n\treturn dl_time_before(right, left);\n}"
  },
  {
    "function_name": "replenish_dl_entity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "763-812",
    "snippet": "static void replenish_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_of(dl_se)->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_of(dl_se)->dl_period;\n\t\tdl_se->runtime += pi_of(dl_se)->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pi_of",
          "args": [
            "dl_se"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "pi_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "57-60",
          "snippet": "static inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred_once",
          "args": [
            "\"sched: DL replenish lagged too much\\n\""
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq)"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pi_of(dl_se)->dl_runtime <= 0"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void replenish_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_of(dl_se)->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_of(dl_se)->dl_period;\n\t\tdl_se->runtime += pi_of(dl_se)->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_of(dl_se)->dl_deadline;\n\t\tdl_se->runtime = pi_of(dl_se)->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}"
  },
  {
    "function_name": "setup_new_dl_entity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "720-743",
    "snippet": "static inline void setup_new_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tWARN_ON(is_dl_boosted(dl_se));\n\tWARN_ON(dl_time_before(rq_clock(rq), dl_se->deadline));\n\n\t/*\n\t * We are racing with the deadline timer. So, do nothing because\n\t * the deadline timer handler will take care of properly recharging\n\t * the runtime and postponing the deadline\n\t */\n\tif (dl_se->dl_throttled)\n\t\treturn;\n\n\t/*\n\t * We use the regular wall clock time to set deadlines in the\n\t * future; in fact, we must consider execution overheads (time\n\t * spent on hardirq context, etc.).\n\t */\n\tdl_se->deadline = rq_clock(rq) + dl_se->dl_deadline;\n\tdl_se->runtime = dl_se->dl_runtime;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "dl_time_before(rq_clock(rq), dl_se->deadline)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "rq_clock(rq)",
            "dl_se->deadline"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "is_dl_boosted(dl_se)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dl_boosted",
          "args": [
            "dl_se"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "is_dl_boosted",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "62-65",
          "snippet": "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline void setup_new_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tWARN_ON(is_dl_boosted(dl_se));\n\tWARN_ON(dl_time_before(rq_clock(rq), dl_se->deadline));\n\n\t/*\n\t * We are racing with the deadline timer. So, do nothing because\n\t * the deadline timer handler will take care of properly recharging\n\t * the runtime and postponing the deadline\n\t */\n\tif (dl_se->dl_throttled)\n\t\treturn;\n\n\t/*\n\t * We use the regular wall clock time to set deadlines in the\n\t * future; in fact, we must consider execution overheads (time\n\t * spent on hardirq context, etc.).\n\t */\n\tdl_se->deadline = rq_clock(rq) + dl_se->dl_deadline;\n\tdl_se->runtime = dl_se->dl_runtime;\n}"
  },
  {
    "function_name": "deadline_queue_pull_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "699-701",
    "snippet": "static inline void deadline_queue_pull_task(struct rq *rq)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_pull_task(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "deadline_queue_push_tasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "695-697",
    "snippet": "static inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "pull_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "691-693",
    "snippet": "static inline void pull_dl_task(struct rq *rq)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void pull_dl_task(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "need_pull_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "686-689",
    "snippet": "static inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "dec_dl_migration",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "681-684",
    "snippet": "static inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}"
  },
  {
    "function_name": "inc_dl_migration",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "676-679",
    "snippet": "static inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}"
  },
  {
    "function_name": "dequeue_pushable_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "671-674",
    "snippet": "static inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
  },
  {
    "function_name": "enqueue_pushable_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "666-669",
    "snippet": "static inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
  },
  {
    "function_name": "dl_task_offline_migration",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "594-662",
    "snippet": "static struct rq *dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = NULL;\n\tstruct dl_bw *dl_b;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t/*\n\t\t * If we cannot preempt any rq, fall back to pick any\n\t\t * online CPU:\n\t\t */\n\t\tcpu = cpumask_any_and(cpu_active_mask, p->cpus_ptr);\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t/*\n\t\t\t * Failed to find any suitable CPU.\n\t\t\t * The task will never come back!\n\t\t\t */\n\t\t\tBUG_ON(dl_bandwidth_enabled());\n\n\t\t\t/*\n\t\t\t * If admission control is disabled we\n\t\t\t * try a little harder to let the task\n\t\t\t * run.\n\t\t\t */\n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tif (p->dl.dl_non_contending || p->dl.dl_throttled) {\n\t\t/*\n\t\t * Inactive timer is armed (or callback is running, but\n\t\t * waiting for us to release rq locks). In any case, when it\n\t\t * will fire (or continue), it will see running_bw of this\n\t\t * task migrated to later_rq (and correctly handle it).\n\t\t */\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\n\t\tadd_rq_bw(&p->dl, &later_rq->dl);\n\t\tadd_running_bw(&p->dl, &later_rq->dl);\n\t} else {\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\tadd_rq_bw(&p->dl, &later_rq->dl);\n\t}\n\n\t/*\n\t * And we finally need to fixup root_domain(s) bandwidth accounting,\n\t * since p is still hanging out in the old (now moved to default) root\n\t * domain.\n\t */\n\tdl_b = &rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\t__dl_sub(dl_b, p->dl.dl_bw, cpumask_weight(rq->rd->span));\n\traw_spin_unlock(&dl_b->lock);\n\n\tdl_b = &later_rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\t__dl_add(dl_b, p->dl.dl_bw, cpumask_weight(later_rq->rd->span));\n\traw_spin_unlock(&dl_b->lock);\n\n\tset_task_cpu(p, later_rq->cpu);\n\tdouble_unlock_balance(later_rq, rq);\n\n\treturn later_rq;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "double_unlock_balance",
          "args": [
            "later_rq",
            "rq"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "double_unlock_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2597-2603",
          "snippet": "static inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\tif (__rq_lockp(this_rq) != __rq_lockp(busiest))\n\t\traw_spin_rq_unlock(busiest);\n\tlock_set_subclass(&__rq_lockp(this_rq)->dep_map, 0, _RET_IP_);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\tif (__rq_lockp(this_rq) != __rq_lockp(busiest))\n\t\traw_spin_rq_unlock(busiest);\n\tlock_set_subclass(&__rq_lockp(this_rq)->dep_map, 0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_cpu",
          "args": [
            "p",
            "later_rq->cpu"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "set_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "3026-3079",
          "snippet": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tunsigned int state = READ_ONCE(p->__state);\n\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(state != TASK_RUNNING && state != TASK_WAKING && !p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(__rq_lockp(task_rq(p)))));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n\n\tWARN_ON_ONCE(is_migration_disabled(p));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tunsigned int state = READ_ONCE(p->__state);\n\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(state != TASK_RUNNING && state != TASK_WAKING && !p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(__rq_lockp(task_rq(p)))));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n\n\tWARN_ON_ONCE(is_migration_disabled(p));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_add",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "cpumask_weight(later_rq->rd->span)"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_add",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "313-318",
          "snippet": "static inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "later_rq->rd->span"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_sub",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "cpumask_weight(rq->rd->span)"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_sub",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "306-311",
          "snippet": "static inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "rq->rd->span"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_rq_bw",
          "args": [
            "&p->dl",
            "&later_rq->dl"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "add_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "205-210",
          "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "212-217",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_running_bw",
          "args": [
            "&p->dl",
            "&later_rq->dl"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "add_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "219-224",
          "snippet": "static inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "226-231",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_lock_balance",
          "args": [
            "rq",
            "later_rq"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "double_lock_balance",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2590-2595",
          "snippet": "static inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tlockdep_assert_irqs_disabled();\n\n\treturn _double_lock_balance(this_rq, busiest);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tlockdep_assert_irqs_disabled();\n\n\treturn _double_lock_balance(this_rq, busiest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any",
          "args": [
            "cpu_active_mask"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dl_bandwidth_enabled()"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_bandwidth_enabled",
          "args": [],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bandwidth_enabled",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "275-278",
          "snippet": "static inline int dl_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int dl_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "cpu_active_mask",
            "p->cpus_ptr"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_later_rq",
          "args": [
            "p",
            "rq"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_later_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2147-2202",
          "snippet": "static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define DL_MAX_TRIES 3"
          ],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\n#define DL_MAX_TRIES 3\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_mask) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct rq *dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = NULL;\n\tstruct dl_bw *dl_b;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t/*\n\t\t * If we cannot preempt any rq, fall back to pick any\n\t\t * online CPU:\n\t\t */\n\t\tcpu = cpumask_any_and(cpu_active_mask, p->cpus_ptr);\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t/*\n\t\t\t * Failed to find any suitable CPU.\n\t\t\t * The task will never come back!\n\t\t\t */\n\t\t\tBUG_ON(dl_bandwidth_enabled());\n\n\t\t\t/*\n\t\t\t * If admission control is disabled we\n\t\t\t * try a little harder to let the task\n\t\t\t * run.\n\t\t\t */\n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tif (p->dl.dl_non_contending || p->dl.dl_throttled) {\n\t\t/*\n\t\t * Inactive timer is armed (or callback is running, but\n\t\t * waiting for us to release rq locks). In any case, when it\n\t\t * will fire (or continue), it will see running_bw of this\n\t\t * task migrated to later_rq (and correctly handle it).\n\t\t */\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\n\t\tadd_rq_bw(&p->dl, &later_rq->dl);\n\t\tadd_running_bw(&p->dl, &later_rq->dl);\n\t} else {\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\tadd_rq_bw(&p->dl, &later_rq->dl);\n\t}\n\n\t/*\n\t * And we finally need to fixup root_domain(s) bandwidth accounting,\n\t * since p is still hanging out in the old (now moved to default) root\n\t * domain.\n\t */\n\tdl_b = &rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\t__dl_sub(dl_b, p->dl.dl_bw, cpumask_weight(rq->rd->span));\n\traw_spin_unlock(&dl_b->lock);\n\n\tdl_b = &later_rq->rd->dl_bw;\n\traw_spin_lock(&dl_b->lock);\n\t__dl_add(dl_b, p->dl.dl_bw, cpumask_weight(later_rq->rd->span));\n\traw_spin_unlock(&dl_b->lock);\n\n\tset_task_cpu(p, later_rq->cpu);\n\tdouble_unlock_balance(later_rq, rq);\n\n\treturn later_rq;\n}"
  },
  {
    "function_name": "deadline_queue_pull_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "587-590",
    "snippet": "static inline void deadline_queue_pull_task(struct rq *rq)\n{\n\tqueue_balance_callback(rq, &per_cpu(dl_pull_head, rq->cpu), pull_dl_task);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_balance_callback",
          "args": [
            "rq",
            "&per_cpu(dl_pull_head, rq->cpu)",
            "pull_dl_task"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "queue_balance_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1701-1714",
          "snippet": "static inline void\nqueue_balance_callback(struct rq *rq,\n\t\t       struct callback_head *head,\n\t\t       void (*func)(struct rq *rq))\n{\n\tlockdep_assert_rq_held(rq);\n\n\tif (unlikely(head->next || rq->balance_callback == &balance_push_callback))\n\t\treturn;\n\n\thead->func = (void (*)(struct callback_head *))func;\n\thead->next = rq->balance_callback;\n\trq->balance_callback = head;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct callback_head balance_push_callback;",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct callback_head balance_push_callback;\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nqueue_balance_callback(struct rq *rq,\n\t\t       struct callback_head *head,\n\t\t       void (*func)(struct rq *rq))\n{\n\tlockdep_assert_rq_held(rq);\n\n\tif (unlikely(head->next || rq->balance_callback == &balance_push_callback))\n\t\treturn;\n\n\thead->func = (void (*)(struct callback_head *))func;\n\thead->next = rq->balance_callback;\n\trq->balance_callback = head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "dl_pull_head",
            "rq->cpu"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_pull_task(struct rq *rq)\n{\n\tqueue_balance_callback(rq, &per_cpu(dl_pull_head, rq->cpu), pull_dl_task);\n}"
  },
  {
    "function_name": "deadline_queue_push_tasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "579-585",
    "snippet": "static inline void deadline_queue_push_tasks(struct rq *rq)\n{\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn;\n\n\tqueue_balance_callback(rq, &per_cpu(dl_push_head, rq->cpu), push_dl_tasks);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_balance_callback",
          "args": [
            "rq",
            "&per_cpu(dl_push_head, rq->cpu)",
            "push_dl_tasks"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "queue_balance_callback",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1701-1714",
          "snippet": "static inline void\nqueue_balance_callback(struct rq *rq,\n\t\t       struct callback_head *head,\n\t\t       void (*func)(struct rq *rq))\n{\n\tlockdep_assert_rq_held(rq);\n\n\tif (unlikely(head->next || rq->balance_callback == &balance_push_callback))\n\t\treturn;\n\n\thead->func = (void (*)(struct callback_head *))func;\n\thead->next = rq->balance_callback;\n\trq->balance_callback = head;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct callback_head balance_push_callback;",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct callback_head balance_push_callback;\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nqueue_balance_callback(struct rq *rq,\n\t\t       struct callback_head *head,\n\t\t       void (*func)(struct rq *rq))\n{\n\tlockdep_assert_rq_held(rq);\n\n\tif (unlikely(head->next || rq->balance_callback == &balance_push_callback))\n\t\treturn;\n\n\thead->func = (void (*)(struct callback_head *))func;\n\thead->next = rq->balance_callback;\n\trq->balance_callback = head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "dl_push_head",
            "rq->cpu"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_pushable_dl_tasks",
          "args": [
            "rq"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "has_pushable_dl_tasks",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "561-564",
          "snippet": "static inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_push_tasks(struct rq *rq)\n{\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn;\n\n\tqueue_balance_callback(rq, &per_cpu(dl_push_head, rq->cpu), push_dl_tasks);\n}"
  },
  {
    "function_name": "need_pull_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "568-571",
    "snippet": "static inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn rq->online && dl_task(prev);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "prev"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn rq->online && dl_task(prev);\n}"
  },
  {
    "function_name": "has_pushable_dl_tasks",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "561-564",
    "snippet": "static inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&rq->dl.pushable_dl_tasks_root.rb_root"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}"
  },
  {
    "function_name": "dequeue_pushable_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "545-559",
    "snippet": "static void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct rb_root_cached *root = &dl_rq->pushable_dl_tasks_root;\n\tstruct rb_node *leftmost;\n\n\tif (RB_EMPTY_NODE(&p->pushable_dl_tasks))\n\t\treturn;\n\n\tleftmost = rb_erase_cached(&p->pushable_dl_tasks, root);\n\tif (leftmost)\n\t\tdl_rq->earliest_dl.next = __node_2_pdl(leftmost)->dl.deadline;\n\n\tRB_CLEAR_NODE(&p->pushable_dl_tasks);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&p->pushable_dl_tasks"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__node_2_pdl",
          "args": [
            "leftmost"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase_cached",
          "args": [
            "&p->pushable_dl_tasks",
            "root"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&p->pushable_dl_tasks"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct rb_root_cached *root = &dl_rq->pushable_dl_tasks_root;\n\tstruct rb_node *leftmost;\n\n\tif (RB_EMPTY_NODE(&p->pushable_dl_tasks))\n\t\treturn;\n\n\tleftmost = rb_erase_cached(&p->pushable_dl_tasks, root);\n\tif (leftmost)\n\t\tdl_rq->earliest_dl.next = __node_2_pdl(leftmost)->dl.deadline;\n\n\tRB_CLEAR_NODE(&p->pushable_dl_tasks);\n}"
  },
  {
    "function_name": "enqueue_pushable_dl_task",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "532-543",
    "snippet": "static void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct rb_node *leftmost;\n\n\tBUG_ON(!RB_EMPTY_NODE(&p->pushable_dl_tasks));\n\n\tleftmost = rb_add_cached(&p->pushable_dl_tasks,\n\t\t\t\t &rq->dl.pushable_dl_tasks_root,\n\t\t\t\t __pushable_less);\n\tif (leftmost)\n\t\trq->dl.earliest_dl.next = p->dl.deadline;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_add_cached",
          "args": [
            "&p->pushable_dl_tasks",
            "&rq->dl.pushable_dl_tasks_root",
            "__pushable_less"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!RB_EMPTY_NODE(&p->pushable_dl_tasks)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&p->pushable_dl_tasks"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct rb_node *leftmost;\n\n\tBUG_ON(!RB_EMPTY_NODE(&p->pushable_dl_tasks));\n\n\tleftmost = rb_add_cached(&p->pushable_dl_tasks,\n\t\t\t\t &rq->dl.pushable_dl_tasks_root,\n\t\t\t\t __pushable_less);\n\tif (leftmost)\n\t\trq->dl.earliest_dl.next = p->dl.deadline;\n}"
  },
  {
    "function_name": "__pushable_less",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "523-526",
    "snippet": "static inline bool __pushable_less(struct rb_node *a, const struct rb_node *b)\n{\n\treturn dl_entity_preempt(&__node_2_pdl(a)->dl, &__node_2_pdl(b)->dl);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_entity_preempt",
          "args": [
            "&__node_2_pdl(a)->dl",
            "&__node_2_pdl(b)->dl"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_preempt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "243-248",
          "snippet": "static inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__node_2_pdl",
          "args": [
            "b"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__node_2_pdl",
          "args": [
            "a"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline bool __pushable_less(struct rb_node *a, const struct rb_node *b)\n{\n\treturn dl_entity_preempt(&__node_2_pdl(a)->dl, &__node_2_pdl(b)->dl);\n}"
  },
  {
    "function_name": "dec_dl_migration",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "510-518",
    "snippet": "static void dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory--;\n\n\tupdate_dl_migration(dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_dl_migration",
          "args": [
            "dl_rq"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_migration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "487-498",
          "snippet": "static void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory--;\n\n\tupdate_dl_migration(dl_rq);\n}"
  },
  {
    "function_name": "inc_dl_migration",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "500-508",
    "snippet": "static void inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory++;\n\n\tupdate_dl_migration(dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_dl_migration",
          "args": [
            "dl_rq"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_migration",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "487-498",
          "snippet": "static void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory++;\n\n\tupdate_dl_migration(dl_rq);\n}"
  },
  {
    "function_name": "update_dl_migration",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "487-498",
    "snippet": "static void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_clear_overload",
          "args": [
            "rq_of_dl_rq(dl_rq)"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "dl_clear_overload",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "478-485",
          "snippet": "static inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_set_overload",
          "args": [
            "rq_of_dl_rq(dl_rq)"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "dl_set_overload",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "462-476",
          "snippet": "static inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}"
  },
  {
    "function_name": "dl_clear_overload",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "478-485",
    "snippet": "static inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "rq->cpu",
            "rq->rd->dlo_mask"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&rq->rd->dlo_count"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}"
  },
  {
    "function_name": "dl_set_overload",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "462-476",
    "snippet": "static inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rq->rd->dlo_count"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "rq->cpu",
            "rq->rd->dlo_mask"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}"
  },
  {
    "function_name": "dl_overloaded",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "457-460",
    "snippet": "static inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rq->rd->dlo_count"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}"
  },
  {
    "function_name": "init_dl_rq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "435-453",
    "snippet": "void init_dl_rq(struct dl_rq *dl_rq)\n{\n\tdl_rq->root = RB_ROOT_CACHED;\n\n#ifdef CONFIG_SMP\n\t/* zero means no -deadline tasks */\n\tdl_rq->earliest_dl.curr = dl_rq->earliest_dl.next = 0;\n\n\tdl_rq->dl_nr_migratory = 0;\n\tdl_rq->overloaded = 0;\n\tdl_rq->pushable_dl_tasks_root = RB_ROOT_CACHED;\n#else\n\tinit_dl_bw(&dl_rq->dl_bw);\n#endif\n\n\tdl_rq->running_bw = 0;\n\tdl_rq->this_bw = 0;\n\tinit_dl_rq_bw_ratio(dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_dl_rq_bw_ratio",
          "args": [
            "dl_rq"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_rq_bw_ratio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2713-2724",
          "snippet": "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dl_bw",
          "args": [
            "&dl_rq->dl_bw"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "423-433",
          "snippet": "void init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct dl_bandwidth def_dl_bandwidth;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstruct dl_bandwidth def_dl_bandwidth;\n\nvoid init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nvoid init_dl_rq(struct dl_rq *dl_rq)\n{\n\tdl_rq->root = RB_ROOT_CACHED;\n\n#ifdef CONFIG_SMP\n\t/* zero means no -deadline tasks */\n\tdl_rq->earliest_dl.curr = dl_rq->earliest_dl.next = 0;\n\n\tdl_rq->dl_nr_migratory = 0;\n\tdl_rq->overloaded = 0;\n\tdl_rq->pushable_dl_tasks_root = RB_ROOT_CACHED;\n#else\n\tinit_dl_bw(&dl_rq->dl_bw);\n#endif\n\n\tdl_rq->running_bw = 0;\n\tdl_rq->this_bw = 0;\n\tinit_dl_rq_bw_ratio(dl_rq);\n}"
  },
  {
    "function_name": "init_dl_bw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "423-433",
    "snippet": "void init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct dl_bandwidth def_dl_bandwidth;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&def_dl_bandwidth.dl_runtime_lock"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "global_rt_period()",
            "global_rt_runtime()"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "4468-4482",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_runtime",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_runtime",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2022-2028",
          "snippet": "static inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RUNTIME_INF\t\t((u64)~0ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RUNTIME_INF\t\t((u64)~0ULL)\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_period",
          "args": [],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_period",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2017-2020",
          "snippet": "static inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&def_dl_bandwidth.dl_runtime_lock"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&dl_b->lock"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstruct dl_bandwidth def_dl_bandwidth;\n\nvoid init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}"
  },
  {
    "function_name": "init_dl_bandwidth",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "416-421",
    "snippet": "void init_dl_bandwidth(struct dl_bandwidth *dl_b, u64 period, u64 runtime)\n{\n\traw_spin_lock_init(&dl_b->dl_runtime_lock);\n\tdl_b->dl_period = period;\n\tdl_b->dl_runtime = runtime;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&dl_b->dl_runtime_lock"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_bandwidth(struct dl_bandwidth *dl_b, u64 period, u64 runtime)\n{\n\traw_spin_lock_init(&dl_b->dl_runtime_lock);\n\tdl_b->dl_period = period;\n\tdl_b->dl_runtime = runtime;\n}"
  },
  {
    "function_name": "is_leftmost",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "407-412",
    "snippet": "static inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}"
  },
  {
    "function_name": "task_contending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "370-405",
    "snippet": "static void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_running_bw",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "add_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "219-224",
          "snippet": "static inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "dl_task_of(dl_se)"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&dl_se->inactive_timer"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "823-826",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_rq_bw",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "add_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "205-210",
          "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}"
  },
  {
    "function_name": "task_non_contending",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "314-368",
    "snippet": "static void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif ((zerolag_time < 0) || hrtimer_active(&dl_se->inactive_timer)) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (READ_ONCE(p->__state) == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL_HARD);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "timer",
            "ns_to_ktime(zerolag_time)",
            "HRTIMER_MODE_REL_HARD"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "zerolag_time"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "208-211",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_clear_params",
          "args": [
            "p"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_clear_params",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2923-2942",
          "snippet": "void __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n\n#ifdef CONFIG_RT_MUTEXES\n\tdl_se->pi_se\t\t\t= dl_se;\n#endif\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nvoid __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n\n#ifdef CONFIG_RT_MUTEXES\n\tdl_se->pi_se\t\t\t= dl_se;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_sub",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "dl_bw_cpus(task_cpu(p))"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_sub",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "306-311",
          "snippet": "static inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "task_cpu(p)"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "139-142",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ftrace.c",
          "lines": "7612-7633",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include \"ftrace_internal.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include \"ftrace_internal.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/kprobes.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\tstruct trace_pid_list *no_pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\tno_pid_list = rcu_dereference_protected(tr->function_no_pids,\n\t\t\t\t\t\tmutex_is_locked(&ftrace_lock));\n\n\tif (trace_ignore_this_task(pid_list, no_pid_list, current))\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       FTRACE_PID_IGNORE);\n\telse\n\t\tthis_cpu_write(tr->array_buffer.data->ftrace_ignore_pid,\n\t\t\t       current->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "176-179",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "212-217",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->__state"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "task_cpu(p)"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "134-137",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "p->__state"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "2320-2410",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p, *push_task;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tpush_task = NULL;\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tif (is_migration_disabled(p)) {\n\t\t\t\tpush_task = get_push_task(src_rq);\n\t\t\t} else {\n\t\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\t\tset_task_cpu(p, this_cpu);\n\t\t\t\tactivate_task(this_rq, p, 0);\n\t\t\t\tdmin = p->dl.deadline;\n\t\t\t\tresched = true;\n\t\t\t}\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\n\t\tif (push_task) {\n\t\t\traw_spin_rq_unlock(this_rq);\n\t\t\tstop_one_cpu_nowait(src_rq->cpu, push_cpu_stop,\n\t\t\t\t\t    push_task, &src_rq->push_work);\n\t\t\traw_spin_rq_lock(this_rq);\n\t\t}\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "226-231",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "&dl_se->inactive_timer"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/hrtimer.c",
          "lines": "1604-1621",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "update_idle_rq_clock_pelt",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/pelt.h",
          "lines": "202-203",
          "snippet": "static inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }",
          "includes": [
            "#include \"sched-pelt.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n\nstatic inline void\nupdate_idle_rq_clock_pelt(struct rq *rq) { }"
        }
      },
      {
        "call_info": {
          "callee": "div64_long",
          "args": [
            "(dl_se->runtime * dl_se->dl_period)",
            "dl_se->dl_runtime"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "dl_se->dl_non_contending"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "231-238",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif ((zerolag_time < 0) || hrtimer_active(&dl_se->inactive_timer)) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || READ_ONCE(p->__state) == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (READ_ONCE(p->__state) == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL_HARD);\n}"
  },
  {
    "function_name": "dl_change_utilization",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "233-258",
    "snippet": "static void dl_change_utilization(struct task_struct *p, u64 new_bw)\n{\n\tstruct rq *rq;\n\n\tBUG_ON(p->dl.flags & SCHED_FLAG_SUGOV);\n\n\tif (task_on_rq_queued(p))\n\t\treturn;\n\n\trq = task_rq(p);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\t__sub_rq_bw(p->dl.dl_bw, &rq->dl);\n\t__add_rq_bw(new_bw, &rq->dl);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_rq_bw",
          "args": [
            "new_bw",
            "&rq->dl"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "__add_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "182-190",
          "snippet": "static inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sub_rq_bw",
          "args": [
            "p->dl.dl_bw",
            "&rq->dl"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__sub_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "192-203",
          "snippet": "static inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fork.c",
          "lines": "745-761",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <linux/bpf.h>",
            "#include <linux/io_uring.h>",
            "#include <linux/scs.h>",
            "#include <linux/kasan.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/anon_inodes.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <linux/bpf.h>\n#include <linux/io_uring.h>\n#include <linux/scs.h>\n#include <linux/kasan.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm_inline.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/seq_file.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/anon_inodes.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(refcount_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tio_uring_free(tsk);\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk, true);\n\tsecurity_task_free(tsk);\n\tbpf_task_storage_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\tsched_core_free(tsk);\n\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&p->dl.inactive_timer"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/posix-timers.c",
          "lines": "823-826",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/time_namespace.h>",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/time_namespace.h>\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "226-231",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "is_task_rq_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5634-5637",
          "snippet": "static inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2044-2047",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void post_init_entity_util_avg(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void post_init_entity_util_avg(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p->dl.flags & SCHED_FLAG_SUGOV"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic void dl_change_utilization(struct task_struct *p, u64 new_bw)\n{\n\tstruct rq *rq;\n\n\tBUG_ON(p->dl.flags & SCHED_FLAG_SUGOV);\n\n\tif (task_on_rq_queued(p))\n\t\treturn;\n\n\trq = task_rq(p);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be canceled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\t__sub_rq_bw(p->dl.dl_bw, &rq->dl);\n\t__add_rq_bw(new_bw, &rq->dl);\n}"
  },
  {
    "function_name": "sub_running_bw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "226-231",
    "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sub_running_bw",
          "args": [
            "dl_se->dl_bw",
            "dl_rq"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__sub_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "168-180",
          "snippet": "static inline\nvoid __sub_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->running_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw > old); /* underflow */\n\tif (dl_rq->running_bw > old)\n\t\tdl_rq->running_bw = 0;\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid __sub_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->running_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw > old); /* underflow */\n\tif (dl_rq->running_bw > old)\n\t\tdl_rq->running_bw = 0;\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "231-238",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
  },
  {
    "function_name": "add_running_bw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "219-224",
    "snippet": "static inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_running_bw",
          "args": [
            "dl_se->dl_bw",
            "dl_rq"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__add_running_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "155-166",
          "snippet": "static inline\nvoid __add_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->running_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw < old); /* overflow */\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid __add_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->running_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw < old); /* overflow */\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "231-238",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}"
  },
  {
    "function_name": "sub_rq_bw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "212-217",
    "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sub_rq_bw",
          "args": [
            "dl_se->dl_bw",
            "dl_rq"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__sub_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "192-203",
          "snippet": "static inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "231-238",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
  },
  {
    "function_name": "add_rq_bw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "205-210",
    "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_rq_bw",
          "args": [
            "dl_se->dl_bw",
            "dl_rq"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "__add_rq_bw",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "182-190",
          "snippet": "static inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "231-238",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
  },
  {
    "function_name": "__sub_rq_bw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "192-203",
    "snippet": "static inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->running_bw > dl_rq->this_bw"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->this_bw > old"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_rq_held",
          "args": [
            "rq_of_dl_rq(dl_rq)"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_rq_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1307-1310",
          "snippet": "static inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}"
  },
  {
    "function_name": "__add_rq_bw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "182-190",
    "snippet": "static inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->this_bw < old"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_rq_held",
          "args": [
            "rq_of_dl_rq(dl_rq)"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_rq_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1307-1310",
          "snippet": "static inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}"
  },
  {
    "function_name": "__sub_running_bw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "168-180",
    "snippet": "static inline\nvoid __sub_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->running_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw > old); /* underflow */\n\tif (dl_rq->running_bw > old)\n\t\tdl_rq->running_bw = 0;\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpufreq_update_util",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "0"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "cpufreq_update_util",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2841-2841",
          "snippet": "static inline void cpufreq_update_util(struct rq *rq, unsigned int flags) {}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void cpufreq_update_util(struct rq *rq, unsigned int flags) {}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->running_bw > old"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_rq_held",
          "args": [
            "rq_of_dl_rq(dl_rq)"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_rq_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1307-1310",
          "snippet": "static inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid __sub_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->running_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw > old); /* underflow */\n\tif (dl_rq->running_bw > old)\n\t\tdl_rq->running_bw = 0;\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}"
  },
  {
    "function_name": "__add_running_bw",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "155-166",
    "snippet": "static inline\nvoid __add_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->running_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw < old); /* overflow */\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpufreq_update_util",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "0"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "cpufreq_update_util",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2841-2841",
          "snippet": "static inline void cpufreq_update_util(struct rq *rq, unsigned int flags) {}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void cpufreq_update_util(struct rq *rq, unsigned int flags) {}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->running_bw > dl_rq->this_bw"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->running_bw < old"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_rq_held",
          "args": [
            "rq_of_dl_rq(dl_rq)"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_rq_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "1307-1310",
          "snippet": "static inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool raw_spin_rq_trylock(struct rq *rq);",
            "extern void raw_spin_rq_unlock(struct rq *rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern struct task_struct *pick_next_task_idle(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool raw_spin_rq_trylock(struct rq *rq);\nextern void raw_spin_rq_unlock(struct rq *rq);\nextern void update_rq_clock(struct rq *rq);\nextern struct task_struct *pick_next_task_idle(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void lockdep_assert_rq_held(struct rq *rq)\n{\n\tlockdep_assert_held(__rq_lockp(rq));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\n\nstatic inline\nvoid __add_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_rq_held(rq_of_dl_rq(dl_rq));\n\tdl_rq->running_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw < old); /* overflow */\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}"
  },
  {
    "function_name": "dl_bw_visited",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "149-152",
    "snippet": "static inline bool dl_bw_visited(int cpu, u64 gen)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool dl_bw_visited(int cpu, u64 gen)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "dl_bw_capacity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "144-147",
    "snippet": "static inline unsigned long dl_bw_capacity(int i)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline unsigned long dl_bw_capacity(int i)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
  },
  {
    "function_name": "dl_bw_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "139-142",
    "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "dl_bw_of",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "134-137",
    "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
  },
  {
    "function_name": "dl_bw_visited",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "123-132",
    "snippet": "static inline bool dl_bw_visited(int cpu, u64 gen)\n{\n\tstruct root_domain *rd = cpu_rq(cpu)->rd;\n\n\tif (rd->visit_gen == gen)\n\t\treturn true;\n\n\trd->visit_gen = gen;\n\treturn false;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool dl_bw_visited(int cpu, u64 gen)\n{\n\tstruct root_domain *rd = cpu_rq(cpu)->rd;\n\n\tif (rd->visit_gen == gen)\n\t\treturn true;\n\n\trd->visit_gen = gen;\n\treturn false;\n}"
  },
  {
    "function_name": "dl_bw_capacity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "113-121",
    "snippet": "static inline unsigned long dl_bw_capacity(int i)\n{\n\tif (!static_branch_unlikely(&sched_asym_cpucapacity) &&\n\t    capacity_orig_of(i) == SCHED_CAPACITY_SCALE) {\n\t\treturn dl_bw_cpus(i) << SCHED_CAPACITY_SHIFT;\n\t} else {\n\t\treturn __dl_bw_capacity(i);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dl_bw_capacity",
          "args": [
            "i"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_bw_capacity",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "95-107",
          "snippet": "static inline unsigned long __dl_bw_capacity(int i)\n{\n\tstruct root_domain *rd = cpu_rq(i)->rd;\n\tunsigned long cap = 0;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask)\n\t\tcap += capacity_orig_of(i);\n\n\treturn cap;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline unsigned long __dl_bw_capacity(int i)\n{\n\tstruct root_domain *rd = cpu_rq(i)->rd;\n\tunsigned long cap = 0;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask)\n\t\tcap += capacity_orig_of(i);\n\n\treturn cap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "i"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "139-142",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capacity_orig_of",
          "args": [
            "i"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "capacity_orig_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2935-2938",
          "snippet": "static inline unsigned long capacity_orig_of(int cpu)\n{\n\treturn cpu_rq(cpu)->cpu_capacity_orig;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline unsigned long capacity_orig_of(int cpu)\n{\n\treturn cpu_rq(cpu)->cpu_capacity_orig;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sched_asym_cpucapacity"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline unsigned long dl_bw_capacity(int i)\n{\n\tif (!static_branch_unlikely(&sched_asym_cpucapacity) &&\n\t    capacity_orig_of(i) == SCHED_CAPACITY_SCALE) {\n\t\treturn dl_bw_cpus(i) << SCHED_CAPACITY_SHIFT;\n\t} else {\n\t\treturn __dl_bw_capacity(i);\n\t}\n}"
  },
  {
    "function_name": "__dl_bw_capacity",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "95-107",
    "snippet": "static inline unsigned long __dl_bw_capacity(int i)\n{\n\tstruct root_domain *rd = cpu_rq(i)->rd;\n\tunsigned long cap = 0;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask)\n\t\tcap += capacity_orig_of(i);\n\n\treturn cap;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capacity_orig_of",
          "args": [
            "i"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "capacity_orig_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/sched.h",
          "lines": "2935-2938",
          "snippet": "static inline unsigned long capacity_orig_of(int cpu)\n{\n\treturn cpu_rq(cpu)->cpu_capacity_orig;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include <trace/events/sched.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/energy_model.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/bitops.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include <trace/events/sched.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/ratelimit.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/energy_model.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/bitops.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/smt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic inline unsigned long capacity_orig_of(int cpu)\n{\n\treturn cpu_rq(cpu)->cpu_capacity_orig;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu_and",
          "args": [
            "i",
            "rd->span",
            "cpu_active_mask"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "!rcu_read_lock_sched_held()",
            "\"sched RCU must be held\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched_held",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline unsigned long __dl_bw_capacity(int i)\n{\n\tstruct root_domain *rd = cpu_rq(i)->rd;\n\tunsigned long cap = 0;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask)\n\t\tcap += capacity_orig_of(i);\n\n\treturn cap;\n}"
  },
  {
    "function_name": "dl_bw_cpus",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "76-93",
    "snippet": "static inline int dl_bw_cpus(int i)\n{\n\tstruct root_domain *rd = cpu_rq(i)->rd;\n\tint cpus;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\n\tif (cpumask_subset(rd->span, cpu_active_mask))\n\t\treturn cpumask_weight(rd->span);\n\n\tcpus = 0;\n\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask)\n\t\tcpus++;\n\n\treturn cpus;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_cpu_and",
          "args": [
            "i",
            "rd->span",
            "cpu_active_mask"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "rd->span"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "rd->span",
            "cpu_active_mask"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "!rcu_read_lock_sched_held()",
            "\"sched RCU must be held\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched_held",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\tstruct root_domain *rd = cpu_rq(i)->rd;\n\tint cpus;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\n\tif (cpumask_subset(rd->span, cpu_active_mask))\n\t\treturn cpumask_weight(rd->span);\n\n\tcpus = 0;\n\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask)\n\t\tcpus++;\n\n\treturn cpus;\n}"
  },
  {
    "function_name": "dl_bw_of",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "69-74",
    "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\treturn &cpu_rq(i)->rd->dl_bw;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_rq",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5032-5048",
          "snippet": "for_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int i;",
            "unsigned long long sum = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nint i;\nunsigned long long sum = 0;\n\nfor_each_possible_cpu(i)\n\t\tsum += cpu_rq(i)->nr_switches;\n\n\treturn sum;\n}\n\n/*\n * Consumers of these two interfaces, like for example the cpuidle menu\n * governor, are using nonsensical data. Preferring shallow idle state selection\n * for a CPU that has IO-wait which might not even end up running the task when\n * it does become runnable.\n */\n\nunsigned int nr_iowait_cpu(int cpu)\n{\n\treturn atomic_read(&cpu_rq(cpu)->nr_iowait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "!rcu_read_lock_sched_held()",
            "\"sched RCU must be held\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched_held",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "119-126",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn lock_is_held(&rcu_sched_lock_map) || !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\treturn &cpu_rq(i)->rd->dl_bw;\n}"
  },
  {
    "function_name": "is_dl_boosted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "62-65",
    "snippet": "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "pi_of",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "57-60",
    "snippet": "static inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}"
  },
  {
    "function_name": "is_dl_boosted",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "52-55",
    "snippet": "static inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn pi_of(dl_se) != dl_se;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pi_of",
          "args": [
            "dl_se"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "pi_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "57-60",
          "snippet": "static inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool is_dl_boosted(struct sched_dl_entity *dl_se)\n{\n\treturn pi_of(dl_se) != dl_se;\n}"
  },
  {
    "function_name": "pi_of",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "47-50",
    "snippet": "static inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->pi_se;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct sched_dl_entity *pi_of(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->pi_se;\n}"
  },
  {
    "function_name": "on_dl_rq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "41-44",
    "snippet": "static inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&dl_se->rb_node"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}"
  },
  {
    "function_name": "dl_rq_of_se",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "33-39",
    "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "is_task_rq_idle",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/core.c",
          "lines": "5634-5637",
          "snippet": "static inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}",
          "includes": [
            "#include <linux/entry-common.h>",
            "#include \"features.h\"",
            "#include \"smp.h\"",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../../fs/io-wq.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/scs.h>",
            "#include <linux/kcov.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\"",
            "#include <trace/events/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/entry-common.h>\n#include \"features.h\"\n#include \"smp.h\"\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../../fs/io-wq.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/scs.h>\n#include <linux/kcov.h>\n#include <linux/blkdev.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n#include <trace/events/sched.h>\n\nstatic __always_inline struct;\n\nstatic inline bool is_task_rq_idle(struct task_struct *t)\n{\n\treturn (task_rq(t)->idle == t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
  },
  {
    "function_name": "rq_of_dl_rq",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "28-31",
    "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);",
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dl_rq",
            "structrq",
            "dl"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void init_dl_rq_bw_ratio(struct dl_rq *dl_rq);\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
  },
  {
    "function_name": "dl_task_of",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/sched/deadline.c",
    "lines": "23-26",
    "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "DEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dl_se",
            "structtask_struct",
            "dl"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nDEFINE_SCHED_CLASS(dl) = {\n\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\t.set_next_task\t\t= set_next_task_dl,\n\n#ifdef CONFIG_SMP\n\t.balance\t\t= balance_dl,\n\t.pick_task\t\t= pick_task_dl,\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n\t.find_lock_rq\t\t= find_lock_later_rq,\n#endif\n\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
  }
]