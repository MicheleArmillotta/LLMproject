[
  {
    "function_name": "crash_save_vmcoreinfo_init",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "393-491",
    "snippet": "static int __init crash_save_vmcoreinfo_init(void)\n{\n\tvmcoreinfo_data = (unsigned char *)get_zeroed_page(GFP_KERNEL);\n\tif (!vmcoreinfo_data) {\n\t\tpr_warn(\"Memory allocation for vmcoreinfo_data failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvmcoreinfo_note = alloc_pages_exact(VMCOREINFO_NOTE_SIZE,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!vmcoreinfo_note) {\n\t\tfree_page((unsigned long)vmcoreinfo_data);\n\t\tvmcoreinfo_data = NULL;\n\t\tpr_warn(\"Memory allocation for vmcoreinfo_note failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tVMCOREINFO_OSRELEASE(init_uts_ns.name.release);\n\tVMCOREINFO_BUILD_ID();\n\tVMCOREINFO_PAGESIZE(PAGE_SIZE);\n\n\tVMCOREINFO_SYMBOL(init_uts_ns);\n\tVMCOREINFO_OFFSET(uts_namespace, name);\n\tVMCOREINFO_SYMBOL(node_online_map);\n#ifdef CONFIG_MMU\n\tVMCOREINFO_SYMBOL_ARRAY(swapper_pg_dir);\n#endif\n\tVMCOREINFO_SYMBOL(_stext);\n\tVMCOREINFO_SYMBOL(vmap_area_list);\n\n#ifndef CONFIG_NUMA\n\tVMCOREINFO_SYMBOL(mem_map);\n\tVMCOREINFO_SYMBOL(contig_page_data);\n#endif\n#ifdef CONFIG_SPARSEMEM\n\tVMCOREINFO_SYMBOL_ARRAY(mem_section);\n\tVMCOREINFO_LENGTH(mem_section, NR_SECTION_ROOTS);\n\tVMCOREINFO_STRUCT_SIZE(mem_section);\n\tVMCOREINFO_OFFSET(mem_section, section_mem_map);\n\tVMCOREINFO_NUMBER(SECTION_SIZE_BITS);\n\tVMCOREINFO_NUMBER(MAX_PHYSMEM_BITS);\n#endif\n\tVMCOREINFO_STRUCT_SIZE(page);\n\tVMCOREINFO_STRUCT_SIZE(pglist_data);\n\tVMCOREINFO_STRUCT_SIZE(zone);\n\tVMCOREINFO_STRUCT_SIZE(free_area);\n\tVMCOREINFO_STRUCT_SIZE(list_head);\n\tVMCOREINFO_SIZE(nodemask_t);\n\tVMCOREINFO_OFFSET(page, flags);\n\tVMCOREINFO_OFFSET(page, _refcount);\n\tVMCOREINFO_OFFSET(page, mapping);\n\tVMCOREINFO_OFFSET(page, lru);\n\tVMCOREINFO_OFFSET(page, _mapcount);\n\tVMCOREINFO_OFFSET(page, private);\n\tVMCOREINFO_OFFSET(page, compound_dtor);\n\tVMCOREINFO_OFFSET(page, compound_order);\n\tVMCOREINFO_OFFSET(page, compound_head);\n\tVMCOREINFO_OFFSET(pglist_data, node_zones);\n\tVMCOREINFO_OFFSET(pglist_data, nr_zones);\n#ifdef CONFIG_FLATMEM\n\tVMCOREINFO_OFFSET(pglist_data, node_mem_map);\n#endif\n\tVMCOREINFO_OFFSET(pglist_data, node_start_pfn);\n\tVMCOREINFO_OFFSET(pglist_data, node_spanned_pages);\n\tVMCOREINFO_OFFSET(pglist_data, node_id);\n\tVMCOREINFO_OFFSET(zone, free_area);\n\tVMCOREINFO_OFFSET(zone, vm_stat);\n\tVMCOREINFO_OFFSET(zone, spanned_pages);\n\tVMCOREINFO_OFFSET(free_area, free_list);\n\tVMCOREINFO_OFFSET(list_head, next);\n\tVMCOREINFO_OFFSET(list_head, prev);\n\tVMCOREINFO_OFFSET(vmap_area, va_start);\n\tVMCOREINFO_OFFSET(vmap_area, list);\n\tVMCOREINFO_LENGTH(zone.free_area, MAX_ORDER);\n\tlog_buf_vmcoreinfo_setup();\n\tVMCOREINFO_LENGTH(free_area.free_list, MIGRATE_TYPES);\n\tVMCOREINFO_NUMBER(NR_FREE_PAGES);\n\tVMCOREINFO_NUMBER(PG_lru);\n\tVMCOREINFO_NUMBER(PG_private);\n\tVMCOREINFO_NUMBER(PG_swapcache);\n\tVMCOREINFO_NUMBER(PG_swapbacked);\n\tVMCOREINFO_NUMBER(PG_slab);\n#ifdef CONFIG_MEMORY_FAILURE\n\tVMCOREINFO_NUMBER(PG_hwpoison);\n#endif\n\tVMCOREINFO_NUMBER(PG_head_mask);\n#define PAGE_BUDDY_MAPCOUNT_VALUE\t(~PG_buddy)\n\tVMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);\n#ifdef CONFIG_HUGETLB_PAGE\n\tVMCOREINFO_NUMBER(HUGETLB_PAGE_DTOR);\n#define PAGE_OFFLINE_MAPCOUNT_VALUE\t(~PG_offline)\n\tVMCOREINFO_NUMBER(PAGE_OFFLINE_MAPCOUNT_VALUE);\n#endif\n\n\tarch_crash_save_vmcoreinfo();\n\tupdate_vmcoreinfo_note();\n\n\treturn 0;\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [
      "#define PAGE_OFFLINE_MAPCOUNT_VALUE\t(~PG_offline)",
      "#define PAGE_BUDDY_MAPCOUNT_VALUE\t(~PG_buddy)"
    ],
    "globals_used": [
      "unsigned char *vmcoreinfo_data;",
      "u32 *vmcoreinfo_note;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_vmcoreinfo_note",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "update_vmcoreinfo_note",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "331-340",
          "snippet": "static void update_vmcoreinfo_note(void)\n{\n\tu32 *buf = vmcoreinfo_note;\n\n\tif (!vmcoreinfo_size)\n\t\treturn;\n\tbuf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,\n\t\t\t      vmcoreinfo_size);\n\tfinal_note(buf);\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned char *vmcoreinfo_data;",
            "size_t vmcoreinfo_size;",
            "u32 *vmcoreinfo_note;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nunsigned char *vmcoreinfo_data;\nsize_t vmcoreinfo_size;\nu32 *vmcoreinfo_note;\n\nstatic void update_vmcoreinfo_note(void)\n{\n\tu32 *buf = vmcoreinfo_note;\n\n\tif (!vmcoreinfo_size)\n\t\treturn;\n\tbuf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,\n\t\t\t      vmcoreinfo_size);\n\tfinal_note(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_crash_save_vmcoreinfo",
          "args": [],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "arch_crash_save_vmcoreinfo",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "384-385",
          "snippet": "void __weak arch_crash_save_vmcoreinfo(void)\n{}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nvoid __weak arch_crash_save_vmcoreinfo(void)\n{}"
        }
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "PAGE_OFFLINE_MAPCOUNT_VALUE"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "HUGETLB_PAGE_DTOR"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "PAGE_BUDDY_MAPCOUNT_VALUE"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "PG_head_mask"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "PG_hwpoison"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "PG_slab"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "PG_swapbacked"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "PG_swapcache"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "PG_private"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "PG_lru"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "NR_FREE_PAGES"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_LENGTH",
          "args": [
            "free_area.free_list",
            "MIGRATE_TYPES"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_buf_vmcoreinfo_setup",
          "args": [],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "log_buf_vmcoreinfo_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "900-957",
          "snippet": "void log_buf_vmcoreinfo_setup(void)\n{\n\tstruct dev_printk_info *dev_info = NULL;\n\n\tVMCOREINFO_SYMBOL(prb);\n\tVMCOREINFO_SYMBOL(printk_rb_static);\n\tVMCOREINFO_SYMBOL(clear_seq);\n\n\t/*\n\t * Export struct size and field offsets. User space tools can\n\t * parse it and detect any changes to structure down the line.\n\t */\n\n\tVMCOREINFO_STRUCT_SIZE(printk_ringbuffer);\n\tVMCOREINFO_OFFSET(printk_ringbuffer, desc_ring);\n\tVMCOREINFO_OFFSET(printk_ringbuffer, text_data_ring);\n\tVMCOREINFO_OFFSET(printk_ringbuffer, fail);\n\n\tVMCOREINFO_STRUCT_SIZE(prb_desc_ring);\n\tVMCOREINFO_OFFSET(prb_desc_ring, count_bits);\n\tVMCOREINFO_OFFSET(prb_desc_ring, descs);\n\tVMCOREINFO_OFFSET(prb_desc_ring, infos);\n\tVMCOREINFO_OFFSET(prb_desc_ring, head_id);\n\tVMCOREINFO_OFFSET(prb_desc_ring, tail_id);\n\n\tVMCOREINFO_STRUCT_SIZE(prb_desc);\n\tVMCOREINFO_OFFSET(prb_desc, state_var);\n\tVMCOREINFO_OFFSET(prb_desc, text_blk_lpos);\n\n\tVMCOREINFO_STRUCT_SIZE(prb_data_blk_lpos);\n\tVMCOREINFO_OFFSET(prb_data_blk_lpos, begin);\n\tVMCOREINFO_OFFSET(prb_data_blk_lpos, next);\n\n\tVMCOREINFO_STRUCT_SIZE(printk_info);\n\tVMCOREINFO_OFFSET(printk_info, seq);\n\tVMCOREINFO_OFFSET(printk_info, ts_nsec);\n\tVMCOREINFO_OFFSET(printk_info, text_len);\n\tVMCOREINFO_OFFSET(printk_info, caller_id);\n\tVMCOREINFO_OFFSET(printk_info, dev_info);\n\n\tVMCOREINFO_STRUCT_SIZE(dev_printk_info);\n\tVMCOREINFO_OFFSET(dev_printk_info, subsystem);\n\tVMCOREINFO_LENGTH(printk_info_subsystem, sizeof(dev_info->subsystem));\n\tVMCOREINFO_OFFSET(dev_printk_info, device);\n\tVMCOREINFO_LENGTH(printk_info_device, sizeof(dev_info->device));\n\n\tVMCOREINFO_STRUCT_SIZE(prb_data_ring);\n\tVMCOREINFO_OFFSET(prb_data_ring, size_bits);\n\tVMCOREINFO_OFFSET(prb_data_ring, data);\n\tVMCOREINFO_OFFSET(prb_data_ring, head_lpos);\n\tVMCOREINFO_OFFSET(prb_data_ring, tail_lpos);\n\n\tVMCOREINFO_SIZE(atomic_long_t);\n\tVMCOREINFO_TYPE_OFFSET(atomic_long_t, counter);\n\n\tVMCOREINFO_STRUCT_SIZE(latched_seq);\n\tVMCOREINFO_OFFSET(latched_seq, val);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid log_buf_vmcoreinfo_setup(void)\n{\n\tstruct dev_printk_info *dev_info = NULL;\n\n\tVMCOREINFO_SYMBOL(prb);\n\tVMCOREINFO_SYMBOL(printk_rb_static);\n\tVMCOREINFO_SYMBOL(clear_seq);\n\n\t/*\n\t * Export struct size and field offsets. User space tools can\n\t * parse it and detect any changes to structure down the line.\n\t */\n\n\tVMCOREINFO_STRUCT_SIZE(printk_ringbuffer);\n\tVMCOREINFO_OFFSET(printk_ringbuffer, desc_ring);\n\tVMCOREINFO_OFFSET(printk_ringbuffer, text_data_ring);\n\tVMCOREINFO_OFFSET(printk_ringbuffer, fail);\n\n\tVMCOREINFO_STRUCT_SIZE(prb_desc_ring);\n\tVMCOREINFO_OFFSET(prb_desc_ring, count_bits);\n\tVMCOREINFO_OFFSET(prb_desc_ring, descs);\n\tVMCOREINFO_OFFSET(prb_desc_ring, infos);\n\tVMCOREINFO_OFFSET(prb_desc_ring, head_id);\n\tVMCOREINFO_OFFSET(prb_desc_ring, tail_id);\n\n\tVMCOREINFO_STRUCT_SIZE(prb_desc);\n\tVMCOREINFO_OFFSET(prb_desc, state_var);\n\tVMCOREINFO_OFFSET(prb_desc, text_blk_lpos);\n\n\tVMCOREINFO_STRUCT_SIZE(prb_data_blk_lpos);\n\tVMCOREINFO_OFFSET(prb_data_blk_lpos, begin);\n\tVMCOREINFO_OFFSET(prb_data_blk_lpos, next);\n\n\tVMCOREINFO_STRUCT_SIZE(printk_info);\n\tVMCOREINFO_OFFSET(printk_info, seq);\n\tVMCOREINFO_OFFSET(printk_info, ts_nsec);\n\tVMCOREINFO_OFFSET(printk_info, text_len);\n\tVMCOREINFO_OFFSET(printk_info, caller_id);\n\tVMCOREINFO_OFFSET(printk_info, dev_info);\n\n\tVMCOREINFO_STRUCT_SIZE(dev_printk_info);\n\tVMCOREINFO_OFFSET(dev_printk_info, subsystem);\n\tVMCOREINFO_LENGTH(printk_info_subsystem, sizeof(dev_info->subsystem));\n\tVMCOREINFO_OFFSET(dev_printk_info, device);\n\tVMCOREINFO_LENGTH(printk_info_device, sizeof(dev_info->device));\n\n\tVMCOREINFO_STRUCT_SIZE(prb_data_ring);\n\tVMCOREINFO_OFFSET(prb_data_ring, size_bits);\n\tVMCOREINFO_OFFSET(prb_data_ring, data);\n\tVMCOREINFO_OFFSET(prb_data_ring, head_lpos);\n\tVMCOREINFO_OFFSET(prb_data_ring, tail_lpos);\n\n\tVMCOREINFO_SIZE(atomic_long_t);\n\tVMCOREINFO_TYPE_OFFSET(atomic_long_t, counter);\n\n\tVMCOREINFO_STRUCT_SIZE(latched_seq);\n\tVMCOREINFO_OFFSET(latched_seq, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_LENGTH",
          "args": [
            "zone.free_area",
            "MAX_ORDER"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "vmap_area",
            "list"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "vmap_area",
            "va_start"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "list_head",
            "prev"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "list_head",
            "next"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "free_area",
            "free_list"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "zone",
            "spanned_pages"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "zone",
            "vm_stat"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "zone",
            "free_area"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "pglist_data",
            "node_id"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "pglist_data",
            "node_spanned_pages"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "pglist_data",
            "node_start_pfn"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "pglist_data",
            "node_mem_map"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "pglist_data",
            "nr_zones"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "pglist_data",
            "node_zones"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "page",
            "compound_head"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "page",
            "compound_order"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "page",
            "compound_dtor"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "page",
            "private"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "page",
            "_mapcount"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "page",
            "lru"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "page",
            "mapping"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "page",
            "_refcount"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "page",
            "flags"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SIZE",
          "args": [
            "nodemask_t"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_STRUCT_SIZE",
          "args": [
            "list_head"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_STRUCT_SIZE",
          "args": [
            "free_area"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_STRUCT_SIZE",
          "args": [
            "zone"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_STRUCT_SIZE",
          "args": [
            "pglist_data"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_STRUCT_SIZE",
          "args": [
            "page"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "MAX_PHYSMEM_BITS"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_NUMBER",
          "args": [
            "SECTION_SIZE_BITS"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "mem_section",
            "section_mem_map"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_STRUCT_SIZE",
          "args": [
            "mem_section"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_LENGTH",
          "args": [
            "mem_section",
            "NR_SECTION_ROOTS"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL_ARRAY",
          "args": [
            "mem_section"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "contig_page_data"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "mem_map"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "vmap_area_list"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "_stext"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL_ARRAY",
          "args": [
            "swapper_pg_dir"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "node_online_map"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OFFSET",
          "args": [
            "uts_namespace",
            "name"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_SYMBOL",
          "args": [
            "init_uts_ns"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_PAGESIZE",
          "args": [
            "PAGE_SIZE"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_BUILD_ID",
          "args": [],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VMCOREINFO_OSRELEASE",
          "args": [
            "init_uts_ns.name.release"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Memory allocation for vmcoreinfo_note failed\\n\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)vmcoreinfo_data"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "kimage_free_page_list",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kexec_core.c",
          "lines": "341-349",
          "snippet": "void kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}",
          "includes": [
            "#include \"kexec_internal.h\"",
            "#include <crypto/hash.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/objtool.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compiler.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/swap.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/console.h>",
            "#include <linux/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cpu.h>",
            "#include <linux/pm.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/freezer.h>",
            "#include <linux/device.h>",
            "#include <linux/suspend.h>",
            "#include <linux/numa.h>",
            "#include <linux/utsname.h>",
            "#include <linux/elfcore.h>",
            "#include <linux/elf.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/ioport.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/list.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kexec.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kexec_internal.h\"\n#include <crypto/hash.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/kmsg_dump.h>\n#include <linux/objtool.h>\n#include <linux/hugetlb.h>\n#include <linux/compiler.h>\n#include <linux/syscore_ops.h>\n#include <linux/swap.h>\n#include <linux/vmalloc.h>\n#include <linux/console.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/cpu.h>\n#include <linux/pm.h>\n#include <linux/panic_notifier.h>\n#include <linux/freezer.h>\n#include <linux/device.h>\n#include <linux/suspend.h>\n#include <linux/numa.h>\n#include <linux/utsname.h>\n#include <linux/elfcore.h>\n#include <linux/elf.h>\n#include <linux/hardirq.h>\n#include <linux/ioport.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/kexec.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n\nvoid kimage_free_page_list(struct list_head *list)\n{\n\tstruct page *page, *next;\n\n\tlist_for_each_entry_safe(page, next, list, lru) {\n\t\tlist_del(&page->lru);\n\t\tkimage_free_pages(page);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pages_exact",
          "args": [
            "VMCOREINFO_NOTE_SIZE",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Memory allocation for vmcoreinfo_data failed\\n\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\n#define PAGE_OFFLINE_MAPCOUNT_VALUE\t(~PG_offline)\n#define PAGE_BUDDY_MAPCOUNT_VALUE\t(~PG_buddy)\n\nunsigned char *vmcoreinfo_data;\nu32 *vmcoreinfo_note;\n\nstatic int __init crash_save_vmcoreinfo_init(void)\n{\n\tvmcoreinfo_data = (unsigned char *)get_zeroed_page(GFP_KERNEL);\n\tif (!vmcoreinfo_data) {\n\t\tpr_warn(\"Memory allocation for vmcoreinfo_data failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tvmcoreinfo_note = alloc_pages_exact(VMCOREINFO_NOTE_SIZE,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!vmcoreinfo_note) {\n\t\tfree_page((unsigned long)vmcoreinfo_data);\n\t\tvmcoreinfo_data = NULL;\n\t\tpr_warn(\"Memory allocation for vmcoreinfo_note failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tVMCOREINFO_OSRELEASE(init_uts_ns.name.release);\n\tVMCOREINFO_BUILD_ID();\n\tVMCOREINFO_PAGESIZE(PAGE_SIZE);\n\n\tVMCOREINFO_SYMBOL(init_uts_ns);\n\tVMCOREINFO_OFFSET(uts_namespace, name);\n\tVMCOREINFO_SYMBOL(node_online_map);\n#ifdef CONFIG_MMU\n\tVMCOREINFO_SYMBOL_ARRAY(swapper_pg_dir);\n#endif\n\tVMCOREINFO_SYMBOL(_stext);\n\tVMCOREINFO_SYMBOL(vmap_area_list);\n\n#ifndef CONFIG_NUMA\n\tVMCOREINFO_SYMBOL(mem_map);\n\tVMCOREINFO_SYMBOL(contig_page_data);\n#endif\n#ifdef CONFIG_SPARSEMEM\n\tVMCOREINFO_SYMBOL_ARRAY(mem_section);\n\tVMCOREINFO_LENGTH(mem_section, NR_SECTION_ROOTS);\n\tVMCOREINFO_STRUCT_SIZE(mem_section);\n\tVMCOREINFO_OFFSET(mem_section, section_mem_map);\n\tVMCOREINFO_NUMBER(SECTION_SIZE_BITS);\n\tVMCOREINFO_NUMBER(MAX_PHYSMEM_BITS);\n#endif\n\tVMCOREINFO_STRUCT_SIZE(page);\n\tVMCOREINFO_STRUCT_SIZE(pglist_data);\n\tVMCOREINFO_STRUCT_SIZE(zone);\n\tVMCOREINFO_STRUCT_SIZE(free_area);\n\tVMCOREINFO_STRUCT_SIZE(list_head);\n\tVMCOREINFO_SIZE(nodemask_t);\n\tVMCOREINFO_OFFSET(page, flags);\n\tVMCOREINFO_OFFSET(page, _refcount);\n\tVMCOREINFO_OFFSET(page, mapping);\n\tVMCOREINFO_OFFSET(page, lru);\n\tVMCOREINFO_OFFSET(page, _mapcount);\n\tVMCOREINFO_OFFSET(page, private);\n\tVMCOREINFO_OFFSET(page, compound_dtor);\n\tVMCOREINFO_OFFSET(page, compound_order);\n\tVMCOREINFO_OFFSET(page, compound_head);\n\tVMCOREINFO_OFFSET(pglist_data, node_zones);\n\tVMCOREINFO_OFFSET(pglist_data, nr_zones);\n#ifdef CONFIG_FLATMEM\n\tVMCOREINFO_OFFSET(pglist_data, node_mem_map);\n#endif\n\tVMCOREINFO_OFFSET(pglist_data, node_start_pfn);\n\tVMCOREINFO_OFFSET(pglist_data, node_spanned_pages);\n\tVMCOREINFO_OFFSET(pglist_data, node_id);\n\tVMCOREINFO_OFFSET(zone, free_area);\n\tVMCOREINFO_OFFSET(zone, vm_stat);\n\tVMCOREINFO_OFFSET(zone, spanned_pages);\n\tVMCOREINFO_OFFSET(free_area, free_list);\n\tVMCOREINFO_OFFSET(list_head, next);\n\tVMCOREINFO_OFFSET(list_head, prev);\n\tVMCOREINFO_OFFSET(vmap_area, va_start);\n\tVMCOREINFO_OFFSET(vmap_area, list);\n\tVMCOREINFO_LENGTH(zone.free_area, MAX_ORDER);\n\tlog_buf_vmcoreinfo_setup();\n\tVMCOREINFO_LENGTH(free_area.free_list, MIGRATE_TYPES);\n\tVMCOREINFO_NUMBER(NR_FREE_PAGES);\n\tVMCOREINFO_NUMBER(PG_lru);\n\tVMCOREINFO_NUMBER(PG_private);\n\tVMCOREINFO_NUMBER(PG_swapcache);\n\tVMCOREINFO_NUMBER(PG_swapbacked);\n\tVMCOREINFO_NUMBER(PG_slab);\n#ifdef CONFIG_MEMORY_FAILURE\n\tVMCOREINFO_NUMBER(PG_hwpoison);\n#endif\n\tVMCOREINFO_NUMBER(PG_head_mask);\n#define PAGE_BUDDY_MAPCOUNT_VALUE\t(~PG_buddy)\n\tVMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);\n#ifdef CONFIG_HUGETLB_PAGE\n\tVMCOREINFO_NUMBER(HUGETLB_PAGE_DTOR);\n#define PAGE_OFFLINE_MAPCOUNT_VALUE\t(~PG_offline)\n\tVMCOREINFO_NUMBER(PAGE_OFFLINE_MAPCOUNT_VALUE);\n#endif\n\n\tarch_crash_save_vmcoreinfo();\n\tupdate_vmcoreinfo_note();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "paddr_vmcoreinfo_note",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "387-390",
    "snippet": "phys_addr_t __weak paddr_vmcoreinfo_note(void)\n{\n\treturn __pa(vmcoreinfo_note);\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32 *vmcoreinfo_note;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vmcoreinfo_note"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "__padata_free",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/padata.c",
          "lines": "820-835",
          "snippet": "static void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD,\n\t\t\t\t\t    &pinst->cpu_dead_node);\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->cpu_online_node);\n#endif\n\n\tWARN_ON(!list_empty(&pinst->pslist));\n\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tdestroy_workqueue(pinst->serial_wq);\n\tdestroy_workqueue(pinst->parallel_wq);\n\tkfree(pinst);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/padata.h>",
            "#include <linux/cpu.h>",
            "#include <linux/err.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/export.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/sysfs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/padata.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/completion.h>\n\nstatic void __padata_free(struct padata_instance *pinst)\n{\n#ifdef CONFIG_HOTPLUG_CPU\n\tcpuhp_state_remove_instance_nocalls(CPUHP_PADATA_DEAD,\n\t\t\t\t\t    &pinst->cpu_dead_node);\n\tcpuhp_state_remove_instance_nocalls(hp_online, &pinst->cpu_online_node);\n#endif\n\n\tWARN_ON(!list_empty(&pinst->pslist));\n\n\tfree_cpumask_var(pinst->cpumask.pcpu);\n\tfree_cpumask_var(pinst->cpumask.cbcpu);\n\tdestroy_workqueue(pinst->serial_wq);\n\tdestroy_workqueue(pinst->parallel_wq);\n\tkfree(pinst);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nu32 *vmcoreinfo_note;\n\nphys_addr_t __weak paddr_vmcoreinfo_note(void)\n{\n\treturn __pa(vmcoreinfo_note);\n}"
  },
  {
    "function_name": "arch_crash_save_vmcoreinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "384-385",
    "snippet": "void __weak arch_crash_save_vmcoreinfo(void)\n{}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nvoid __weak arch_crash_save_vmcoreinfo(void)\n{}"
  },
  {
    "function_name": "vmcoreinfo_append_str",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "363-378",
    "snippet": "void vmcoreinfo_append_str(const char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[0x50];\n\tsize_t r;\n\n\tva_start(args, fmt);\n\tr = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tr = min(r, (size_t)VMCOREINFO_BYTES - vmcoreinfo_size);\n\n\tmemcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);\n\n\tvmcoreinfo_size += r;\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned char *vmcoreinfo_data;",
      "size_t vmcoreinfo_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&vmcoreinfo_data[vmcoreinfo_size]",
            "buf",
            "r"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "r",
            "(size_t)VMCOREINFO_BYTES - vmcoreinfo_size"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/irq/internals.h",
          "lines": "388-389",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_shutdown_and_deactivate(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_shutdown_and_deactivate(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t __handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vscnprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "fmt",
            "args"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nunsigned char *vmcoreinfo_data;\nsize_t vmcoreinfo_size;\n\nvoid vmcoreinfo_append_str(const char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[0x50];\n\tsize_t r;\n\n\tva_start(args, fmt);\n\tr = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tr = min(r, (size_t)VMCOREINFO_BYTES - vmcoreinfo_size);\n\n\tmemcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);\n\n\tvmcoreinfo_size += r;\n}"
  },
  {
    "function_name": "crash_save_vmcoreinfo",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "350-361",
    "snippet": "void crash_save_vmcoreinfo(void)\n{\n\tif (!vmcoreinfo_note)\n\t\treturn;\n\n\t/* Use the safe copy to generate vmcoreinfo note if have */\n\tif (vmcoreinfo_data_safecopy)\n\t\tvmcoreinfo_data = vmcoreinfo_data_safecopy;\n\n\tvmcoreinfo_append_str(\"CRASHTIME=%lld\\n\", ktime_get_real_seconds());\n\tupdate_vmcoreinfo_note();\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned char *vmcoreinfo_data;",
      "u32 *vmcoreinfo_note;",
      "static unsigned char *vmcoreinfo_data_safecopy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_vmcoreinfo_note",
          "args": [],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "update_vmcoreinfo_note",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "331-340",
          "snippet": "static void update_vmcoreinfo_note(void)\n{\n\tu32 *buf = vmcoreinfo_note;\n\n\tif (!vmcoreinfo_size)\n\t\treturn;\n\tbuf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,\n\t\t\t      vmcoreinfo_size);\n\tfinal_note(buf);\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned char *vmcoreinfo_data;",
            "size_t vmcoreinfo_size;",
            "u32 *vmcoreinfo_note;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nunsigned char *vmcoreinfo_data;\nsize_t vmcoreinfo_size;\nu32 *vmcoreinfo_note;\n\nstatic void update_vmcoreinfo_note(void)\n{\n\tu32 *buf = vmcoreinfo_note;\n\n\tif (!vmcoreinfo_size)\n\t\treturn;\n\tbuf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,\n\t\t\t      vmcoreinfo_size);\n\tfinal_note(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcoreinfo_append_str",
          "args": [
            "\"CRASHTIME=%lld\\n\"",
            "ktime_get_real_seconds()"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "vmcoreinfo_append_str",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "363-378",
          "snippet": "void vmcoreinfo_append_str(const char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[0x50];\n\tsize_t r;\n\n\tva_start(args, fmt);\n\tr = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tr = min(r, (size_t)VMCOREINFO_BYTES - vmcoreinfo_size);\n\n\tmemcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);\n\n\tvmcoreinfo_size += r;\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned char *vmcoreinfo_data;",
            "size_t vmcoreinfo_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nunsigned char *vmcoreinfo_data;\nsize_t vmcoreinfo_size;\n\nvoid vmcoreinfo_append_str(const char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[0x50];\n\tsize_t r;\n\n\tva_start(args, fmt);\n\tr = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tr = min(r, (size_t)VMCOREINFO_BYTES - vmcoreinfo_size);\n\n\tmemcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);\n\n\tvmcoreinfo_size += r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nunsigned char *vmcoreinfo_data;\nu32 *vmcoreinfo_note;\nstatic unsigned char *vmcoreinfo_data_safecopy;\n\nvoid crash_save_vmcoreinfo(void)\n{\n\tif (!vmcoreinfo_note)\n\t\treturn;\n\n\t/* Use the safe copy to generate vmcoreinfo note if have */\n\tif (vmcoreinfo_data_safecopy)\n\t\tvmcoreinfo_data = vmcoreinfo_data_safecopy;\n\n\tvmcoreinfo_append_str(\"CRASHTIME=%lld\\n\", ktime_get_real_seconds());\n\tupdate_vmcoreinfo_note();\n}"
  },
  {
    "function_name": "crash_update_vmcoreinfo_safecopy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "342-348",
    "snippet": "void crash_update_vmcoreinfo_safecopy(void *ptr)\n{\n\tif (ptr)\n\t\tmemcpy(ptr, vmcoreinfo_data, vmcoreinfo_size);\n\n\tvmcoreinfo_data_safecopy = ptr;\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned char *vmcoreinfo_data;",
      "size_t vmcoreinfo_size;",
      "static unsigned char *vmcoreinfo_data_safecopy;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "vmcoreinfo_data",
            "vmcoreinfo_size"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nunsigned char *vmcoreinfo_data;\nsize_t vmcoreinfo_size;\nstatic unsigned char *vmcoreinfo_data_safecopy;\n\nvoid crash_update_vmcoreinfo_safecopy(void *ptr)\n{\n\tif (ptr)\n\t\tmemcpy(ptr, vmcoreinfo_data, vmcoreinfo_size);\n\n\tvmcoreinfo_data_safecopy = ptr;\n}"
  },
  {
    "function_name": "update_vmcoreinfo_note",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "331-340",
    "snippet": "static void update_vmcoreinfo_note(void)\n{\n\tu32 *buf = vmcoreinfo_note;\n\n\tif (!vmcoreinfo_size)\n\t\treturn;\n\tbuf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,\n\t\t\t      vmcoreinfo_size);\n\tfinal_note(buf);\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned char *vmcoreinfo_data;",
      "size_t vmcoreinfo_size;",
      "u32 *vmcoreinfo_note;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "final_note",
          "args": [
            "buf"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "final_note",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "326-329",
          "snippet": "void final_note(Elf_Word *buf)\n{\n\tmemset(buf, 0, sizeof(struct elf_note));\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nvoid final_note(Elf_Word *buf)\n{\n\tmemset(buf, 0, sizeof(struct elf_note));\n}"
        }
      },
      {
        "call_info": {
          "callee": "append_elf_note",
          "args": [
            "buf",
            "VMCOREINFO_NOTE_NAME",
            "0",
            "vmcoreinfo_data",
            "vmcoreinfo_size"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "append_elf_note",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "309-324",
          "snippet": "Elf_Word *append_elf_note(Elf_Word *buf, char *name, unsigned int type,\n\t\t\t  void *data, size_t data_len)\n{\n\tstruct elf_note *note = (struct elf_note *)buf;\n\n\tnote->n_namesz = strlen(name) + 1;\n\tnote->n_descsz = data_len;\n\tnote->n_type   = type;\n\tbuf += DIV_ROUND_UP(sizeof(*note), sizeof(Elf_Word));\n\tmemcpy(buf, name, note->n_namesz);\n\tbuf += DIV_ROUND_UP(note->n_namesz, sizeof(Elf_Word));\n\tmemcpy(buf, data, data_len);\n\tbuf += DIV_ROUND_UP(data_len, sizeof(Elf_Word));\n\n\treturn buf;\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nElf_Word *append_elf_note(Elf_Word *buf, char *name, unsigned int type,\n\t\t\t  void *data, size_t data_len)\n{\n\tstruct elf_note *note = (struct elf_note *)buf;\n\n\tnote->n_namesz = strlen(name) + 1;\n\tnote->n_descsz = data_len;\n\tnote->n_type   = type;\n\tbuf += DIV_ROUND_UP(sizeof(*note), sizeof(Elf_Word));\n\tmemcpy(buf, name, note->n_namesz);\n\tbuf += DIV_ROUND_UP(note->n_namesz, sizeof(Elf_Word));\n\tmemcpy(buf, data, data_len);\n\tbuf += DIV_ROUND_UP(data_len, sizeof(Elf_Word));\n\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nunsigned char *vmcoreinfo_data;\nsize_t vmcoreinfo_size;\nu32 *vmcoreinfo_note;\n\nstatic void update_vmcoreinfo_note(void)\n{\n\tu32 *buf = vmcoreinfo_note;\n\n\tif (!vmcoreinfo_size)\n\t\treturn;\n\tbuf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,\n\t\t\t      vmcoreinfo_size);\n\tfinal_note(buf);\n}"
  },
  {
    "function_name": "final_note",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "326-329",
    "snippet": "void final_note(Elf_Word *buf)\n{\n\tmemset(buf, 0, sizeof(struct elf_note));\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "sizeof(struct elf_note)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nvoid final_note(Elf_Word *buf)\n{\n\tmemset(buf, 0, sizeof(struct elf_note));\n}"
  },
  {
    "function_name": "append_elf_note",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "309-324",
    "snippet": "Elf_Word *append_elf_note(Elf_Word *buf, char *name, unsigned int type,\n\t\t\t  void *data, size_t data_len)\n{\n\tstruct elf_note *note = (struct elf_note *)buf;\n\n\tnote->n_namesz = strlen(name) + 1;\n\tnote->n_descsz = data_len;\n\tnote->n_type   = type;\n\tbuf += DIV_ROUND_UP(sizeof(*note), sizeof(Elf_Word));\n\tmemcpy(buf, name, note->n_namesz);\n\tbuf += DIV_ROUND_UP(note->n_namesz, sizeof(Elf_Word));\n\tmemcpy(buf, data, data_len);\n\tbuf += DIV_ROUND_UP(data_len, sizeof(Elf_Word));\n\n\treturn buf;\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "data_len",
            "sizeof(Elf_Word)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "data",
            "data_len"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "note->n_namesz",
            "sizeof(Elf_Word)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "sizeof(*note)",
            "sizeof(Elf_Word)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nElf_Word *append_elf_note(Elf_Word *buf, char *name, unsigned int type,\n\t\t\t  void *data, size_t data_len)\n{\n\tstruct elf_note *note = (struct elf_note *)buf;\n\n\tnote->n_namesz = strlen(name) + 1;\n\tnote->n_descsz = data_len;\n\tnote->n_type   = type;\n\tbuf += DIV_ROUND_UP(sizeof(*note), sizeof(Elf_Word));\n\tmemcpy(buf, name, note->n_namesz);\n\tbuf += DIV_ROUND_UP(note->n_namesz, sizeof(Elf_Word));\n\tmemcpy(buf, data, data_len);\n\tbuf += DIV_ROUND_UP(data_len, sizeof(Elf_Word));\n\n\treturn buf;\n}"
  },
  {
    "function_name": "parse_crashkernel_dummy",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "303-306",
    "snippet": "static int __init parse_crashkernel_dummy(char *arg)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init parse_crashkernel_dummy(char *arg)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_crashkernel_low",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "290-297",
    "snippet": "int __init parse_crashkernel_low(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\"crashkernel=\", suffix_tbl[SUFFIX_LOW]);\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [
      "#define SUFFIX_LOW  1"
    ],
    "globals_used": [
      "static __initdata char *suffix_tbl[] = {\n\t[SUFFIX_HIGH] = \",high\",\n\t[SUFFIX_LOW]  = \",low\",\n\t[SUFFIX_NULL] = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__parse_crashkernel",
          "args": [
            "cmdline",
            "system_ram",
            "crash_size",
            "crash_base",
            "\"crashkernel=\"",
            "suffix_tbl[SUFFIX_LOW]"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_crashkernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "231-266",
          "snippet": "static int __init __parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar\t*first_colon, *first_space;\n\tchar\t*ck_cmdline;\n\n\tBUG_ON(!crash_size || !crash_base);\n\t*crash_size = 0;\n\t*crash_base = 0;\n\n\tck_cmdline = get_last_crashkernel(cmdline, name, suffix);\n\n\tif (!ck_cmdline)\n\t\treturn -EINVAL;\n\n\tck_cmdline += strlen(name);\n\n\tif (suffix)\n\t\treturn parse_crashkernel_suffix(ck_cmdline, crash_size,\n\t\t\t\tsuffix);\n\t/*\n\t * if the commandline contains a ':', then that's the extended\n\t * syntax -- if not, it must be the classic syntax\n\t */\n\tfirst_colon = strchr(ck_cmdline, ':');\n\tfirst_space = strchr(ck_cmdline, ' ');\n\tif (first_colon && (!first_space || first_colon < first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init __parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar\t*first_colon, *first_space;\n\tchar\t*ck_cmdline;\n\n\tBUG_ON(!crash_size || !crash_base);\n\t*crash_size = 0;\n\t*crash_base = 0;\n\n\tck_cmdline = get_last_crashkernel(cmdline, name, suffix);\n\n\tif (!ck_cmdline)\n\t\treturn -EINVAL;\n\n\tck_cmdline += strlen(name);\n\n\tif (suffix)\n\t\treturn parse_crashkernel_suffix(ck_cmdline, crash_size,\n\t\t\t\tsuffix);\n\t/*\n\t * if the commandline contains a ':', then that's the extended\n\t * syntax -- if not, it must be the classic syntax\n\t */\n\tfirst_colon = strchr(ck_cmdline, ':');\n\tfirst_space = strchr(ck_cmdline, ' ');\n\tif (first_colon && (!first_space || first_colon < first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\n#define SUFFIX_LOW  1\n\nstatic __initdata char *suffix_tbl[] = {\n\t[SUFFIX_HIGH] = \",high\",\n\t[SUFFIX_LOW]  = \",low\",\n\t[SUFFIX_NULL] = NULL,\n};\n\nint __init parse_crashkernel_low(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\"crashkernel=\", suffix_tbl[SUFFIX_LOW]);\n}"
  },
  {
    "function_name": "parse_crashkernel_high",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "281-288",
    "snippet": "int __init parse_crashkernel_high(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\"crashkernel=\", suffix_tbl[SUFFIX_HIGH]);\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [
      "#define SUFFIX_HIGH 0"
    ],
    "globals_used": [
      "static __initdata char *suffix_tbl[] = {\n\t[SUFFIX_HIGH] = \",high\",\n\t[SUFFIX_LOW]  = \",low\",\n\t[SUFFIX_NULL] = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__parse_crashkernel",
          "args": [
            "cmdline",
            "system_ram",
            "crash_size",
            "crash_base",
            "\"crashkernel=\"",
            "suffix_tbl[SUFFIX_HIGH]"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_crashkernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "231-266",
          "snippet": "static int __init __parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar\t*first_colon, *first_space;\n\tchar\t*ck_cmdline;\n\n\tBUG_ON(!crash_size || !crash_base);\n\t*crash_size = 0;\n\t*crash_base = 0;\n\n\tck_cmdline = get_last_crashkernel(cmdline, name, suffix);\n\n\tif (!ck_cmdline)\n\t\treturn -EINVAL;\n\n\tck_cmdline += strlen(name);\n\n\tif (suffix)\n\t\treturn parse_crashkernel_suffix(ck_cmdline, crash_size,\n\t\t\t\tsuffix);\n\t/*\n\t * if the commandline contains a ':', then that's the extended\n\t * syntax -- if not, it must be the classic syntax\n\t */\n\tfirst_colon = strchr(ck_cmdline, ':');\n\tfirst_space = strchr(ck_cmdline, ' ');\n\tif (first_colon && (!first_space || first_colon < first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init __parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar\t*first_colon, *first_space;\n\tchar\t*ck_cmdline;\n\n\tBUG_ON(!crash_size || !crash_base);\n\t*crash_size = 0;\n\t*crash_base = 0;\n\n\tck_cmdline = get_last_crashkernel(cmdline, name, suffix);\n\n\tif (!ck_cmdline)\n\t\treturn -EINVAL;\n\n\tck_cmdline += strlen(name);\n\n\tif (suffix)\n\t\treturn parse_crashkernel_suffix(ck_cmdline, crash_size,\n\t\t\t\tsuffix);\n\t/*\n\t * if the commandline contains a ':', then that's the extended\n\t * syntax -- if not, it must be the classic syntax\n\t */\n\tfirst_colon = strchr(ck_cmdline, ':');\n\tfirst_space = strchr(ck_cmdline, ' ');\n\tif (first_colon && (!first_space || first_colon < first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\n#define SUFFIX_HIGH 0\n\nstatic __initdata char *suffix_tbl[] = {\n\t[SUFFIX_HIGH] = \",high\",\n\t[SUFFIX_LOW]  = \",low\",\n\t[SUFFIX_NULL] = NULL,\n};\n\nint __init parse_crashkernel_high(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\"crashkernel=\", suffix_tbl[SUFFIX_HIGH]);\n}"
  },
  {
    "function_name": "parse_crashkernel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "272-279",
    "snippet": "int __init parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\t\"crashkernel=\", NULL);\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__parse_crashkernel",
          "args": [
            "cmdline",
            "system_ram",
            "crash_size",
            "crash_base",
            "\"crashkernel=\"",
            "NULL"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_crashkernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "231-266",
          "snippet": "static int __init __parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar\t*first_colon, *first_space;\n\tchar\t*ck_cmdline;\n\n\tBUG_ON(!crash_size || !crash_base);\n\t*crash_size = 0;\n\t*crash_base = 0;\n\n\tck_cmdline = get_last_crashkernel(cmdline, name, suffix);\n\n\tif (!ck_cmdline)\n\t\treturn -EINVAL;\n\n\tck_cmdline += strlen(name);\n\n\tif (suffix)\n\t\treturn parse_crashkernel_suffix(ck_cmdline, crash_size,\n\t\t\t\tsuffix);\n\t/*\n\t * if the commandline contains a ':', then that's the extended\n\t * syntax -- if not, it must be the classic syntax\n\t */\n\tfirst_colon = strchr(ck_cmdline, ':');\n\tfirst_space = strchr(ck_cmdline, ' ');\n\tif (first_colon && (!first_space || first_colon < first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init __parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar\t*first_colon, *first_space;\n\tchar\t*ck_cmdline;\n\n\tBUG_ON(!crash_size || !crash_base);\n\t*crash_size = 0;\n\t*crash_base = 0;\n\n\tck_cmdline = get_last_crashkernel(cmdline, name, suffix);\n\n\tif (!ck_cmdline)\n\t\treturn -EINVAL;\n\n\tck_cmdline += strlen(name);\n\n\tif (suffix)\n\t\treturn parse_crashkernel_suffix(ck_cmdline, crash_size,\n\t\t\t\tsuffix);\n\t/*\n\t * if the commandline contains a ':', then that's the extended\n\t * syntax -- if not, it must be the classic syntax\n\t */\n\tfirst_colon = strchr(ck_cmdline, ':');\n\tfirst_space = strchr(ck_cmdline, ' ');\n\tif (first_colon && (!first_space || first_colon < first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nint __init parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\t\"crashkernel=\", NULL);\n}"
  },
  {
    "function_name": "__parse_crashkernel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "231-266",
    "snippet": "static int __init __parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar\t*first_colon, *first_space;\n\tchar\t*ck_cmdline;\n\n\tBUG_ON(!crash_size || !crash_base);\n\t*crash_size = 0;\n\t*crash_base = 0;\n\n\tck_cmdline = get_last_crashkernel(cmdline, name, suffix);\n\n\tif (!ck_cmdline)\n\t\treturn -EINVAL;\n\n\tck_cmdline += strlen(name);\n\n\tif (suffix)\n\t\treturn parse_crashkernel_suffix(ck_cmdline, crash_size,\n\t\t\t\tsuffix);\n\t/*\n\t * if the commandline contains a ':', then that's the extended\n\t * syntax -- if not, it must be the classic syntax\n\t */\n\tfirst_colon = strchr(ck_cmdline, ':');\n\tfirst_space = strchr(ck_cmdline, ' ');\n\tif (first_colon && (!first_space || first_colon < first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_crashkernel_simple",
          "args": [
            "ck_cmdline",
            "crash_size",
            "crash_base"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "parse_crashkernel_simple",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "126-146",
          "snippet": "static int __init parse_crashkernel_simple(char *cmdline,\n\t\t\t\t\t   unsigned long long *crash_size,\n\t\t\t\t\t   unsigned long long *crash_base)\n{\n\tchar *cur = cmdline;\n\n\t*crash_size = memparse(cmdline, &cur);\n\tif (cmdline == cur) {\n\t\tpr_warn(\"crashkernel: memory value expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*cur == '@')\n\t\t*crash_base = memparse(cur+1, &cur);\n\telse if (*cur != ' ' && *cur != '\\0') {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init parse_crashkernel_simple(char *cmdline,\n\t\t\t\t\t   unsigned long long *crash_size,\n\t\t\t\t\t   unsigned long long *crash_base)\n{\n\tchar *cur = cmdline;\n\n\t*crash_size = memparse(cmdline, &cur);\n\tif (cmdline == cur) {\n\t\tpr_warn(\"crashkernel: memory value expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*cur == '@')\n\t\t*crash_base = memparse(cur+1, &cur);\n\telse if (*cur != ' ' && *cur != '\\0') {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_crashkernel_mem",
          "args": [
            "ck_cmdline",
            "system_ram",
            "crash_size",
            "crash_base"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "parse_crashkernel_mem",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "40-117",
          "snippet": "static int __init parse_crashkernel_mem(char *cmdline,\n\t\t\t\t\tunsigned long long system_ram,\n\t\t\t\t\tunsigned long long *crash_size,\n\t\t\t\t\tunsigned long long *crash_base)\n{\n\tchar *cur = cmdline, *tmp;\n\n\t/* for each entry of the comma-separated list */\n\tdo {\n\t\tunsigned long long start, end = ULLONG_MAX, size;\n\n\t\t/* get the start of the range */\n\t\tstart = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"crashkernel: Memory value expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur = tmp;\n\t\tif (*cur != '-') {\n\t\t\tpr_warn(\"crashkernel: '-' expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur++;\n\n\t\t/* if no ':' is here, than we read the end */\n\t\tif (*cur != ':') {\n\t\t\tend = memparse(cur, &tmp);\n\t\t\tif (cur == tmp) {\n\t\t\t\tpr_warn(\"crashkernel: Memory value expected\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcur = tmp;\n\t\t\tif (end <= start) {\n\t\t\t\tpr_warn(\"crashkernel: end <= start\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (*cur != ':') {\n\t\t\tpr_warn(\"crashkernel: ':' expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur++;\n\n\t\tsize = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"Memory value expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur = tmp;\n\t\tif (size >= system_ram) {\n\t\t\tpr_warn(\"crashkernel: invalid size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* match ? */\n\t\tif (system_ram >= start && system_ram < end) {\n\t\t\t*crash_size = size;\n\t\t\tbreak;\n\t\t}\n\t} while (*cur++ == ',');\n\n\tif (*crash_size > 0) {\n\t\twhile (*cur && *cur != ' ' && *cur != '@')\n\t\t\tcur++;\n\t\tif (*cur == '@') {\n\t\t\tcur++;\n\t\t\t*crash_base = memparse(cur, &tmp);\n\t\t\tif (cur == tmp) {\n\t\t\t\tpr_warn(\"Memory value expected after '@'\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpr_info(\"crashkernel size resulted in zero bytes\\n\");\n\n\treturn 0;\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init parse_crashkernel_mem(char *cmdline,\n\t\t\t\t\tunsigned long long system_ram,\n\t\t\t\t\tunsigned long long *crash_size,\n\t\t\t\t\tunsigned long long *crash_base)\n{\n\tchar *cur = cmdline, *tmp;\n\n\t/* for each entry of the comma-separated list */\n\tdo {\n\t\tunsigned long long start, end = ULLONG_MAX, size;\n\n\t\t/* get the start of the range */\n\t\tstart = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"crashkernel: Memory value expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur = tmp;\n\t\tif (*cur != '-') {\n\t\t\tpr_warn(\"crashkernel: '-' expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur++;\n\n\t\t/* if no ':' is here, than we read the end */\n\t\tif (*cur != ':') {\n\t\t\tend = memparse(cur, &tmp);\n\t\t\tif (cur == tmp) {\n\t\t\t\tpr_warn(\"crashkernel: Memory value expected\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcur = tmp;\n\t\t\tif (end <= start) {\n\t\t\t\tpr_warn(\"crashkernel: end <= start\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (*cur != ':') {\n\t\t\tpr_warn(\"crashkernel: ':' expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur++;\n\n\t\tsize = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"Memory value expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur = tmp;\n\t\tif (size >= system_ram) {\n\t\t\tpr_warn(\"crashkernel: invalid size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* match ? */\n\t\tif (system_ram >= start && system_ram < end) {\n\t\t\t*crash_size = size;\n\t\t\tbreak;\n\t\t}\n\t} while (*cur++ == ',');\n\n\tif (*crash_size > 0) {\n\t\twhile (*cur && *cur != ' ' && *cur != '@')\n\t\t\tcur++;\n\t\tif (*cur == '@') {\n\t\t\tcur++;\n\t\t\t*crash_base = memparse(cur, &tmp);\n\t\t\tif (cur == tmp) {\n\t\t\t\tpr_warn(\"Memory value expected after '@'\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpr_info(\"crashkernel size resulted in zero bytes\\n\");\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ck_cmdline",
            "' '"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "ck_cmdline",
            "':'"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_crashkernel_suffix",
          "args": [
            "ck_cmdline",
            "crash_size",
            "suffix"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "parse_crashkernel_suffix",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "164-188",
          "snippet": "static int __init parse_crashkernel_suffix(char *cmdline,\n\t\t\t\t\t   unsigned long long\t*crash_size,\n\t\t\t\t\t   const char *suffix)\n{\n\tchar *cur = cmdline;\n\n\t*crash_size = memparse(cmdline, &cur);\n\tif (cmdline == cur) {\n\t\tpr_warn(\"crashkernel: memory value expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check with suffix */\n\tif (strncmp(cur, suffix, strlen(suffix))) {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\tcur += strlen(suffix);\n\tif (*cur != ' ' && *cur != '\\0') {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init parse_crashkernel_suffix(char *cmdline,\n\t\t\t\t\t   unsigned long long\t*crash_size,\n\t\t\t\t\t   const char *suffix)\n{\n\tchar *cur = cmdline;\n\n\t*crash_size = memparse(cmdline, &cur);\n\tif (cmdline == cur) {\n\t\tpr_warn(\"crashkernel: memory value expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check with suffix */\n\tif (strncmp(cur, suffix, strlen(suffix))) {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\tcur += strlen(suffix);\n\tif (*cur != ' ' && *cur != '\\0') {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_last_crashkernel",
          "args": [
            "cmdline",
            "name",
            "suffix"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "get_last_crashkernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
          "lines": "190-229",
          "snippet": "static __init char *get_last_crashkernel(char *cmdline,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar *p = cmdline, *ck_cmdline = NULL;\n\n\t/* find crashkernel and use the last one if there are more */\n\tp = strstr(p, name);\n\twhile (p) {\n\t\tchar *end_p = strchr(p, ' ');\n\t\tchar *q;\n\n\t\tif (!end_p)\n\t\t\tend_p = p + strlen(p);\n\n\t\tif (!suffix) {\n\t\t\tint i;\n\n\t\t\t/* skip the one with any known suffix */\n\t\t\tfor (i = 0; suffix_tbl[i]; i++) {\n\t\t\t\tq = end_p - strlen(suffix_tbl[i]);\n\t\t\t\tif (!strncmp(q, suffix_tbl[i],\n\t\t\t\t\t     strlen(suffix_tbl[i])))\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tck_cmdline = p;\n\t\t} else {\n\t\t\tq = end_p - strlen(suffix);\n\t\t\tif (!strncmp(q, suffix, strlen(suffix)))\n\t\t\t\tck_cmdline = p;\n\t\t}\nnext:\n\t\tp = strstr(p+1, name);\n\t}\n\n\tif (!ck_cmdline)\n\t\treturn NULL;\n\n\treturn ck_cmdline;\n}",
          "includes": [
            "#include <crypto/sha1.h>",
            "#include <asm/sections.h>",
            "#include <asm/page.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/init.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/buildid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __initdata char *suffix_tbl[] = {\n\t[SUFFIX_HIGH] = \",high\",\n\t[SUFFIX_LOW]  = \",low\",\n\t[SUFFIX_NULL] = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic __initdata char *suffix_tbl[] = {\n\t[SUFFIX_HIGH] = \",high\",\n\t[SUFFIX_LOW]  = \",low\",\n\t[SUFFIX_NULL] = NULL,\n};\n\nstatic __init char *get_last_crashkernel(char *cmdline,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar *p = cmdline, *ck_cmdline = NULL;\n\n\t/* find crashkernel and use the last one if there are more */\n\tp = strstr(p, name);\n\twhile (p) {\n\t\tchar *end_p = strchr(p, ' ');\n\t\tchar *q;\n\n\t\tif (!end_p)\n\t\t\tend_p = p + strlen(p);\n\n\t\tif (!suffix) {\n\t\t\tint i;\n\n\t\t\t/* skip the one with any known suffix */\n\t\t\tfor (i = 0; suffix_tbl[i]; i++) {\n\t\t\t\tq = end_p - strlen(suffix_tbl[i]);\n\t\t\t\tif (!strncmp(q, suffix_tbl[i],\n\t\t\t\t\t     strlen(suffix_tbl[i])))\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tck_cmdline = p;\n\t\t} else {\n\t\t\tq = end_p - strlen(suffix);\n\t\t\tif (!strncmp(q, suffix, strlen(suffix)))\n\t\t\t\tck_cmdline = p;\n\t\t}\nnext:\n\t\tp = strstr(p+1, name);\n\t}\n\n\tif (!ck_cmdline)\n\t\treturn NULL;\n\n\treturn ck_cmdline;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!crash_size || !crash_base"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init __parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar\t*first_colon, *first_space;\n\tchar\t*ck_cmdline;\n\n\tBUG_ON(!crash_size || !crash_base);\n\t*crash_size = 0;\n\t*crash_base = 0;\n\n\tck_cmdline = get_last_crashkernel(cmdline, name, suffix);\n\n\tif (!ck_cmdline)\n\t\treturn -EINVAL;\n\n\tck_cmdline += strlen(name);\n\n\tif (suffix)\n\t\treturn parse_crashkernel_suffix(ck_cmdline, crash_size,\n\t\t\t\tsuffix);\n\t/*\n\t * if the commandline contains a ':', then that's the extended\n\t * syntax -- if not, it must be the classic syntax\n\t */\n\tfirst_colon = strchr(ck_cmdline, ':');\n\tfirst_space = strchr(ck_cmdline, ' ');\n\tif (first_colon && (!first_space || first_colon < first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}"
  },
  {
    "function_name": "get_last_crashkernel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "190-229",
    "snippet": "static __init char *get_last_crashkernel(char *cmdline,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar *p = cmdline, *ck_cmdline = NULL;\n\n\t/* find crashkernel and use the last one if there are more */\n\tp = strstr(p, name);\n\twhile (p) {\n\t\tchar *end_p = strchr(p, ' ');\n\t\tchar *q;\n\n\t\tif (!end_p)\n\t\t\tend_p = p + strlen(p);\n\n\t\tif (!suffix) {\n\t\t\tint i;\n\n\t\t\t/* skip the one with any known suffix */\n\t\t\tfor (i = 0; suffix_tbl[i]; i++) {\n\t\t\t\tq = end_p - strlen(suffix_tbl[i]);\n\t\t\t\tif (!strncmp(q, suffix_tbl[i],\n\t\t\t\t\t     strlen(suffix_tbl[i])))\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tck_cmdline = p;\n\t\t} else {\n\t\t\tq = end_p - strlen(suffix);\n\t\t\tif (!strncmp(q, suffix, strlen(suffix)))\n\t\t\t\tck_cmdline = p;\n\t\t}\nnext:\n\t\tp = strstr(p+1, name);\n\t}\n\n\tif (!ck_cmdline)\n\t\treturn NULL;\n\n\treturn ck_cmdline;\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __initdata char *suffix_tbl[] = {\n\t[SUFFIX_HIGH] = \",high\",\n\t[SUFFIX_LOW]  = \",low\",\n\t[SUFFIX_NULL] = NULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p+1",
            "name"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "q",
            "suffix",
            "strlen(suffix)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "suffix"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "q",
            "suffix_tbl[i]",
            "strlen(suffix_tbl[i])"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "' '"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "name"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic __initdata char *suffix_tbl[] = {\n\t[SUFFIX_HIGH] = \",high\",\n\t[SUFFIX_LOW]  = \",low\",\n\t[SUFFIX_NULL] = NULL,\n};\n\nstatic __init char *get_last_crashkernel(char *cmdline,\n\t\t\t     const char *name,\n\t\t\t     const char *suffix)\n{\n\tchar *p = cmdline, *ck_cmdline = NULL;\n\n\t/* find crashkernel and use the last one if there are more */\n\tp = strstr(p, name);\n\twhile (p) {\n\t\tchar *end_p = strchr(p, ' ');\n\t\tchar *q;\n\n\t\tif (!end_p)\n\t\t\tend_p = p + strlen(p);\n\n\t\tif (!suffix) {\n\t\t\tint i;\n\n\t\t\t/* skip the one with any known suffix */\n\t\t\tfor (i = 0; suffix_tbl[i]; i++) {\n\t\t\t\tq = end_p - strlen(suffix_tbl[i]);\n\t\t\t\tif (!strncmp(q, suffix_tbl[i],\n\t\t\t\t\t     strlen(suffix_tbl[i])))\n\t\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tck_cmdline = p;\n\t\t} else {\n\t\t\tq = end_p - strlen(suffix);\n\t\t\tif (!strncmp(q, suffix, strlen(suffix)))\n\t\t\t\tck_cmdline = p;\n\t\t}\nnext:\n\t\tp = strstr(p+1, name);\n\t}\n\n\tif (!ck_cmdline)\n\t\treturn NULL;\n\n\treturn ck_cmdline;\n}"
  },
  {
    "function_name": "parse_crashkernel_suffix",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "164-188",
    "snippet": "static int __init parse_crashkernel_suffix(char *cmdline,\n\t\t\t\t\t   unsigned long long\t*crash_size,\n\t\t\t\t\t   const char *suffix)\n{\n\tchar *cur = cmdline;\n\n\t*crash_size = memparse(cmdline, &cur);\n\tif (cmdline == cur) {\n\t\tpr_warn(\"crashkernel: memory value expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check with suffix */\n\tif (strncmp(cur, suffix, strlen(suffix))) {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\tcur += strlen(suffix);\n\tif (*cur != ' ' && *cur != '\\0') {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: unrecognized char: %c\\n\"",
            "*cur"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "suffix"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: unrecognized char: %c\\n\"",
            "*cur"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cur",
            "suffix",
            "strlen(suffix)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: memory value expected\\n\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "cmdline",
            "&cur"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init parse_crashkernel_suffix(char *cmdline,\n\t\t\t\t\t   unsigned long long\t*crash_size,\n\t\t\t\t\t   const char *suffix)\n{\n\tchar *cur = cmdline;\n\n\t*crash_size = memparse(cmdline, &cur);\n\tif (cmdline == cur) {\n\t\tpr_warn(\"crashkernel: memory value expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* check with suffix */\n\tif (strncmp(cur, suffix, strlen(suffix))) {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\tcur += strlen(suffix);\n\tif (*cur != ' ' && *cur != '\\0') {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_crashkernel_simple",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "126-146",
    "snippet": "static int __init parse_crashkernel_simple(char *cmdline,\n\t\t\t\t\t   unsigned long long *crash_size,\n\t\t\t\t\t   unsigned long long *crash_base)\n{\n\tchar *cur = cmdline;\n\n\t*crash_size = memparse(cmdline, &cur);\n\tif (cmdline == cur) {\n\t\tpr_warn(\"crashkernel: memory value expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*cur == '@')\n\t\t*crash_base = memparse(cur+1, &cur);\n\telse if (*cur != ' ' && *cur != '\\0') {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: unrecognized char: %c\\n\"",
            "*cur"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "cur+1",
            "&cur"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: memory value expected\\n\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "cmdline",
            "&cur"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init parse_crashkernel_simple(char *cmdline,\n\t\t\t\t\t   unsigned long long *crash_size,\n\t\t\t\t\t   unsigned long long *crash_base)\n{\n\tchar *cur = cmdline;\n\n\t*crash_size = memparse(cmdline, &cur);\n\tif (cmdline == cur) {\n\t\tpr_warn(\"crashkernel: memory value expected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*cur == '@')\n\t\t*crash_base = memparse(cur+1, &cur);\n\telse if (*cur != ' ' && *cur != '\\0') {\n\t\tpr_warn(\"crashkernel: unrecognized char: %c\\n\", *cur);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_crashkernel_mem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/crash_core.c",
    "lines": "40-117",
    "snippet": "static int __init parse_crashkernel_mem(char *cmdline,\n\t\t\t\t\tunsigned long long system_ram,\n\t\t\t\t\tunsigned long long *crash_size,\n\t\t\t\t\tunsigned long long *crash_base)\n{\n\tchar *cur = cmdline, *tmp;\n\n\t/* for each entry of the comma-separated list */\n\tdo {\n\t\tunsigned long long start, end = ULLONG_MAX, size;\n\n\t\t/* get the start of the range */\n\t\tstart = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"crashkernel: Memory value expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur = tmp;\n\t\tif (*cur != '-') {\n\t\t\tpr_warn(\"crashkernel: '-' expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur++;\n\n\t\t/* if no ':' is here, than we read the end */\n\t\tif (*cur != ':') {\n\t\t\tend = memparse(cur, &tmp);\n\t\t\tif (cur == tmp) {\n\t\t\t\tpr_warn(\"crashkernel: Memory value expected\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcur = tmp;\n\t\t\tif (end <= start) {\n\t\t\t\tpr_warn(\"crashkernel: end <= start\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (*cur != ':') {\n\t\t\tpr_warn(\"crashkernel: ':' expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur++;\n\n\t\tsize = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"Memory value expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur = tmp;\n\t\tif (size >= system_ram) {\n\t\t\tpr_warn(\"crashkernel: invalid size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* match ? */\n\t\tif (system_ram >= start && system_ram < end) {\n\t\t\t*crash_size = size;\n\t\t\tbreak;\n\t\t}\n\t} while (*cur++ == ',');\n\n\tif (*crash_size > 0) {\n\t\twhile (*cur && *cur != ' ' && *cur != '@')\n\t\t\tcur++;\n\t\tif (*cur == '@') {\n\t\t\tcur++;\n\t\t\t*crash_base = memparse(cur, &tmp);\n\t\t\tif (cur == tmp) {\n\t\t\t\tpr_warn(\"Memory value expected after '@'\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpr_info(\"crashkernel size resulted in zero bytes\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include <crypto/sha1.h>",
      "#include <asm/sections.h>",
      "#include <asm/page.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/init.h>",
      "#include <linux/crash_core.h>",
      "#include <linux/buildid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"crashkernel size resulted in zero bytes\\n\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Memory value expected after '@'\\n\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "cur",
            "&tmp"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: invalid size\\n\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Memory value expected\\n\""
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "cur",
            "&tmp"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: ':' expected\\n\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: end <= start\\n\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: Memory value expected\\n\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "cur",
            "&tmp"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: '-' expected\\n\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"crashkernel: Memory value expected\\n\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "cur",
            "&tmp"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/sha1.h>\n#include <asm/sections.h>\n#include <asm/page.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/crash_core.h>\n#include <linux/buildid.h>\n\nstatic int __init parse_crashkernel_mem(char *cmdline,\n\t\t\t\t\tunsigned long long system_ram,\n\t\t\t\t\tunsigned long long *crash_size,\n\t\t\t\t\tunsigned long long *crash_base)\n{\n\tchar *cur = cmdline, *tmp;\n\n\t/* for each entry of the comma-separated list */\n\tdo {\n\t\tunsigned long long start, end = ULLONG_MAX, size;\n\n\t\t/* get the start of the range */\n\t\tstart = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"crashkernel: Memory value expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur = tmp;\n\t\tif (*cur != '-') {\n\t\t\tpr_warn(\"crashkernel: '-' expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur++;\n\n\t\t/* if no ':' is here, than we read the end */\n\t\tif (*cur != ':') {\n\t\t\tend = memparse(cur, &tmp);\n\t\t\tif (cur == tmp) {\n\t\t\t\tpr_warn(\"crashkernel: Memory value expected\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcur = tmp;\n\t\t\tif (end <= start) {\n\t\t\t\tpr_warn(\"crashkernel: end <= start\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (*cur != ':') {\n\t\t\tpr_warn(\"crashkernel: ':' expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur++;\n\n\t\tsize = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"Memory value expected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcur = tmp;\n\t\tif (size >= system_ram) {\n\t\t\tpr_warn(\"crashkernel: invalid size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* match ? */\n\t\tif (system_ram >= start && system_ram < end) {\n\t\t\t*crash_size = size;\n\t\t\tbreak;\n\t\t}\n\t} while (*cur++ == ',');\n\n\tif (*crash_size > 0) {\n\t\twhile (*cur && *cur != ' ' && *cur != '@')\n\t\t\tcur++;\n\t\tif (*cur == '@') {\n\t\t\tcur++;\n\t\t\t*crash_base = memparse(cur, &tmp);\n\t\t\tif (cur == tmp) {\n\t\t\t\tpr_warn(\"Memory value expected after '@'\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpr_info(\"crashkernel size resulted in zero bytes\\n\");\n\n\treturn 0;\n}"
  }
]