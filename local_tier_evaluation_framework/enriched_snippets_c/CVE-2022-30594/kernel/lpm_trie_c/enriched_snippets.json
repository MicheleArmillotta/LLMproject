[
  {
    "function_name": "trie_check_btf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
    "lines": "712-720",
    "snippet": "static int trie_check_btf(const struct bpf_map *map,\n\t\t\t  const struct btf *btf,\n\t\t\t  const struct btf_type *key_type,\n\t\t\t  const struct btf_type *value_type)\n{\n\t/* Keys must have struct bpf_lpm_trie_key embedded. */\n\treturn BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ?\n\t       -EINVAL : 0;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTF_INFO_KIND",
          "args": [
            "key_type->info"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int trie_check_btf(const struct bpf_map *map,\n\t\t\t  const struct btf *btf,\n\t\t\t  const struct btf_type *key_type,\n\t\t\t  const struct btf_type *value_type)\n{\n\t/* Keys must have struct bpf_lpm_trie_key embedded. */\n\treturn BTF_INFO_KIND(key_type->info) != BTF_KIND_STRUCT ?\n\t       -EINVAL : 0;\n}"
  },
  {
    "function_name": "trie_get_next_key",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
    "lines": "614-710",
    "snippet": "static int trie_get_next_key(struct bpf_map *map, void *_key, void *_next_key)\n{\n\tstruct lpm_trie_node *node, *next_node = NULL, *parent, *search_root;\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct bpf_lpm_trie_key *key = _key, *next_key = _next_key;\n\tstruct lpm_trie_node **node_stack = NULL;\n\tint err = 0, stack_ptr = -1;\n\tunsigned int next_bit;\n\tsize_t matchlen;\n\n\t/* The get_next_key follows postorder. For the 4 node example in\n\t * the top of this file, the trie_get_next_key() returns the following\n\t * one after another:\n\t *   192.168.0.0/24\n\t *   192.168.1.0/24\n\t *   192.168.128.0/24\n\t *   192.168.0.0/16\n\t *\n\t * The idea is to return more specific keys before less specific ones.\n\t */\n\n\t/* Empty trie */\n\tsearch_root = rcu_dereference(trie->root);\n\tif (!search_root)\n\t\treturn -ENOENT;\n\n\t/* For invalid key, find the leftmost node in the trie */\n\tif (!key || key->prefixlen > trie->max_prefixlen)\n\t\tgoto find_leftmost;\n\n\tnode_stack = kmalloc_array(trie->max_prefixlen,\n\t\t\t\t   sizeof(struct lpm_trie_node *),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN);\n\tif (!node_stack)\n\t\treturn -ENOMEM;\n\n\t/* Try to find the exact node for the given key */\n\tfor (node = search_root; node;) {\n\t\tnode_stack[++stack_ptr] = node;\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen)\n\t\t\tbreak;\n\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tnode = rcu_dereference(node->child[next_bit]);\n\t}\n\tif (!node || node->prefixlen != key->prefixlen ||\n\t    (node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\tgoto find_leftmost;\n\n\t/* The node with the exactly-matching key has been found,\n\t * find the first node in postorder after the matched node.\n\t */\n\tnode = node_stack[stack_ptr];\n\twhile (stack_ptr > 0) {\n\t\tparent = node_stack[stack_ptr - 1];\n\t\tif (rcu_dereference(parent->child[0]) == node) {\n\t\t\tsearch_root = rcu_dereference(parent->child[1]);\n\t\t\tif (search_root)\n\t\t\t\tgoto find_leftmost;\n\t\t}\n\t\tif (!(parent->flags & LPM_TREE_NODE_FLAG_IM)) {\n\t\t\tnext_node = parent;\n\t\t\tgoto do_copy;\n\t\t}\n\n\t\tnode = parent;\n\t\tstack_ptr--;\n\t}\n\n\t/* did not find anything */\n\terr = -ENOENT;\n\tgoto free_stack;\n\nfind_leftmost:\n\t/* Find the leftmost non-intermediate node, all intermediate nodes\n\t * have exact two children, so this function will never return NULL.\n\t */\n\tfor (node = search_root; node;) {\n\t\tif (node->flags & LPM_TREE_NODE_FLAG_IM) {\n\t\t\tnode = rcu_dereference(node->child[0]);\n\t\t} else {\n\t\t\tnext_node = node;\n\t\t\tnode = rcu_dereference(node->child[0]);\n\t\t\tif (!node)\n\t\t\t\tnode = rcu_dereference(next_node->child[1]);\n\t\t}\n\t}\ndo_copy:\n\tnext_key->prefixlen = next_node->prefixlen;\n\tmemcpy((void *)next_key + offsetof(struct bpf_lpm_trie_key, data),\n\t       next_node->data, trie->data_size);\nfree_stack:\n\tkfree(node_stack);\n\treturn err;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define LPM_TREE_NODE_FLAG_IM BIT(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node_stack"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)next_key + offsetof(struct bpf_lpm_trie_key, data)",
            "next_node->data",
            "trie->data_size"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "next_node->child[1]"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "node->child[0]"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "node->child[0]"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "parent->child[1]"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "parent->child[0]"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "node->child[next_bit]"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_bit",
          "args": [
            "key->data",
            "node->prefixlen"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "extract_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
          "lines": "151-154",
          "snippet": "static inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "longest_prefix_match",
          "args": [
            "trie",
            "node",
            "key"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "longest_prefix_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
          "lines": "164-224",
          "snippet": "static size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t/* data_size >= 16 has very small probability.\n\t * We do not use a loop for optimal code generation.\n\t */\n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t/* data_size >= 16 has very small probability.\n\t * We do not use a loop for optimal code generation.\n\t */\n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "trie->max_prefixlen",
            "sizeof(struct lpm_trie_node *)",
            "GFP_ATOMIC | __GFP_NOWARN"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "trie->root"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structlpm_trie",
            "map"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define LPM_TREE_NODE_FLAG_IM BIT(0)\n\nstatic int trie_get_next_key(struct bpf_map *map, void *_key, void *_next_key)\n{\n\tstruct lpm_trie_node *node, *next_node = NULL, *parent, *search_root;\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct bpf_lpm_trie_key *key = _key, *next_key = _next_key;\n\tstruct lpm_trie_node **node_stack = NULL;\n\tint err = 0, stack_ptr = -1;\n\tunsigned int next_bit;\n\tsize_t matchlen;\n\n\t/* The get_next_key follows postorder. For the 4 node example in\n\t * the top of this file, the trie_get_next_key() returns the following\n\t * one after another:\n\t *   192.168.0.0/24\n\t *   192.168.1.0/24\n\t *   192.168.128.0/24\n\t *   192.168.0.0/16\n\t *\n\t * The idea is to return more specific keys before less specific ones.\n\t */\n\n\t/* Empty trie */\n\tsearch_root = rcu_dereference(trie->root);\n\tif (!search_root)\n\t\treturn -ENOENT;\n\n\t/* For invalid key, find the leftmost node in the trie */\n\tif (!key || key->prefixlen > trie->max_prefixlen)\n\t\tgoto find_leftmost;\n\n\tnode_stack = kmalloc_array(trie->max_prefixlen,\n\t\t\t\t   sizeof(struct lpm_trie_node *),\n\t\t\t\t   GFP_ATOMIC | __GFP_NOWARN);\n\tif (!node_stack)\n\t\treturn -ENOMEM;\n\n\t/* Try to find the exact node for the given key */\n\tfor (node = search_root; node;) {\n\t\tnode_stack[++stack_ptr] = node;\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen)\n\t\t\tbreak;\n\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tnode = rcu_dereference(node->child[next_bit]);\n\t}\n\tif (!node || node->prefixlen != key->prefixlen ||\n\t    (node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\tgoto find_leftmost;\n\n\t/* The node with the exactly-matching key has been found,\n\t * find the first node in postorder after the matched node.\n\t */\n\tnode = node_stack[stack_ptr];\n\twhile (stack_ptr > 0) {\n\t\tparent = node_stack[stack_ptr - 1];\n\t\tif (rcu_dereference(parent->child[0]) == node) {\n\t\t\tsearch_root = rcu_dereference(parent->child[1]);\n\t\t\tif (search_root)\n\t\t\t\tgoto find_leftmost;\n\t\t}\n\t\tif (!(parent->flags & LPM_TREE_NODE_FLAG_IM)) {\n\t\t\tnext_node = parent;\n\t\t\tgoto do_copy;\n\t\t}\n\n\t\tnode = parent;\n\t\tstack_ptr--;\n\t}\n\n\t/* did not find anything */\n\terr = -ENOENT;\n\tgoto free_stack;\n\nfind_leftmost:\n\t/* Find the leftmost non-intermediate node, all intermediate nodes\n\t * have exact two children, so this function will never return NULL.\n\t */\n\tfor (node = search_root; node;) {\n\t\tif (node->flags & LPM_TREE_NODE_FLAG_IM) {\n\t\t\tnode = rcu_dereference(node->child[0]);\n\t\t} else {\n\t\t\tnext_node = node;\n\t\t\tnode = rcu_dereference(node->child[0]);\n\t\t\tif (!node)\n\t\t\t\tnode = rcu_dereference(next_node->child[1]);\n\t\t}\n\t}\ndo_copy:\n\tnext_key->prefixlen = next_node->prefixlen;\n\tmemcpy((void *)next_key + offsetof(struct bpf_lpm_trie_key, data),\n\t       next_node->data, trie->data_size);\nfree_stack:\n\tkfree(node_stack);\n\treturn err;\n}"
  },
  {
    "function_name": "trie_free",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
    "lines": "575-612",
    "snippet": "static void trie_free(struct bpf_map *map)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node __rcu **slot;\n\tstruct lpm_trie_node *node;\n\n\t/* Always start at the root and walk down to a node that has no\n\t * children. Then free that node, nullify its reference in the parent\n\t * and start over.\n\t */\n\n\tfor (;;) {\n\t\tslot = &trie->root;\n\n\t\tfor (;;) {\n\t\t\tnode = rcu_dereference_protected(*slot, 1);\n\t\t\tif (!node)\n\t\t\t\tgoto out;\n\n\t\t\tif (rcu_access_pointer(node->child[0])) {\n\t\t\t\tslot = &node->child[0];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rcu_access_pointer(node->child[1])) {\n\t\t\t\tslot = &node->child[1];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkfree(node);\n\t\t\tRCU_INIT_POINTER(*slot, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(trie);\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "trie"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "*slot",
            "NULL"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[1]"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[0]"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "*slot",
            "1"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structlpm_trie",
            "map"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void trie_free(struct bpf_map *map)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node __rcu **slot;\n\tstruct lpm_trie_node *node;\n\n\t/* Always start at the root and walk down to a node that has no\n\t * children. Then free that node, nullify its reference in the parent\n\t * and start over.\n\t */\n\n\tfor (;;) {\n\t\tslot = &trie->root;\n\n\t\tfor (;;) {\n\t\t\tnode = rcu_dereference_protected(*slot, 1);\n\t\t\tif (!node)\n\t\t\t\tgoto out;\n\n\t\t\tif (rcu_access_pointer(node->child[0])) {\n\t\t\t\tslot = &node->child[0];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rcu_access_pointer(node->child[1])) {\n\t\t\t\tslot = &node->child[1];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tkfree(node);\n\t\t\tRCU_INIT_POINTER(*slot, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(trie);\n}"
  },
  {
    "function_name": "trie_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
    "lines": "542-573",
    "snippet": "static struct bpf_map *trie_alloc(union bpf_attr *attr)\n{\n\tstruct lpm_trie *trie;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 ||\n\t    !(attr->map_flags & BPF_F_NO_PREALLOC) ||\n\t    attr->map_flags & ~LPM_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags) ||\n\t    attr->key_size < LPM_KEY_SIZE_MIN ||\n\t    attr->key_size > LPM_KEY_SIZE_MAX ||\n\t    attr->value_size < LPM_VAL_SIZE_MIN ||\n\t    attr->value_size > LPM_VAL_SIZE_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttrie = kzalloc(sizeof(*trie), GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT);\n\tif (!trie)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&trie->map, attr);\n\ttrie->data_size = attr->key_size -\n\t\t\t  offsetof(struct bpf_lpm_trie_key, data);\n\ttrie->max_prefixlen = trie->data_size * 8;\n\n\tspin_lock_init(&trie->lock);\n\n\treturn &trie->map;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define LPM_CREATE_FLAG_MASK\t(BPF_F_NO_PREALLOC | BPF_F_NUMA_NODE |\t\\\n\t\t\t\t BPF_F_ACCESS_MASK)",
      "#define LPM_KEY_SIZE_MIN\tLPM_KEY_SIZE(LPM_DATA_SIZE_MIN)",
      "#define LPM_KEY_SIZE_MAX\tLPM_KEY_SIZE(LPM_DATA_SIZE_MAX)",
      "#define LPM_VAL_SIZE_MIN\t1",
      "#define LPM_VAL_SIZE_MAX\t(KMALLOC_MAX_SIZE - LPM_DATA_SIZE_MAX - \\\n\t\t\t\t sizeof(struct lpm_trie_node))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&trie->lock"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_init_from_attr",
          "args": [
            "&trie->map",
            "attr"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_from_attr",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "361-370",
          "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = bpf_map_flags_retain_permanent(attr->map_flags);\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n\tmap->map_extra = attr->map_extra;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*trie)",
            "GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_flags_access_ok",
          "args": [
            "attr->map_flags"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_capable",
          "args": [],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define LPM_CREATE_FLAG_MASK\t(BPF_F_NO_PREALLOC | BPF_F_NUMA_NODE |\t\\\n\t\t\t\t BPF_F_ACCESS_MASK)\n#define LPM_KEY_SIZE_MIN\tLPM_KEY_SIZE(LPM_DATA_SIZE_MIN)\n#define LPM_KEY_SIZE_MAX\tLPM_KEY_SIZE(LPM_DATA_SIZE_MAX)\n#define LPM_VAL_SIZE_MIN\t1\n#define LPM_VAL_SIZE_MAX\t(KMALLOC_MAX_SIZE - LPM_DATA_SIZE_MAX - \\\n\t\t\t\t sizeof(struct lpm_trie_node))\n\nstatic struct bpf_map *trie_alloc(union bpf_attr *attr)\n{\n\tstruct lpm_trie *trie;\n\n\tif (!bpf_capable())\n\t\treturn ERR_PTR(-EPERM);\n\n\t/* check sanity of attributes */\n\tif (attr->max_entries == 0 ||\n\t    !(attr->map_flags & BPF_F_NO_PREALLOC) ||\n\t    attr->map_flags & ~LPM_CREATE_FLAG_MASK ||\n\t    !bpf_map_flags_access_ok(attr->map_flags) ||\n\t    attr->key_size < LPM_KEY_SIZE_MIN ||\n\t    attr->key_size > LPM_KEY_SIZE_MAX ||\n\t    attr->value_size < LPM_VAL_SIZE_MIN ||\n\t    attr->value_size > LPM_VAL_SIZE_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttrie = kzalloc(sizeof(*trie), GFP_USER | __GFP_NOWARN | __GFP_ACCOUNT);\n\tif (!trie)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* copy mandatory map attributes */\n\tbpf_map_init_from_attr(&trie->map, attr);\n\ttrie->data_size = attr->key_size -\n\t\t\t  offsetof(struct bpf_lpm_trie_key, data);\n\ttrie->max_prefixlen = trie->data_size * 8;\n\n\tspin_lock_init(&trie->lock);\n\n\treturn &trie->map;\n}"
  },
  {
    "function_name": "trie_delete_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
    "lines": "433-526",
    "snippet": "static int trie_delete_elem(struct bpf_map *map, void *_key)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct bpf_lpm_trie_key *key = _key;\n\tstruct lpm_trie_node __rcu **trim, **trim2;\n\tstruct lpm_trie_node *node, *parent;\n\tunsigned long irq_flags;\n\tunsigned int next_bit;\n\tsize_t matchlen = 0;\n\tint ret = 0;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&trie->lock, irq_flags);\n\n\t/* Walk the tree looking for an exact key/length match and keeping\n\t * track of the path we traverse.  We will need to know the node\n\t * we wish to delete, and the slot that points to the node we want\n\t * to delete.  We may also need to know the nodes parent and the\n\t * slot that contains it.\n\t */\n\ttrim = &trie->root;\n\ttrim2 = trim;\n\tparent = NULL;\n\twhile ((node = rcu_dereference_protected(\n\t\t       *trim, lockdep_is_held(&trie->lock)))) {\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen)\n\t\t\tbreak;\n\n\t\tparent = node;\n\t\ttrim2 = trim;\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\ttrim = &node->child[next_bit];\n\t}\n\n\tif (!node || node->prefixlen != key->prefixlen ||\n\t    node->prefixlen != matchlen ||\n\t    (node->flags & LPM_TREE_NODE_FLAG_IM)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrie->n_entries--;\n\n\t/* If the node we are removing has two children, simply mark it\n\t * as intermediate and we are done.\n\t */\n\tif (rcu_access_pointer(node->child[0]) &&\n\t    rcu_access_pointer(node->child[1])) {\n\t\tnode->flags |= LPM_TREE_NODE_FLAG_IM;\n\t\tgoto out;\n\t}\n\n\t/* If the parent of the node we are about to delete is an intermediate\n\t * node, and the deleted node doesn't have any children, we can delete\n\t * the intermediate parent as well and promote its other child\n\t * up the tree.  Doing this maintains the invariant that all\n\t * intermediate nodes have exactly 2 children and that there are no\n\t * unnecessary intermediate nodes in the tree.\n\t */\n\tif (parent && (parent->flags & LPM_TREE_NODE_FLAG_IM) &&\n\t    !node->child[0] && !node->child[1]) {\n\t\tif (node == rcu_access_pointer(parent->child[0]))\n\t\t\trcu_assign_pointer(\n\t\t\t\t*trim2, rcu_access_pointer(parent->child[1]));\n\t\telse\n\t\t\trcu_assign_pointer(\n\t\t\t\t*trim2, rcu_access_pointer(parent->child[0]));\n\t\tkfree_rcu(parent, rcu);\n\t\tkfree_rcu(node, rcu);\n\t\tgoto out;\n\t}\n\n\t/* The node we are removing has either zero or one child. If there\n\t * is a child, move it into the removed node's slot then delete\n\t * the node.  Otherwise just clear the slot and delete the node.\n\t */\n\tif (node->child[0])\n\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[0]));\n\telse if (node->child[1])\n\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[1]));\n\telse\n\t\tRCU_INIT_POINTER(*trim, NULL);\n\tkfree_rcu(node, rcu);\n\nout:\n\tspin_unlock_irqrestore(&trie->lock, irq_flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define LPM_TREE_NODE_FLAG_IM BIT(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&trie->lock",
            "irq_flags"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "node",
            "rcu"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "*trim",
            "NULL"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*trim",
            "rcu_access_pointer(node->child[1])"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[1]"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*trim",
            "rcu_access_pointer(node->child[0])"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[0]"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*trim2",
            "rcu_access_pointer(parent->child[0])"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "parent->child[0]"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*trim2",
            "rcu_access_pointer(parent->child[1])"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "parent->child[1]"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "parent->child[0]"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[1]"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "node->child[0]"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_bit",
          "args": [
            "key->data",
            "node->prefixlen"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "extract_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
          "lines": "151-154",
          "snippet": "static inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "longest_prefix_match",
          "args": [
            "trie",
            "node",
            "key"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "longest_prefix_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
          "lines": "164-224",
          "snippet": "static size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t/* data_size >= 16 has very small probability.\n\t * We do not use a loop for optimal code generation.\n\t */\n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t/* data_size >= 16 has very small probability.\n\t * We do not use a loop for optimal code generation.\n\t */\n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "*trim",
            "lockdep_is_held(&trie->lock)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&trie->lock"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&trie->lock",
            "irq_flags"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structlpm_trie",
            "map"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define LPM_TREE_NODE_FLAG_IM BIT(0)\n\nstatic int trie_delete_elem(struct bpf_map *map, void *_key)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct bpf_lpm_trie_key *key = _key;\n\tstruct lpm_trie_node __rcu **trim, **trim2;\n\tstruct lpm_trie_node *node, *parent;\n\tunsigned long irq_flags;\n\tunsigned int next_bit;\n\tsize_t matchlen = 0;\n\tint ret = 0;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&trie->lock, irq_flags);\n\n\t/* Walk the tree looking for an exact key/length match and keeping\n\t * track of the path we traverse.  We will need to know the node\n\t * we wish to delete, and the slot that points to the node we want\n\t * to delete.  We may also need to know the nodes parent and the\n\t * slot that contains it.\n\t */\n\ttrim = &trie->root;\n\ttrim2 = trim;\n\tparent = NULL;\n\twhile ((node = rcu_dereference_protected(\n\t\t       *trim, lockdep_is_held(&trie->lock)))) {\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen)\n\t\t\tbreak;\n\n\t\tparent = node;\n\t\ttrim2 = trim;\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\ttrim = &node->child[next_bit];\n\t}\n\n\tif (!node || node->prefixlen != key->prefixlen ||\n\t    node->prefixlen != matchlen ||\n\t    (node->flags & LPM_TREE_NODE_FLAG_IM)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\ttrie->n_entries--;\n\n\t/* If the node we are removing has two children, simply mark it\n\t * as intermediate and we are done.\n\t */\n\tif (rcu_access_pointer(node->child[0]) &&\n\t    rcu_access_pointer(node->child[1])) {\n\t\tnode->flags |= LPM_TREE_NODE_FLAG_IM;\n\t\tgoto out;\n\t}\n\n\t/* If the parent of the node we are about to delete is an intermediate\n\t * node, and the deleted node doesn't have any children, we can delete\n\t * the intermediate parent as well and promote its other child\n\t * up the tree.  Doing this maintains the invariant that all\n\t * intermediate nodes have exactly 2 children and that there are no\n\t * unnecessary intermediate nodes in the tree.\n\t */\n\tif (parent && (parent->flags & LPM_TREE_NODE_FLAG_IM) &&\n\t    !node->child[0] && !node->child[1]) {\n\t\tif (node == rcu_access_pointer(parent->child[0]))\n\t\t\trcu_assign_pointer(\n\t\t\t\t*trim2, rcu_access_pointer(parent->child[1]));\n\t\telse\n\t\t\trcu_assign_pointer(\n\t\t\t\t*trim2, rcu_access_pointer(parent->child[0]));\n\t\tkfree_rcu(parent, rcu);\n\t\tkfree_rcu(node, rcu);\n\t\tgoto out;\n\t}\n\n\t/* The node we are removing has either zero or one child. If there\n\t * is a child, move it into the removed node's slot then delete\n\t * the node.  Otherwise just clear the slot and delete the node.\n\t */\n\tif (node->child[0])\n\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[0]));\n\telse if (node->child[1])\n\t\trcu_assign_pointer(*trim, rcu_access_pointer(node->child[1]));\n\telse\n\t\tRCU_INIT_POINTER(*trim, NULL);\n\tkfree_rcu(node, rcu);\n\nout:\n\tspin_unlock_irqrestore(&trie->lock, irq_flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "trie_update_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
    "lines": "302-430",
    "snippet": "static int trie_update_elem(struct bpf_map *map,\n\t\t\t    void *_key, void *value, u64 flags)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node *node, *im_node = NULL, *new_node = NULL;\n\tstruct lpm_trie_node __rcu **slot;\n\tstruct bpf_lpm_trie_key *key = _key;\n\tunsigned long irq_flags;\n\tunsigned int next_bit;\n\tsize_t matchlen = 0;\n\tint ret = 0;\n\n\tif (unlikely(flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&trie->lock, irq_flags);\n\n\t/* Allocate and fill a new node */\n\n\tif (trie->n_entries == trie->map.max_entries) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tnew_node = lpm_trie_node_alloc(trie, value);\n\tif (!new_node) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttrie->n_entries++;\n\n\tnew_node->prefixlen = key->prefixlen;\n\tRCU_INIT_POINTER(new_node->child[0], NULL);\n\tRCU_INIT_POINTER(new_node->child[1], NULL);\n\tmemcpy(new_node->data, key->data, trie->data_size);\n\n\t/* Now find a slot to attach the new node. To do that, walk the tree\n\t * from the root and match as many bits as possible for each node until\n\t * we either find an empty slot or a slot that needs to be replaced by\n\t * an intermediate node.\n\t */\n\tslot = &trie->root;\n\n\twhile ((node = rcu_dereference_protected(*slot,\n\t\t\t\t\tlockdep_is_held(&trie->lock)))) {\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen ||\n\t\t    node->prefixlen == trie->max_prefixlen)\n\t\t\tbreak;\n\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tslot = &node->child[next_bit];\n\t}\n\n\t/* If the slot is empty (a free child pointer or an empty root),\n\t * simply assign the @new_node to that slot and be done.\n\t */\n\tif (!node) {\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tgoto out;\n\t}\n\n\t/* If the slot we picked already exists, replace it with @new_node\n\t * which already has the correct data array set.\n\t */\n\tif (node->prefixlen == matchlen) {\n\t\tnew_node->child[0] = node->child[0];\n\t\tnew_node->child[1] = node->child[1];\n\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\ttrie->n_entries--;\n\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tkfree_rcu(node, rcu);\n\n\t\tgoto out;\n\t}\n\n\t/* If the new node matches the prefix completely, it must be inserted\n\t * as an ancestor. Simply insert it between @node and *@slot.\n\t */\n\tif (matchlen == key->prefixlen) {\n\t\tnext_bit = extract_bit(node->data, matchlen);\n\t\trcu_assign_pointer(new_node->child[next_bit], node);\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tgoto out;\n\t}\n\n\tim_node = lpm_trie_node_alloc(trie, NULL);\n\tif (!im_node) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tim_node->prefixlen = matchlen;\n\tim_node->flags |= LPM_TREE_NODE_FLAG_IM;\n\tmemcpy(im_node->data, node->data, trie->data_size);\n\n\t/* Now determine which child to install in which slot */\n\tif (extract_bit(key->data, matchlen)) {\n\t\trcu_assign_pointer(im_node->child[0], node);\n\t\trcu_assign_pointer(im_node->child[1], new_node);\n\t} else {\n\t\trcu_assign_pointer(im_node->child[0], new_node);\n\t\trcu_assign_pointer(im_node->child[1], node);\n\t}\n\n\t/* Finally, assign the intermediate node to the determined slot */\n\trcu_assign_pointer(*slot, im_node);\n\nout:\n\tif (ret) {\n\t\tif (new_node)\n\t\t\ttrie->n_entries--;\n\n\t\tkfree(new_node);\n\t\tkfree(im_node);\n\t}\n\n\tspin_unlock_irqrestore(&trie->lock, irq_flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define LPM_TREE_NODE_FLAG_IM BIT(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&trie->lock",
            "irq_flags"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "im_node"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/params.c",
          "lines": "62-75",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/security.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/security.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*slot",
            "im_node"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "im_node->child[1]",
            "node"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "im_node->child[0]",
            "new_node"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "im_node->child[1]",
            "new_node"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "im_node->child[0]",
            "node"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_bit",
          "args": [
            "key->data",
            "matchlen"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "extract_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
          "lines": "151-154",
          "snippet": "static inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "im_node->data",
            "node->data",
            "trie->data_size"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lpm_trie_node_alloc",
          "args": [
            "trie",
            "NULL"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "lpm_trie_node_alloc",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
          "lines": "278-299",
          "snippet": "static struct lpm_trie_node *lpm_trie_node_alloc(const struct lpm_trie *trie,\n\t\t\t\t\t\t const void *value)\n{\n\tstruct lpm_trie_node *node;\n\tsize_t size = sizeof(struct lpm_trie_node) + trie->data_size;\n\n\tif (value)\n\t\tsize += trie->map.value_size;\n\n\tnode = bpf_map_kmalloc_node(&trie->map, size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t    trie->map.numa_node);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->flags = 0;\n\n\tif (value)\n\t\tmemcpy(node->data + trie->data_size, value,\n\t\t       trie->map.value_size);\n\n\treturn node;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct lpm_trie_node *lpm_trie_node_alloc(const struct lpm_trie *trie,\n\t\t\t\t\t\t const void *value)\n{\n\tstruct lpm_trie_node *node;\n\tsize_t size = sizeof(struct lpm_trie_node) + trie->data_size;\n\n\tif (value)\n\t\tsize += trie->map.value_size;\n\n\tnode = bpf_map_kmalloc_node(&trie->map, size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t    trie->map.numa_node);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->flags = 0;\n\n\tif (value)\n\t\tmemcpy(node->data + trie->data_size, value,\n\t\t       trie->map.value_size);\n\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*slot",
            "new_node"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "new_node->child[next_bit]",
            "node"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "node",
            "rcu"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_rcu_shrink_scan",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree.c",
          "lines": "3649-3670",
          "snippet": "static unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_nocb.h\"",
            "#include \"tree_exp.h\"",
            "#include \"tree_stall.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/panic_notifier.h>",
            "#include <linux/panic.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_sched_exp_online_cleanup(int cpu);",
            "static DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_nocb.h\"\n#include \"tree_exp.h\"\n#include \"tree_stall.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include \"../time/tick-internal.h\"\n#include <linux/kasan.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/isolation.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/smpboot.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/kprobes.h>\n#include <linux/sysrq.h>\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/panic_notifier.h>\n#include <linux/panic.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void sync_sched_exp_online_cleanup(int cpu);\nstatic DEFINE_PER_CPU(struct kfree_rcu_cpu, krc) = {\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(krc.lock),\n};\n\nstatic unsigned long\nkfree_rcu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tint cpu, freed = 0;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tint count;\n\t\tstruct kfree_rcu_cpu *krcp = per_cpu_ptr(&krc, cpu);\n\n\t\tcount = krcp->count;\n\t\tcount += drain_page_cache(krcp);\n\t\tkfree_rcu_monitor(&krcp->monitor_work.work);\n\n\t\tsc->nr_to_scan -= count;\n\t\tfreed += count;\n\n\t\tif (sc->nr_to_scan <= 0)\n\t\t\tbreak;\n\t}\n\n\treturn freed == 0 ? SHRINK_STOP : freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*slot",
            "new_node"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*slot",
            "new_node"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "longest_prefix_match",
          "args": [
            "trie",
            "node",
            "key"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "longest_prefix_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
          "lines": "164-224",
          "snippet": "static size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t/* data_size >= 16 has very small probability.\n\t * We do not use a loop for optimal code generation.\n\t */\n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t/* data_size >= 16 has very small probability.\n\t * We do not use a loop for optimal code generation.\n\t */\n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "*slot",
            "lockdep_is_held(&trie->lock)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&trie->lock"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_lockdep_is_held_nocb",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/tree_nocb.h",
          "lines": "1458-1461",
          "snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int rcu_lockdep_is_held_nocb(struct rcu_data *rdp)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "new_node->child[1]",
            "NULL"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "new_node->child[0]",
            "NULL"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&trie->lock",
            "irq_flags"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "flags > BPF_EXIST"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structlpm_trie",
            "map"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define LPM_TREE_NODE_FLAG_IM BIT(0)\n\nstatic int trie_update_elem(struct bpf_map *map,\n\t\t\t    void *_key, void *value, u64 flags)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node *node, *im_node = NULL, *new_node = NULL;\n\tstruct lpm_trie_node __rcu **slot;\n\tstruct bpf_lpm_trie_key *key = _key;\n\tunsigned long irq_flags;\n\tunsigned int next_bit;\n\tsize_t matchlen = 0;\n\tint ret = 0;\n\n\tif (unlikely(flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\n\tif (key->prefixlen > trie->max_prefixlen)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&trie->lock, irq_flags);\n\n\t/* Allocate and fill a new node */\n\n\tif (trie->n_entries == trie->map.max_entries) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tnew_node = lpm_trie_node_alloc(trie, value);\n\tif (!new_node) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttrie->n_entries++;\n\n\tnew_node->prefixlen = key->prefixlen;\n\tRCU_INIT_POINTER(new_node->child[0], NULL);\n\tRCU_INIT_POINTER(new_node->child[1], NULL);\n\tmemcpy(new_node->data, key->data, trie->data_size);\n\n\t/* Now find a slot to attach the new node. To do that, walk the tree\n\t * from the root and match as many bits as possible for each node until\n\t * we either find an empty slot or a slot that needs to be replaced by\n\t * an intermediate node.\n\t */\n\tslot = &trie->root;\n\n\twhile ((node = rcu_dereference_protected(*slot,\n\t\t\t\t\tlockdep_is_held(&trie->lock)))) {\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\n\t\tif (node->prefixlen != matchlen ||\n\t\t    node->prefixlen == key->prefixlen ||\n\t\t    node->prefixlen == trie->max_prefixlen)\n\t\t\tbreak;\n\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tslot = &node->child[next_bit];\n\t}\n\n\t/* If the slot is empty (a free child pointer or an empty root),\n\t * simply assign the @new_node to that slot and be done.\n\t */\n\tif (!node) {\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tgoto out;\n\t}\n\n\t/* If the slot we picked already exists, replace it with @new_node\n\t * which already has the correct data array set.\n\t */\n\tif (node->prefixlen == matchlen) {\n\t\tnew_node->child[0] = node->child[0];\n\t\tnew_node->child[1] = node->child[1];\n\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\ttrie->n_entries--;\n\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tkfree_rcu(node, rcu);\n\n\t\tgoto out;\n\t}\n\n\t/* If the new node matches the prefix completely, it must be inserted\n\t * as an ancestor. Simply insert it between @node and *@slot.\n\t */\n\tif (matchlen == key->prefixlen) {\n\t\tnext_bit = extract_bit(node->data, matchlen);\n\t\trcu_assign_pointer(new_node->child[next_bit], node);\n\t\trcu_assign_pointer(*slot, new_node);\n\t\tgoto out;\n\t}\n\n\tim_node = lpm_trie_node_alloc(trie, NULL);\n\tif (!im_node) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tim_node->prefixlen = matchlen;\n\tim_node->flags |= LPM_TREE_NODE_FLAG_IM;\n\tmemcpy(im_node->data, node->data, trie->data_size);\n\n\t/* Now determine which child to install in which slot */\n\tif (extract_bit(key->data, matchlen)) {\n\t\trcu_assign_pointer(im_node->child[0], node);\n\t\trcu_assign_pointer(im_node->child[1], new_node);\n\t} else {\n\t\trcu_assign_pointer(im_node->child[0], new_node);\n\t\trcu_assign_pointer(im_node->child[1], node);\n\t}\n\n\t/* Finally, assign the intermediate node to the determined slot */\n\trcu_assign_pointer(*slot, im_node);\n\nout:\n\tif (ret) {\n\t\tif (new_node)\n\t\t\ttrie->n_entries--;\n\n\t\tkfree(new_node);\n\t\tkfree(im_node);\n\t}\n\n\tspin_unlock_irqrestore(&trie->lock, irq_flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lpm_trie_node_alloc",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
    "lines": "278-299",
    "snippet": "static struct lpm_trie_node *lpm_trie_node_alloc(const struct lpm_trie *trie,\n\t\t\t\t\t\t const void *value)\n{\n\tstruct lpm_trie_node *node;\n\tsize_t size = sizeof(struct lpm_trie_node) + trie->data_size;\n\n\tif (value)\n\t\tsize += trie->map.value_size;\n\n\tnode = bpf_map_kmalloc_node(&trie->map, size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t    trie->map.numa_node);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->flags = 0;\n\n\tif (value)\n\t\tmemcpy(node->data + trie->data_size, value,\n\t\t       trie->map.value_size);\n\n\treturn node;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "node->data + trie->data_size",
            "value",
            "trie->map.value_size"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/events/internal.h",
          "lines": "180-184",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/refcount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/refcount.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_kmalloc_node",
          "args": [
            "&trie->map",
            "size",
            "GFP_ATOMIC | __GFP_NOWARN",
            "trie->map.numa_node"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_kmalloc_node",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/syscall.c",
          "lines": "427-438",
          "snippet": "void *bpf_map_kmalloc_node(const struct bpf_map *map, size_t size, gfp_t flags,\n\t\t\t   int node)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kmalloc_node(size, flags | __GFP_ACCOUNT, node);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/memcontrol.h>",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/bpf-netns.h>",
            "#include <linux/poll.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/pgtable.h>",
            "#include <uapi/linux/btf.h>",
            "#include <linux/audit.h>",
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/memcontrol.h>\n#include <linux/rcupdate_trace.h>\n#include <linux/bpf-netns.h>\n#include <linux/poll.h>\n#include <linux/bpf_lsm.h>\n#include <linux/pgtable.h>\n#include <uapi/linux/btf.h>\n#include <linux/audit.h>\n#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_kmalloc_node(const struct bpf_map *map, size_t size, gfp_t flags,\n\t\t\t   int node)\n{\n\tstruct mem_cgroup *old_memcg;\n\tvoid *ptr;\n\n\told_memcg = set_active_memcg(map->memcg);\n\tptr = kmalloc_node(size, flags | __GFP_ACCOUNT, node);\n\tset_active_memcg(old_memcg);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic struct lpm_trie_node *lpm_trie_node_alloc(const struct lpm_trie *trie,\n\t\t\t\t\t\t const void *value)\n{\n\tstruct lpm_trie_node *node;\n\tsize_t size = sizeof(struct lpm_trie_node) + trie->data_size;\n\n\tif (value)\n\t\tsize += trie->map.value_size;\n\n\tnode = bpf_map_kmalloc_node(&trie->map, size, GFP_ATOMIC | __GFP_NOWARN,\n\t\t\t\t    trie->map.numa_node);\n\tif (!node)\n\t\treturn NULL;\n\n\tnode->flags = 0;\n\n\tif (value)\n\t\tmemcpy(node->data + trie->data_size, value,\n\t\t       trie->map.value_size);\n\n\treturn node;\n}"
  },
  {
    "function_name": "trie_lookup_elem",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
    "lines": "227-276",
    "snippet": "static void *trie_lookup_elem(struct bpf_map *map, void *_key)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node *node, *found = NULL;\n\tstruct bpf_lpm_trie_key *key = _key;\n\n\t/* Start walking the trie from the root node ... */\n\n\tfor (node = rcu_dereference_check(trie->root, rcu_read_lock_bh_held());\n\t     node;) {\n\t\tunsigned int next_bit;\n\t\tsize_t matchlen;\n\n\t\t/* Determine the longest prefix of @node that matches @key.\n\t\t * If it's the maximum possible prefix for this trie, we have\n\t\t * an exact match and can return it directly.\n\t\t */\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\t\tif (matchlen == trie->max_prefixlen) {\n\t\t\tfound = node;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If the number of bits that match is smaller than the prefix\n\t\t * length of @node, bail out and return the node we have seen\n\t\t * last in the traversal (ie, the parent).\n\t\t */\n\t\tif (matchlen < node->prefixlen)\n\t\t\tbreak;\n\n\t\t/* Consider this node as return candidate unless it is an\n\t\t * artificially added intermediate one.\n\t\t */\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\tfound = node;\n\n\t\t/* If the node match is fully satisfied, let's see if we can\n\t\t * become more specific. Determine the next bit in the key and\n\t\t * traverse down.\n\t\t */\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tnode = rcu_dereference_check(node->child[next_bit],\n\t\t\t\t\t     rcu_read_lock_bh_held());\n\t}\n\n\tif (!found)\n\t\treturn NULL;\n\n\treturn found->data + trie->data_size;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define LPM_TREE_NODE_FLAG_IM BIT(0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "node->child[next_bit]",
            "rcu_read_lock_bh_held()"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_bh_held",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/rcu/update.c",
          "lines": "330-337",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"tasks.h\"",
            "#include \"rcu.h\"",
            "#include <linux/rcupdate_trace.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/slab.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tasks.h\"\n#include \"rcu.h\"\n#include <linux/rcupdate_trace.h>\n#include <linux/irq_work.h>\n#include <linux/slab.h>\n#include <linux/kprobes.h>\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tbool ret;\n\n\tif (rcu_read_lock_held_common(&ret))\n\t\treturn ret;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "extract_bit",
          "args": [
            "key->data",
            "node->prefixlen"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "extract_bit",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
          "lines": "151-154",
          "snippet": "static inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "longest_prefix_match",
          "args": [
            "trie",
            "node",
            "key"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "longest_prefix_match",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
          "lines": "164-224",
          "snippet": "static size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t/* data_size >= 16 has very small probability.\n\t * We do not use a loop for optimal code generation.\n\t */\n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}",
          "includes": [
            "#include <uapi/linux/btf.h>",
            "#include <net/ipv6.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t/* data_size >= 16 has very small probability.\n\t * We do not use a loop for optimal code generation.\n\t */\n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "trie->root",
            "rcu_read_lock_bh_held()"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structlpm_trie",
            "map"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\n#define LPM_TREE_NODE_FLAG_IM BIT(0)\n\nstatic void *trie_lookup_elem(struct bpf_map *map, void *_key)\n{\n\tstruct lpm_trie *trie = container_of(map, struct lpm_trie, map);\n\tstruct lpm_trie_node *node, *found = NULL;\n\tstruct bpf_lpm_trie_key *key = _key;\n\n\t/* Start walking the trie from the root node ... */\n\n\tfor (node = rcu_dereference_check(trie->root, rcu_read_lock_bh_held());\n\t     node;) {\n\t\tunsigned int next_bit;\n\t\tsize_t matchlen;\n\n\t\t/* Determine the longest prefix of @node that matches @key.\n\t\t * If it's the maximum possible prefix for this trie, we have\n\t\t * an exact match and can return it directly.\n\t\t */\n\t\tmatchlen = longest_prefix_match(trie, node, key);\n\t\tif (matchlen == trie->max_prefixlen) {\n\t\t\tfound = node;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* If the number of bits that match is smaller than the prefix\n\t\t * length of @node, bail out and return the node we have seen\n\t\t * last in the traversal (ie, the parent).\n\t\t */\n\t\tif (matchlen < node->prefixlen)\n\t\t\tbreak;\n\n\t\t/* Consider this node as return candidate unless it is an\n\t\t * artificially added intermediate one.\n\t\t */\n\t\tif (!(node->flags & LPM_TREE_NODE_FLAG_IM))\n\t\t\tfound = node;\n\n\t\t/* If the node match is fully satisfied, let's see if we can\n\t\t * become more specific. Determine the next bit in the key and\n\t\t * traverse down.\n\t\t */\n\t\tnext_bit = extract_bit(key->data, node->prefixlen);\n\t\tnode = rcu_dereference_check(node->child[next_bit],\n\t\t\t\t\t     rcu_read_lock_bh_held());\n\t}\n\n\tif (!found)\n\t\treturn NULL;\n\n\treturn found->data + trie->data_size;\n}"
  },
  {
    "function_name": "longest_prefix_match",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
    "lines": "164-224",
    "snippet": "static size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t/* data_size >= 16 has very small probability.\n\t * We do not use a loop for optimal code generation.\n\t */\n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "node->data[i] ^ key->data[i]"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "diff"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "diff"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fls64",
          "args": [
            "diff"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct lpm_trie_node, data) % sizeof(u32)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "node->prefixlen",
            "key->prefixlen"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__reg_combine_min_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "9059-9087",
          "snippet": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t/* We might have learned new bounds from the var_off. */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t/* We might have learned something about the sign bit. */\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic size_t longest_prefix_match(const struct lpm_trie *trie,\n\t\t\t\t   const struct lpm_trie_node *node,\n\t\t\t\t   const struct bpf_lpm_trie_key *key)\n{\n\tu32 limit = min(node->prefixlen, key->prefixlen);\n\tu32 prefixlen = 0, i = 0;\n\n\tBUILD_BUG_ON(offsetof(struct lpm_trie_node, data) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(struct bpf_lpm_trie_key, data) % sizeof(u32));\n\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) && defined(CONFIG_64BIT)\n\n\t/* data_size >= 16 has very small probability.\n\t * We do not use a loop for optimal code generation.\n\t */\n\tif (trie->data_size >= 8) {\n\t\tu64 diff = be64_to_cpu(*(__be64 *)node->data ^\n\t\t\t\t       *(__be64 *)key->data);\n\n\t\tprefixlen = 64 - fls64(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti = 8;\n\t}\n#endif\n\n\twhile (trie->data_size >= i + 4) {\n\t\tu32 diff = be32_to_cpu(*(__be32 *)&node->data[i] ^\n\t\t\t\t       *(__be32 *)&key->data[i]);\n\n\t\tprefixlen += 32 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 4;\n\t}\n\n\tif (trie->data_size >= i + 2) {\n\t\tu16 diff = be16_to_cpu(*(__be16 *)&node->data[i] ^\n\t\t\t\t       *(__be16 *)&key->data[i]);\n\n\t\tprefixlen += 16 - fls(diff);\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t\tif (diff)\n\t\t\treturn prefixlen;\n\t\ti += 2;\n\t}\n\n\tif (trie->data_size >= i + 1) {\n\t\tprefixlen += 8 - fls(node->data[i] ^ key->data[i]);\n\n\t\tif (prefixlen >= limit)\n\t\t\treturn limit;\n\t}\n\n\treturn prefixlen;\n}"
  },
  {
    "function_name": "extract_bit",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/lpm_trie.c",
    "lines": "151-154",
    "snippet": "static inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}",
    "includes": [
      "#include <uapi/linux/btf.h>",
      "#include <net/ipv6.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <uapi/linux/btf.h>\n#include <net/ipv6.h>\n#include <linux/vmalloc.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic inline int extract_bit(const u8 *data, size_t index)\n{\n\treturn !!(data[index / 8] & (1 << (7 - (index % 8))));\n}"
  }
]