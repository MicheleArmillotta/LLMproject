[
  {
    "function_name": "kcsan_selftest",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/selftest.c",
    "lines": "248-271",
    "snippet": "static int __init kcsan_selftest(void)\n{\n\tint passed = 0;\n\tint total = 0;\n\n#define RUN_TEST(do_test)                                                      \\\n\tdo {                                                                   \\\n\t\t++total;                                                       \\\n\t\tif (do_test())                                                 \\\n\t\t\t++passed;                                              \\\n\t\telse                                                           \\\n\t\t\tpr_err(\"selftest: \" #do_test \" failed\");               \\\n\t} while (0)\n\n\tRUN_TEST(test_requires);\n\tRUN_TEST(test_encode_decode);\n\tRUN_TEST(test_matching_access);\n\tRUN_TEST(test_barrier);\n\n\tpr_info(\"selftest: %d/%d tests passed\\n\", passed, total);\n\tif (passed != total)\n\t\tpanic(\"selftests failed\");\n\treturn 0;\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/init.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"selftests failed\""
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "hardlockup_panic_setup",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog.c",
          "lines": "74-85",
          "snippet": "static int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kvm_para.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/tick.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/nmi.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_para.h>\n#include <asm/irq_regs.h>\n#include <linux/stop_machine.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/tick.h>\n#include <linux/sysctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/nmi.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\tnmi_watchdog_user_enabled = 0;\n\telse if (!strncmp(str, \"1\", 1))\n\t\tnmi_watchdog_user_enabled = 1;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"selftest: %d/%d tests passed\\n\"",
            "passed",
            "total"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RUN_TEST",
          "args": [
            "test_barrier"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RUN_TEST",
          "args": [
            "test_matching_access"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RUN_TEST",
          "args": [
            "test_encode_decode"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RUN_TEST",
          "args": [
            "test_requires"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic int __init kcsan_selftest(void)\n{\n\tint passed = 0;\n\tint total = 0;\n\n#define RUN_TEST(do_test)                                                      \\\n\tdo {                                                                   \\\n\t\t++total;                                                       \\\n\t\tif (do_test())                                                 \\\n\t\t\t++passed;                                              \\\n\t\telse                                                           \\\n\t\t\tpr_err(\"selftest: \" #do_test \" failed\");               \\\n\t} while (0)\n\n\tRUN_TEST(test_requires);\n\tRUN_TEST(test_encode_decode);\n\tRUN_TEST(test_matching_access);\n\tRUN_TEST(test_barrier);\n\n\tpr_info(\"selftest: %d/%d tests passed\\n\", passed, total);\n\tif (passed != total)\n\t\tpanic(\"selftests failed\");\n\treturn 0;\n}"
  },
  {
    "function_name": "test_barrier",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/selftest.c",
    "lines": "117-246",
    "snippet": "static bool __init test_barrier(void)\n{\n#ifdef CONFIG_KCSAN_WEAK_MEMORY\n\tstruct kcsan_scoped_access *reorder_access = &current->kcsan_ctx.reorder_access;\n#else\n\tstruct kcsan_scoped_access *reorder_access = NULL;\n#endif\n\tbool ret = true;\n\tarch_spinlock_t arch_spinlock = __ARCH_SPIN_LOCK_UNLOCKED;\n\tatomic_t dummy;\n\tlong test_var;\n\n\tif (!reorder_access || !IS_ENABLED(CONFIG_SMP))\n\t\treturn true;\n\n#define __KCSAN_CHECK_BARRIER(access_type, barrier, name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treorder_access->type = (access_type) | KCSAN_ACCESS_SCOPED;\t\t\t\\\n\t\treorder_access->size = 1;\t\t\t\t\t\t\t\\\n\t\tbarrier;\t\t\t\t\t\t\t\t\t\\\n\t\tif (reorder_access->size != 0) {\t\t\t\t\t\t\\\n\t\t\tpr_err(\"improperly instrumented type=(\" #access_type \"): \" name \"\\n\");\t\\\n\t\t\tret = false;\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n#define KCSAN_CHECK_READ_BARRIER(b)  __KCSAN_CHECK_BARRIER(0, b, #b)\n#define KCSAN_CHECK_WRITE_BARRIER(b) __KCSAN_CHECK_BARRIER(KCSAN_ACCESS_WRITE, b, #b)\n#define KCSAN_CHECK_RW_BARRIER(b)    __KCSAN_CHECK_BARRIER(KCSAN_ACCESS_WRITE | KCSAN_ACCESS_COMPOUND, b, #b)\n\n\tkcsan_nestable_atomic_begin(); /* No watchpoints in called functions. */\n\n\tKCSAN_CHECK_READ_BARRIER(mb());\n\tKCSAN_CHECK_READ_BARRIER(rmb());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb());\n\tKCSAN_CHECK_READ_BARRIER(smp_rmb());\n\tKCSAN_CHECK_READ_BARRIER(dma_rmb());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb__before_atomic());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb__after_atomic());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb__after_spinlock());\n\tKCSAN_CHECK_READ_BARRIER(smp_store_mb(test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(smp_store_release(&test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(xchg(&test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(xchg_release(&test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(cmpxchg(&test_var, 0,  0));\n\tKCSAN_CHECK_READ_BARRIER(cmpxchg_release(&test_var, 0,  0));\n\tKCSAN_CHECK_READ_BARRIER(atomic_set_release(&dummy, 0));\n\tKCSAN_CHECK_READ_BARRIER(atomic_add_return(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(atomic_add_return_release(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(atomic_fetch_add(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(atomic_fetch_add_release(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(test_and_set_bit(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(test_and_clear_bit(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(test_and_change_bit(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(clear_bit_unlock(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(__clear_bit_unlock(0, &test_var));\n\tarch_spin_lock(&arch_spinlock);\n\tKCSAN_CHECK_READ_BARRIER(arch_spin_unlock(&arch_spinlock));\n\tspin_lock(&test_spinlock);\n\tKCSAN_CHECK_READ_BARRIER(spin_unlock(&test_spinlock));\n\n\tKCSAN_CHECK_WRITE_BARRIER(mb());\n\tKCSAN_CHECK_WRITE_BARRIER(wmb());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_wmb());\n\tKCSAN_CHECK_WRITE_BARRIER(dma_wmb());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__before_atomic());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__after_atomic());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__after_spinlock());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_store_mb(test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(smp_store_release(&test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(xchg(&test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(xchg_release(&test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(cmpxchg(&test_var, 0,  0));\n\tKCSAN_CHECK_WRITE_BARRIER(cmpxchg_release(&test_var, 0,  0));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_set_release(&dummy, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_add_return(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_add_return_release(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_fetch_add(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_fetch_add_release(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(test_and_set_bit(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(test_and_clear_bit(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(test_and_change_bit(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(clear_bit_unlock(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(__clear_bit_unlock(0, &test_var));\n\tarch_spin_lock(&arch_spinlock);\n\tKCSAN_CHECK_WRITE_BARRIER(arch_spin_unlock(&arch_spinlock));\n\tspin_lock(&test_spinlock);\n\tKCSAN_CHECK_WRITE_BARRIER(spin_unlock(&test_spinlock));\n\n\tKCSAN_CHECK_RW_BARRIER(mb());\n\tKCSAN_CHECK_RW_BARRIER(wmb());\n\tKCSAN_CHECK_RW_BARRIER(rmb());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb());\n\tKCSAN_CHECK_RW_BARRIER(smp_wmb());\n\tKCSAN_CHECK_RW_BARRIER(smp_rmb());\n\tKCSAN_CHECK_RW_BARRIER(dma_wmb());\n\tKCSAN_CHECK_RW_BARRIER(dma_rmb());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb__before_atomic());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb__after_atomic());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb__after_spinlock());\n\tKCSAN_CHECK_RW_BARRIER(smp_store_mb(test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(smp_store_release(&test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(xchg(&test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(xchg_release(&test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(cmpxchg(&test_var, 0,  0));\n\tKCSAN_CHECK_RW_BARRIER(cmpxchg_release(&test_var, 0,  0));\n\tKCSAN_CHECK_RW_BARRIER(atomic_set_release(&dummy, 0));\n\tKCSAN_CHECK_RW_BARRIER(atomic_add_return(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(atomic_add_return_release(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(atomic_fetch_add(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(atomic_fetch_add_release(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(test_and_set_bit(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(test_and_clear_bit(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(test_and_change_bit(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(clear_bit_unlock(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(__clear_bit_unlock(0, &test_var));\n\tarch_spin_lock(&arch_spinlock);\n\tKCSAN_CHECK_RW_BARRIER(arch_spin_unlock(&arch_spinlock));\n\tspin_lock(&test_spinlock);\n\tKCSAN_CHECK_RW_BARRIER(spin_unlock(&test_spinlock));\n\n#ifdef clear_bit_unlock_is_negative_byte\n\tKCSAN_CHECK_RW_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var));\n#endif\n\tkcsan_nestable_atomic_end();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/init.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(test_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kcsan_nestable_atomic_end",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_nestable_atomic_end",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "855-868",
          "snippet": "void kcsan_nestable_atomic_end(void)\n{\n\tif (get_ctx()->atomic_nest_count-- == 0) {\n\t\t/*\n\t\t * Warn if kcsan_nestable_atomic_end() calls are unbalanced with\n\t\t * kcsan_nestable_atomic_begin() calls, which causes\n\t\t * atomic_nest_count to become negative and should not happen.\n\t\t */\n\t\tkcsan_nestable_atomic_begin(); /* restore to 0 */\n\t\tkcsan_disable_current(); /* disable to generate warning */\n\t\tWARN(1, \"Unbalanced %s()\", __func__);\n\t\tkcsan_enable_current();\n\t}\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nvoid kcsan_nestable_atomic_end(void)\n{\n\tif (get_ctx()->atomic_nest_count-- == 0) {\n\t\t/*\n\t\t * Warn if kcsan_nestable_atomic_end() calls are unbalanced with\n\t\t * kcsan_nestable_atomic_begin() calls, which causes\n\t\t * atomic_nest_count to become negative and should not happen.\n\t\t */\n\t\tkcsan_nestable_atomic_begin(); /* restore to 0 */\n\t\tkcsan_disable_current(); /* disable to generate warning */\n\t\tWARN(1, \"Unbalanced %s()\", __func__);\n\t\tkcsan_enable_current();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "clear_bit_unlock_is_negative_byte(0, &test_var)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock_is_negative_byte",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "clear_bit_unlock_is_negative_byte(0, &test_var)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock_is_negative_byte",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "clear_bit_unlock_is_negative_byte(0, &test_var)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock_is_negative_byte",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "spin_unlock(&test_spinlock)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&test_spinlock"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/helpers.c",
          "lines": "315-322",
          "snippet": "static inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"../../lib/kstrtox.h\"",
            "#include <linux/security.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/ctype.h>",
            "#include <linux/filter.h>",
            "#include <linux/uidgid.h>",
            "#include <linux/sched.h>",
            "#include <linux/ktime.h>",
            "#include <linux/topology.h>",
            "#include <linux/smp.h>",
            "#include <linux/random.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, irqsave_flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../../lib/kstrtox.h\"\n#include <linux/security.h>\n#include <linux/proc_ns.h>\n#include <linux/pid_namespace.h>\n#include <linux/jiffies.h>\n#include <linux/ctype.h>\n#include <linux/filter.h>\n#include <linux/uidgid.h>\n#include <linux/sched.h>\n#include <linux/ktime.h>\n#include <linux/topology.h>\n#include <linux/smp.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_PER_CPU(unsigned long, irqsave_flags);\n\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&test_spinlock"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "reg_may_point_to_spin_lock",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "445-449",
          "snippet": "static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg);\n\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "arch_spin_unlock(&arch_spinlock)"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "__clear_bit_unlock(0, &test_var)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "clear_bit_unlock(0, &test_var)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "test_and_change_bit(0, &test_var)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_change_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "test_and_clear_bit(0, &test_var)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "test_and_set_bit(0, &test_var)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "atomic_fetch_add_release(1, &dummy)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "atomic_fetch_add(1, &dummy)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "atomic_add_return_release(1, &dummy)"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "atomic_add_return(1, &dummy)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "atomic_set_release(&dummy, 0)"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set_release",
          "args": [
            "&dummy",
            "0"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "cmpxchg_release(&test_var, 0,  0)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg_release",
          "args": [
            "&test_var",
            "0",
            "0"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_cmpxchg_release",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/rtmutex.c",
          "lines": "261-266",
          "snippet": "static __always_inline bool rt_mutex_cmpxchg_release(struct rt_mutex_base *lock,\n\t\t\t\t\t\t     struct task_struct *old,\n\t\t\t\t\t\t     struct task_struct *new)\n{\n\treturn false;\n}",
          "includes": [
            "# include \"ww_mutex.h\"",
            "#include \"rtmutex_common.h\"",
            "#include <linux/ww_mutex.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"ww_mutex.h\"\n#include \"rtmutex_common.h\"\n#include <linux/ww_mutex.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n\nstatic __always_inline struct;\n\nstatic __always_inline bool rt_mutex_cmpxchg_release(struct rt_mutex_base *lock,\n\t\t\t\t\t\t     struct task_struct *old,\n\t\t\t\t\t\t     struct task_struct *new)\n{\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "cmpxchg(&test_var, 0,  0)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&test_var",
            "0",
            "0"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "rb_time_cmpxchg",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/ring_buffer.c",
          "lines": "737-742",
          "snippet": "static bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}",
          "includes": [
            "#include <asm/local64.h>",
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/security.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_recursion.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local64.h>\n#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/security.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n#include <linux/trace_recursion.h>\n\nstatic bool rb_time_cmpxchg(rb_time_t *t, u64 expect, u64 set)\n{\n\tu64 val;\n\tval = local64_cmpxchg(&t->time, expect, set);\n\treturn val == expect;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "xchg_release(&test_var, 0)"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "xchg(&test_var, 0)"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xchg_tail",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/qspinlock.c",
          "lines": "220-238",
          "snippet": "static __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}",
          "includes": [
            "#include \"qspinlock.c\"",
            "#include \"qspinlock_paravirt.h\"",
            "#include \"mcs_spinlock.h\"",
            "#include \"qspinlock_stat.h\"",
            "#include <asm/qspinlock.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/bug.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [
            "#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qspinlock.c\"\n#include \"qspinlock_paravirt.h\"\n#include \"mcs_spinlock.h\"\n#include \"qspinlock_stat.h\"\n#include <asm/qspinlock.h>\n#include <asm/byteorder.h>\n#include <linux/prefetch.h>\n#include <linux/mutex.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/bug.h>\n#include <linux/smp.h>\n\n#define _Q_LOCKED_PENDING_MASK (_Q_LOCKED_MASK | _Q_PENDING_MASK)\n\nstatic __always_inline u32 xchg_tail(struct qspinlock *lock, u32 tail)\n{\n\tu32 old, new, val = atomic_read(&lock->val);\n\n\tfor (;;) {\n\t\tnew = (val & _Q_LOCKED_PENDING_MASK) | tail;\n\t\t/*\n\t\t * We can use relaxed semantics since the caller ensures that\n\t\t * the MCS node is properly initialized before updating the\n\t\t * tail.\n\t\t */\n\t\told = atomic_cmpxchg_relaxed(&lock->val, val, new);\n\t\tif (old == val)\n\t\t\tbreak;\n\n\t\tval = old;\n\t}\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "smp_store_release(&test_var, 0)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "smp_store_mb(test_var, 0)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "test_var",
            "0"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "smp_mb__after_spinlock()"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "smp_mb__after_atomic()"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "smp_mb__before_atomic()"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "dma_rmb()"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_rmb",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "dma_wmb()"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_wmb",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "smp_rmb()"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "smp_wmb()"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "smp_mb()"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "rmb()"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "wmb()"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_RW_BARRIER",
          "args": [
            "mb()"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "decrement_wakelocks_number",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/power/wakelock.c",
          "lines": "81-81",
          "snippet": "static inline void decrement_wakelocks_number(void) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic inline void decrement_wakelocks_number(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "spin_unlock(&test_spinlock)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "arch_spin_unlock(&arch_spinlock)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "__clear_bit_unlock(0, &test_var)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "clear_bit_unlock(0, &test_var)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "test_and_change_bit(0, &test_var)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_change_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "test_and_clear_bit(0, &test_var)"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "test_and_set_bit(0, &test_var)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "atomic_fetch_add_release(1, &dummy)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "atomic_fetch_add(1, &dummy)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "atomic_add_return_release(1, &dummy)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "atomic_add_return(1, &dummy)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "atomic_set_release(&dummy, 0)"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set_release",
          "args": [
            "&dummy",
            "0"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "cmpxchg_release(&test_var, 0,  0)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "cmpxchg(&test_var, 0,  0)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "xchg_release(&test_var, 0)"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "xchg(&test_var, 0)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "smp_store_release(&test_var, 0)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "smp_store_mb(test_var, 0)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "test_var",
            "0"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "smp_mb__after_spinlock()"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "smp_mb__after_atomic()"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "smp_mb__before_atomic()"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "dma_wmb()"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_wmb",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "smp_wmb()"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "smp_mb()"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "wmb()"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wmb",
          "args": [],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_WRITE_BARRIER",
          "args": [
            "mb()"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "spin_unlock(&test_spinlock)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "arch_spin_unlock(&arch_spinlock)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&arch_spinlock"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "__clear_bit_unlock(0, &test_var)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "clear_bit_unlock(0, &test_var)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit_unlock",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "test_and_change_bit(0, &test_var)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_change_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "test_and_clear_bit(0, &test_var)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "test_and_set_bit(0, &test_var)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "0",
            "&test_var"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "atomic_fetch_add_release(1, &dummy)"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "atomic_fetch_add(1, &dummy)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "atomic_add_return_release(1, &dummy)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return_release",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "atomic_add_return(1, &dummy)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "1",
            "&dummy"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "atomic_set_release(&dummy, 0)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set_release",
          "args": [
            "&dummy",
            "0"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "cmpxchg_release(&test_var, 0,  0)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "cmpxchg(&test_var, 0,  0)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "xchg_release(&test_var, 0)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "xchg(&test_var, 0)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "smp_store_release(&test_var, 0)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&test_var",
            "0"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "smp_store_mb(test_var, 0)"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "test_var",
            "0"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "smp_mb__after_spinlock()"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_spinlock",
          "args": [],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "smp_mb__after_atomic()"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "smp_mb__before_atomic()"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "dma_rmb()"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dma_rmb",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "smp_rmb()"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "smp_mb()"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "rmb()"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmb",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KCSAN_CHECK_READ_BARRIER",
          "args": [
            "mb()"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcsan_nestable_atomic_begin",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_nestable_atomic_begin",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "842-852",
          "snippet": "void kcsan_nestable_atomic_begin(void)\n{\n\t/*\n\t * Do *not* check and warn if we are in a flat atomic region: nestable\n\t * and flat atomic regions are independent from each other.\n\t * See include/linux/kcsan.h: struct kcsan_ctx comments for more\n\t * comments.\n\t */\n\n\t++get_ctx()->atomic_nest_count;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nstatic __always_inline struct;\nstatic __always_inline struct;\n\nvoid kcsan_nestable_atomic_begin(void)\n{\n\t/*\n\t * Do *not* check and warn if we are in a flat atomic region: nestable\n\t * and flat atomic regions are independent from each other.\n\t * See include/linux/kcsan.h: struct kcsan_ctx comments for more\n\t * comments.\n\t */\n\n\t++get_ctx()->atomic_nest_count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SMP"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_SPINLOCK(test_spinlock);\n\nstatic bool __init test_barrier(void)\n{\n#ifdef CONFIG_KCSAN_WEAK_MEMORY\n\tstruct kcsan_scoped_access *reorder_access = &current->kcsan_ctx.reorder_access;\n#else\n\tstruct kcsan_scoped_access *reorder_access = NULL;\n#endif\n\tbool ret = true;\n\tarch_spinlock_t arch_spinlock = __ARCH_SPIN_LOCK_UNLOCKED;\n\tatomic_t dummy;\n\tlong test_var;\n\n\tif (!reorder_access || !IS_ENABLED(CONFIG_SMP))\n\t\treturn true;\n\n#define __KCSAN_CHECK_BARRIER(access_type, barrier, name)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treorder_access->type = (access_type) | KCSAN_ACCESS_SCOPED;\t\t\t\\\n\t\treorder_access->size = 1;\t\t\t\t\t\t\t\\\n\t\tbarrier;\t\t\t\t\t\t\t\t\t\\\n\t\tif (reorder_access->size != 0) {\t\t\t\t\t\t\\\n\t\t\tpr_err(\"improperly instrumented type=(\" #access_type \"): \" name \"\\n\");\t\\\n\t\t\tret = false;\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\\\n\t} while (0)\n#define KCSAN_CHECK_READ_BARRIER(b)  __KCSAN_CHECK_BARRIER(0, b, #b)\n#define KCSAN_CHECK_WRITE_BARRIER(b) __KCSAN_CHECK_BARRIER(KCSAN_ACCESS_WRITE, b, #b)\n#define KCSAN_CHECK_RW_BARRIER(b)    __KCSAN_CHECK_BARRIER(KCSAN_ACCESS_WRITE | KCSAN_ACCESS_COMPOUND, b, #b)\n\n\tkcsan_nestable_atomic_begin(); /* No watchpoints in called functions. */\n\n\tKCSAN_CHECK_READ_BARRIER(mb());\n\tKCSAN_CHECK_READ_BARRIER(rmb());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb());\n\tKCSAN_CHECK_READ_BARRIER(smp_rmb());\n\tKCSAN_CHECK_READ_BARRIER(dma_rmb());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb__before_atomic());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb__after_atomic());\n\tKCSAN_CHECK_READ_BARRIER(smp_mb__after_spinlock());\n\tKCSAN_CHECK_READ_BARRIER(smp_store_mb(test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(smp_store_release(&test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(xchg(&test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(xchg_release(&test_var, 0));\n\tKCSAN_CHECK_READ_BARRIER(cmpxchg(&test_var, 0,  0));\n\tKCSAN_CHECK_READ_BARRIER(cmpxchg_release(&test_var, 0,  0));\n\tKCSAN_CHECK_READ_BARRIER(atomic_set_release(&dummy, 0));\n\tKCSAN_CHECK_READ_BARRIER(atomic_add_return(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(atomic_add_return_release(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(atomic_fetch_add(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(atomic_fetch_add_release(1, &dummy));\n\tKCSAN_CHECK_READ_BARRIER(test_and_set_bit(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(test_and_clear_bit(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(test_and_change_bit(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(clear_bit_unlock(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(__clear_bit_unlock(0, &test_var));\n\tarch_spin_lock(&arch_spinlock);\n\tKCSAN_CHECK_READ_BARRIER(arch_spin_unlock(&arch_spinlock));\n\tspin_lock(&test_spinlock);\n\tKCSAN_CHECK_READ_BARRIER(spin_unlock(&test_spinlock));\n\n\tKCSAN_CHECK_WRITE_BARRIER(mb());\n\tKCSAN_CHECK_WRITE_BARRIER(wmb());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_wmb());\n\tKCSAN_CHECK_WRITE_BARRIER(dma_wmb());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__before_atomic());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__after_atomic());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_mb__after_spinlock());\n\tKCSAN_CHECK_WRITE_BARRIER(smp_store_mb(test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(smp_store_release(&test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(xchg(&test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(xchg_release(&test_var, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(cmpxchg(&test_var, 0,  0));\n\tKCSAN_CHECK_WRITE_BARRIER(cmpxchg_release(&test_var, 0,  0));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_set_release(&dummy, 0));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_add_return(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_add_return_release(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_fetch_add(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(atomic_fetch_add_release(1, &dummy));\n\tKCSAN_CHECK_WRITE_BARRIER(test_and_set_bit(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(test_and_clear_bit(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(test_and_change_bit(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(clear_bit_unlock(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(__clear_bit_unlock(0, &test_var));\n\tarch_spin_lock(&arch_spinlock);\n\tKCSAN_CHECK_WRITE_BARRIER(arch_spin_unlock(&arch_spinlock));\n\tspin_lock(&test_spinlock);\n\tKCSAN_CHECK_WRITE_BARRIER(spin_unlock(&test_spinlock));\n\n\tKCSAN_CHECK_RW_BARRIER(mb());\n\tKCSAN_CHECK_RW_BARRIER(wmb());\n\tKCSAN_CHECK_RW_BARRIER(rmb());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb());\n\tKCSAN_CHECK_RW_BARRIER(smp_wmb());\n\tKCSAN_CHECK_RW_BARRIER(smp_rmb());\n\tKCSAN_CHECK_RW_BARRIER(dma_wmb());\n\tKCSAN_CHECK_RW_BARRIER(dma_rmb());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb__before_atomic());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb__after_atomic());\n\tKCSAN_CHECK_RW_BARRIER(smp_mb__after_spinlock());\n\tKCSAN_CHECK_RW_BARRIER(smp_store_mb(test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(smp_store_release(&test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(xchg(&test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(xchg_release(&test_var, 0));\n\tKCSAN_CHECK_RW_BARRIER(cmpxchg(&test_var, 0,  0));\n\tKCSAN_CHECK_RW_BARRIER(cmpxchg_release(&test_var, 0,  0));\n\tKCSAN_CHECK_RW_BARRIER(atomic_set_release(&dummy, 0));\n\tKCSAN_CHECK_RW_BARRIER(atomic_add_return(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(atomic_add_return_release(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(atomic_fetch_add(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(atomic_fetch_add_release(1, &dummy));\n\tKCSAN_CHECK_RW_BARRIER(test_and_set_bit(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(test_and_clear_bit(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(test_and_change_bit(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(clear_bit_unlock(0, &test_var));\n\tKCSAN_CHECK_RW_BARRIER(__clear_bit_unlock(0, &test_var));\n\tarch_spin_lock(&arch_spinlock);\n\tKCSAN_CHECK_RW_BARRIER(arch_spin_unlock(&arch_spinlock));\n\tspin_lock(&test_spinlock);\n\tKCSAN_CHECK_RW_BARRIER(spin_unlock(&test_spinlock));\n\n#ifdef clear_bit_unlock_is_negative_byte\n\tKCSAN_CHECK_RW_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var));\n\tKCSAN_CHECK_READ_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var));\n\tKCSAN_CHECK_WRITE_BARRIER(clear_bit_unlock_is_negative_byte(0, &test_var));\n#endif\n\tkcsan_nestable_atomic_end();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "test_matching_access",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/selftest.c",
    "lines": "86-109",
    "snippet": "static bool __init test_matching_access(void)\n{\n\tif (WARN_ON(!matching_access(10, 1, 10, 1)))\n\t\treturn false;\n\tif (WARN_ON(!matching_access(10, 2, 11, 1)))\n\t\treturn false;\n\tif (WARN_ON(!matching_access(10, 1, 9, 2)))\n\t\treturn false;\n\tif (WARN_ON(matching_access(10, 1, 11, 1)))\n\t\treturn false;\n\tif (WARN_ON(matching_access(9, 1, 10, 1)))\n\t\treturn false;\n\n\t/*\n\t * An access of size 0 could match another access, as demonstrated here.\n\t * Rather than add more comparisons to 'matching_access()', which would\n\t * end up in the fast-path for *all* checks, check_access() simply\n\t * returns for all accesses of size 0.\n\t */\n\tif (WARN_ON(!matching_access(8, 8, 12, 0)))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/init.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!matching_access(8, 8, 12, 0)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "matching_access",
          "args": [
            "8",
            "8",
            "12",
            "0"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "matching_access",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/encoding.h",
          "lines": "93-100",
          "snippet": "static __always_inline bool matching_access(unsigned long addr1, size_t size1,\n\t\t\t\t\t    unsigned long addr2, size_t size2)\n{\n\tunsigned long end_range1 = addr1 + size1 - 1;\n\tunsigned long end_range2 = addr2 + size2 - 1;\n\n\treturn addr1 <= end_range2 && addr2 <= end_range1;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/bits.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/bits.h>\n\nstatic __always_inline bool matching_access(unsigned long addr1, size_t size1,\n\t\t\t\t\t    unsigned long addr2, size_t size2)\n{\n\tunsigned long end_range1 = addr1 + size1 - 1;\n\tunsigned long end_range2 = addr2 + size2 - 1;\n\n\treturn addr1 <= end_range2 && addr2 <= end_range1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "matching_access(9, 1, 10, 1)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "matching_access(10, 1, 11, 1)"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!matching_access(10, 1, 9, 2)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!matching_access(10, 2, 11, 1)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!matching_access(10, 1, 10, 1)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic bool __init test_matching_access(void)\n{\n\tif (WARN_ON(!matching_access(10, 1, 10, 1)))\n\t\treturn false;\n\tif (WARN_ON(!matching_access(10, 2, 11, 1)))\n\t\treturn false;\n\tif (WARN_ON(!matching_access(10, 1, 9, 2)))\n\t\treturn false;\n\tif (WARN_ON(matching_access(10, 1, 11, 1)))\n\t\treturn false;\n\tif (WARN_ON(matching_access(9, 1, 10, 1)))\n\t\treturn false;\n\n\t/*\n\t * An access of size 0 could match another access, as demonstrated here.\n\t * Rather than add more comparisons to 'matching_access()', which would\n\t * end up in the fast-path for *all* checks, check_access() simply\n\t * returns for all accesses of size 0.\n\t */\n\tif (WARN_ON(!matching_access(8, 8, 12, 0)))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "test_encode_decode",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/selftest.c",
    "lines": "36-83",
    "snippet": "static bool __init test_encode_decode(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ITERS_PER_TEST; ++i) {\n\t\tsize_t size = prandom_u32_max(MAX_ENCODABLE_SIZE) + 1;\n\t\tbool is_write = !!prandom_u32_max(2);\n\t\tunsigned long verif_masked_addr;\n\t\tlong encoded_watchpoint;\n\t\tbool verif_is_write;\n\t\tunsigned long addr;\n\t\tsize_t verif_size;\n\n\t\tprandom_bytes(&addr, sizeof(addr));\n\t\tif (addr < PAGE_SIZE)\n\t\t\taddr = PAGE_SIZE;\n\n\t\tif (WARN_ON(!check_encodable(addr, size)))\n\t\t\treturn false;\n\n\t\tencoded_watchpoint = encode_watchpoint(addr, size, is_write);\n\n\t\t/* Check special watchpoints */\n\t\tif (WARN_ON(decode_watchpoint(INVALID_WATCHPOINT, &verif_masked_addr, &verif_size, &verif_is_write)))\n\t\t\treturn false;\n\t\tif (WARN_ON(decode_watchpoint(CONSUMED_WATCHPOINT, &verif_masked_addr, &verif_size, &verif_is_write)))\n\t\t\treturn false;\n\n\t\t/* Check decoding watchpoint returns same data */\n\t\tif (WARN_ON(!decode_watchpoint(encoded_watchpoint, &verif_masked_addr, &verif_size, &verif_is_write)))\n\t\t\treturn false;\n\t\tif (WARN_ON(verif_masked_addr != (addr & WATCHPOINT_ADDR_MASK)))\n\t\t\tgoto fail;\n\t\tif (WARN_ON(verif_size != size))\n\t\t\tgoto fail;\n\t\tif (WARN_ON(is_write != verif_is_write))\n\t\t\tgoto fail;\n\n\t\tcontinue;\nfail:\n\t\tpr_err(\"%s fail: %s %zu bytes @ %lx -> encoded: %lx -> %s %zu bytes @ %lx\\n\",\n\t\t       __func__, is_write ? \"write\" : \"read\", size, addr, encoded_watchpoint,\n\t\t       verif_is_write ? \"write\" : \"read\", verif_size, verif_masked_addr);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/init.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [
      "#define ITERS_PER_TEST 2000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s fail: %s %zu bytes @ %lx -> encoded: %lx -> %s %zu bytes @ %lx\\n\"",
            "__func__",
            "is_write ? \"write\" : \"read\"",
            "size",
            "addr",
            "encoded_watchpoint",
            "verif_is_write ? \"write\" : \"read\"",
            "verif_size",
            "verif_masked_addr"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "is_write != verif_is_write"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "verif_size != size"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "verif_masked_addr != (addr & WATCHPOINT_ADDR_MASK)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!decode_watchpoint(encoded_watchpoint, &verif_masked_addr, &verif_size, &verif_is_write)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_watchpoint",
          "args": [
            "encoded_watchpoint",
            "&verif_masked_addr",
            "&verif_size",
            "&verif_is_write"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "decode_watchpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/encoding.h",
          "lines": "69-83",
          "snippet": "static __always_inline bool decode_watchpoint(long watchpoint,\n\t\t\t\t\t      unsigned long *addr_masked,\n\t\t\t\t\t      size_t *size,\n\t\t\t\t\t      bool *is_write)\n{\n\tif (watchpoint == INVALID_WATCHPOINT ||\n\t    watchpoint == CONSUMED_WATCHPOINT)\n\t\treturn false;\n\n\t*addr_masked =    (unsigned long)watchpoint & WATCHPOINT_ADDR_MASK;\n\t*size\t     =   ((unsigned long)watchpoint & WATCHPOINT_SIZE_MASK) >> WATCHPOINT_ADDR_BITS;\n\t*is_write    = !!((unsigned long)watchpoint & WATCHPOINT_WRITE_MASK);\n\n\treturn true;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/bits.h>"
          ],
          "macros_used": [
            "#define WATCHPOINT_ADDR_MASK\tGENMASK(WATCHPOINT_ADDR_BITS-1, 0)",
            "#define WATCHPOINT_SIZE_MASK\tGENMASK(BITS_PER_LONG-2, WATCHPOINT_ADDR_BITS)",
            "#define WATCHPOINT_WRITE_MASK\tBIT(BITS_PER_LONG-1)",
            "#define WATCHPOINT_ADDR_BITS (BITS_PER_LONG-1 - WATCHPOINT_SIZE_BITS)",
            "#define CONSUMED_WATCHPOINT 1",
            "#define INVALID_WATCHPOINT  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/bits.h>\n\n#define WATCHPOINT_ADDR_MASK\tGENMASK(WATCHPOINT_ADDR_BITS-1, 0)\n#define WATCHPOINT_SIZE_MASK\tGENMASK(BITS_PER_LONG-2, WATCHPOINT_ADDR_BITS)\n#define WATCHPOINT_WRITE_MASK\tBIT(BITS_PER_LONG-1)\n#define WATCHPOINT_ADDR_BITS (BITS_PER_LONG-1 - WATCHPOINT_SIZE_BITS)\n#define CONSUMED_WATCHPOINT 1\n#define INVALID_WATCHPOINT  0\n\nstatic __always_inline bool decode_watchpoint(long watchpoint,\n\t\t\t\t\t      unsigned long *addr_masked,\n\t\t\t\t\t      size_t *size,\n\t\t\t\t\t      bool *is_write)\n{\n\tif (watchpoint == INVALID_WATCHPOINT ||\n\t    watchpoint == CONSUMED_WATCHPOINT)\n\t\treturn false;\n\n\t*addr_masked =    (unsigned long)watchpoint & WATCHPOINT_ADDR_MASK;\n\t*size\t     =   ((unsigned long)watchpoint & WATCHPOINT_SIZE_MASK) >> WATCHPOINT_ADDR_BITS;\n\t*is_write    = !!((unsigned long)watchpoint & WATCHPOINT_WRITE_MASK);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "decode_watchpoint(CONSUMED_WATCHPOINT, &verif_masked_addr, &verif_size, &verif_is_write)"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "decode_watchpoint(INVALID_WATCHPOINT, &verif_masked_addr, &verif_size, &verif_is_write)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encode_watchpoint",
          "args": [
            "addr",
            "size",
            "is_write"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "encode_watchpoint",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/encoding.h",
          "lines": "61-67",
          "snippet": "static inline long\nencode_watchpoint(unsigned long addr, size_t size, bool is_write)\n{\n\treturn (long)((is_write ? WATCHPOINT_WRITE_MASK : 0) |\n\t\t      (size << WATCHPOINT_ADDR_BITS) |\n\t\t      (addr & WATCHPOINT_ADDR_MASK));\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/bits.h>"
          ],
          "macros_used": [
            "#define WATCHPOINT_ADDR_MASK\tGENMASK(WATCHPOINT_ADDR_BITS-1, 0)",
            "#define WATCHPOINT_WRITE_MASK\tBIT(BITS_PER_LONG-1)",
            "#define WATCHPOINT_ADDR_BITS (BITS_PER_LONG-1 - WATCHPOINT_SIZE_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/bits.h>\n\n#define WATCHPOINT_ADDR_MASK\tGENMASK(WATCHPOINT_ADDR_BITS-1, 0)\n#define WATCHPOINT_WRITE_MASK\tBIT(BITS_PER_LONG-1)\n#define WATCHPOINT_ADDR_BITS (BITS_PER_LONG-1 - WATCHPOINT_SIZE_BITS)\n\nstatic inline long\nencode_watchpoint(unsigned long addr, size_t size, bool is_write)\n{\n\treturn (long)((is_write ? WATCHPOINT_WRITE_MASK : 0) |\n\t\t      (size << WATCHPOINT_ADDR_BITS) |\n\t\t      (addr & WATCHPOINT_ADDR_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!check_encodable(addr, size)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_encodable",
          "args": [
            "addr",
            "size"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "check_encodable",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/encoding.h",
          "lines": "52-59",
          "snippet": "static inline bool check_encodable(unsigned long addr, size_t size)\n{\n\t/*\n\t * While we can encode addrs<PAGE_SIZE, avoid crashing with a NULL\n\t * pointer deref inside KCSAN.\n\t */\n\treturn addr >= PAGE_SIZE && size <= MAX_ENCODABLE_SIZE;\n}",
          "includes": [
            "#include \"kcsan.h\"",
            "#include <linux/mm.h>",
            "#include <linux/log2.h>",
            "#include <linux/bits.h>"
          ],
          "macros_used": [
            "#define MAX_ENCODABLE_SIZE (SLOT_RANGE * (1 + KCSAN_CHECK_ADJACENT))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kcsan.h\"\n#include <linux/mm.h>\n#include <linux/log2.h>\n#include <linux/bits.h>\n\n#define MAX_ENCODABLE_SIZE (SLOT_RANGE * (1 + KCSAN_CHECK_ADJACENT))\n\nstatic inline bool check_encodable(unsigned long addr, size_t size)\n{\n\t/*\n\t * While we can encode addrs<PAGE_SIZE, avoid crashing with a NULL\n\t * pointer deref inside KCSAN.\n\t */\n\treturn addr >= PAGE_SIZE && size <= MAX_ENCODABLE_SIZE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prandom_bytes",
          "args": [
            "&addr",
            "sizeof(addr)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prandom_u32_max",
          "args": [
            "2"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "kcsan_prandom_u32_max",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/core.c",
          "lines": "294-302",
          "snippet": "static u32 kcsan_prandom_u32_max(u32 ep_ro)\n{\n\tu32 state = this_cpu_read(kcsan_rand_state);\n\n\tstate = 1664525 * state + 1013904223;\n\tthis_cpu_write(kcsan_rand_state, state);\n\n\treturn state % ep_ro;\n}",
          "includes": [
            "#include \"permissive.h\"",
            "#include \"kcsan.h\"",
            "#include \"encoding.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/bug.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(u32, kcsan_rand_state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"permissive.h\"\n#include \"kcsan.h\"\n#include \"encoding.h\"\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/bug.h>\n#include <linux/atomic.h>\n\nstatic DEFINE_PER_CPU(u32, kcsan_rand_state);\n\nstatic u32 kcsan_prandom_u32_max(u32 ep_ro)\n{\n\tu32 state = this_cpu_read(kcsan_rand_state);\n\n\tstate = 1664525 * state + 1013904223;\n\tthis_cpu_write(kcsan_rand_state, state);\n\n\treturn state % ep_ro;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\n#define ITERS_PER_TEST 2000\n\nstatic bool __init test_encode_decode(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ITERS_PER_TEST; ++i) {\n\t\tsize_t size = prandom_u32_max(MAX_ENCODABLE_SIZE) + 1;\n\t\tbool is_write = !!prandom_u32_max(2);\n\t\tunsigned long verif_masked_addr;\n\t\tlong encoded_watchpoint;\n\t\tbool verif_is_write;\n\t\tunsigned long addr;\n\t\tsize_t verif_size;\n\n\t\tprandom_bytes(&addr, sizeof(addr));\n\t\tif (addr < PAGE_SIZE)\n\t\t\taddr = PAGE_SIZE;\n\n\t\tif (WARN_ON(!check_encodable(addr, size)))\n\t\t\treturn false;\n\n\t\tencoded_watchpoint = encode_watchpoint(addr, size, is_write);\n\n\t\t/* Check special watchpoints */\n\t\tif (WARN_ON(decode_watchpoint(INVALID_WATCHPOINT, &verif_masked_addr, &verif_size, &verif_is_write)))\n\t\t\treturn false;\n\t\tif (WARN_ON(decode_watchpoint(CONSUMED_WATCHPOINT, &verif_masked_addr, &verif_size, &verif_is_write)))\n\t\t\treturn false;\n\n\t\t/* Check decoding watchpoint returns same data */\n\t\tif (WARN_ON(!decode_watchpoint(encoded_watchpoint, &verif_masked_addr, &verif_size, &verif_is_write)))\n\t\t\treturn false;\n\t\tif (WARN_ON(verif_masked_addr != (addr & WATCHPOINT_ADDR_MASK)))\n\t\t\tgoto fail;\n\t\tif (WARN_ON(verif_size != size))\n\t\t\tgoto fail;\n\t\tif (WARN_ON(is_write != verif_is_write))\n\t\t\tgoto fail;\n\n\t\tcontinue;\nfail:\n\t\tpr_err(\"%s fail: %s %zu bytes @ %lx -> encoded: %lx -> %s %zu bytes @ %lx\\n\",\n\t\t       __func__, is_write ? \"write\" : \"read\", size, addr, encoded_watchpoint,\n\t\t       verif_is_write ? \"write\" : \"read\", verif_size, verif_masked_addr);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "test_requires",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/kcsan/selftest.c",
    "lines": "26-30",
    "snippet": "static bool __init test_requires(void)\n{\n\t/* random should be initialized for the below tests */\n\treturn prandom_u32() + prandom_u32() != 0;\n}",
    "includes": [
      "#include \"encoding.h\"",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/sched.h>",
      "#include <linux/random.h>",
      "#include <linux/printk.h>",
      "#include <linux/kernel.h>",
      "#include <linux/kcsan-checks.h>",
      "#include <linux/init.h>",
      "#include <linux/bitops.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prandom_u32",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"encoding.h\"\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/kcsan-checks.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n\nstatic bool __init test_requires(void)\n{\n\t/* random should be initialized for the below tests */\n\treturn prandom_u32() + prandom_u32() != 0;\n}"
  }
]