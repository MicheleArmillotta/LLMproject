[
  {
    "function_name": "main",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/iterators/iterators.c",
    "lines": "38-94",
    "snippet": "int main(int argc, char **argv)\n{\n\tstruct rlimit rlim = { RLIM_INFINITY, RLIM_INFINITY };\n\tstruct iterators_bpf *skel;\n\tint err, magic;\n\tint debug_fd;\n\n\tdebug_fd = open(\"/dev/console\", O_WRONLY | O_NOCTTY | O_CLOEXEC);\n\tif (debug_fd < 0)\n\t\treturn 1;\n\tto_kernel = dup(1);\n\tclose(1);\n\tdup(debug_fd);\n\t/* now stdin and stderr point to /dev/console */\n\n\tread(from_kernel, &magic, sizeof(magic));\n\tif (magic != BPF_PRELOAD_START) {\n\t\tprintf(\"bad start magic %d\\n\", magic);\n\t\treturn 1;\n\t}\n\tsetrlimit(RLIMIT_MEMLOCK, &rlim);\n\t/* libbpf opens BPF object and loads it into the kernel */\n\tskel = iterators_bpf__open_and_load();\n\tif (!skel) {\n\t\t/* iterators.skel.h is little endian.\n\t\t * libbpf doesn't support automatic little->big conversion\n\t\t * of BPF bytecode yet.\n\t\t * The program load will fail in such case.\n\t\t */\n\t\tprintf(\"Failed load could be due to wrong endianness\\n\");\n\t\treturn 1;\n\t}\n\terr = iterators_bpf__attach(skel);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* send two bpf_link IDs with names to the kernel */\n\terr = send_link_to_kernel(skel->links.dump_bpf_map, \"maps.debug\");\n\tif (err)\n\t\tgoto cleanup;\n\terr = send_link_to_kernel(skel->links.dump_bpf_prog, \"progs.debug\");\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* The kernel will proceed with pinnging the links in bpffs.\n\t * UMD will wait on read from pipe.\n\t */\n\tread(from_kernel, &magic, sizeof(magic));\n\tif (magic != BPF_PRELOAD_END) {\n\t\tprintf(\"bad final magic %d\\n\", magic);\n\t\terr = -EINVAL;\n\t}\ncleanup:\n\titerators_bpf__destroy(skel);\n\n\treturn err != 0;\n}",
    "includes": [
      "#include \"bpf_preload_common.h\"",
      "#include \"iterators.skel.h\"",
      "#include <sys/mount.h>",
      "#include <bpf/bpf.h>",
      "#include <bpf/libbpf.h>",
      "#include <sys/resource.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int to_kernel = -1;",
      "int from_kernel = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterators_bpf__destroy",
          "args": [
            "skel"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "iterators_bpf__destroy",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/iterators/iterators.skel.h",
          "lines": "32-40",
          "snippet": "static void\niterators_bpf__destroy(struct iterators_bpf *obj)\n{\n\tif (!obj)\n\t\treturn;\n\tif (obj->skeleton)\n\t\tbpf_object__destroy_skeleton(obj->skeleton);\n\tfree(obj);\n}",
          "includes": [
            "#include <bpf/libbpf.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <bpf/libbpf.h>\n#include <stdlib.h>\n\nstatic void\niterators_bpf__destroy(struct iterators_bpf *obj)\n{\n\tif (!obj)\n\t\treturn;\n\tif (obj->skeleton)\n\t\tbpf_object__destroy_skeleton(obj->skeleton);\n\tfree(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"bad final magic %d\\n\"",
            "magic"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "check_bpf_snprintf_call",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "6467-6502",
          "snippet": "static int check_bpf_snprintf_call(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_reg_state *regs)\n{\n\tstruct bpf_reg_state *fmt_reg = &regs[BPF_REG_3];\n\tstruct bpf_reg_state *data_len_reg = &regs[BPF_REG_5];\n\tstruct bpf_map *fmt_map = fmt_reg->map_ptr;\n\tint err, fmt_map_off, num_args;\n\tu64 fmt_addr;\n\tchar *fmt;\n\n\t/* data must be an array of u64 */\n\tif (data_len_reg->var_off.value % 8)\n\t\treturn -EINVAL;\n\tnum_args = data_len_reg->var_off.value / 8;\n\n\t/* fmt being ARG_PTR_TO_CONST_STR guarantees that var_off is const\n\t * and map_direct_value_addr is set.\n\t */\n\tfmt_map_off = fmt_reg->off + fmt_reg->var_off.value;\n\terr = fmt_map->ops->map_direct_value_addr(fmt_map, &fmt_addr,\n\t\t\t\t\t\t  fmt_map_off);\n\tif (err) {\n\t\tverbose(env, \"verifier bug\\n\");\n\t\treturn -EFAULT;\n\t}\n\tfmt = (char *)(long)fmt_addr + fmt_map_off;\n\n\t/* We are also guaranteed that fmt+fmt_map_off is NULL terminated, we\n\t * can focus on validating the format specifiers.\n\t */\n\terr = bpf_bprintf_prepare(fmt, UINT_MAX, NULL, NULL, num_args);\n\tif (err < 0)\n\t\tverbose(env, \"Invalid format string\\n\");\n\n\treturn err;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nstatic int check_bpf_snprintf_call(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_reg_state *regs)\n{\n\tstruct bpf_reg_state *fmt_reg = &regs[BPF_REG_3];\n\tstruct bpf_reg_state *data_len_reg = &regs[BPF_REG_5];\n\tstruct bpf_map *fmt_map = fmt_reg->map_ptr;\n\tint err, fmt_map_off, num_args;\n\tu64 fmt_addr;\n\tchar *fmt;\n\n\t/* data must be an array of u64 */\n\tif (data_len_reg->var_off.value % 8)\n\t\treturn -EINVAL;\n\tnum_args = data_len_reg->var_off.value / 8;\n\n\t/* fmt being ARG_PTR_TO_CONST_STR guarantees that var_off is const\n\t * and map_direct_value_addr is set.\n\t */\n\tfmt_map_off = fmt_reg->off + fmt_reg->var_off.value;\n\terr = fmt_map->ops->map_direct_value_addr(fmt_map, &fmt_addr,\n\t\t\t\t\t\t  fmt_map_off);\n\tif (err) {\n\t\tverbose(env, \"verifier bug\\n\");\n\t\treturn -EFAULT;\n\t}\n\tfmt = (char *)(long)fmt_addr + fmt_map_off;\n\n\t/* We are also guaranteed that fmt+fmt_map_off is NULL terminated, we\n\t * can focus on validating the format specifiers.\n\t */\n\terr = bpf_bprintf_prepare(fmt, UINT_MAX, NULL, NULL, num_args);\n\tif (err < 0)\n\t\tverbose(env, \"Invalid format string\\n\");\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "from_kernel",
            "&magic",
            "sizeof(magic)"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "882-893",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_link_to_kernel",
          "args": [
            "skel->links.dump_bpf_prog",
            "\"progs.debug\""
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "send_link_to_kernel",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/iterators/iterators.c",
          "lines": "19-36",
          "snippet": "static int send_link_to_kernel(struct bpf_link *link, const char *link_name)\n{\n\tstruct bpf_preload_info obj = {};\n\tstruct bpf_link_info info = {};\n\t__u32 info_len = sizeof(info);\n\tint err;\n\n\terr = bpf_obj_get_info_by_fd(bpf_link__fd(link), &info, &info_len);\n\tif (err)\n\t\treturn err;\n\tobj.link_id = info.id;\n\tif (strlen(link_name) >= sizeof(obj.link_name))\n\t\treturn -E2BIG;\n\tstrcpy(obj.link_name, link_name);\n\tif (write(to_kernel, &obj, sizeof(obj)) != sizeof(obj))\n\t\treturn -EPIPE;\n\treturn 0;\n}",
          "includes": [
            "#include \"bpf_preload_common.h\"",
            "#include \"iterators.skel.h\"",
            "#include <sys/mount.h>",
            "#include <bpf/bpf.h>",
            "#include <bpf/libbpf.h>",
            "#include <sys/resource.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int to_kernel = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bpf_preload_common.h\"\n#include \"iterators.skel.h\"\n#include <sys/mount.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include <sys/resource.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint to_kernel = -1;\n\nstatic int send_link_to_kernel(struct bpf_link *link, const char *link_name)\n{\n\tstruct bpf_preload_info obj = {};\n\tstruct bpf_link_info info = {};\n\t__u32 info_len = sizeof(info);\n\tint err;\n\n\terr = bpf_obj_get_info_by_fd(bpf_link__fd(link), &info, &info_len);\n\tif (err)\n\t\treturn err;\n\tobj.link_id = info.id;\n\tif (strlen(link_name) >= sizeof(obj.link_name))\n\t\treturn -E2BIG;\n\tstrcpy(obj.link_name, link_name);\n\tif (write(to_kernel, &obj, sizeof(obj)) != sizeof(obj))\n\t\treturn -EPIPE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterators_bpf__attach",
          "args": [
            "skel"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "iterators_bpf__attach",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/iterators/iterators.skel.h",
          "lines": "91-95",
          "snippet": "static inline int\niterators_bpf__attach(struct iterators_bpf *obj)\n{\n\treturn bpf_object__attach_skeleton(obj->skeleton);\n}",
          "includes": [
            "#include <bpf/libbpf.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <bpf/libbpf.h>\n#include <stdlib.h>\n\nstatic inline int\niterators_bpf__attach(struct iterators_bpf *obj)\n{\n\treturn bpf_object__attach_skeleton(obj->skeleton);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Failed load could be due to wrong endianness\\n\""
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "859-869",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterators_bpf__open_and_load",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "iterators_bpf__open_and_load",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/iterators/iterators.skel.h",
          "lines": "76-89",
          "snippet": "static inline struct iterators_bpf *\niterators_bpf__open_and_load(void)\n{\n\tstruct iterators_bpf *obj;\n\n\tobj = iterators_bpf__open();\n\tif (!obj)\n\t\treturn NULL;\n\tif (iterators_bpf__load(obj)) {\n\t\titerators_bpf__destroy(obj);\n\t\treturn NULL;\n\t}\n\treturn obj;\n}",
          "includes": [
            "#include <bpf/libbpf.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <bpf/libbpf.h>\n#include <stdlib.h>\n\nstatic inline struct iterators_bpf *\niterators_bpf__open_and_load(void)\n{\n\tstruct iterators_bpf *obj;\n\n\tobj = iterators_bpf__open();\n\tif (!obj)\n\t\treturn NULL;\n\tif (iterators_bpf__load(obj)) {\n\t\titerators_bpf__destroy(obj);\n\t\treturn NULL;\n\t}\n\treturn obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "RLIMIT_MEMLOCK",
            "&rlim"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "debug_fd"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "has_duplicate_listener",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/seccomp.c",
          "lines": "1767-1782",
          "snippet": "static bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t/* must be protected against concurrent TSYNC */\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/lockdep.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/capability.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid.h>",
            "#include <linux/filter.h>",
            "#include <linux/file.h>",
            "#include <asm/syscall.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/prctl.h>",
            "#include <linux/nospec.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/coredump.h>",
            "#include <linux/compat.h>",
            "#include <linux/audit.h>",
            "#include <linux/refcount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n#include <linux/anon_inodes.h>\n#include <linux/uaccess.h>\n#include <linux/capability.h>\n#include <linux/ptrace.h>\n#include <linux/pid.h>\n#include <linux/filter.h>\n#include <linux/file.h>\n#include <asm/syscall.h>\n#include <linux/sysctl.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/seccomp.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/prctl.h>\n#include <linux/nospec.h>\n#include <linux/kmemleak.h>\n#include <linux/coredump.h>\n#include <linux/compat.h>\n#include <linux/audit.h>\n#include <linux/refcount.h>\n\nstatic bool has_duplicate_listener(struct seccomp_filter *new_child)\n{\n\tstruct seccomp_filter *cur;\n\n\t/* must be protected against concurrent TSYNC */\n\tlockdep_assert_held(&current->sighand->siglock);\n\n\tif (!new_child->notif)\n\t\treturn false;\n\tfor (cur = current->seccomp.filter; cur; cur = cur->prev) {\n\t\tif (cur->notif)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "1"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "close_work",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/acct.c",
          "lines": "182-190",
          "snippet": "static void close_work(struct work_struct *work)\n{\n\tstruct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);\n\tstruct file *file = acct->file;\n\tif (file->f_op->flush)\n\t\tfile->f_op->flush(file, NULL);\n\t__fput_sync(file);\n\tcomplete(&acct->done);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_acct_process(struct bsd_acct_struct *acct);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void do_acct_process(struct bsd_acct_struct *acct);\n\nstatic void close_work(struct work_struct *work)\n{\n\tstruct bsd_acct_struct *acct = container_of(work, struct bsd_acct_struct, work);\n\tstruct file *file = acct->file;\n\tif (file->f_op->flush)\n\t\tfile->f_op->flush(file, NULL);\n\t__fput_sync(file);\n\tcomplete(&acct->done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/console\"",
            "O_WRONLY | O_NOCTTY | O_CLOEXEC"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "fei_open",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/fail_function.c",
          "lines": "217-220",
          "snippet": "static int fei_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &fei_seq_ops);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/error-injection.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct seq_operations fei_seq_ops = {\n\t.start\t= fei_seq_start,\n\t.next\t= fei_seq_next,\n\t.stop\t= fei_seq_stop,\n\t.show\t= fei_seq_show,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kprobes.h>\n#include <linux/kallsyms.h>\n#include <linux/fault-inject.h>\n#include <linux/debugfs.h>\n#include <linux/error-injection.h>\n\nstatic const struct seq_operations fei_seq_ops = {\n\t.start\t= fei_seq_start,\n\t.next\t= fei_seq_next,\n\t.stop\t= fei_seq_stop,\n\t.show\t= fei_seq_show,\n};\n\nstatic int fei_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &fei_seq_ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bpf_preload_common.h\"\n#include \"iterators.skel.h\"\n#include <sys/mount.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include <sys/resource.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint to_kernel = -1;\nint from_kernel = 0;\n\nint main(int argc, char **argv)\n{\n\tstruct rlimit rlim = { RLIM_INFINITY, RLIM_INFINITY };\n\tstruct iterators_bpf *skel;\n\tint err, magic;\n\tint debug_fd;\n\n\tdebug_fd = open(\"/dev/console\", O_WRONLY | O_NOCTTY | O_CLOEXEC);\n\tif (debug_fd < 0)\n\t\treturn 1;\n\tto_kernel = dup(1);\n\tclose(1);\n\tdup(debug_fd);\n\t/* now stdin and stderr point to /dev/console */\n\n\tread(from_kernel, &magic, sizeof(magic));\n\tif (magic != BPF_PRELOAD_START) {\n\t\tprintf(\"bad start magic %d\\n\", magic);\n\t\treturn 1;\n\t}\n\tsetrlimit(RLIMIT_MEMLOCK, &rlim);\n\t/* libbpf opens BPF object and loads it into the kernel */\n\tskel = iterators_bpf__open_and_load();\n\tif (!skel) {\n\t\t/* iterators.skel.h is little endian.\n\t\t * libbpf doesn't support automatic little->big conversion\n\t\t * of BPF bytecode yet.\n\t\t * The program load will fail in such case.\n\t\t */\n\t\tprintf(\"Failed load could be due to wrong endianness\\n\");\n\t\treturn 1;\n\t}\n\terr = iterators_bpf__attach(skel);\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* send two bpf_link IDs with names to the kernel */\n\terr = send_link_to_kernel(skel->links.dump_bpf_map, \"maps.debug\");\n\tif (err)\n\t\tgoto cleanup;\n\terr = send_link_to_kernel(skel->links.dump_bpf_prog, \"progs.debug\");\n\tif (err)\n\t\tgoto cleanup;\n\n\t/* The kernel will proceed with pinnging the links in bpffs.\n\t * UMD will wait on read from pipe.\n\t */\n\tread(from_kernel, &magic, sizeof(magic));\n\tif (magic != BPF_PRELOAD_END) {\n\t\tprintf(\"bad final magic %d\\n\", magic);\n\t\terr = -EINVAL;\n\t}\ncleanup:\n\titerators_bpf__destroy(skel);\n\n\treturn err != 0;\n}"
  },
  {
    "function_name": "send_link_to_kernel",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/preload/iterators/iterators.c",
    "lines": "19-36",
    "snippet": "static int send_link_to_kernel(struct bpf_link *link, const char *link_name)\n{\n\tstruct bpf_preload_info obj = {};\n\tstruct bpf_link_info info = {};\n\t__u32 info_len = sizeof(info);\n\tint err;\n\n\terr = bpf_obj_get_info_by_fd(bpf_link__fd(link), &info, &info_len);\n\tif (err)\n\t\treturn err;\n\tobj.link_id = info.id;\n\tif (strlen(link_name) >= sizeof(obj.link_name))\n\t\treturn -E2BIG;\n\tstrcpy(obj.link_name, link_name);\n\tif (write(to_kernel, &obj, sizeof(obj)) != sizeof(obj))\n\t\treturn -EPIPE;\n\treturn 0;\n}",
    "includes": [
      "#include \"bpf_preload_common.h\"",
      "#include \"iterators.skel.h\"",
      "#include <sys/mount.h>",
      "#include <bpf/bpf.h>",
      "#include <bpf/libbpf.h>",
      "#include <sys/resource.h>",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int to_kernel = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "to_kernel",
            "&obj",
            "sizeof(obj)"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_verifier_log_write",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/bpf/verifier.c",
          "lines": "328-339",
          "snippet": "void bpf_verifier_log_write(struct bpf_verifier_env *env,\n\t\t\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/btf_ids.h>",
            "#include <linux/bpf_lsm.h>",
            "#include <linux/error-injection.h>",
            "#include <linux/ctype.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/btf_ids.h>\n#include <linux/bpf_lsm.h>\n#include <linux/error-injection.h>\n#include <linux/ctype.h>\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/bpf-cgroup.h>\n#include <uapi/linux/btf.h>\n\nvoid bpf_verifier_log_write(struct bpf_verifier_env *env,\n\t\t\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!bpf_verifier_log_needed(&env->log))\n\t\treturn;\n\n\tva_start(args, fmt);\n\tbpf_verifier_vlog(&env->log, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "obj.link_name",
            "link_name"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "link_name"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_eprobe.c",
          "lines": "384-401",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_dynevent.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_dynevent.h\"\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Return the length of string -- including null terminal byte */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint ret, len = 0;\n\tu8 c;\n\n#ifdef CONFIG_ARCH_HAS_NON_OVERLAPPING_ADDRESS_SPACE\n\tif (addr < TASK_SIZE)\n\t\treturn fetch_store_strlen_user(addr);\n#endif\n\n\tdo {\n\t\tret = copy_from_kernel_nofault(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < MAX_STRING_SIZE);\n\n\treturn (ret < 0) ? ret : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_obj_get_info_by_fd",
          "args": [
            "bpf_link__fd(link)",
            "&info",
            "&info_len"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_link__fd",
          "args": [
            "link"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bpf_preload_common.h\"\n#include \"iterators.skel.h\"\n#include <sys/mount.h>\n#include <bpf/bpf.h>\n#include <bpf/libbpf.h>\n#include <sys/resource.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n\nint to_kernel = -1;\n\nstatic int send_link_to_kernel(struct bpf_link *link, const char *link_name)\n{\n\tstruct bpf_preload_info obj = {};\n\tstruct bpf_link_info info = {};\n\t__u32 info_len = sizeof(info);\n\tint err;\n\n\terr = bpf_obj_get_info_by_fd(bpf_link__fd(link), &info, &info_len);\n\tif (err)\n\t\treturn err;\n\tobj.link_id = info.id;\n\tif (strlen(link_name) >= sizeof(obj.link_name))\n\t\treturn -E2BIG;\n\tstrcpy(obj.link_name, link_name);\n\tif (write(to_kernel, &obj, sizeof(obj)) != sizeof(obj))\n\t\treturn -EPIPE;\n\treturn 0;\n}"
  }
]