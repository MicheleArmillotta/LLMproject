[
  {
    "function_name": "init_timer_list_procfs",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "349-358",
    "snippet": "static int __init init_timer_list_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create_seq_private(\"timer_list\", 0400, NULL, &timer_list_sops,\n\t\t\tsizeof(struct timer_list_iter), NULL);\n\tif (!pe)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_seq_private",
          "args": [
            "\"timer_list\"",
            "0400",
            "NULL",
            "&timer_list_sops",
            "sizeof(struct timer_list_iter)",
            "NULL"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic int __init init_timer_list_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create_seq_private(\"timer_list\", 0400, NULL, &timer_list_sops,\n\t\t\tsizeof(struct timer_list_iter), NULL);\n\tif (!pe)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "timer_list_stop",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "338-340",
    "snippet": "static void timer_list_stop(struct seq_file *seq, void *v)\n{\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void timer_list_stop(struct seq_file *seq, void *v)\n{\n}"
  },
  {
    "function_name": "timer_list_next",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "331-336",
    "snippet": "static void *timer_list_next(struct seq_file *file, void *v, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\t++*offset;\n\treturn move_iter(iter, 1);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_iter",
          "args": [
            "iter",
            "1"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "move_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "301-318",
          "snippet": "static void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void *timer_list_next(struct seq_file *file, void *v, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\t++*offset;\n\treturn move_iter(iter, 1);\n}"
  },
  {
    "function_name": "timer_list_start",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "320-329",
    "snippet": "static void *timer_list_start(struct seq_file *file, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\n\tif (!*offset)\n\t\titer->now = ktime_to_ns(ktime_get());\n\titer->cpu = -1;\n\titer->second_pass = false;\n\treturn move_iter(iter, *offset);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_iter",
          "args": [
            "iter",
            "*offset"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "move_iter",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "301-318",
          "snippet": "static void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_get()"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void *timer_list_start(struct seq_file *file, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\n\tif (!*offset)\n\t\titer->now = ktime_to_ns(ktime_get());\n\titer->cpu = -1;\n\titer->second_pass = false;\n\treturn move_iter(iter, *offset);\n}"
  },
  {
    "function_name": "move_iter",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "301-318",
    "snippet": "static void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_next",
          "args": [
            "iter->cpu",
            "cpu_online_mask"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn NULL;\n#else\n\t\t\treturn NULL;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}"
  },
  {
    "function_name": "timer_list_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "284-299",
    "snippet": "static int timer_list_show(struct seq_file *m, void *v)\n{\n\tstruct timer_list_iter *iter = v;\n\n\tif (iter->cpu == -1 && !iter->second_pass)\n\t\ttimer_list_header(m, iter->now);\n\telse if (!iter->second_pass)\n\t\tprint_cpu(m, iter->cpu, iter->now);\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\telse if (iter->cpu == -1 && iter->second_pass)\n\t\ttimer_list_show_tickdevices_header(m);\n\telse\n\t\tprint_tickdevice(m, tick_get_device(iter->cpu), iter->cpu);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_list_show_tickdevices_header",
          "args": [
            "m"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "timer_list_show_tickdevices_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "242-254",
          "snippet": "static void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_cpu",
          "args": [
            "m",
            "iter->cpu",
            "iter->now"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "print_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "115-174",
          "snippet": "static void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tSEQ_printf(m, \"cpu: %d\\n\", cpu);\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tSEQ_printf(m, \" clock %d:\\n\", i);\n\t\tprint_base(m, cpu_base->clock_base + i, now);\n\t}\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(cpu_base->x))\n#define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(cpu_base->x)))\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tP_ns(expires_next);\n\tP(hres_active);\n\tP(nr_events);\n\tP(nr_retries);\n\tP(nr_hangs);\n\tP(max_hang_time);\n#endif\n#undef P\n#undef P_ns\n\n#ifdef CONFIG_TICK_ONESHOT\n# define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(ts->x))\n# define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(ts->x)))\n\t{\n\t\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\t\tP(nohz_mode);\n\t\tP_ns(last_tick);\n\t\tP(tick_stopped);\n\t\tP(idle_jiffies);\n\t\tP(idle_calls);\n\t\tP(idle_sleeps);\n\t\tP_ns(idle_entrytime);\n\t\tP_ns(idle_waketime);\n\t\tP_ns(idle_exittime);\n\t\tP_ns(idle_sleeptime);\n\t\tP_ns(iowait_sleeptime);\n\t\tP(last_jiffies);\n\t\tP(next_timer);\n\t\tP_ns(idle_expires);\n\t\tSEQ_printf(m, \"jiffies: %Lu\\n\",\n\t\t\t   (unsigned long long)jiffies);\n\t}\n#endif\n\n#undef P\n#undef P_ns\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tSEQ_printf(m, \"cpu: %d\\n\", cpu);\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tSEQ_printf(m, \" clock %d:\\n\", i);\n\t\tprint_base(m, cpu_base->clock_base + i, now);\n\t}\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(cpu_base->x))\n#define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(cpu_base->x)))\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tP_ns(expires_next);\n\tP(hres_active);\n\tP(nr_events);\n\tP(nr_retries);\n\tP(nr_hangs);\n\tP(max_hang_time);\n#endif\n#undef P\n#undef P_ns\n\n#ifdef CONFIG_TICK_ONESHOT\n# define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(ts->x))\n# define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(ts->x)))\n\t{\n\t\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\t\tP(nohz_mode);\n\t\tP_ns(last_tick);\n\t\tP(tick_stopped);\n\t\tP(idle_jiffies);\n\t\tP(idle_calls);\n\t\tP(idle_sleeps);\n\t\tP_ns(idle_entrytime);\n\t\tP_ns(idle_waketime);\n\t\tP_ns(idle_exittime);\n\t\tP_ns(idle_sleeptime);\n\t\tP_ns(iowait_sleeptime);\n\t\tP(last_jiffies);\n\t\tP(next_timer);\n\t\tP_ns(idle_expires);\n\t\tSEQ_printf(m, \"jiffies: %Lu\\n\",\n\t\t\t   (unsigned long long)jiffies);\n\t}\n#endif\n\n#undef P\n#undef P_ns\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_list_header",
          "args": [
            "m",
            "iter->now"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "timer_list_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "257-263",
          "snippet": "static inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.9\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.9\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic int timer_list_show(struct seq_file *m, void *v)\n{\n\tstruct timer_list_iter *iter = v;\n\n\tif (iter->cpu == -1 && !iter->second_pass)\n\t\ttimer_list_header(m, iter->now);\n\telse if (!iter->second_pass)\n\t\tprint_cpu(m, iter->cpu, iter->now);\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\telse if (iter->cpu == -1 && iter->second_pass)\n\t\ttimer_list_show_tickdevices_header(m);\n\telse\n\t\tprint_tickdevice(m, tick_get_device(iter->cpu), iter->cpu);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "sysrq_timer_list_show",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "265-281",
    "snippet": "void sysrq_timer_list_show(void)\n{\n\tu64 now = ktime_to_ns(ktime_get());\n\tint cpu;\n\n\ttimer_list_header(NULL, now);\n\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu, now);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\ttimer_list_show_tickdevices_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_tickdevice(NULL, tick_get_device(cpu), cpu);\n#endif\n\treturn;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_list_show_tickdevices_header",
          "args": [
            "NULL"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "timer_list_show_tickdevices_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "242-254",
          "snippet": "static void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_list_header",
          "args": [
            "NULL",
            "now"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "timer_list_header",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "257-263",
          "snippet": "static inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.9\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.9\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_get()"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timekeeping.c",
          "lines": "1025-1030",
          "snippet": "noinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/audit.h>",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/audit.h>\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nnoinstr time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nvoid sysrq_timer_list_show(void)\n{\n\tu64 now = ktime_to_ns(ktime_get());\n\tint cpu;\n\n\ttimer_list_header(NULL, now);\n\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(NULL, cpu, now);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS\n\ttimer_list_show_tickdevices_header(NULL);\n\tfor_each_online_cpu(cpu)\n\t\tprint_tickdevice(NULL, tick_get_device(cpu), cpu);\n#endif\n\treturn;\n}"
  },
  {
    "function_name": "timer_list_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "257-263",
    "snippet": "static inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.9\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "31-43",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tSEQ_printf(m, \"Timer List Version: v0.9\\n\");\n\tSEQ_printf(m, \"HRTIMER_MAX_CLOCK_BASES: %d\\n\", HRTIMER_MAX_CLOCK_BASES);\n\tSEQ_printf(m, \"now at %Ld nsecs\\n\", (unsigned long long)now);\n\tSEQ_printf(m, \"\\n\");\n}"
  },
  {
    "function_name": "timer_list_show_tickdevices_header",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "242-254",
    "snippet": "static void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "31-43",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "tick_get_broadcast_oneshot_mask()"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_get_broadcast_oneshot_mask",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_broadcast_oneshot_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "613-616",
          "snippet": "struct cpumask *tick_get_broadcast_oneshot_mask(void)\n{\n\treturn tick_broadcast_oneshot_mask;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstruct cpumask *tick_get_broadcast_oneshot_mask(void)\n{\n\treturn tick_broadcast_oneshot_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_pr_args",
          "args": [
            "tick_get_broadcast_mask()"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_get_broadcast_mask",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_broadcast_mask",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "61-64",
          "snippet": "struct cpumask *tick_get_broadcast_mask(void)\n{\n\treturn tick_broadcast_mask;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static cpumask_var_t tick_broadcast_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic cpumask_var_t tick_broadcast_mask;\n\nstruct cpumask *tick_get_broadcast_mask(void)\n{\n\treturn tick_broadcast_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_tickdevice",
          "args": [
            "m",
            "tick_get_broadcast_device()",
            "-1"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "print_tickdevice",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "177-240",
          "snippet": "static void\nprint_tickdevice(struct seq_file *m, struct tick_device *td, int cpu)\n{\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttouch_nmi_watchdog();\n\n\tSEQ_printf(m, \"Tick Device: mode:     %d\\n\", td->mode);\n\tif (cpu < 0)\n\t\tSEQ_printf(m, \"Broadcast device\\n\");\n\telse\n\t\tSEQ_printf(m, \"Per CPU device: %d\\n\", cpu);\n\n\tSEQ_printf(m, \"Clock Event Device: \");\n\tif (!dev) {\n\t\tSEQ_printf(m, \"<NULL>\\n\");\n\t\treturn;\n\t}\n\tSEQ_printf(m, \"%s\\n\", dev->name);\n\tSEQ_printf(m, \" max_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tSEQ_printf(m, \" min_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tSEQ_printf(m, \" mult:           %u\\n\", dev->mult);\n\tSEQ_printf(m, \" shift:          %u\\n\", dev->shift);\n\tSEQ_printf(m, \" mode:           %d\\n\", clockevent_get_state(dev));\n\tSEQ_printf(m, \" next_event:     %Ld nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tSEQ_printf(m, \" set_next_event: %ps\\n\", dev->set_next_event);\n\n\tif (dev->set_state_shutdown)\n\t\tSEQ_printf(m, \" shutdown:       %ps\\n\",\n\t\t\tdev->set_state_shutdown);\n\n\tif (dev->set_state_periodic)\n\t\tSEQ_printf(m, \" periodic:       %ps\\n\",\n\t\t\tdev->set_state_periodic);\n\n\tif (dev->set_state_oneshot)\n\t\tSEQ_printf(m, \" oneshot:        %ps\\n\",\n\t\t\tdev->set_state_oneshot);\n\n\tif (dev->set_state_oneshot_stopped)\n\t\tSEQ_printf(m, \" oneshot stopped: %ps\\n\",\n\t\t\tdev->set_state_oneshot_stopped);\n\n\tif (dev->tick_resume)\n\t\tSEQ_printf(m, \" resume:         %ps\\n\",\n\t\t\tdev->tick_resume);\n\n\tSEQ_printf(m, \" event_handler:  %ps\\n\", dev->event_handler);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" retries:        %lu\\n\", dev->retries);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tif (cpu >= 0) {\n\t\tconst struct clock_event_device *wd = tick_get_wakeup_device(cpu);\n\n\t\tSEQ_printf(m, \"Wakeup Device: %s\\n\", wd ? wd->name : \"<NULL>\");\n\t}\n#endif\n\tSEQ_printf(m, \"\\n\");\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_tickdevice(struct seq_file *m, struct tick_device *td, int cpu)\n{\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttouch_nmi_watchdog();\n\n\tSEQ_printf(m, \"Tick Device: mode:     %d\\n\", td->mode);\n\tif (cpu < 0)\n\t\tSEQ_printf(m, \"Broadcast device\\n\");\n\telse\n\t\tSEQ_printf(m, \"Per CPU device: %d\\n\", cpu);\n\n\tSEQ_printf(m, \"Clock Event Device: \");\n\tif (!dev) {\n\t\tSEQ_printf(m, \"<NULL>\\n\");\n\t\treturn;\n\t}\n\tSEQ_printf(m, \"%s\\n\", dev->name);\n\tSEQ_printf(m, \" max_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tSEQ_printf(m, \" min_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tSEQ_printf(m, \" mult:           %u\\n\", dev->mult);\n\tSEQ_printf(m, \" shift:          %u\\n\", dev->shift);\n\tSEQ_printf(m, \" mode:           %d\\n\", clockevent_get_state(dev));\n\tSEQ_printf(m, \" next_event:     %Ld nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tSEQ_printf(m, \" set_next_event: %ps\\n\", dev->set_next_event);\n\n\tif (dev->set_state_shutdown)\n\t\tSEQ_printf(m, \" shutdown:       %ps\\n\",\n\t\t\tdev->set_state_shutdown);\n\n\tif (dev->set_state_periodic)\n\t\tSEQ_printf(m, \" periodic:       %ps\\n\",\n\t\t\tdev->set_state_periodic);\n\n\tif (dev->set_state_oneshot)\n\t\tSEQ_printf(m, \" oneshot:        %ps\\n\",\n\t\t\tdev->set_state_oneshot);\n\n\tif (dev->set_state_oneshot_stopped)\n\t\tSEQ_printf(m, \" oneshot stopped: %ps\\n\",\n\t\t\tdev->set_state_oneshot_stopped);\n\n\tif (dev->tick_resume)\n\t\tSEQ_printf(m, \" resume:         %ps\\n\",\n\t\t\tdev->tick_resume);\n\n\tSEQ_printf(m, \" event_handler:  %ps\\n\", dev->event_handler);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" retries:        %lu\\n\", dev->retries);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tif (cpu >= 0) {\n\t\tconst struct clock_event_device *wd = tick_get_wakeup_device(cpu);\n\n\t\tSEQ_printf(m, \"Wakeup Device: %s\\n\", wd ? wd->name : \"<NULL>\");\n\t}\n#endif\n\tSEQ_printf(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_get_broadcast_device",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_broadcast_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "56-59",
          "snippet": "struct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tick_device tick_broadcast_device;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct tick_device tick_broadcast_device;\n\nstruct tick_device *tick_get_broadcast_device(void)\n{\n\treturn &tick_broadcast_device;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tSEQ_printf(m, \"tick_broadcast_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_mask()));\n#ifdef CONFIG_TICK_ONESHOT\n\tSEQ_printf(m, \"tick_broadcast_oneshot_mask: %*pb\\n\",\n\t\t   cpumask_pr_args(tick_get_broadcast_oneshot_mask()));\n#endif\n\tSEQ_printf(m, \"\\n\");\n#endif\n}"
  },
  {
    "function_name": "print_tickdevice",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "177-240",
    "snippet": "static void\nprint_tickdevice(struct seq_file *m, struct tick_device *td, int cpu)\n{\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttouch_nmi_watchdog();\n\n\tSEQ_printf(m, \"Tick Device: mode:     %d\\n\", td->mode);\n\tif (cpu < 0)\n\t\tSEQ_printf(m, \"Broadcast device\\n\");\n\telse\n\t\tSEQ_printf(m, \"Per CPU device: %d\\n\", cpu);\n\n\tSEQ_printf(m, \"Clock Event Device: \");\n\tif (!dev) {\n\t\tSEQ_printf(m, \"<NULL>\\n\");\n\t\treturn;\n\t}\n\tSEQ_printf(m, \"%s\\n\", dev->name);\n\tSEQ_printf(m, \" max_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tSEQ_printf(m, \" min_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tSEQ_printf(m, \" mult:           %u\\n\", dev->mult);\n\tSEQ_printf(m, \" shift:          %u\\n\", dev->shift);\n\tSEQ_printf(m, \" mode:           %d\\n\", clockevent_get_state(dev));\n\tSEQ_printf(m, \" next_event:     %Ld nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tSEQ_printf(m, \" set_next_event: %ps\\n\", dev->set_next_event);\n\n\tif (dev->set_state_shutdown)\n\t\tSEQ_printf(m, \" shutdown:       %ps\\n\",\n\t\t\tdev->set_state_shutdown);\n\n\tif (dev->set_state_periodic)\n\t\tSEQ_printf(m, \" periodic:       %ps\\n\",\n\t\t\tdev->set_state_periodic);\n\n\tif (dev->set_state_oneshot)\n\t\tSEQ_printf(m, \" oneshot:        %ps\\n\",\n\t\t\tdev->set_state_oneshot);\n\n\tif (dev->set_state_oneshot_stopped)\n\t\tSEQ_printf(m, \" oneshot stopped: %ps\\n\",\n\t\t\tdev->set_state_oneshot_stopped);\n\n\tif (dev->tick_resume)\n\t\tSEQ_printf(m, \" resume:         %ps\\n\",\n\t\t\tdev->tick_resume);\n\n\tSEQ_printf(m, \" event_handler:  %ps\\n\", dev->event_handler);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" retries:        %lu\\n\", dev->retries);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tif (cpu >= 0) {\n\t\tconst struct clock_event_device *wd = tick_get_wakeup_device(cpu);\n\n\t\tSEQ_printf(m, \"Wakeup Device: %s\\n\", wd ? wd->name : \"<NULL>\");\n\t}\n#endif\n\tSEQ_printf(m, \"\\n\");\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "31-43",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tick_get_wakeup_device",
          "args": [
            "cpu"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_wakeup_device",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-broadcast.c",
          "lines": "68-71",
          "snippet": "const struct clock_event_device *tick_get_wakeup_device(int cpu)\n{\n\treturn tick_get_oneshot_wakeup_device(cpu);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/profile.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device *tick_get_oneshot_wakeup_device(int cpu);\n\nconst struct clock_event_device *tick_get_wakeup_device(int cpu)\n{\n\treturn tick_get_oneshot_wakeup_device(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "dev->next_event"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clockevent_get_state",
          "args": [
            "dev"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "clockevent_get_state",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-internal.h",
          "lines": "39-42",
          "snippet": "static inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}",
          "includes": [
            "#include \"tick-sched.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/tick.h>",
            "#include <linux/hrtimer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-sched.h\"\n#include \"timekeeping.h\"\n#include <linux/tick.h>\n#include <linux/hrtimer.h>\n\nstatic inline enum clock_event_state clockevent_get_state(struct clock_event_device *dev)\n{\n\treturn dev->state_use_accessors;\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_tickdevice(struct seq_file *m, struct tick_device *td, int cpu)\n{\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttouch_nmi_watchdog();\n\n\tSEQ_printf(m, \"Tick Device: mode:     %d\\n\", td->mode);\n\tif (cpu < 0)\n\t\tSEQ_printf(m, \"Broadcast device\\n\");\n\telse\n\t\tSEQ_printf(m, \"Per CPU device: %d\\n\", cpu);\n\n\tSEQ_printf(m, \"Clock Event Device: \");\n\tif (!dev) {\n\t\tSEQ_printf(m, \"<NULL>\\n\");\n\t\treturn;\n\t}\n\tSEQ_printf(m, \"%s\\n\", dev->name);\n\tSEQ_printf(m, \" max_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tSEQ_printf(m, \" min_delta_ns:   %llu\\n\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tSEQ_printf(m, \" mult:           %u\\n\", dev->mult);\n\tSEQ_printf(m, \" shift:          %u\\n\", dev->shift);\n\tSEQ_printf(m, \" mode:           %d\\n\", clockevent_get_state(dev));\n\tSEQ_printf(m, \" next_event:     %Ld nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tSEQ_printf(m, \" set_next_event: %ps\\n\", dev->set_next_event);\n\n\tif (dev->set_state_shutdown)\n\t\tSEQ_printf(m, \" shutdown:       %ps\\n\",\n\t\t\tdev->set_state_shutdown);\n\n\tif (dev->set_state_periodic)\n\t\tSEQ_printf(m, \" periodic:       %ps\\n\",\n\t\t\tdev->set_state_periodic);\n\n\tif (dev->set_state_oneshot)\n\t\tSEQ_printf(m, \" oneshot:        %ps\\n\",\n\t\t\tdev->set_state_oneshot);\n\n\tif (dev->set_state_oneshot_stopped)\n\t\tSEQ_printf(m, \" oneshot stopped: %ps\\n\",\n\t\t\tdev->set_state_oneshot_stopped);\n\n\tif (dev->tick_resume)\n\t\tSEQ_printf(m, \" resume:         %ps\\n\",\n\t\t\tdev->tick_resume);\n\n\tSEQ_printf(m, \" event_handler:  %ps\\n\", dev->event_handler);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" retries:        %lu\\n\", dev->retries);\n\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n\tif (cpu >= 0) {\n\t\tconst struct clock_event_device *wd = tick_get_wakeup_device(cpu);\n\n\t\tSEQ_printf(m, \"Wakeup Device: %s\\n\", wd ? wd->name : \"<NULL>\");\n\t}\n#endif\n\tSEQ_printf(m, \"\\n\");\n}"
  },
  {
    "function_name": "print_cpu",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "115-174",
    "snippet": "static void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tSEQ_printf(m, \"cpu: %d\\n\", cpu);\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tSEQ_printf(m, \" clock %d:\\n\", i);\n\t\tprint_base(m, cpu_base->clock_base + i, now);\n\t}\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(cpu_base->x))\n#define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(cpu_base->x)))\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tP_ns(expires_next);\n\tP(hres_active);\n\tP(nr_events);\n\tP(nr_retries);\n\tP(nr_hangs);\n\tP(max_hang_time);\n#endif\n#undef P\n#undef P_ns\n\n#ifdef CONFIG_TICK_ONESHOT\n# define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(ts->x))\n# define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(ts->x)))\n\t{\n\t\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\t\tP(nohz_mode);\n\t\tP_ns(last_tick);\n\t\tP(tick_stopped);\n\t\tP(idle_jiffies);\n\t\tP(idle_calls);\n\t\tP(idle_sleeps);\n\t\tP_ns(idle_entrytime);\n\t\tP_ns(idle_waketime);\n\t\tP_ns(idle_exittime);\n\t\tP_ns(idle_sleeptime);\n\t\tP_ns(iowait_sleeptime);\n\t\tP(last_jiffies);\n\t\tP(next_timer);\n\t\tP_ns(idle_expires);\n\t\tSEQ_printf(m, \"jiffies: %Lu\\n\",\n\t\t\t   (unsigned long long)jiffies);\n\t}\n#endif\n\n#undef P\n#undef P_ns\n\tSEQ_printf(m, \"\\n\");\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "31-43",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "idle_expires"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "next_timer"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "last_jiffies"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "iowait_sleeptime"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "idle_sleeptime"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "idle_exittime"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "idle_waketime"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "idle_entrytime"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "idle_sleeps"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "idle_calls"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "idle_jiffies"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "tick_stopped"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "last_tick"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nohz_mode"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_get_tick_sched",
          "args": [
            "cpu"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "tick_get_tick_sched",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/tick-sched.c",
          "lines": "41-44",
          "snippet": "struct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic DEFINE_PER_CPU(struct tick_sched, tick_cpu_sched);\n\nstruct tick_sched *tick_get_tick_sched(int cpu)\n{\n\treturn &per_cpu(tick_cpu_sched, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "max_hang_time"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nr_hangs"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nr_retries"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "nr_events"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P",
          "args": [
            "hres_active"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "P_ns",
          "args": [
            "expires_next"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_base",
          "args": [
            "m",
            "cpu_base->clock_base + i",
            "now"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "print_base",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "98-113",
          "snippet": "static void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tSEQ_printf(m, \"  .base:       %pK\\n\", base);\n\tSEQ_printf(m, \"  .index:      %d\\n\", base->index);\n\n\tSEQ_printf(m, \"  .resolution: %u nsecs\\n\", hrtimer_resolution);\n\n\tSEQ_printf(m,   \"  .get_time:   %ps\\n\", base->get_time);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tSEQ_printf(m, \"  .offset:     %Lu nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tSEQ_printf(m,   \"active timers:\\n\");\n\tprint_active_timers(m, base, now + ktime_to_ns(base->offset));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tSEQ_printf(m, \"  .base:       %pK\\n\", base);\n\tSEQ_printf(m, \"  .index:      %d\\n\", base->index);\n\n\tSEQ_printf(m, \"  .resolution: %u nsecs\\n\", hrtimer_resolution);\n\n\tSEQ_printf(m,   \"  .get_time:   %ps\\n\", base->get_time);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tSEQ_printf(m, \"  .offset:     %Lu nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tSEQ_printf(m,   \"active timers:\\n\");\n\tprint_active_timers(m, base, now + ktime_to_ns(base->offset));\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "hrtimer_bases",
            "cpu"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_set_per_cpu",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/kthread.c",
          "lines": "588-603",
          "snippet": "void kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/numa.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/mm.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/sched/isolation.h>\n#include <linux/numa.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/mmu_context.h>\n#include <linux/mm.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_set_per_cpu(struct task_struct *k, int cpu)\n{\n\tstruct kthread *kthread = to_kthread(k);\n\tif (!kthread)\n\t\treturn;\n\n\tWARN_ON_ONCE(!(k->flags & PF_NO_SETAFFINITY));\n\n\tif (cpu < 0) {\n\t\tclear_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n\t\treturn;\n\t}\n\n\tkthread->cpu = cpu;\n\tset_bit(KTHREAD_IS_PER_CPU, &kthread->flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tSEQ_printf(m, \"cpu: %d\\n\", cpu);\n\tfor (i = 0; i < HRTIMER_MAX_CLOCK_BASES; i++) {\n\t\tSEQ_printf(m, \" clock %d:\\n\", i);\n\t\tprint_base(m, cpu_base->clock_base + i, now);\n\t}\n#define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(cpu_base->x))\n#define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(cpu_base->x)))\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tP_ns(expires_next);\n\tP(hres_active);\n\tP(nr_events);\n\tP(nr_retries);\n\tP(nr_hangs);\n\tP(max_hang_time);\n#endif\n#undef P\n#undef P_ns\n\n#ifdef CONFIG_TICK_ONESHOT\n# define P(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu\\n\", #x, \\\n\t\t   (unsigned long long)(ts->x))\n# define P_ns(x) \\\n\tSEQ_printf(m, \"  .%-15s: %Lu nsecs\\n\", #x, \\\n\t\t   (unsigned long long)(ktime_to_ns(ts->x)))\n\t{\n\t\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\t\tP(nohz_mode);\n\t\tP_ns(last_tick);\n\t\tP(tick_stopped);\n\t\tP(idle_jiffies);\n\t\tP(idle_calls);\n\t\tP(idle_sleeps);\n\t\tP_ns(idle_entrytime);\n\t\tP_ns(idle_waketime);\n\t\tP_ns(idle_exittime);\n\t\tP_ns(idle_sleeptime);\n\t\tP_ns(iowait_sleeptime);\n\t\tP(last_jiffies);\n\t\tP(next_timer);\n\t\tP_ns(idle_expires);\n\t\tSEQ_printf(m, \"jiffies: %Lu\\n\",\n\t\t\t   (unsigned long long)jiffies);\n\t}\n#endif\n\n#undef P\n#undef P_ns\n\tSEQ_printf(m, \"\\n\");\n}"
  },
  {
    "function_name": "print_base",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "98-113",
    "snippet": "static void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tSEQ_printf(m, \"  .base:       %pK\\n\", base);\n\tSEQ_printf(m, \"  .index:      %d\\n\", base->index);\n\n\tSEQ_printf(m, \"  .resolution: %u nsecs\\n\", hrtimer_resolution);\n\n\tSEQ_printf(m,   \"  .get_time:   %ps\\n\", base->get_time);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tSEQ_printf(m, \"  .offset:     %Lu nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tSEQ_printf(m,   \"active timers:\\n\");\n\tprint_active_timers(m, base, now + ktime_to_ns(base->offset));\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_active_timers",
          "args": [
            "m",
            "base",
            "now + ktime_to_ns(base->offset)"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "print_active_timers",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "59-96",
          "snippet": "static void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\n\ttouch_nmi_watchdog();\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t/*\n\t * Crude but we have to do this O(N*N) thing, because\n\t * we have to unlock the base when printing:\n\t */\n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\n\ttouch_nmi_watchdog();\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t/*\n\t * Crude but we have to do this O(N*N) thing, because\n\t * we have to unlock the base when printing:\n\t */\n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "base->offset"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\"active timers:\\n\""
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "31-43",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "base->offset"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tSEQ_printf(m, \"  .base:       %pK\\n\", base);\n\tSEQ_printf(m, \"  .index:      %d\\n\", base->index);\n\n\tSEQ_printf(m, \"  .resolution: %u nsecs\\n\", hrtimer_resolution);\n\n\tSEQ_printf(m,   \"  .get_time:   %ps\\n\", base->get_time);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\tSEQ_printf(m, \"  .offset:     %Lu nsecs\\n\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tSEQ_printf(m,   \"active timers:\\n\");\n\tprint_active_timers(m, base, now + ktime_to_ns(base->offset));\n}"
  },
  {
    "function_name": "print_active_timers",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "59-96",
    "snippet": "static void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\n\ttouch_nmi_watchdog();\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t/*\n\t * Crude but we have to do this O(N*N) thing, because\n\t * we have to unlock the base when printing:\n\t */\n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&base->cpu_base->lock",
            "flags"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "192-195",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_timer",
          "args": [
            "m",
            "timer",
            "&tmp",
            "i",
            "now"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "print_timer",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "45-57",
          "snippet": "static void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: <%pK>, %ps\", idx, taddr, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: <%pK>, %ps\", idx, taddr, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "curr",
            "structhrtimer",
            "node"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_iterate_next",
          "args": [
            "curr"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timerqueue_getnext",
          "args": [
            "&base->active"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&base->cpu_base->lock",
            "flags"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/locking/spinlock.c",
          "lines": "383-393",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "touch_nmi_watchdog",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "arch_touch_nmi_watchdog",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/watchdog_hld.c",
          "lines": "32-42",
          "snippet": "notrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}",
          "includes": [
            "#include <linux/perf_event.h>",
            "#include <asm/irq_regs.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(bool, watchdog_nmi_touch);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/perf_event.h>\n#include <asm/irq_regs.h>\n#include <linux/sched/debug.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n\nstatic DEFINE_PER_CPU(bool, watchdog_nmi_touch);\n\nnotrace void arch_touch_nmi_watchdog(void)\n{\n\t/*\n\t * Using __raw here because some code paths have\n\t * preemption enabled.  If preemption is enabled\n\t * then interrupts should be enabled too, in which\n\t * case we shouldn't have to worry about the watchdog\n\t * going off.\n\t */\n\traw_cpu_write(watchdog_nmi_touch, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\n\ttouch_nmi_watchdog();\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t/*\n\t * Crude but we have to do this O(N*N) thing, because\n\t * we have to unlock the base when printing:\n\t */\n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}"
  },
  {
    "function_name": "print_timer",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "45-57",
    "snippet": "static void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: <%pK>, %ps\", idx, taddr, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SEQ_printf",
          "args": [
            "m",
            "\" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\"",
            "(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer))",
            "(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer))",
            "(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now)",
            "(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now)"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "SEQ_printf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
          "lines": "31-43",
          "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/nmi.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "hrtimer_get_expires(timer)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "hrtimer_get_softexpires(timer)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_softexpires",
          "args": [
            "timer"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "hrtimer_get_expires(timer)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_expires",
          "args": [
            "timer"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "hrtimer_get_softexpires(timer)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_softexpires",
          "args": [
            "timer"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n\tSEQ_printf(m, \" #%d: <%pK>, %ps\", idx, taddr, timer->function);\n\tSEQ_printf(m, \", S:%02x\", timer->state);\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\\n\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}"
  },
  {
    "function_name": "SEQ_printf",
    "container": null,
    "file": "output_repos_c/CVE-2022-30594/repo/kernel/time/timer_list.c",
    "lines": "31-43",
    "snippet": "static void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/nmi.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/sched.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/module.h>",
      "#include <linux/proc_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vprintk",
          "args": [
            "fmt",
            "args"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "vprintk_deferred",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/printk/printk.c",
          "lines": "3275-3283",
          "snippet": "int vprintk_deferred(const char *fmt, va_list args)\n{\n\tint r;\n\n\tr = vprintk_emit(0, LOGLEVEL_SCHED, NULL, fmt, args);\n\tdefer_console_output();\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include \"printk_ringbuffer.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include \"printk_ringbuffer.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint vprintk_deferred(const char *fmt, va_list args)\n{\n\tint r;\n\n\tr = vprintk_emit(0, LOGLEVEL_SCHED, NULL, fmt, args);\n\tdefer_console_output();\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_vprintf",
          "args": [
            "m",
            "fmt",
            "args"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_vprintf",
          "container": null,
          "file": "output_repos_c/CVE-2022-30594/repo/kernel/trace/trace_seq.c",
          "lines": "141-157",
          "snippet": "void trace_seq_vprintf(struct trace_seq *s, const char *fmt, va_list args)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_vprintf(&s->seq, fmt, args);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_vprintf(struct trace_seq *s, const char *fmt, va_list args)\n{\n\tunsigned int save_len = s->seq.len;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tseq_buf_vprintf(&s->seq, fmt, args);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/uaccess.h>\n#include <linux/nmi.h>\n#include <linux/kallsyms.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\nstatic void SEQ_printf(struct seq_file *m, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tif (m)\n\t\tseq_vprintf(m, fmt, args);\n\telse\n\t\tvprintk(fmt, args);\n\n\tva_end(args);\n}"
  }
]